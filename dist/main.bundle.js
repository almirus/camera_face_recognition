window["checkPhoto"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \****************************************************************/
/*! exports provided: AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, avgPool3d, backend, backend_util, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, booleanMaskAsync, broadcastTo, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dTranspose, conv3d, conv3dTranspose, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, diag, disableDeprecationWarnings, dispose, disposeVariables, div, divNoNan, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, engine, env, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, frame, fused, gather, gatherND, gather_util, getBackend, getGradient, getKernel, getKernelsForBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, inTopKAsync, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maxPool3d, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomGamma, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, registerGradient, registerKernel, relu, relu6, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, scatter_util, selu, separableConv2d, serialization, setBackend, setPlatform, setdiff1dAsync, sigmoid, sign, signal, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, slice_util, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stft, stridedSlice, sub, subStrict, sum, sumOutType, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unregisterGradient, unregisterKernel, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process, Buffer, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return bd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return wd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return Cd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return Ed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return xo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return s; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return o; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return bo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return Id; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return xd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return kd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return Ct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return ch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return Rd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return wt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return gt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return St; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return rc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return oc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return ac; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return Cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return El; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return Rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return Il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return cu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool3d", function() { return vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backend_util", function() { return Uo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return zl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return Xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return Yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return $u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return Ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return Gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return Hu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return vr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "booleanMaskAsync", function() { return Uc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "broadcastTo", function() { return mr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return id; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return gr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return hu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return yr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return Dn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return Yn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return $n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return Qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return Jn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return Zn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return Hc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return qc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return Zc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return Kc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv3dTranspose", function() { return tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return xr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return vo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return Xe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return br; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return Yc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diag", function() { return eh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return je; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return Ye; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return sc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divNoNan", function() { return uc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return cc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return nh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return _l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return Ke; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return qe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "engine", function() { return $e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "env", function() { return i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return Rc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return Ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return wr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return Cr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return Xl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return Hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return lc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frame", function() { return ih; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return zh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return Lc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return th; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather_util", function() { return Xr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return an; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGradient", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKernel", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKernelsForBackend", function() { return f; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return co; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return lo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return kc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return Sc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return Ac; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return Dc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return ah; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return oh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return Yl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return Nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "image", function() { return Oh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inTopKAsync", function() { return lh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return ed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return Ql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return Du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return Au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return Su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return en; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return Ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "less", function() { return Tc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return Nc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return Fc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return _c; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return Ih; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return Ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return yo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return kl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return Qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return Ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return Zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return tc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return bh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return el; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return od; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return Sl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool3d", function() { return pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return hc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return fc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return Al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return Qe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return Dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return dc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return pc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return vc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return mc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return Tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return Hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return gc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return yc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return Gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return Er; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return wu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return Td; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return Vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return Oc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return Mc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return Rr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return zn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return jn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "op", function() { return An; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return Ir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return Sr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return Ar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return Dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return xc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return bc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return Ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return Fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return Je; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return Tr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomGamma", function() { return Fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return Nr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return _r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return Kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "real", function() { return Tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return Cu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerGradient", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerKernel", function() { return d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return Bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu6", function() { return Pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return sn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return Or; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return sl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return $l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return Eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return Ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return On; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return jl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatter_util", function() { return to; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return Ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return Jc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return ld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return rn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPlatform", function() { return fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return Vr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return Iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signal", function() { return uh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return Tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return Nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return yl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return xl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice_util", function() { return uo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return go; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return Fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return Mr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return Zl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return Jl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return tr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return _u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "square", function() { return tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return wc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return Br; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return Pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return Ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stft", function() { return sh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return ql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return Cc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return Ec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return Nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sumOutType", function() { return Tt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return Mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return Bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return Fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return Mn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return Bn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return Pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return Ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return Wn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return Un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return Mt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return md; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return Ze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return Lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return Kl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "train", function() { return Ad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return Wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return Wr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unregisterGradient", function() { return m; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unregisterKernel", function() { return v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return Wc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return Ur; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "util", function() { return st; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return ho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return fo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return Vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return po; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return gd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return yd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "where", function() { return ec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return nc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return Gn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return Xn; });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}function n(t,e,n,r){return new(n||(n=Promise))((function(o,a){function i(t){try{u(r.next(t))}catch(t){a(t)}}function s(t){try{u(r.throw(t))}catch(t){a(t)}}function u(t){t.done?o(t.value):new n((function(e){e(t.value)})).then(i,s)}u((r=r.apply(t,e||[])).next())}))}function r(t,e){var n,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=e.call(t,i)}catch(t){a=[6,t],r=0}finally{n=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var o=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.setPlatform=function(t,e){null!=this.platform&&console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+e+"."),this.platformName=t,this.platform=e},t.prototype.registerFlag=function(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){var r=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+r+"."),this.set(t,r)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e,n,r=(e=this.global.location.search,n={},e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return a(n,e[0],e[1]),e.join("=")})),n);if("tfjsflags"in r)r.tfjsflags.split(",").forEach((function(e){var n=e.split(":"),r=n[0],o=n[1];t.urlFlags[r]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(r,o)}))}},t}();function a(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function i(){return s}var s=null;var u=new Map,c=new Map;function l(t,e){var n=g(t,e);return u.get(n)}function h(t){return c.get(t)}function f(t){for(var e=u.entries(),n=[];;){var r=e.next(),o=r.done,a=r.value;if(o)break;var i=a[0],s=a[1];i.split("_")[0]===t&&n.push(s)}return n}function d(t){var e=t.kernelName,n=t.backendName,r=g(e,n);if(u.has(r))throw new Error("The kernel '"+e+"' for backend '"+n+"' is already registered");u.set(r,t)}function p(t){var e=t.kernelName;c.has(e)&&console.warn("Overriding the gradient for '"+e+"'"),c.set(e,t)}function v(t,e){var n=g(t,e);if(!u.has(n))throw new Error("The kernel '"+t+"' for backend '"+e+"' is not registered");u.delete(n)}function m(t){if(!c.has(t))throw new Error("The gradient '"+t+"' for backend is not registered");c.delete(t)}function g(t,e){return e+"_"+t}function y(t){for(var e=t.length,n=0,r=0;e>0;)r=Math.random()*e|0,n=t[--e],t[e]=t[r],t[r]=n}function x(t,e,n){return Math.max(t,Math.min(e,n))}function b(t){return t%2==0?t:t+1}function w(t){for(var e=0,n=0;n<t.length;n++)e+=t[n];return e}function C(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function E(t,e,n){void 0===n&&(n=""),C(S(t,e),(function(){return n+" Shapes "+t+" and "+e+" must match"}))}function R(t){C(null!=t,(function(){return"The input to the tensor constructor must be a non-null value."}))}function I(t,e,n){if(void 0===e&&(e=[]),void 0===n&&(n=!1),null==e&&(e=[]),Array.isArray(t)||V(t)&&!n)for(var r=0;r<t.length;++r)I(t[r],e,n);else e.push(t);return e}function k(t){if(0===t.length)return 1;for(var e=t[0],n=1;n<t.length;n++)e*=t[n];return e}function S(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function A(t){return t%1==0}function D(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)}function T(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function N(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function F(t,e,n){return void 0===e&&(e=function(t){return 0}),new Promise((function(r,o){var a=0,i=function(){if(t())r();else{a++;var s=e(a);null!=n&&a>=n?o():setTimeout(i,s)}};i()}))}function _(t,e){for(var n=1,r=-1,o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(-1===t[o]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+r+" and dim "+o);r=o}else if(t[o]<0)throw Error("Shapes can not be < 0. Found "+t[o]+" at dim "+o);if(-1===r){if(e>0&&e!==n)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===n)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%n!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+n);var a=t.slice();return a[r]=e/n,a}function O(t,e){var n=e.length;return C((t=null==t?e.map((function(t,e){return e})):[].concat(t)).every((function(t){return t>=-n&&t<n})),(function(){return"All values in axis param must be in range [-"+n+", "+n+") but got axis "+t})),C(t.every((function(t){return A(t)})),(function(){return"All values in axis param must be integers but got axis "+t})),t.map((function(t){return t<0?n+t:t}))}function M(t,e){for(var n=[],r=[],o=null!=e&&Array.isArray(e)&&0===e.length,a=null==e||o?null:O(e,t).sort(),i=0,s=0;s<t.length;++s){if(null!=a){if(a[i]===s&&1!==t[s])throw new Error("Can't squeeze axis "+s+" since its dim '"+t[s]+"' is not 1");(null==a[i]||a[i]>s)&&1===t[s]&&(n.push(t[s]),r.push(s)),a[i]<=s&&i++}1!==t[s]&&(n.push(t[s]),r.push(s))}return{newShape:n,keptDims:r}}function B(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function P(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function L(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type "+e+" being uploaded contains "+r+".")}}function W(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function U(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function V(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function z(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function G(t){if(null==t)return 0;var e=0;return t.forEach((function(t){return e+=t.length})),e}function H(t){return"string"==typeof t||t instanceof String}function q(t){return"boolean"==typeof t}function K(t){return"number"==typeof t}function j(t){return Array.isArray(t)?j(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":K(t)?"float32":H(t)?"string":q(t)?"bool":"float32"}function X(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Y(t,e){for(var n=e;n<t;++n)if(t%n==0)return n;return t}function $(t){var e=t.length;if(e<2)return[];var n=new Array(e-1);n[e-2]=t[e-1];for(var r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Q(t,e,n){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=I(t)),n&&L(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var r=new Uint8Array(t.length),o=0;o<r.length;++o)0!==Math.round(t[o])&&(r[o]=1);return r}throw new Error("Unknown data type "+e)}function J(t,e){if(0===t.length)return e[0];var n=t.reduce((function(t,e){return t*e}));if(0===n)return[];if(n!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,n,r){var o=new Array;if(1===n.length)for(var a=n[0],i=0;i<a;i++)o[i]=r[e+i];else{a=n[0];var s=n.slice(1),u=s.reduce((function(t,e){return t*e}));for(i=0;i<a;i++)o[i]=t(e+i*u,s,r)}return o}(0,t,e)}function Z(t,e){for(var n=tt(t,e),r=0;r<n.length;r++)n[r]=1;return n}function tt(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function et(){return i().platform.now()}function nt(t){t.forEach((function(e){C(Number.isInteger(e)&&e>=0,(function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."}))}))}function rt(t,e){return void 0===e&&(e="utf-8"),e=e||"utf-8",i().platform.encode(t,e)}function ot(t,e){return void 0===e&&(e="utf-8"),e=e||"utf-8",i().platform.decode(t,e)}function at(t,e,n){if(0===e)return 0;if(1===e)return t[0];for(var r=t[t.length-1],o=0;o<t.length-1;++o)r+=n[o]*t[o];return r}function it(t,e,n){if(0===e)return[];if(1===e)return[t];for(var r=new Array(e),o=0;o<r.length-1;++o)r[o]=Math.floor(t/n[o]),t-=r[o]*n[o];return r[r.length-1]=t,r}var st=Object.freeze({shuffle:y,clamp:x,nearestLargerEven:b,sum:w,randUniform:function(t,e){var n=Math.random();return e*n+(1-n)*t},distSquared:function(t,e){for(var n=0,r=0;r<t.length;r++){var o=Number(t[r])-Number(e[r]);n+=o*o}return n},assert:C,assertShapesMatch:E,assertNonNull:R,flatten:I,sizeFromShape:k,isScalarShape:function(t){return 0===t.length},arraysEqual:S,isInt:A,tanh:D,sizeToSquarishShape:T,createShuffledIndices:function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return y(e),e},rightPad:N,repeatedTry:F,inferFromImplicitShape:_,parseAxisParam:O,squeezeShape:M,getTypedArrayFromDType:B,getArrayFromDType:P,checkConversionForErrors:L,isValidDtype:W,hasEncodingLoss:U,isTypedArray:V,bytesPerElement:z,bytesFromStringArray:G,isString:H,isBoolean:q,isNumber:K,inferDtype:j,isFunction:X,nearestDivisor:Y,computeStrides:$,toTypedArray:Q,toNestedArray:J,makeOnesTypedArray:Z,makeZerosTypedArray:tt,now:et,assertNonNegativeIntegerDimensions:nt,fetch:function(t,e){return i().platform.fetch(t,e)},encodeString:rt,decodeString:ot,locToIndex:at,indexToLoc:it}),ut=function(){function t(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new ct)}return t.prototype.profileKernel=function(t,e,n){var r,o=this,a=this.backendTimer.time((function(){r=n()}));return r.forEach((function(n){n.data().then((function(r){!function(t,e,n){if("float32"!==e)return!1;for(var r=0;r<t.length;r++){var o=t[r];if(isNaN(o)||!isFinite(o))return console.warn("Found "+o+" in the result of '"+n+"'"),!0}}(r,n.dtype,t),a.then((function(a){var i="";null!=a.getExtraProfileInfo&&(i=a.getExtraProfileInfo()),o.logger.logKernelProfile(t,n,r,a.kernelMs,e,i)}))}))})),r},t}();var ct=function(){function t(){}return t.prototype.logKernelProfile=function(t,e,n,r,o,a){var i="number"==typeof r?N(r+"ms",9):r.error,s=N(t,25),u=e.rank,c=e.size,l=N(e.shape.toString(),14),h="";for(var f in o){var d=o[f].shape||e.shape,p=d.length;h+=f+": "+p+"D "+(p>0?d:"")+" "}console.log("%c"+s+"\t%c"+i+"\t%c"+u+"D "+l+"\t%c"+c+"\t%c"+h+"\t%c"+a,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")},t}();var lt=20,ht=3,ft=7;function dt(t,e,n,r){var o=$(e),a=function(t,e,n,r){var o=k(e),a=r[r.length-1],i=new Array(a).fill(0),s=e.length,u="complex64"===n?mt(t):t;if(s>1)for(var c=0;c<o/a;c++)for(var l=c*a,h=0;h<a;h++)i[h]=Math.max(i[h],pt(u[l+h],0,n).length);return i}(t,e,n,o),i=e.length,s=function t(e,n,r,o,a,i){void 0===i&&(i=!0);var s="complex64"===r?2:1,u=n[0],c=n.length;if(0===c){return"complex64"===r?[pt(mt(e)[0],0,r)]:"bool"===r?[vt(e[0])]:[e[0].toString()]}if(1===c){if(u>lt){var l=ht*s,h=Array.from(e.slice(0,l)),f=Array.from(e.slice((u-ht)*s,u*s));return"complex64"===r&&(h=mt(h),f=mt(f)),["["+h.map((function(t,e){return pt(t,a[e],r)})).join(", ")+", ..., "+f.map((function(t,e){return pt(t,a[u-ht+e],r)})).join(", ")+"]"]}return["["+("complex64"===r?mt(e):Array.from(e)).map((function(t,e){return pt(t,a[e],r)})).join(", ")+"]"]}var d=n.slice(1),p=o.slice(1),v=o[0]*s,m=[];if(u>lt){for(var g=0;g<ht;g++){var y=(x=g*v)+v;m.push.apply(m,t(e.slice(x,y),d,r,p,a,!1))}m.push("...");for(g=u-ht;g<u;g++){y=(x=g*v)+v;m.push.apply(m,t(e.slice(x,y),d,r,p,a,g===u-1))}}else for(g=0;g<u;g++){var x;y=(x=g*v)+v;m.push.apply(m,t(e.slice(x,y),d,r,p,a,g===u-1))}var b=2===c?",":"";m[0]="["+m[0]+b;for(g=1;g<m.length-1;g++)m[g]=" "+m[g]+b;var w=",\n";for(g=2;g<c;g++)w+="\n";return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":w),m}(t,e,n,o,a),u=["Tensor"];return r&&(u.push("  dtype: "+n),u.push("  rank: "+i),u.push("  shape: ["+e+"]"),u.push("  values:")),u.push(s.map((function(t){return"    "+t})).join("\n")),u.join("\n")}function pt(t,e,n){return N(Array.isArray(t)?parseFloat(t[0].toFixed(ft))+" + "+parseFloat(t[1].toFixed(ft))+"j":H(t)?"'"+t+"'":"bool"===n?vt(t):parseFloat(t.toFixed(ft)).toString(),e)}function vt(t){return 0===t?"false":"true"}function mt(t){for(var e=[],n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var gt=function(){function t(t,e,n){var r=this;if(this.dtype=e,this.shape=t.slice(),this.size=k(t),null!=n){var o=n.length;C(o===this.size,(function(){return"Length of values '"+o+"' does not match the size inferred by the shape '"+r.size+"'."}))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||P(e,this.size),this.strides=$(t)}return t.prototype.set=function(t){for(var e=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),C(n.length===this.rank,(function(){return"The number of provided coordinates ("+n.length+") must match the rank ("+e.rank+")"}));var o=this.locToIndex(n);this.values[o]=t},t.prototype.get=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];0===t.length&&(t=[0]);for(var n=0,r=0,o=t;r<o.length;r++){var a=o[r];if(a<0||a>=this.shape[n]){var i="Requested out of range element at "+t+".   Buffer shape="+this.shape;throw new Error(i)}n++}for(var s=t[t.length-1],u=0;u<t.length-1;++u)s+=this.strides[u]*t[u];return this.values[s]},t.prototype.locToIndex=function(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];for(var e=t[t.length-1],n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e},t.prototype.indexToLoc=function(t){if(0===this.rank)return[];if(1===this.rank)return[t];for(var e=new Array(this.shape.length),n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return yt().makeTensor(this.values,this.shape,this.dtype)},t}(),yt=null,xt=null,bt=null;var wt=function(){function t(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=k(t),this.strides=$(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}return t.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},t.prototype.asScalar=function(){return this.throwIfDisposed(),C(1===this.size,(function(){return"The array must have only 1 element."})),this.reshape([])},t.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},t.prototype.as2D=function(t,e){return this.throwIfDisposed(),this.reshape([t,e])},t.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),this.reshape([t,e,n])},t.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),this.reshape([t,e,n,r])},t.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),this.reshape([t,e,n,r,o])},t.prototype.asType=function(t){return this.throwIfDisposed(),xt.cast(this,t)},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.buffer=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,xt.buffer(this.shape,this.dtype,t)]}}))}))},t.prototype.bufferSync=function(){return xt.buffer(this.shape,this.dtype,this.dataSync())},t.prototype.array=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,J(this.shape,t)]}}))}))},t.prototype.arraySync=function(){return J(this.shape,this.dataSync())},t.prototype.data=function(){return n(this,void 0,void 0,(function(){var t,e;return r(this,(function(n){switch(n.label){case 0:return this.throwIfDisposed(),t=yt().read(this.dataId),"string"!==this.dtype?[3,2]:[4,t];case 1:e=n.sent();try{return[2,e.map((function(t){return ot(t)}))]}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}n.label=2;case 2:return[2,t]}}))}))},t.prototype.dataSync=function(){this.throwIfDisposed();var t=yt().readSync(this.dataId);if("string"===this.dtype)try{return t.map((function(t){return ot(t)}))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t},t.prototype.bytes=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return this.throwIfDisposed(),[4,yt().read(this.dataId)];case 1:return t=e.sent(),"string"===this.dtype?[2,t]:[2,new Uint8Array(t.buffer)]}}))}))},t.prototype.dispose=function(){this.isDisposed||(yt().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),t.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},t.prototype.toFloat=function(){return this.asType("float32")},t.prototype.toInt=function(){return this.asType("int32")},t.prototype.toBool=function(){return this.asType("bool")},t.prototype.print=function(t){return void 0===t&&(t=!1),xt.print(this,t)},t.prototype.reshape=function(t){return this.throwIfDisposed(),xt.reshape(this,t)},t.prototype.reshapeAs=function(t){return this.throwIfDisposed(),this.reshape(t.shape)},t.prototype.expandDims=function(t){return void 0===t&&(t=0),xt.expandDims(this,t)},t.prototype.cumsum=function(t,e,n){return void 0===t&&(t=0),void 0===e&&(e=!1),void 0===n&&(n=!1),xt.cumsum(this,t,e,n)},t.prototype.squeeze=function(t){return this.throwIfDisposed(),xt.squeeze(this,t)},t.prototype.clone=function(){return this.throwIfDisposed(),xt.clone(this)},t.prototype.oneHot=function(t,e,n){return this.throwIfDisposed(),xt.oneHot(this,t,e,n)},t.prototype.toString=function(t){return void 0===t&&(t=!1),dt(this.dataSync(),this.shape,this.dtype,t)},t.prototype.tile=function(t){return this.throwIfDisposed(),xt.tile(this,t)},t.prototype.gather=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),xt.gather(this,t,e)},t.prototype.matMul=function(t,e,n){return void 0===e&&(e=!1),void 0===n&&(n=!1),this.throwIfDisposed(),xt.matMul(this,t,e,n)},t.prototype.dot=function(t){return this.throwIfDisposed(),xt.dot(this,t)},t.prototype.norm=function(t,e,n){return void 0===t&&(t="euclidean"),void 0===e&&(e=null),void 0===n&&(n=!1),this.throwIfDisposed(),xt.norm(this,t,e,n)},t.prototype.slice=function(t,e){return this.throwIfDisposed(),xt.slice(this,t,e)},t.prototype.reverse=function(t){return this.throwIfDisposed(),xt.reverse(this,t)},t.prototype.concat=function(e,n){return void 0===n&&(n=0),this.throwIfDisposed(),e instanceof t&&(e=[e]),xt.concat([this].concat(e),n)},t.prototype.split=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),xt.split(this,t,e)},t.prototype.stack=function(t,e){return void 0===e&&(e=0),xt.stack([this,t],e)},t.prototype.unstack=function(t){return void 0===t&&(t=0),xt.unstack(this,t)},t.prototype.pad=function(t,e){return void 0===e&&(e=0),xt.pad(this,t,e)},t.prototype.batchNormalization=function(t,e,n,r,o){return void 0===n&&(n=.001),bt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(t,e,o,r,n)},t.prototype.batchNorm=function(t,e,n,r,o){return void 0===o&&(o=.001),this.throwIfDisposed(),xt.batchNorm(this,t,e,n,r,o)},t.prototype.all=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.all(this,t,e)},t.prototype.any=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.any(this,t,e)},t.prototype.logSumExp=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.logSumExp(this,t,e)},t.prototype.sum=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.sum(this,t,e)},t.prototype.prod=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.prod(this,t,e)},t.prototype.mean=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.mean(this,t,e)},t.prototype.min=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.min(this,t,e)},t.prototype.max=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.max(this,t,e)},t.prototype.argMin=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),xt.argMin(this,t)},t.prototype.argMax=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),xt.argMax(this,t)},t.prototype.cast=function(t){return this.throwIfDisposed(),xt.cast(this,t)},t.prototype.add=function(t){return this.throwIfDisposed(),xt.add(this,t)},t.prototype.addStrict=function(t){return this.throwIfDisposed(),xt.addStrict(this,t)},t.prototype.atan2=function(t){return this.throwIfDisposed(),xt.atan2(this,t)},t.prototype.sub=function(t){return this.throwIfDisposed(),xt.sub(this,t)},t.prototype.subStrict=function(t){return this.throwIfDisposed(),xt.subStrict(this,t)},t.prototype.pow=function(t){return this.throwIfDisposed(),xt.pow(this,t)},t.prototype.powStrict=function(t){return this.throwIfDisposed(),xt.powStrict(this,t)},t.prototype.mul=function(t){return this.throwIfDisposed(),xt.mul(this,t)},t.prototype.mulStrict=function(t){return this.throwIfDisposed(),xt.mulStrict(this,t)},t.prototype.div=function(t){return this.throwIfDisposed(),xt.div(this,t)},t.prototype.divNoNan=function(t){return this.throwIfDisposed(),xt.divNoNan(this,t)},t.prototype.floorDiv=function(t){return this.throwIfDisposed(),xt.floorDiv(this,t)},t.prototype.divStrict=function(t){return this.throwIfDisposed(),xt.divStrict(this,t)},t.prototype.minimum=function(t){return this.throwIfDisposed(),xt.minimum(this,t)},t.prototype.minimumStrict=function(t){return this.throwIfDisposed(),xt.minimumStrict(this,t)},t.prototype.maximum=function(t){return this.throwIfDisposed(),xt.maximum(this,t)},t.prototype.maximumStrict=function(t){return this.throwIfDisposed(),xt.maximumStrict(this,t)},t.prototype.mod=function(t){return this.throwIfDisposed(),xt.mod(this,t)},t.prototype.modStrict=function(t){return this.throwIfDisposed(),xt.modStrict(this,t)},t.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),xt.squaredDifferenceStrict(this,t)},t.prototype.transpose=function(t){return this.throwIfDisposed(),xt.transpose(this,t)},t.prototype.notEqual=function(t){return this.throwIfDisposed(),xt.notEqual(this,t)},t.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),xt.notEqualStrict(this,t)},t.prototype.less=function(t){return this.throwIfDisposed(),xt.less(this,t)},t.prototype.lessStrict=function(t){return this.throwIfDisposed(),xt.lessStrict(this,t)},t.prototype.equal=function(t){return this.throwIfDisposed(),xt.equal(this,t)},t.prototype.equalStrict=function(t){return this.throwIfDisposed(),xt.equalStrict(this,t)},t.prototype.lessEqual=function(t){return this.throwIfDisposed(),xt.lessEqual(this,t)},t.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),xt.lessEqualStrict(this,t)},t.prototype.greater=function(t){return this.throwIfDisposed(),xt.greater(this,t)},t.prototype.greaterStrict=function(t){return this.throwIfDisposed(),xt.greaterStrict(this,t)},t.prototype.greaterEqual=function(t){return this.throwIfDisposed(),xt.greaterEqual(this,t)},t.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),xt.greaterEqualStrict(this,t)},t.prototype.logicalAnd=function(t){return this.throwIfDisposed(),xt.logicalAnd(this,t)},t.prototype.logicalOr=function(t){return this.throwIfDisposed(),xt.logicalOr(this,t)},t.prototype.logicalNot=function(){return this.throwIfDisposed(),xt.logicalNot(this)},t.prototype.logicalXor=function(t){return this.throwIfDisposed(),xt.logicalXor(this,t)},t.prototype.where=function(t,e){return this.throwIfDisposed(),xt.where(t,this,e)},t.prototype.neg=function(){return this.throwIfDisposed(),xt.neg(this)},t.prototype.ceil=function(){return this.throwIfDisposed(),xt.ceil(this)},t.prototype.floor=function(){return this.throwIfDisposed(),xt.floor(this)},t.prototype.sign=function(){return this.throwIfDisposed(),xt.sign(this)},t.prototype.isNaN=function(){return this.throwIfDisposed(),xt.isNaN(this)},t.prototype.isInf=function(){return this.throwIfDisposed(),xt.isInf(this)},t.prototype.isFinite=function(){return this.throwIfDisposed(),xt.isFinite(this)},t.prototype.exp=function(){return this.throwIfDisposed(),xt.exp(this)},t.prototype.expm1=function(){return this.throwIfDisposed(),xt.expm1(this)},t.prototype.log=function(){return this.throwIfDisposed(),xt.log(this)},t.prototype.log1p=function(){return this.throwIfDisposed(),xt.log1p(this)},t.prototype.sqrt=function(){return this.throwIfDisposed(),xt.sqrt(this)},t.prototype.rsqrt=function(){return this.throwIfDisposed(),xt.rsqrt(this)},t.prototype.square=function(){return this.throwIfDisposed(),xt.square(this)},t.prototype.reciprocal=function(){return this.throwIfDisposed(),xt.reciprocal(this)},t.prototype.abs=function(){return this.throwIfDisposed(),xt.abs(this)},t.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),xt.clipByValue(this,t,e)},t.prototype.relu=function(){return this.throwIfDisposed(),xt.relu(this)},t.prototype.relu6=function(){return this.throwIfDisposed(),xt.relu6(this)},t.prototype.elu=function(){return this.throwIfDisposed(),xt.elu(this)},t.prototype.selu=function(){return this.throwIfDisposed(),xt.selu(this)},t.prototype.leakyRelu=function(t){return void 0===t&&(t=.2),this.throwIfDisposed(),xt.leakyRelu(this,t)},t.prototype.prelu=function(t){return this.throwIfDisposed(),xt.prelu(this,t)},t.prototype.sigmoid=function(){return this.throwIfDisposed(),xt.sigmoid(this)},t.prototype.logSigmoid=function(){return this.throwIfDisposed(),xt.logSigmoid(this)},t.prototype.softplus=function(){return this.throwIfDisposed(),xt.softplus(this)},t.prototype.zerosLike=function(){return this.throwIfDisposed(),xt.zerosLike(this)},t.prototype.onesLike=function(){return this.throwIfDisposed(),xt.onesLike(this)},t.prototype.sin=function(){return this.throwIfDisposed(),xt.sin(this)},t.prototype.cos=function(){return this.throwIfDisposed(),xt.cos(this)},t.prototype.tan=function(){return this.throwIfDisposed(),xt.tan(this)},t.prototype.asin=function(){return this.throwIfDisposed(),xt.asin(this)},t.prototype.acos=function(){return this.throwIfDisposed(),xt.acos(this)},t.prototype.atan=function(){return this.throwIfDisposed(),xt.atan(this)},t.prototype.sinh=function(){return this.throwIfDisposed(),xt.sinh(this)},t.prototype.cosh=function(){return this.throwIfDisposed(),xt.cosh(this)},t.prototype.tanh=function(){return this.throwIfDisposed(),xt.tanh(this)},t.prototype.asinh=function(){return this.throwIfDisposed(),xt.asinh(this)},t.prototype.acosh=function(){return this.throwIfDisposed(),xt.acosh(this)},t.prototype.atanh=function(){return this.throwIfDisposed(),xt.atanh(this)},t.prototype.erf=function(){return this.throwIfDisposed(),xt.erf(this)},t.prototype.round=function(){return this.throwIfDisposed(),xt.round(this)},t.prototype.step=function(t){return void 0===t&&(t=0),this.throwIfDisposed(),xt.step(this,t)},t.prototype.softmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),xt.softmax(this,t)},t.prototype.logSoftmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),xt.logSoftmax(this,t)},t.prototype.resizeBilinear=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),xt.image.resizeBilinear(this,t,e)},t.prototype.resizeNearestNeighbor=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),xt.image.resizeNearestNeighbor(this,t,e)},t.prototype.conv1d=function(t,e,n,r,o,a){return void 0===r&&(r="NWC"),void 0===o&&(o=1),this.throwIfDisposed(),xt.conv1d(this,t,e,n,r,o,a)},t.prototype.conv2d=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),xt.conv2d(this,t,e,n,r,o,a)},t.prototype.conv2dTranspose=function(t,e,n,r,o){return this.throwIfDisposed(),xt.conv2dTranspose(this,t,e,n,r,o)},t.prototype.depthwiseConv2D=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),xt.depthwiseConv2d(this,t,e,n,r,o,a)},t.prototype.separableConv2d=function(t,e,n,r,o,a){return void 0===o&&(o=[1,1]),void 0===a&&(a="NHWC"),this.throwIfDisposed(),xt.separableConv2d(this,t,e,n,r,o,a)},t.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),xt.avgPool(this,t,e,n,r)},t.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),xt.maxPool(this,t,e,n,r)},t.prototype.localResponseNormalization=function(t,e,n,r){return void 0===t&&(t=5),void 0===e&&(e=1),void 0===n&&(n=1),void 0===r&&(r=.5),xt.localResponseNormalization(this,t,e,n,r)},t.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),xt.pool(this,t,e,n,r,o)},t.prototype.variable=function(t,e,n){return void 0===t&&(t=!0),this.throwIfDisposed(),yt().makeVariable(this,t,e,n)},t.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),xt.unsortedSegmentSum(this,t,e)},t.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),xt.batchToSpaceND(this,t,e)},t.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),xt.spaceToBatchND(this,t,e)},t.prototype.topk=function(t,e){return void 0===t&&(t=1),void 0===e&&(e=!0),this.throwIfDisposed(),xt.topk(this,t,e)},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s){return void 0===r&&(r=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),this.throwIfDisposed(),xt.stridedSlice(this,t,e,n,r,o,a,i,s)},t.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),xt.depthToSpace(this,t,e)},t.prototype.fft=function(){return this.throwIfDisposed(),xt.spectral.fft(this)},t.prototype.ifft=function(){return this.throwIfDisposed(),xt.spectral.ifft(this)},t.prototype.rfft=function(){return this.throwIfDisposed(),xt.spectral.rfft(this)},t.prototype.irfft=function(){return this.throwIfDisposed(),xt.spectral.irfft(this)},t}();Object.defineProperty(wt,Symbol.hasInstance,{value:function(t){return!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype}});var Ct,Et,Rt,It,kt,St=function(t){function n(e,n,r,o){var a=t.call(this,e.shape,e.dtype,e.dataId,o)||this;return a.trainable=n,a.name=r,a}return e(n,t),n.prototype.assign=function(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value ("+t.dtype+") and previous value ("+this.dtype+") must match");if(!S(t.shape,this.shape))throw new Error("shape of the new value ("+t.shape+") and previous value ("+this.shape+") must match");yt().disposeTensor(this),this.dataId=t.dataId,yt().incRef(this,null)},n.prototype.dispose=function(){yt().disposeVariable(this),this.isDisposedInternal=!0},n}(wt);Object.defineProperty(St,Symbol.hasInstance,{value:function(t){return t instanceof wt&&null!=t.assign&&t.assign instanceof Function}}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Ct||(Ct={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Et||(Et={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Rt||(Rt={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(It||(It={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(kt||(kt={}));var At={float32:It,int32:Et,bool:Rt,complex64:kt};function Dt(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast "+t+" with "+e)}return At[t][e]}function Tt(t){return Dt(t,"int32")}function Nt(t,e){if(t.dtype===e.dtype)return[t,e];var n=Dt(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Ft(t,e){C(t.dtype===e.dtype,(function(){return"The dtypes of the first("+t.dtype+") and second("+e.dtype+") input must match"}))}function _t(t){var e=[];return function t(e,n,r){if(null==e)return;if(e instanceof wt)return void n.push(e);if(o=e,!Array.isArray(o)&&"object"!=typeof o)return;var o;var a=e;for(var i in a){var s=a[i];r.has(s)||(r.add(s),t(s,n,r))}}(t,e,new Set),e}var Ot,Mt=Object.freeze({makeTypesMatch:Nt,assertTypesMatch:Ft,isTensorInList:function(t,e){return e.some((function(e){return e.id===t.id}))},getTensorsInContainer:_t}),Bt=function(){function t(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.dispose=function(){for(var t in this.registeredVariables)this.registeredVariables[t].dispose()},t}(),Pt=function(){function t(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Bt}return t.prototype.ready=function(){return n(this,void 0,void 0,(function(){var t,e,n;return r(this,(function(r){switch(r.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then((function(){}))];if(null!=this.backendInstance)return[2];t=this.getSortedBackends(),e=0,r.label=1;case 1:return e<t.length?(n=t[e],[4,this.initializeBackend(n).success]):[3,5];case 2:return r.sent()?[4,this.setBackend(n)]:[3,4];case 3:return r.sent(),[2];case 4:return e++,[3,1];case 5:throw new Error("Could not initialize any backends, all backend initializations failed.")}}))}))},Object.defineProperty(t.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){var t=this.initializeBackendsAndReturnBest(),e=t.name;if(t.asyncInit)throw new Error("The highest priority backend '"+e+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance},enumerable:!0,configurable:!0}),t.prototype.backendNames=function(){return Object.keys(this.registryFactory)},t.prototype.findBackend=function(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;if(this.initializeBackend(t).asyncInit)return null}return this.registry[t]},t.prototype.findBackendFactory=function(t){return t in this.registryFactory?this.registryFactory[t].factory:null},t.prototype.registerBackend=function(t,e,n){return void 0===n&&(n=1),t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)},t.prototype.setBackend=function(t){return n(this,void 0,void 0,(function(){var e,n,o;return r(this,(function(r){switch(r.label){case 0:if(null==this.registryFactory[t])throw new Error("Backend name '"+t+"' not found in registry");return this.backendName=t,null!=this.registry[t]?[3,4]:(this.backendInstance=null,e=this.initializeBackend(t),n=e.success,e.asyncInit?[4,n]:[3,2]);case 1:return o=r.sent(),[3,3];case 2:o=n,r.label=3;case 3:if(!o)return[2,!1];r.label=4;case 4:return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new ut(this.backendInstance),[2,!0]}}))}))},t.prototype.setupRegisteredKernels=function(){var t=this;f(this.backendName).forEach((function(e){null!=e.setupFunc&&e.setupFunc(t.backendInstance)}))},t.prototype.disposeRegisteredKernels=function(t){var e=this;f(t).forEach((function(n){null!=n.disposeFunc&&n.disposeFunc(e.registry[t])}))},t.prototype.initializeBackend=function(t){var e=this,n=this.registryFactory[t];if(null==n)throw new Error("Cannot initialize backend "+t+", no registration found.");try{var r=n.factory();if(Promise.resolve(r)===r){var o=++this.pendingBackendInitId,a=r.then((function(n){return!(o<e.pendingBackendInitId)&&(e.registry[t]=n,e.pendingBackendInit=null,!0)})).catch((function(n){return!(o<e.pendingBackendInitId)&&(e.pendingBackendInit=null,console.warn("Initialization of backend "+t+" failed"),console.warn(n.stack||n.message),!1)}));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(e){return console.warn("Initialization of backend "+t+" failed"),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}},t.prototype.removeBackend=function(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)},t.prototype.getSortedBackends=function(){var t=this;if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((function(e,n){return t.registryFactory[n].priority-t.registryFactory[e].priority}))},t.prototype.initializeBackendsAndReturnBest=function(){for(var t=this.getSortedBackends(),e=0;e<t.length;e++){var n=t[e],r=this.initializeBackend(n),o=r.success,a=r.asyncInit;if(a||o)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")},t.prototype.moveData=function(t,e){var n=this.state.tensorInfo.get(e),r=n.backend,o=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,o,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++},t.prototype.tidy=function(t,e){var n,r=this,o=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}return this.scopedRun((function(){return r.startScope(o)}),(function(){return r.endScope(n)}),(function(){return(n=e())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n}))},t.prototype.scopedRun=function(t,e,n){t();try{var r=n();return e(),r}catch(t){throw e(),t}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.clone=function(t){var e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(function(t){return{x:function(){return t.toFloat()}}}),[]),e},t.prototype.runKernel=function(t,e,n,r,o){return this.runKernelFunc(null,e,null,t,n,r,o)},t.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")},t.prototype.checkKernelForMemLeak=function(t,e,n){var r=this.backend.numDataIds(),o=0;n.forEach((function(t){o+="complex64"===t.dtype?3:1}));var a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-e-o-a;if(i>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+i+" data ids) after running '"+t+"'")},t.prototype.runKernelFunc=function(t,e,n,r,o,a,i){var s,u=this;void 0===a&&(a=[]),void 0===i&&(i=[]);var c=[],h=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");var f,d=function(t){h&&(c=t.map((function(t){return u.keep(u.clone(t))})))},p=this.state.numBytes,v=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);var m,g=l(r,this.backendName);return f=null!=g?function(){var t=u.backend.numDataIds();m=g.kernelFunc({inputs:e,attrs:o,backend:u.backend});var n=Array.isArray(m)?m:[m];u.shouldCheckForMemLeaks()&&u.checkKernelForMemLeak(r,t,n);var s=n.map((function(t){var e=t.dataId,n=t.shape,r=t.dtype;return u.makeTensorFromDataId(e,n,r)})),c=s.filter((function(t,e){return i[e]}));return d((a||[]).slice().concat(c)),s}:function(){var e=u.backend.numDataIds();m=u.tidy((function(){return t(u.backend,d)}));var n=Array.isArray(m)?m:[m];return u.shouldCheckForMemLeaks()&&u.checkKernelForMemLeak(r,e,n),n},this.scopedRun((function(){return u.state.kernelDepth++}),(function(){return u.state.kernelDepth--}),(function(){s=u.ENV.getBool("DEBUG")?u.profiler.profileKernel(r,e,(function(){return f()})):f()})),h&&this.addTapeNode(r,e,s,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-p,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-v,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map((function(t){return e[t].shape})),outputShapes:s.map((function(t){return t.shape}))}),Array.isArray(m)?s:s[0]},t.prototype.makeTensor=function(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;var o=t;"string"===n&&H(t[0])&&(o=t.map((function(t){return rt(t)})));var a=r.write(o,e,n),i=new wt(e,n,a,this.nextTensorId());if(this.incRef(i,r),"string"===n){var s=this.state.tensorInfo.get(a),u=G(o);this.state.numBytes+=u-s.bytes,s.bytes=u}return i},t.prototype.makeTensorFromDataId=function(t,e,n,r){var o=new wt(e,n=n||"float32",t,this.nextTensorId());return this.incRef(o,r),o},t.prototype.makeVariable=function(t,e,n,r){void 0===e&&(e=!0),n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.asType(r));var o=new St(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error("Variable with name "+o.name+" was already registered");return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o},t.prototype.incRef=function(t,e){var n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;var r=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(r=t.size*z(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:r,refCount:0}),this.state.numBytes+=r}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof St||this.track(t)},t.prototype.disposeTensor=function(t){if(this.state.tensorInfo.has(t.dataId)){this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;var e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}},t.prototype.disposeVariables=function(){for(var t in this.state.registeredVariables){var e=this.state.registeredVariables[t];this.disposeVariable(e)}},t.prototype.disposeVariable=function(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]},t.prototype.memory=function(){var t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t},t.prototype.profile=function(t){return n(this,void 0,void 0,(function(){var e,n;return r(this,(function(r){return this.state.profiling=!0,e=this.state.numBytes,n=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map((function(t){return t.totalBytesSnapshot}))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n,[2,this.state.activeProfile]}))}))},t.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},t.prototype.addTapeNode=function(t,e,n,r,o){var a=this,i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},s=h(t);null!=s&&(r=s.gradFunc),null!=r&&(i.gradient=function(t){return t=t.map((function(t,e){if(null==t){var r=n[e],o=tt(r.size,r.dtype);return a.makeTensor(o,r.shape,r.dtype)}return t})),r(t.length>1?t:t[0],o)}),this.state.activeTape.push(i)},t.prototype.keep=function(t){return t.kept=!0,t},t.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},t.prototype.endTape=function(){this.state.gradientDepth--},t.prototype.startScope=function(t){var e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e},t.prototype.endScope=function(t){for(var e=this,n=_t(t),r=new Set(n.map((function(t){return t.id}))),o=0;o<this.state.activeScope.track.length;o++){var a=this.state.activeScope.track[o];a.kept||r.has(a.id)||a.dispose()}var i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach((function(t){t.kept||t.scopeId!==i.id||e.track(t)}))},t.prototype.gradients=function(t,e,n,r){var o=this;if(void 0===r&&(r=!1),C(e.length>0,(function(){return"gradients() received an empty list of xs."})),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '"+n.dtype+"'");var a=this.scopedRun((function(){return o.startTape()}),(function(){return o.endTape()}),(function(){return o.tidy("forward",t)}));C(a instanceof wt,(function(){return"The result y returned by f() must be a tensor."}));var i=function(t,e,n){for(var r={},o={},a=0;a<e.length;a++)r[e[a].id]=!0;for(a=0;a<t.length;a++){var i=(p=t[a]).inputs;for(var s in i){for(var u=i[s],c=!1,l=0;l<e.length;l++)if(r[u.id]){p.outputs.forEach((function(t){return r[t.id]=!0})),c=!0,o[p.id]=!0;break}if(c)break}}var h={};h[n.id]=!0;var f={};for(a=t.length-1;a>=0;a--)for(i=(p=t[a]).inputs,l=0;l<p.outputs.length;l++)if(h[p.outputs[l].id]){for(var s in i)h[i[s].id]=!0,f[p.id]=!0;break}var d=[];for(a=0;a<t.length;a++){var p;if(o[(p=t[a]).id]&&f[p.id]){var v={};for(var s in p.inputs){var m=p.inputs[s];r[m.id]&&(v[s]=m)}var g=Object.assign({},p);g.inputs=v,g.outputs=p.outputs,d.push(g)}}return d}(this.state.activeTape,e,a);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(function(){var t,r,s={};s[a.id]=null==n?(t=a.shape,r=Z(k(t),"float32"),Lt.makeTensor(r,t,"float32")):n,function(t,e,n){for(var r=function(r){var o=e[r],a=[];if(o.outputs.forEach((function(e){var n=t[e.id];null!=n?a.push(n):a.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+o.kernelName+".");var i=o.gradient(a),s=function(e){if(!(e in i))throw new Error("Cannot backprop through input "+e+". Available gradients found: "+Object.keys(i)+".");var r=n((function(){return i[e]()}));if("float32"!==r.dtype)throw new Error("Error in gradient for op "+o.kernelName+". The gradient of input "+e+" must have 'float32' dtype, but has '"+r.dtype+"'");var a=o.inputs[e];if(!S(r.shape,a.shape))throw new Error("Error in gradient for op "+o.kernelName+". The gradient of input '"+e+"' has shape '"+r.shape+"', which does not match the shape of the input '"+a.shape+"'");if(null==t[a.id])t[a.id]=r;else{var s=t[a.id];t[a.id]=s.add(r),s.dispose()}};for(var u in o.inputs)s(u)},o=e.length-1;o>=0;o--)r(o)}(s,i,(function(t){return o.tidy(t)}));var u=e.map((function(t){return s[t.id]}));return 0===o.state.gradientDepth&&(o.state.activeTape.forEach((function(t){for(var e=0,n=t.saved;e<n.length;e++){n[e].dispose()}})),o.state.activeTape=null),{value:a,grads:u}}))},t.prototype.customGrad=function(t){var e=this;return C(X(t),(function(){return"The f passed in customGrad(f) must be a function."})),function(){for(var n,r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];C(r.every((function(t){return t instanceof wt})),(function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"}));var a={};return r.forEach((function(t,e){a[e]=t})),e.runKernelFunc((function(e,o){return C((n=t.apply(void 0,r.concat([o]))).value instanceof wt,(function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"})),C(X(n.gradFunc),(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."})),n.value}),a,(function(t,e){var o=n.gradFunc(t,e),a=Array.isArray(o)?o:[o];C(a.length===r.length,(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."})),C(a.every((function(t){return t instanceof wt})),(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."}));var i={};return a.forEach((function(t,e){i[e]=function(){return t}})),i}))}},t.prototype.readSync=function(t){return this.state.tensorInfo.get(t).backend.readSync(t)},t.prototype.read=function(t){return this.state.tensorInfo.get(t).backend.read(t)},t.prototype.time=function(t){return n(this,void 0,void 0,(function(){var e,n;return r(this,(function(r){switch(r.label){case 0:return e=et(),[4,this.backend.time(t)];case 1:return(n=r.sent()).wallMs=et()-e,[2,n]}}))}))},t.prototype.track=function(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t},Object.defineProperty(t.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),t.prototype.reset=function(){for(var t in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Bt,this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null},t.nextTensorId=0,t.nextVariableId=0,t}();var Lt=function(){var t=function(){if(null==Ot){var t=void 0;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Ot=t}return Ot}();if(null==t._tfengine){var e=new o(t);t._tfengine=new Pt(e)}return function(t){s=t}(t._tfengine.ENV),yt=function(){return t._tfengine},t._tfengine}();function Wt(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var Ut=i();Ut.registerFlag("DEBUG",(function(){return!1}),(function(t){t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Ut.registerFlag("IS_BROWSER",(function(){return Wt()})),Ut.registerFlag("IS_NODE",(function(){return"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node})),Ut.registerFlag("IS_CHROME",(function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)})),Ut.registerFlag("PROD",(function(){return!1})),Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(function(){return Ut.getBool("DEBUG")})),Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED",(function(){return!0})),Ut.registerFlag("IS_TEST",(function(){return!1}));var Vt,zt,Gt,Ht={},qt={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Kt(t,e){Ht[t]=e}function jt(t){t in Ht||(Ht[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);if(e.addEventListener("webglcontextlost",(function(e){e.preventDefault(),delete Ht[t]}),!1),1===t)return e.getContext("webgl",qt)||e.getContext("experimental-webgl",qt);return e.getContext("webgl2",qt)}(t));var e=Ht[t];return e.isContextLost()?(delete Ht[t],jt(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Ht[t])}function Xt(t,e){return[e,t]}function Yt(t){var e=k(t);return T(Math.ceil(e/4))}function $t(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Qt(t,e){var n,r,o,a,s,u,c,l,h,f=t;return 2===i().getNumber("WEBGL_VERSION")?(n=f.R32F,r=f.R16F,o=f.RGBA16F,a=f.RGBA32F,s=f.RED,u=4,c=1,l=f.HALF_FLOAT,h=f.FLOAT):(n=t.RGBA,r=t.RGBA,o=t.RGBA,a=f.RGBA,s=t.RGBA,u=4,c=4,l=null!=e?e.HALF_FLOAT_OES:null,h=t.FLOAT),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:s,downloadTextureFormat:t.RGBA,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:l,textureTypeFloat:h}}function Jt(t,e,n){var r=n();return e&&function(t){var e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+ne(t,e))}(t),r}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(Vt||(Vt={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(zt||(zt={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Gt||(Gt={}));var Zt=5.96e-8,te=65504;function ee(t){return!!(i().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||Zt<Math.abs(t)&&Math.abs(t)<te)}function ne(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}function re(t,e,n){return ke(t,e,(function(){return t.getExtension(n)}),'Extension "'+n+'" not supported on this browser.')}function oe(t,e,n){var r=ke(t,e,(function(){return t.createShader(t.VERTEX_SHADER)}),"Unable to create vertex WebGLShader.");if(Jt(t,e,(function(){return t.shaderSource(r,n)})),Jt(t,e,(function(){return t.compileShader(r)})),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function ae(t,e,n){var r=ke(t,e,(function(){return t.createShader(t.FRAGMENT_SHADER)}),"Unable to create fragment WebGLShader.");if(Jt(t,e,(function(){return t.shaderSource(r,n)})),Jt(t,e,(function(){return t.compileShader(r)})),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw function(t,e){var n=ue.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);for(var r=+n[1],o=t.split("\n"),a=o.length.toString().length+2,i=o.map((function(t,e){return N((e+1).toString(),a)+t})),s=0,u=0;u<i.length;u++)s=Math.max(i[u].length,s);var c=i.slice(0,r-1),l=i.slice(r-1,r),h=i.slice(r);console.log(c.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+N(l[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(n,t.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var ie,se,ue=/ERROR: [0-9]+:([0-9]+):/g;function ce(t,e){return ke(t,e,(function(){return t.createProgram()}),"Unable to create WebGLProgram.")}function le(t,e,n){if(Jt(t,e,(function(){return t.linkProgram(n)})),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function he(t,e,n){if(Jt(t,e,(function(){return t.validateProgram(n)})),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function fe(t,e,n){var r=ke(t,e,(function(){return t.createBuffer()}),"Unable to create WebGLBuffer");return Jt(t,e,(function(){return t.bindBuffer(t.ARRAY_BUFFER,r)})),Jt(t,e,(function(){return t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)})),r}function de(t,e,n){var r=ke(t,e,(function(){return t.createBuffer()}),"Unable to create WebGLBuffer");return Jt(t,e,(function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r)})),Jt(t,e,(function(){return t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)})),r}function pe(t,e){return ke(t,e,(function(){return t.createTexture()}),"Unable to create WebGLTexture.")}function ve(t,e){var n=i().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){var r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+("["+n+"x"+n+"]")+".")}}function me(t,e){return ke(t,e,(function(){return t.createFramebuffer()}),"Unable to create WebGLFramebuffer.")}function ge(t,e,n,r,o,a,i,s){var u=t.getAttribLocation(n,r);return-1!==u&&(Jt(t,e,(function(){return t.bindBuffer(t.ARRAY_BUFFER,o)})),Jt(t,e,(function(){return t.vertexAttribPointer(u,a,t.FLOAT,!1,i,s)})),Jt(t,e,(function(){return t.enableVertexAttribArray(u)})),!0)}function ye(t,e,n,r){Se(t,r),Jt(t,e,(function(){return t.activeTexture(t.TEXTURE0+r)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,n)}))}function xe(t,e,n,r){return ke(t,e,(function(){return t.getUniformLocation(n,r)}),'uniform "'+r+'" not present in program.')}function be(t,e,n){return t.getUniformLocation(e,n)}function we(t,e,n,r,o,a){Jt(t,e,(function(){return ye(t,e,r,a)})),Jt(t,e,(function(){return t.uniform1i(o,a)}))}function Ce(t,e,n,r){Jt(t,e,(function(){return t.bindFramebuffer(t.FRAMEBUFFER,r)})),Jt(t,e,(function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0)}))}function Ee(t,e,n){Jt(t,e,(function(){return t.bindFramebuffer(t.FRAMEBUFFER,n)})),Jt(t,e,(function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)}))}function Re(t){var e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Ie(t,e))}function Ie(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}function ke(t,e,n,r){var o=Jt(t,e,(function(){return n()}));if(null==o)throw new Error(r);return o}function Se(t,e){var n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+n+"]")+".")}function Ae(t,e){return void 0===e&&(e=2),k(t.slice(0,t.length-e))}function De(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Te(t){var e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[Ae(t)].concat(De(t))),e}function Ne(t,e){var n;void 0===e&&(e=!1);var r=i().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(r*=2,1===(t=t.map((function(e,n){return n>=t.length-2?b(t[n]):t[n]}))).length&&(t=[2,t[0]])),2!==t.length){var o=M(t);t=o.newShape}var a=k(t);if(t.length<=1&&a<=r)return[1,a];if(2===t.length&&t[0]<=r&&t[1]<=r)return t;if(3===t.length&&t[0]*t[1]<=r&&t[2]<=r)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=r&&t[1]*t[2]<=r)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=r&&t[3]<=r)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=r&&t[1]*t[2]*t[3]<=r)return[t[0],t[1]*t[2]*t[3]];if(e){var s=Ae(t),u=2,c=2;return t.length&&(u=(n=De(t))[0],c=n[1]),T(a=s*(u/2)*(c/2)).map((function(t){return 2*t}))}return T(a)}function Fe(t){return t%2==0}function _e(t,e){if(S(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){var n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(Fe(n)&&Fe(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&Fe(t[0])&&Fe(e[0])}function Oe(t){if(null==ie){var e=jt(t);ie=e.getParameter(e.MAX_TEXTURE_SIZE)}return ie}function Me(t){if(null==se){var e=jt(t);se=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,se)}function Be(t){if(0===t)return 0;var e=jt(t);return Pe(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:Pe(e,"EXT_disjoint_timer_query")?1:0}function Pe(t,e){return null!=t.getExtension(e)}function Le(t){try{if(null!=jt(t))return!0}catch(t){return!1}return!1}function We(t){if(0===t)return!1;var e=jt(t);if(1===t){if(!Pe(e,"OES_texture_float"))return!1}else if(!Pe(e,"EXT_color_buffer_float"))return!1;return Ve(e)}function Ue(t){if(0===t)return!1;var e=jt(t);if(1!==t){if(Pe(e,"EXT_color_buffer_float"))return Ve(e);if(Pe(e,"EXT_color_buffer_half_float")){var n=e.getExtension("EXT_color_buffer_half_float");return function(t,e){var n=Qt(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);var o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),a}(e,n)}return!1}return!!Pe(e,"OES_texture_float")&&(!!Pe(e,"WEBGL_color_buffer_float")&&Ve(e))}function Ve(t){var e=Qt(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);var r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);var o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),o}function ze(t){return 2===t&&null!=jt(t).fenceSync}var Ge=Object.freeze({callAndCheck:Jt,canBeRepresented:ee,getWebGLErrorMessage:ne,getExtensionOrThrow:re,createVertexShader:oe,createFragmentShader:ae,createProgram:ce,linkProgram:le,validateProgram:he,createStaticVertexBuffer:fe,createStaticIndexBuffer:de,getNumChannels:function(){return 2===i().getNumber("WEBGL_VERSION")?1:4},createTexture:pe,validateTextureSize:ve,createFramebuffer:me,bindVertexBufferToProgramAttribute:ge,bindTextureUnit:ye,unbindTextureUnit:function(t,e,n){Se(t,n),Jt(t,e,(function(){return t.activeTexture(t.TEXTURE0+n)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)}))},getProgramUniformLocationOrThrow:xe,getProgramUniformLocation:be,bindTextureToProgramUniformSampler:we,bindCanvasToFramebuffer:function(t,e){Jt(t,e,(function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)})),Jt(t,e,(function(){return t.viewport(0,0,t.canvas.width,t.canvas.height)})),Jt(t,e,(function(){return t.scissor(0,0,t.canvas.width,t.canvas.height)}))},bindColorTextureToFramebuffer:Ce,unbindColorTextureFromFramebuffer:Ee,validateFramebuffer:Re,getFramebufferErrorMessage:Ie,getBatchDim:Ae,getRowsCols:De,getShapeAs3D:Te,getTextureShapeFromLogicalShape:Ne,isReshapeFree:_e,getWebGLMaxTextureSize:Oe,resetMaxTextureSize:function(){ie=null},resetMaxTexturesInShader:function(){se=null},getMaxTexturesInShader:Me,getWebGLDisjointQueryTimerVersion:Be,hasExtension:Pe,isWebGLVersionEnabled:Le,isCapableOfRenderingToFloatTexture:We,isDownloadFloatTextureEnabled:Ue,isWebGLFenceEnabled:ze}),He=i();function qe(){i().set("PROD",!0)}function Ke(){i().set("DEBUG",!0)}function je(){i().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Xe(t){i().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Ye(){Lt.disposeVariables()}function $e(){return Lt}function Qe(){return Lt.memory()}function Je(t){return Lt.profile(t)}function Ze(t,e){return Lt.tidy(t,e)}function tn(t){_t(t).forEach((function(t){return t.dispose()}))}function en(t){return Lt.keep(t)}function nn(t){return Lt.time(t)}function rn(t){return Lt.setBackend(t)}function on(){return Lt.ready()}function an(){return Lt.backendName}function sn(t){Lt.removeBackend(t)}function un(t){return Lt.findBackend(t)}function cn(t){return Lt.findBackendFactory(t)}function ln(t,e,n){return void 0===n&&(n=1),Lt.registerBackend(t,e,n)}function hn(){return Lt.backend}function fn(t,e){i().setPlatform(t,e)}function dn(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];i().getBool("IS_TEST")||console.warn.apply(console,t)}function pn(t,e){var n=t;if(V(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];for(var r=[];Array.isArray(n)||V(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&i().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){if(r=r||[],!Array.isArray(e)&&!V(e))return void C(0===n.length,(function(){return"Element arr["+r.join("][")+"] is a primitive, but should be an array/TypedArray of "+n[0]+" elements"}));C(n.length>0,(function(){return"Element arr["+r.join("][")+"] should be a primitive, but is an array of "+e.length+" elements"})),C(e.length===n[0],(function(){return"Element arr["+r.join("][")+"] should have "+n[0]+" elements, but has "+e.length+" elements"}));for(var o=n.slice(1),a=0;a<e.length;++a)t(e[a],o,r.concat(a))}(t,r,[]),r}function vn(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error("Argument '"+n+"' passed to '"+r+"' must be "+t+" tensor, but got "+e+" tensor")}function mn(t,e,n,r){if(void 0===r&&(r="numeric"),t instanceof wt)return vn(r,t.dtype,e,n),t;var o=j(t);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),vn(r,o,e,n),null==t||!V(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){var a=null==t?"null":t.constructor.name;throw new Error("Argument '"+e+"' passed to '"+n+"' must be a Tensor or TensorLike, but got '"+a+"'")}var s=pn(t,o);V(t)||Array.isArray(t)||(t=[t]);var u="string"!==o?Q(t,o,i().getBool("DEBUG")):I(t,[],!0);return Lt.makeTensor(u,s,o)}function gn(t,e,n,r){if(void 0===r&&(r="numeric"),!Array.isArray(t))throw new Error("Argument "+e+" passed to "+n+" must be a `Tensor[]` or `TensorLike[]`");return t.map((function(t,r){return mn(t,e+"["+r+"]",n)}),r)}function yn(t,e){for(var n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function xn(t,e,n){for(var r=t.length+e.length,o=[],a=0,i=0,s=0;s<r;s++)-1===n.indexOf(s)?o.push(t[a++]):o.push(e[i++]);return o}function bn(t,e){for(var n=[],r=t.length,o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map((function(e){return t[e]}))]}function wn(t,e){return xn(t,e.map((function(t){return 1})),e)}function Cn(t,e,n){C(yn(e,n),(function(){return t+" supports only inner-most axes for now. Got axes "+e+" and rank-"+n+" input."}))}function En(t,e){if(yn(t,e))return null;for(var n=[],r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((function(t){return n.push(t)})),n}function Rn(t){return t.map((function(t,e){return[e,t]})).sort((function(t,e){return t[1]-e[1]})).map((function(t){return t[0]}))}function In(t,e){for(var n=[],r=e-t;r<e;++r)n.push(r);return n}function kn(t,e){var n=t[0].length;t.forEach((function(t,e){C(t.length===n,(function(){return"Error in concat"+n+"D: rank of tensors["+e+"] must be the same as the rank of the rest ("+n+")"}))})),C(e>=0&&e<n,(function(){return"Error in concat"+n+"D: axis must be between 0 and "+(n-1)+"."}));var r=t[0];t.forEach((function(t,o){for(var a=0;a<n;a++)C(a===e||t[a]===r[a],(function(){return"Error in concat"+n+"D: Shape of tensors["+o+"] ("+t+") does not match the shape of the rest ("+r+") along the non-concatenated axis "+o+"."}))}))}function Sn(t,e){for(var n=t[0].slice(),r=1;r<t.length;r++)n[e]+=t[r][e];return n}function An(t){var e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");var n=e[0],r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));var o=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];Lt.startScope(n);try{var o=r.apply(void 0,t);return o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Lt.endScope(o),o}catch(t){throw Lt.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}He.registerFlag("HAS_WEBGL",(function(){return He.getNumber("WEBGL_VERSION")>0})),He.registerFlag("WEBGL_VERSION",(function(){return Le(2)?2:Le(1)?1:0})),He.registerFlag("WEBGL_BUFFER_SUPPORTED",(function(){return 2===He.get("WEBGL_VERSION")})),He.registerFlag("WEBGL_CPU_FORWARD",(function(){return!0})),He.registerFlag("WEBGL_FORCE_F16_TEXTURES",(function(){return!1})),He.registerFlag("WEBGL_PACK",(function(){return He.getBool("HAS_WEBGL")})),He.registerFlag("WEBGL_PACK_NORMALIZATION",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_CLIP",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_DEPTHWISECONV",(function(){return!1})),He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_REDUCE",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_LAZILY_UNPACK",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_CONV_IM2COL",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(function(){return Oe(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(function(){return Me(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(function(){var t=He.getNumber("WEBGL_VERSION");return 0===t?0:Be(t)})),He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(function(){return He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(t=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))));var t})),He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(function(){return We(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(function(){return!He.getBool("WEBGL_FORCE_F16_TEXTURES")&&He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")})),He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(function(){return Ue(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_FENCE_API_ENABLED",(function(){return ze(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(function(){return He.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0})),bt=Xe;var Dn=An({complex_:function(t,e){var n=mn(t,"real","complex"),r=mn(e,"imag","complex");return E(n.shape,r.shape,"real and imag shapes, "+n.shape+" and "+r.shape+", must match in call to tf.complex()."),Lt.runKernelFunc((function(t){return t.complex(n,r)}),{$real:n,$imag:r})}}),Tn=An({real_:function(t){var e=mn(t,"input","real");return Lt.runKernelFunc((function(t){return t.real(e)}),{$input:e})}}),Nn=An({imag_:function(t){var e=mn(t,"input","imag");return Lt.runKernelFunc((function(t){return t.imag(e)}),{$input:e})}});function Fn(t,e,n){return _n(t,e,pn(t,n),n)}function _n(t,e,n,r){if(null==r&&(r=j(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!V(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){nt(e);var o=k(e),a=k(n);C(o===a,(function(){return"Based on the provided shape, ["+e+"], the tensor should have "+o+" values but has "+a}));for(var s=0;s<n.length;++s){var u=n[s],c=s!==n.length-1||u!==k(e.slice(s));C(n[s]===e[s]||!c,(function(){return"Error creating a new Tensor. Inferred shape ("+n+") does not match the provided shape ("+e+"). "}))}}return V(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?Q(t,r,i().getBool("DEBUG")):I(t,[],!0),Lt.makeTensor(t,e,r)}function On(t,e){if((V(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&V(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return _n(t,[],[],e)}function Mn(t,e){R(t);var n=pn(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return _n(t,null,n,e)}function Bn(t,e,n){if(R(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");var r=pn(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _n(t,e,r,n)}function Pn(t,e,n){if(R(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");var r=pn(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return _n(t,e,r,n)}function Ln(t,e,n){if(R(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");var r=pn(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return _n(t,e,r,n)}function Wn(t,e,n){if(R(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");var r=pn(t,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return _n(t,e,r,n)}function Un(t,e,n){if(R(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");var r=pn(t,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return _n(t,e=e||r,r,n)}function Vn(t,e,n,r){return void 0===e&&(e=!0),Lt.makeVariable(t,e,n,r)}function zn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=zn(t,"float32"),r=Gn(t,"float32");return Dn(n,r)}var o=Z(k(t),e);return Lt.makeTensor(o,t,e)}function Gn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=Gn(t,"float32"),r=Gn(t,"float32");return Dn(n,r)}var o=tt(k(t),e);return Lt.makeTensor(o,t,e)}function Hn(t,e,n){return Lt.runKernelFunc((function(r){return r.fill(t,e,n)}),{})}function qn(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return Lt.runKernelFunc((function(r){return r.linspace(t,e,n)}),{})}function Kn(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r="float32"),0===n)throw new Error("Cannot have a step of zero");if(t===e||t<e&&n<0||e<t&&n>1)return Gn([0],r);var o=tt(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+n;return Mn(o,r)}var jn=An({onesLike_:function(t){var e=mn(t,"x","onesLike");if("complex64"===e.dtype){var n=jn(Tn(e)),r=Xn(Nn(e));return Dn(n,r)}return Lt.runKernelFunc((function(t){return t.onesLike(e)}),{$x:e},(function(t,e){return{$x:function(){return Xn(t)}}}))}}),Xn=An({zerosLike_:function(t){var e=mn(t,"x","zerosLike");return Lt.runKernelFunc((function(t){return t.zerosLike(e)}),{$x:e},(function(t,e){return{$x:function(){return Xn(t)}}}))}});var Yn=An({concat_:function(t,e){void 0===e&&(e=0),C(t.length>=1,(function(){return"Pass at least one tensor to concat"}));var n=gn(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach((function(t){if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype "+t.dtype+". ")})),e=O(e,n[0].shape)[0];var r=Sn(n.map((function(t){return t.shape})),e);if(0===k(r))return Fn([],r);if(1===(n=n.filter((function(t){return t.size>0}))).length)return n[0];var o=n.map((function(t){return t.shape}));kn(o,e);var a=n,i={axis:e};return Lt.runKernelFunc((function(t){return t.concat(n,e)}),a,(function(t){var n=o.map((function(t){return t[e]}));return tr(t,n,e).map((function(t){return function(){return t}}))}),"Concat",i)}}),$n=An({concat1d_:function(t){return Yn(t,0)}}),Qn=An({concat2d_:function(t,e){return Yn(t,e)}}),Jn=An({concat3d_:function(t,e){return Yn(t,e)}}),Zn=An({concat4d_:function(t,e){return Yn(t,e)}}),tr=An({split_:function(t,e,n){void 0===n&&(n=0);var r,o=mn(t,"x","split");return n=O(n,o.shape)[0],"number"==typeof e?(C(o.shape[n]%e==0,(function(){return"Number of splits must evenly divide the axis."})),r=new Array(e).fill(o.shape[n]/e)):(C(o.shape[n]===e.reduce((function(t,e){return t+e})),(function(){return"The sum of sizes must match the size of the axis dimension."})),r=e),Lt.runKernelFunc((function(t){return t.split(o,r,n)}),{$x:o},(function(t){return{$x:function(){return Yn(t,n)}}}))}});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function er(t,e){return t(e={exports:{}},e.exports),e.exports}var nr=er((function(t){!function(t,e,n){function r(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function a(t,e){var n=new r(t),a=e&&e.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.alea=a}(0,t,!1)})),rr=er((function(t){!function(t,e,n){function r(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xor128=a}(0,t,!1)})),or=er((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xorwow=a}(0,t,!1)})),ar=er((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.x,o=e.i;return t=r[o],n=(t^=t>>>7)^t<<24,n^=(t=r[o+1&7])^t>>>10,n^=(t=r[o+3&7])^t>>>3,n^=(t=r[o+4&7])^t<<7,t=r[o+7&7],n^=(t^=t<<13)^t<<9,r[o]=n,e.i=o+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.x&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xorshift7=a}(0,t,!1)})),ir=er((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.w,o=e.X,a=e.i;return e.w=r=r+1640531527|0,n=o[a+34&127],t=o[a=a+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=o[a]=n^t,e.i=a,n+(r^r>>>16)|0},function(t,e){var n,r,o,a,i,s=[],u=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,u=Math.max(u,e.length)),o=0,a=-32;a<u;++a)e&&(r^=e.charCodeAt((a+32)%e.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(e&&e.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;t.w=i,t.X=s,t.i=o}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.X&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xor4096=a}(0,t,!1)})),sr=er((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,o=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^o,e.a=o-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.tychei=a}(0,t,!1)})),ur=er((function(t){!function(e,n){var r,o=this,a=256,i=6,s="random",u=n.pow(a,i),c=n.pow(2,52),l=2*c,h=a-1;function f(t,h,f){var g=[],y=v(function t(e,n){var r,o=[],a=typeof e;if(n&&"object"==a)for(r in e)try{o.push(t(e[r],n-1))}catch(t){}return o.length?o:"string"==a?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return r&&(t=r.randomBytes)?t=t(a):(t=new Uint8Array(a),(o.crypto||o.msCrypto).getRandomValues(t)),m(t)}catch(t){var n=o.navigator,i=n&&n.plugins;return[+new Date,o,i,o.screen,m(e)]}}():t,3),g),x=new d(g),b=function(){for(var t=x.g(i),e=u,n=0;t<c;)t=(t+n)*a,e*=a,n=x.g(1);for(;t>=l;)t/=2,e/=2,n>>>=1;return(t+n)/e};return b.int32=function(){return 0|x.g(4)},b.quick=function(){return x.g(4)/4294967296},b.double=b,v(m(x.S),e),(h.pass||f||function(t,e,r,o){return o&&(o.S&&p(o,x),t.state=function(){return p(x,{})}),r?(n[s]=t,e):t})(b,y,"global"in h?h.global:this==n,h.state)}function d(t){var e,n=t.length,r=this,o=0,i=r.i=r.j=0,s=r.S=[];for(n||(t=[n++]);o<a;)s[o]=o++;for(o=0;o<a;o++)s[o]=s[i=h&i+t[o%n]+(e=s[o])],s[i]=e;(r.g=function(t){for(var e,n=0,o=r.i,i=r.j,s=r.S;t--;)e=s[o=h&o+1],n=n*a+s[h&(s[o]=s[i=h&i+e])+(s[i]=e)];return r.i=o,r.j=i,n})(a)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function v(t,e){for(var n,r=t+"",o=0;o<r.length;)e[h&o]=h&(n^=19*e[h&o])+r.charCodeAt(o++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(n["seed"+s]=f,v(n.random(),e),t.exports){t.exports=f;try{r=__webpack_require__(/*! crypto */ 0)}catch(t){}}}([],Math)}));ur.alea=nr,ur.xor128=rr,ur.xorwow=or,ur.xorshift7=ar,ur.xor4096=ir,ur.tychei=sr;var cr=ur.alea,lr=function(){function t(t,e,n,r,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var a=o||Math.random();this.random=cr(a.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var t=this.nextVal;return this.nextVal=NaN,t}for(var e,n,r=!1;!r;){var o=void 0,a=void 0,i=void 0;do{i=(o=2*this.random()-1)*o+(a=2*this.random()-1)*a}while(i>=1||0===i);var s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*s,n=this.mean+this.stdDev*a*s,this.truncated&&!this.isValidTruncated(e)||(r=!0)}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(e)},t.prototype.convertValue=function(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)},t.prototype.isValidTruncated=function(t){return t<=this.upper&&t>=this.lower},t}(),hr=function(){function t(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;var o=r||Math.random();this.randu=cr(o.toString()),this.randn=new lr(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}return t.prototype.nextValue=function(){for(var t,e,n,r,o,a;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=1-.331*(t=r*r)*t,n=.5*t+this.d*(1-a+Math.log(a)),(o=this.randu())<e||Math.log(o)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)},t.prototype.convertValue=function(t){return"float32"===this.dtype?t:Math.round(t)},t}(),fr=function(){function t(t,e,n,r){var o=this;if(void 0===t&&(t=0),void 0===e&&(e=1),this.canReturnFloat=function(){return null==o.dtype||"float32"===o.dtype},this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+t+" - "+e+" <= 1 and dtype is not float");this.random=cr(r)}return t.prototype.convertValue=function(t){return this.canReturnFloat()?t:Math.round(t)},t.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},t}();function dr(t,e,n){return void 0===e&&(e="float32"),e=e||"float32",nt(t),new gt(t,e,n)}function pr(t,e){void 0===e&&(e=!1),console.log(t.toString(e))}var vr=An({batchToSpaceND_:function(t,e,n){var r=mn(t,"x","batchToSpaceND"),o=e.reduce((function(t,e){return t*e}));return C(r.rank>=1+e.length,(function(){return"input rank is "+r.rank+" but should be > than blockShape.length "+e.length})),C(n.length===e.length,(function(){return"crops.length is "+n.length+" but should be equal to blockShape.length  "+e.length})),C(r.shape[0]%o==0,(function(){return"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+e.join(" * ")+" === "+o})),Lt.runKernelFunc((function(t){return t.batchToSpaceND(r,e,n)}),{$x:r},(function(t){return{$x:function(){return t.spaceToBatchND(e,n)}}}))}}),mr=An({broadcastTo_:function(t,e){var n=mn(t,"broadcastTo","x"),r=n.shape;if(e.some((function(t){return!(t>0)||t%1!=0})))throw new Error("broadcastTo(): Invalid broadcast shape ["+e+"].");if(e.length<n.rank)throw new Error("broadcastTo(): shape.length="+e.length+" < input.rank="+n.rank+".");if(e.length>n.rank){for(var o=n.shape.slice();o.length<e.length;)o.unshift(1);n=n.reshape(o)}for(var a=Array.from(e),i=e.length-1;i>=0;i--)if(n.shape[i]===e[i])a[i]=1;else if(1!==n.shape[i])throw new Error("broadcastTo(): ["+r+"] cannot be broadcast to ["+e+"].");var s=a.map((function(t,e){return t>1?e:-1})).filter((function(t){return t>=0}));return 0===s.length?n.clone():Lt.runKernelFunc((function(t){return t.tile(n,a)}),{input:n},(function(t){return{input:function(){return t.sum(s,!0)}}}))}}),gr=An({cast_:function(t,e){var n=mn(t,"x","cast");if(!W(e))throw new Error("Failed to cast to unknown dtype "+e);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");var r={dtype:e};return Lt.runKernelFunc((function(t){return t.cast(n,e)}),{x:n},(function(t){return{x:function(){return t.clone()}}}),"Cast",r)}}),yr=An({clone_:function(t){var e=mn(t,"x","clone",null);return Lt.runKernelFunc((function(){return Lt.makeTensorFromDataId(e.dataId,e.shape,e.dtype)}),{$x:e},(function(t){return{$x:function(){return t.toFloat()}}}))}}),xr=An({cumsum_:function(t,e,n,r){void 0===e&&(e=0),void 0===n&&(n=!1),void 0===r&&(r=!1);var o=mn(t,"x","cumsum"),a=En([e|=0],o.rank),i=o;null!=a&&(i=o.transpose(a));var s=In(1,o.rank)[0],u=Lt.runKernelFunc((function(t){return t.cumsum(i,s,n,r)}),{permutedX:i},(function(t){return{permutedX:function(){return t.cumsum(e,n,!r)}}}));return null!=a&&(u=u.transpose(a)),u}}),br=An({depthToSpace_:function(t,e,n){void 0===n&&(n="NHWC");var r=mn(t,"x","depthToSpace"),o="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return C(o*e>=0,(function(){return"Negative dimension size caused by overflow when multiplying\n      "+o+" and "+e+"  for depthToSpace with input shape\n      "+r.shape})),C(a*e>=0,(function(){return"Negative dimension size caused by overflow when multiplying\n      "+a+" and "+e+" for depthToSpace with input shape\n          "+r.shape})),C(i%(e*e)==0,(function(){return"Dimension size must be evenly divisible by "+e*e+" but is "+i+" for depthToSpace with input shape "+r.shape})),Lt.runKernelFunc((function(t){return t.depthToSpace(r,e,n)}),{$x:r})}}),wr=An({expandDims_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","expandDims",null);C(e<=n.rank,(function(){return"Axis must be <= rank of the tensor"}));var r=n.shape.slice();return e<0&&(C(-(n.rank+1)<=e,(function(){return"Axis must be in the interval ["+-(n.rank+1)+", "+n.rank+"]"})),e=n.rank+e+1),r.splice(e,0,1),Or(n,r)}}),Cr=An({eye_:function(t,e,n,r){void 0===r&&(r="float32"),null==e&&(e=t);for(var o=dr([t,e],r),a=t<=e?t:e,i=0;i<a;++i)o.set(1,i,i);var s=o.toTensor().as2D(t,e);if(null==n)return s;if(1===n.length)return Lr(wr(s,0),[n[0],1,1]);if(2===n.length)return Lr(wr(wr(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return Lr(wr(wr(wr(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+n.length+"D.")}}),Er=An({multinomial_:function(t,e,n,r){void 0===r&&(r=!1);var o=mn(t,"logits","multinomial"),a=o.size,i=o.rank;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+a+".");if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+i);n=n||Math.random();var s=1===i?o.as2D(1,-1):o,u=Lt.runKernelFunc((function(t){return t.multinomial(s,r,e,n)}),{logits2D:s});return 1===i?u.as1D():u}}),Rr=An({oneHot_:function(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r=0),e<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+e);var o=mn(t,"indices","oneHot","int32"),a=o.shape.concat([e]);return o=o.flatten(),Lt.runKernelFunc((function(t){return t.oneHot(o,e,n,r)}),{$indices:o},(function(t){return{$indices:function(){return Gn(o.shape,"float32")}}})).reshape(a)}}),Ir=An({pad_:function(t,e,n){void 0===n&&(n=0);var r=mn(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var o={paddings:e,constantValue:n};return Lt.runKernelFunc((function(t){return t.pad(r,e,n)}),{x:r},(function(t){var n=e.map((function(t){return t[0]}));return{x:function(){return t.slice(n,r.shape)}}}),"PadV2",o)}}),kr=An({pad1d_:function(t,e,n){return void 0===n&&(n=0),C(2===e.length,(function(){return"Invalid number of paddings. Must be length of 2."})),Ir(t,[e],n)}}),Sr=An({pad2d_:function(t,e,n){return void 0===n&&(n=0),C(2===e.length&&2===e[0].length&&2===e[1].length,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Ir(t,e,n)}}),Ar=An({pad3d_:function(t,e,n){return void 0===n&&(n=0),C(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Ir(t,e,n)}}),Dr=An({pad4d_:function(t,e,n){return void 0===n&&(n=0),C(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Ir(t,e,n)}}),Tr=An({rand_:function(t,e,n){var r=k(t),o=null;if(null==n||"float32"===n)o=new Float32Array(r);else if("int32"===n)o=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);o=new Uint8Array(r)}for(var a=0;a<r;a++)o[a]=e();return Lt.makeTensor(o,t,n)}}),Nr=An({randomNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new lr(e,n,r,!1,o),i=dr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),Fr=An({randomGamma_:function(t,e,n,r,o){if(void 0===n&&(n=1),void 0===r&&(r="float32"),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error("Unsupported data type "+r);for(var a=new hr(e,n,r,o),i=dr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),_r=An({randomUniform_:function(t,e,n,r,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===r&&(r="float32");for(var a=dr(t,r),i=new fr(e,n,null,o),s=0;s<a.values.length;s++)a.values[s]=i.nextValue();return a.toTensor()}}),Or=An({reshape_:function(t,e){var n=mn(t,"x","reshape",null);e=_(e,n.size),C(n.size===k(e),(function(){return"new shape and old shape must have the same number of elements."}));var r={shape:e};return Lt.runKernelFunc((function(t){return t.reshape(n,e)}),{x:n},(function(t){return{x:function(){return t.reshape(n.shape)}}}),"Reshape",r)}}),Mr=An({spaceToBatchND_:function(t,e,n){var r=mn(t,"x","spaceToBatchND");return C(r.rank>=1+e.length,(function(){return"input rank "+r.rank+" should be > than [blockShape] "+e.length})),C(n.length===e.length,(function(){return"paddings.shape[0] "+n.length+" must be equal to [blockShape] "+e.length})),C(r.shape.reduce((function(t,r,o){return o>0&&o<=e.length?t&&(r+n[o-1][0]+n[o-1][1])%e[o-1]==0:t}),!0),(function(){return"input spatial dimensions "+r.shape.slice(1)+" with paddings "+n.toString()+" must be divisible by blockShapes "+e.toString()})),Lt.runKernelFunc((function(t){return t.spaceToBatchND(r,e,n)}),{$x:r},(function(t){return{$x:function(){return t.batchToSpaceND(e,n)}}}))}}),Br=An({squeeze_:function(t,e){var n=mn(t,"x","squeeze");return Or(n,M(n.shape,e).newShape)}}),Pr=An({stack_:function(t,e){void 0===e&&(e=0);var n=gn(t,"tensors","stack");if(C(n.length>=1,(function(){return"Pass at least one tensor to tf.stack"})),1===n.length)return n[0].expandDims(e);var r=n[0].rank,o=n[0].shape,a=n[0].dtype;C(e<=r,(function(){return"Axis must be <= rank of the tensor"})),n.forEach((function(t){E(o,t.shape,"All tensors passed to stack must have matching shapes")})),n.forEach((function(t){C(a===t.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var i=n.map((function(t){return t.expandDims(e)}));return Yn(i,e)}}),Lr=An({tile_:function(t,e){var n=mn(t,"x","tile",null);C(n.rank===e.length,(function(){return"Error in transpose: rank of input "+n.rank+" must match length of reps "+e+"."}));var r=[n],o={reps:e};return Lt.runKernelFunc((function(t,r){var o=t.tile(n,e);return r([n]),o}),{x:n},(function(t,n){var r=n[0];return{x:function(){var n=Xn(r);if(1===r.rank)for(var o=0;o<e[0];++o)n=n.add(t.slice([o*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(o=0;o<e[0];++o)for(var a=0;a<e[1];++a)n=n.add(t.slice([o*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(var i=0;i<e[2];++i)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(i=0;i<e[2];++i)for(var s=0;s<e[3];++s)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return n}}}),"Tile",o,r)}}),Wr=An({truncatedNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new lr(e,n,r,!0,o),i=dr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),Ur=An({unstack_:function(t,e){void 0===e&&(e=0),e=e||0;var n=mn(t,"x","unstack");C(e>=-n.shape.length&&e<n.shape.length,(function(){return"Axis = "+e+" is not in [-"+n.shape.length+", "+n.shape.length+")"})),e<0&&(e+=n.shape.length);var r={axis:e};return Lt.runKernelFunc((function(t){return t.unstack(n,e)}),{x:n},(function(t){return{x:function(){return Pr(t,e)}}}),"Unpack",r)}}),Vr=function(t,e){return n(this,void 0,void 0,(function(){var n,o,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"x","setdiff1d"),o=mn(e,"y","setdiff1d"),C(n.dtype===o.dtype,(function(){return"x and y should have the same dtype, but got x ("+n.dtype+") and y ("+o.dtype+")."})),C(1===n.rank,(function(){return"x should be 1D tensor, but got x ("+n.shape+")."})),C(1===o.rank,(function(){return"y should be 1D tensor, but got y ("+o.shape+")."})),[4,n.data()];case 1:return a=r.sent(),[4,o.data()];case 2:for(i=r.sent(),s=new Set(i),u=0,h=0;h<a.length;h++)s.has(a[h])||u++;for(c=new gt([u],n.dtype),l=new gt([u],"int32"),h=0,f=0;h<a.length;h++)s.has(a[h])||(c.values[f]=a[h],l.values[f]=h,f++);return[2,[c.toTensor(),l.toTensor()]]}}))}))};function zr(t,e,n,r){void 0===r&&(r=!0);var o=[];if(r)(o=o.concat(e.slice(0))).push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);for(var a=e.length,i=0;i<a;++i)o=o.concat([t[i+1]/e[i],e[i]]);o=o.concat(t.slice(a+1))}return o}function Gr(t,e,n){void 0===n&&(n=!0);var r=[];if(n){r.push(e);for(var o=e+1;o<t;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{var a=[],i=[];for(o=1;o<t;++o)o>=2*e+1||o%2==1?i.push(o):a.push(o);r.push.apply(r,a),r.push(0),r.push.apply(r,i)}return r}function Hr(t,e,n,r){void 0===r&&(r=!0);var o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(var a=1;a<t.length;++a)a<=e.length?r?o.push(e[a-1]*t[a]):o.push(t[a]/e[a-1]):o.push(t[a]);return o}function qr(t,e){for(var n=[0],r=0;r<e;++r)n.push(t[r][0]);return n}function Kr(t,e,n){for(var r=t.slice(0,1),o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}function jr(t,e){if(t.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+t.rank+".");if(e.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.shape[e.rank-1]>t.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+e.shape[e.rank-1]+" vs. "+t.rank);if(0===t.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+t.shape+".");for(var n=e.shape,r=n[n.length-1],o=1,a=0;a<n.length-1;++a)o*=n[a];var i=t.shape,s=n.slice();s.pop();var u=1;for(a=r;a<t.rank;++a)u*=i[a],s.push(i[a]);var c=$(t.shape).map((function(t){return t/u})).concat([1]).slice(0,r);return[s,o,u,c]}var Xr=Object.freeze({prepareAndValidate:jr}),Yr=30;function $r(t){return t<=Yr?t:Y(t,Math.floor(Math.sqrt(t)))}function Qr(t,e,n){var r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+", indices.shape: "+e.shape+", shape: "+t+", sliceDim: "+r+", and batchDim: "+o+".";if(n.rank<o)throw new Error(a+" update.rank < "+o+". ");if(t.length<r+(n.rank-o))throw new Error(a+" Output shape length < "+(r+(n.rank-o)));if(n.rank!==o+t.length-r)throw new Error(a+" update.rank != "+(o+t.length-r));for(var i=0;i<o;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+" updates.shape["+i+"] ("+n.shape[i]+") != indices.shape["+i+"] ("+e.shape[i]+").");for(i=0;i<n.rank-o;++i)if(n.shape[i+o]!==t[i+r])throw new Error(a+" updates.shape["+(i+o)+"] ("+n.shape[i+o]+") != shape["+(i+o)+"] ("+t[i+o]+")")}function Jr(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+t.rank+".");if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}Qr(n,e,t)}function Zr(t,e,n){for(var r=e.shape.length,o=r>1?e.shape[r-1]:1,a=n.length,i=1,s=o;s<a;++s)i*=n[s];var u=o<1?1:o;return{sliceRank:o,numUpdates:k(e.shape)/u,sliceSize:i,strides:$(n.slice(0,o)).concat([1]),outputSize:k(n)}}var to=Object.freeze({validateUpdateShape:Qr,validateInput:Jr,calculateShapes:Zr});function eo(t,e,n){C(t.rank===e.length,(function(){return"Error in slice"+t.rank+"D: Length of begin "+e+" must match the rank of the array ("+t.rank+")."})),C(t.rank===n.length,(function(){return"Error in slice"+t.rank+"D: Length of size "+n+" must match the rank of the array ("+t.rank+")."}));for(var r=function(r){C(e[r]+n[r]<=t.shape[r],(function(){return"Error in slice"+t.rank+"D: begin["+r+"] + size["+r+"] ("+(e[r]+n[r])+") would overflow input.shape["+r+"] ("+t.shape[r]+")"}))},o=0;o<t.rank;++o)r(o)}function no(t){for(var e=[],n=0;t>0;)1&t&&e.push(n),t/=2,n++;return e}function ro(t,e,n){for(var r=[],o=0;o<t.length;o++)r[o]=Math.ceil((e[o]-t[o])/n[o]);return r}function oo(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=x(0,a,s-1)}function ao(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=i>0?x(0,a,s):x(-1,a,s-1)}function io(t,e,n){for(var r=n.length,o=0;o<n.length;o++)if(n[o]>1){r=o;break}for(o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function so(t,e){for(var n=t.length>0?t[t.length-1]:1,r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}var uo=Object.freeze({assertParamsValid:eo,maskToAxes:no,computeOutShape:ro,startForAxis:oo,stopForAxis:ao,isSliceContinous:io,computeFlatOffset:so});function co(t){return C(X(t),(function(){return"The f passed in grad(f) must be a function"})),function(e,n){var r=mn(e,"x","tf.grad",null),o=null!=n?mn(n,"dy","tf.grad"):null;return Lt.tidy((function(){var e=Lt.gradients((function(){return t(r)}),[r],o),n=e.value,a=e.grads;return null!=o&&E(n.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),mo(a),a[0]}))}}function lo(t){return C(X(t),(function(){return"The f passed in grads(f) must be a function"})),function(e,n){C(Array.isArray(e),(function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"}));var r=gn(e,"args","tf.grads",null),o=null!=n?mn(n,"dy","tf.grads"):null;return Lt.tidy((function(){var e=Lt.gradients((function(){return t.apply(void 0,r)}),r,o),n=e.value,a=e.grads;return null!=o&&E(n.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),mo(a),a}))}}function ho(t){return C(X(t),(function(){return"The f passed in valueAndGrad(f) must be a function"})),function(e,n){C(e instanceof wt,(function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"})),C(null==n||n instanceof wt,(function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"}));var r=Lt.gradients((function(){return t(e)}),[e],n),o=r.grads,a=r.value;return mo(o),{grad:o[0],value:a}}}function fo(t){return C(X(t),(function(){return"The f passed in valueAndGrads(f) must be a function"})),function(e,n){C(Array.isArray(e)&&e.every((function(t){return t instanceof wt})),(function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"})),C(null==n||n instanceof wt,(function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"}));var r=Lt.gradients((function(){return t.apply(void 0,e)}),e,n);return null!=n&&E(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),mo(r.grads),r}}function po(t,e){C(X(t),(function(){return"The f passed in variableGrads(f) must be a function"})),C(null==e||Array.isArray(e)&&e.every((function(t){return t instanceof St})),(function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"}));var n=null!=e;if(!n)for(var r in e=[],Lt.registeredVariables)e.push(Lt.registeredVariables[r]);var o=n?e.filter((function(t){return!t.trainable})):null,a=e.length;C((e=e.filter((function(t){return t.trainable}))).length>0,(function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+a+" variables is trainable."}));var i=Lt.gradients(t,e,null,!0),s=i.value,u=i.grads;C(u.some((function(t){return null!=t})),(function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."})),C(0===s.rank,(function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+s.rank+" tensor"}));var c={};return e.forEach((function(t,e){null!=u[e]&&(c[t.name]=u[e])})),null!=o&&o.forEach((function(t){return c[t.name]=null})),{value:s,grads:c}}function vo(t){return Lt.customGrad(t)}function mo(t){if(t.filter((function(t){return null==t})).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var go=An({softmax_:function(t,e){void 0===e&&(e=-1);var n=mn(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and dim was "+e);return Lt.runKernelFunc((function(t,r){var o=t.softmax(n,e);return r([o]),o}),{logits:n},(function(t,n){var r=n[0],o=t.mul(r);return{logits:function(){return o.sub(o.sum([e],!0).mul(r))}}}),"Softmax",{dim:e},[],[!0])}}),yo=An({logSoftmax_:function(t,e){void 0===e&&(e=-1);var n=mn(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and axis was "+e);return vo((function(t,n){var r=t.max(e,!0),o=t.sub(r),a=o.toFloat().sub(o.exp().sum(e,!0).log());n([a]);return{value:a,gradFunc:function(t,n){var r=n[0].exp();return t.sub(t.sum(e,!0).mul(r))}}}))(n)}}),xo=function(){function t(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}return t.prototype.get=function(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)},t.prototype.set=function(t,e){this.dataIdsCount++,this.data.set(t,e)},t.prototype.has=function(t){return this.data.has(t)},t.prototype.delete=function(t){return this.dataIdsCount--,this.data.delete(t)},t.prototype.numDataIds=function(){return this.dataIdsCount},t}(),bo=function(){function t(){}return t.prototype.time=function(t){return wo("time")},t.prototype.read=function(t){return wo("read")},t.prototype.readSync=function(t){return wo("readSync")},t.prototype.numDataIds=function(){return wo("numDataIds")},t.prototype.disposeData=function(t){return wo("disposeData")},t.prototype.write=function(t,e,n){return wo("write")},t.prototype.move=function(t,e,n,r){return wo("move")},t.prototype.memory=function(){return wo("memory")},t.prototype.floatPrecision=function(){return wo("floatPrecision")},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.batchMatMul=function(t,e,n,r){return wo("batchMatMul")},t.prototype.fusedBatchMatMul=function(t){t.a,t.b,t.transposeA,t.transposeB,t.bias,t.activation,t.preluActivationWeights;return wo("fusedBatchMatMul")},t.prototype.slice=function(t,e,n){return wo("slice")},t.prototype.stridedSlice=function(t,e,n,r){return wo("stridedSlice")},t.prototype.unstack=function(t,e){return wo("unstack")},t.prototype.reverse=function(t,e){return wo("reverse")},t.prototype.concat=function(t,e){return wo("concat")},t.prototype.neg=function(t){return wo("neg")},t.prototype.add=function(t,e){return wo("add")},t.prototype.addN=function(t){return wo("addN")},t.prototype.subtract=function(t,e){return wo("subtract")},t.prototype.multiply=function(t,e){return wo("multiply")},t.prototype.realDivide=function(t,e){return wo("realDivide")},t.prototype.floorDiv=function(t,e){return wo("floorDiv")},t.prototype.sum=function(t,e){return wo("sum")},t.prototype.prod=function(t,e){return wo("prod")},t.prototype.unsortedSegmentSum=function(t,e,n){return wo("unsortedSegmentSum")},t.prototype.argMin=function(t,e){return wo("argMin")},t.prototype.argMax=function(t,e){return wo("argMax")},t.prototype.equal=function(t,e){return wo("equal")},t.prototype.notEqual=function(t,e){return wo("notEqual")},t.prototype.less=function(t,e){return wo("less")},t.prototype.lessEqual=function(t,e){return wo("lessEqual")},t.prototype.greater=function(t,e){return wo("greater")},t.prototype.greaterEqual=function(t,e){return wo("greaterEqual")},t.prototype.logicalNot=function(t){return wo("logicalNot")},t.prototype.logicalAnd=function(t,e){return wo("logicalAnd")},t.prototype.logicalOr=function(t,e){return wo("logicalOr")},t.prototype.where=function(t){return wo("where")},t.prototype.select=function(t,e,n){return wo("select")},t.prototype.topk=function(t,e,n){return wo("topk")},t.prototype.min=function(t,e){return wo("min")},t.prototype.minimum=function(t,e){return wo("minimum")},t.prototype.mod=function(t,e){return wo("mod")},t.prototype.max=function(t,e){return wo("max")},t.prototype.maximum=function(t,e){return wo("maximum")},t.prototype.all=function(t,e){return wo("all")},t.prototype.any=function(t,e){return wo("any")},t.prototype.squaredDifference=function(t,e){return wo("squaredDifference")},t.prototype.ceil=function(t){return wo("ceil")},t.prototype.floor=function(t){return wo("floor")},t.prototype.round=function(t){return wo("round")},t.prototype.sign=function(t){return wo("sign")},t.prototype.isNaN=function(t){return wo("isNaN")},t.prototype.isInf=function(t){return wo("isInf")},t.prototype.isFinite=function(t){return wo("isFinite")},t.prototype.pow=function(t,e){return wo("pow")},t.prototype.exp=function(t){return wo("exp")},t.prototype.expm1=function(t){return wo("expm1")},t.prototype.softmax=function(t,e){return wo("softmax")},t.prototype.log=function(t){return wo("log")},t.prototype.log1p=function(t){return wo("log1p")},t.prototype.sqrt=function(t){return wo("sqrt")},t.prototype.rsqrt=function(t){return wo("rsqrt")},t.prototype.square=function(t){return wo("square")},t.prototype.reciprocal=function(t){return wo("reciprocal")},t.prototype.relu=function(t){return wo("relu")},t.prototype.relu6=function(t){return wo("relu6")},t.prototype.prelu=function(t,e){return wo("prelu")},t.prototype.elu=function(t){return wo("elu")},t.prototype.eluDer=function(t,e){return wo("eluDer")},t.prototype.selu=function(t){return wo("selu")},t.prototype.int=function(t){return wo("int")},t.prototype.clip=function(t,e,n){return wo("clip")},t.prototype.abs=function(t){return wo("abs")},t.prototype.complexAbs=function(t){return wo("complexAbs")},t.prototype.sigmoid=function(t){return wo("sigmoid")},t.prototype.softplus=function(t){return wo("softplus")},t.prototype.sin=function(t){return wo("sin")},t.prototype.cos=function(t){return wo("cos")},t.prototype.tan=function(t){return wo("tan")},t.prototype.asin=function(t){return wo("asin")},t.prototype.acos=function(t){return wo("acos")},t.prototype.atan=function(t){return wo("atan")},t.prototype.atan2=function(t,e){return wo("atan2")},t.prototype.sinh=function(t){return wo("sinh")},t.prototype.cosh=function(t){return wo("cosh")},t.prototype.tanh=function(t){return wo("tanh")},t.prototype.asinh=function(t){return wo("asinh")},t.prototype.acosh=function(t){return wo("acosh")},t.prototype.atanh=function(t){return wo("atanh")},t.prototype.erf=function(t){return wo("erf")},t.prototype.step=function(t,e){return wo("step")},t.prototype.fusedConv2d=function(t){t.input,t.filter,t.convInfo,t.bias,t.activation,t.preluActivationWeights;return wo("fusedConv2d")},t.prototype.conv2d=function(t,e,n){return wo("conv2d")},t.prototype.conv2dDerInput=function(t,e,n){return wo("conv2dDerInput")},t.prototype.conv2dDerFilter=function(t,e,n){return wo("conv2dDerFilter")},t.prototype.fusedDepthwiseConv2D=function(t){t.input,t.filter,t.convInfo,t.bias,t.activation,t.preluActivationWeights;return wo("fusedDepthwiseConv2D")},t.prototype.depthwiseConv2D=function(t,e,n){return wo("depthwiseConv2D")},t.prototype.depthwiseConv2DDerInput=function(t,e,n){return wo("depthwiseConv2DDerInput")},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){return wo("depthwiseConv2DDerFilter")},t.prototype.conv3d=function(t,e,n){return wo("conv3d")},t.prototype.conv3dDerInput=function(t,e,n){return wo("conv3dDerInput")},t.prototype.conv3dDerFilter=function(t,e,n){return wo("conv3dDerFilter")},t.prototype.maxPool=function(t,e){return wo("maxPool")},t.prototype.maxPoolBackprop=function(t,e,n,r){return wo("maxPoolBackprop")},t.prototype.avgPool=function(t,e){return wo("avgPool")},t.prototype.avgPoolBackprop=function(t,e,n){return wo("avgPoolBackprop")},t.prototype.avgPool3d=function(t,e){return wo("avgPool3d")},t.prototype.avgPool3dBackprop=function(t,e,n){return wo("avgPool3dBackprop")},t.prototype.maxPool3d=function(t,e){return wo("maxPool3d")},t.prototype.maxPool3dBackprop=function(t,e,n,r){return wo("maxPool3dBackprop")},t.prototype.reshape=function(t,e){return wo("reshape")},t.prototype.cast=function(t,e){return wo("cast")},t.prototype.tile=function(t,e){return wo("tile")},t.prototype.pad=function(t,e,n){return wo("pad")},t.prototype.transpose=function(t,e){return wo("transpose")},t.prototype.gather=function(t,e,n){return wo("gather")},t.prototype.gatherND=function(t,e){return wo("gatherND")},t.prototype.scatterND=function(t,e,n){return wo("scatterND")},t.prototype.batchToSpaceND=function(t,e,n){return wo("batchToSpaceND")},t.prototype.spaceToBatchND=function(t,e,n){return wo("spaceToBatchND")},t.prototype.resizeBilinear=function(t,e,n,r){return wo("resizeBilinear")},t.prototype.resizeBilinearBackprop=function(t,e,n){return wo("resizeBilinearBackprop")},t.prototype.resizeNearestNeighbor=function(t,e,n,r){return wo("resizeNearestNeighbor")},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){return wo("resizeNearestNeighborBackprop")},t.prototype.batchNormalization=function(t,e,n,r,o,a){return wo("batchNormalization")},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){return wo("localResponseNormalization4D")},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){return wo("LRNGrad")},t.prototype.multinomial=function(t,e,n,r){return wo("multinomial")},t.prototype.oneHot=function(t,e,n,r){return wo("oneHot")},t.prototype.cumsum=function(t,e,n,r){return wo("cumsum")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return wo("nonMaxSuppression")},t.prototype.fft=function(t){return wo("fft")},t.prototype.ifft=function(t){return wo("ifft")},t.prototype.complex=function(t,e){return wo("complex")},t.prototype.real=function(t){return wo("real")},t.prototype.imag=function(t){return wo("imag")},t.prototype.cropAndResize=function(t,e,n,r,o,a){return wo("cropAndResize")},t.prototype.depthToSpace=function(t,e,n){return wo("depthToSpace")},t.prototype.split=function(t,e,n){return wo("split")},t.prototype.sparseToDense=function(t,e,n,r){return wo("sparseToDense")},t.prototype.diag=function(t){return wo("diag")},t.prototype.fill=function(t,e,n){return wo("fill")},t.prototype.onesLike=function(t){return wo("onesLike")},t.prototype.zerosLike=function(t){return wo("zerosLike")},t.prototype.linspace=function(t,e,n){return wo("linspace")},t.prototype.dispose=function(){return wo("dispose")},t}();function wo(t){throw new Error("'"+t+"' not yet implemented or not found in the registry. Did you forget to import the kernel?")}function Co(t,e){for(var n=t.length,r=[],o=0;o<n;o++){var a=n-1-o,i=t[a]||1;(e[e.length-1-o]||1)>1&&1===i&&r.unshift(a)}return r}function Eo(t,e){for(var n=[],r=0;r<e.length;r++){var o=t[t.length-r-1],a=e.length-r-1,i=e[a];(null==o||1===o&&i>1)&&n.unshift(a)}return n}function Ro(t,e){for(var n=[],r=Math.max(t.length,e.length),o=0;o<r;o++){var a=t[t.length-o-1];null==a&&(a=1);var i=e[e.length-o-1];if(null==i&&(i=1),1===a)n.unshift(i);else if(1===i)n.unshift(a);else{if(a!==i)throw Error("Operands could not be broadcast together with shapes "+t+" and "+e+".");n.unshift(a)}}return n}function Io(t,e,n,r,o,a,i){void 0===i&&(i="channelsLast");var s,u=To(e),c=u[0],l=u[1];if("channelsLast"===i)s=[c,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);s=[c,l,t[1],t[1]]}return So(t,s,n,r,o,a,!1,i)}function ko(t,e,n,r,o,a,i){void 0===i&&(i="NDHWC");var s,u,c=No(e),l=c[0],h=c[1],f=c[2];if("NDHWC"===i)u="channelsLast",s=[l,h,f,t[4],t[4]];else{if("NCDHW"!==i)throw new Error("Unknown dataFormat "+i);u="channelsFirst",s=[l,h,f,t[1],t[1]]}return Ao(t,s,n,r,o,!1,u,a)}function So(t,e,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s="channelsLast");var u=[-1,-1,-1,-1],c=u[0],l=u[1],h=u[2],f=u[3];if("channelsLast"===s)c=t[0],l=t[1],h=t[2],f=t[3];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);c=t[0],f=t[1],l=t[2],h=t[3]}var d,p=e[0],v=e[1],m=e[3],g=To(n),y=g[0],x=g[1],b=To(r),w=b[0],E=b[1],R=Fo(p,w),I=Fo(v,E),k=function(t,e,n,r,o,a,i,s){var u,c,l;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};var h=function(t,e,n,r,o){null==r&&(r=Do(t,e,n));var a=t[0],i=t[1],s=_o((a-e+2*r)/n+1,o);C(A(s),(function(){return"The output # of rows ("+s+") must be an integer. Change the stride and/or zero pad parameters"}));var u=_o((i-e+2*r)/n+1,o);return C(A(u),(function(){return"The output # of columns ("+u+") must be an integer. Change the stride and/or zero pad parameters"})),[s,u]}([e,n],a,r,t,s);c=h[0],l=h[1]}else if("same"===t){c=Math.ceil(e/r),l=Math.ceil(n/o);var f=Math.max(0,(c-1)*r+a-e),d=Math.max(0,(l-1)*o+i-n),p=Math.floor(f/2),v=f-p,m=Math.floor(d/2);u={top:p,bottom:v,left:m,right:d-m,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),l=Math.ceil((n-i+1)/o)}return{padInfo:u,outHeight:c,outWidth:l}}(o,l,h,y,x,R,I,a),S=k.padInfo,D=k.outHeight,T=k.outWidth,N=i?m*f:m;return"channelsFirst"===s?d=[c,N,D,T]:"channelsLast"===s&&(d=[c,D,T,N]),{batchSize:c,dataFormat:s,inHeight:l,inWidth:h,inChannels:f,outHeight:D,outWidth:T,outChannels:N,padInfo:S,strideHeight:y,strideWidth:x,filterHeight:p,filterWidth:v,effectiveFilterHeight:R,effectiveFilterWidth:I,dilationHeight:w,dilationWidth:E,inShape:t,outShape:d,filterShape:e}}function Ao(t,e,n,r,o,a,i,s){void 0===a&&(a=!1),void 0===i&&(i="channelsLast");var u=[-1,-1,-1,-1,-1],c=u[0],l=u[1],h=u[2],f=u[3],d=u[4];if("channelsLast"===i)c=t[0],l=t[1],h=t[2],f=t[3],d=t[4];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);c=t[0],d=t[1],l=t[2],h=t[3],f=t[4]}var p,v=e[0],m=e[1],g=e[2],y=e[4],x=No(n),b=x[0],w=x[1],E=x[2],R=No(r),I=R[0],k=R[1],S=R[2],D=Fo(v,I),T=Fo(m,k),N=Fo(g,S),F=function(t,e,n,r,o,a,i,s,u,c,l){var h,f,d,p;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};var v=function(t,e,n,r,o,a){null==o&&(o=Do(t,e,r));var i=t[0],s=t[1],u=t[2],c=_o((i-e+2*o)/r+1,a);C(A(c),(function(){return"The output # of depths ("+c+") must be an integer. Change the stride and/or zero pad parameters"}));var l=_o((s-e+2*o)/r+1,a);C(A(l),(function(){return"The output # of rows ("+l+") must be an integer. Change the stride and/or zero pad parameters"}));var h=_o((u-e+2*o)/r+1,a);return C(A(h),(function(){return"The output # of columns ("+h+") must be an integer. Change the stride and/or zero pad parameters"})),[c,l,h,n]}([e,n,r,1],s,1,o,t,l);f=v[0],d=v[1],p=v[2]}else if("same"===t){f=Math.ceil(e/o),d=Math.ceil(n/a),p=Math.ceil(r/i);var m=(f-1)*o+s-e,g=(d-1)*a+u-n,y=(p-1)*i+c-r,x=Math.floor(m/2),b=m-x,w=Math.floor(g/2),E=g-w,R=Math.floor(y/2);h={top:w,bottom:E,left:R,right:y-R,front:x,back:b,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((e-s+1)/o),d=Math.ceil((n-u+1)/a),p=Math.ceil((r-c+1)/i)}return{padInfo:h,outDepth:f,outHeight:d,outWidth:p}}(o,l,h,f,b,w,E,D,T,N,s),_=F.padInfo,O=F.outDepth,M=F.outHeight,B=F.outWidth,P=a?y*d:y;return"channelsFirst"===i?p=[c,P,O,M,B]:"channelsLast"===i&&(p=[c,O,M,B,P]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:h,inWidth:f,inChannels:d,outDepth:O,outHeight:M,outWidth:B,outChannels:P,padInfo:_,strideDepth:b,strideHeight:w,strideWidth:E,filterDepth:v,filterHeight:m,filterWidth:g,effectiveFilterDepth:D,effectiveFilterHeight:T,effectiveFilterWidth:N,dilationDepth:I,dilationHeight:k,dilationWidth:S,inShape:t,outShape:p,filterShape:e}}function Do(t,e,n,r){void 0===r&&(r=1);var o=Fo(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}function To(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function No(t){return"number"==typeof t?[t,t,t]:t}function Fo(t,e){return e<=1?t:t+(t-1)*(e-1)}function _o(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function Oo(t){var e=To(t),n=e[0],r=e[1],o=e[2];return 1===n&&1===r&&1===o}function Mo(t,e){return Oo(t)||Oo(e)}function Bo(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat "+t)}function Po(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();var r=Gn(t.shape),o=t.toFloat(),a=n.complex(o,r);return r.dispose(),o.dispose(),a}if(!U(t.dtype,e))return Lt.makeTensorFromDataId(t.dataId,t.shape,e);if("complex64"===t.dtype){var i=n.real(t);a=i.cast(e);return i.dispose(),a}if("int32"===e)return n.int(t);if("bool"===e){var s=On(0,t.dtype);a=n.notEqual(t,s);return s.dispose(),a}throw new Error("Error in Cast: failed to cast "+t.dtype+" to "+e)}function Lo(t,e){return Lt.makeTensorFromDataId(t.dataId,e,t.dtype)}function Wo(t,e,n){var r=(e-t)/(n-1),o=tt(n,"float32");o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+r;return Mn(o,"float32")}var Uo=Object.freeze({castTensor:Po,reshapeTensor:Lo,linspaceImpl:Wo,upcastType:Dt,axesAreInnerMostDims:yn,combineLocations:xn,computeOutAndReduceShapes:bn,expandShapeToKeepDim:wn,assertAxesAreInnerMostDims:Cn,getAxesPermutation:En,getUndoAxesPermutation:Rn,getInnerMostAxes:In,getBroadcastDims:Co,getReductionAxes:Eo,assertAndGetBroadcastShape:Ro,assertParamsConsistent:kn,computeOutShape:Sn,computePool2DInfo:Io,computePool3DInfo:ko,computeConv2DInfo:So,computeConv3DInfo:Ao,computeDefaultPad:Do,tupleValuesAreOne:Oo,eitherStridesOrDilationsAreOne:Mo,convertConv2DDataFormat:Bo,PARALLELIZE_THRESHOLD:Yr,computeOptimalWindowSize:$r});function Vo(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+t.length+", imag: "+e.length+".");for(var n=new Float32Array(2*t.length),r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function zo(t,e){return{real:t[2*e],imag:t[2*e+1]}}function Go(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function Ho(t,e,n){var r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function qo(t,e,n){var r=function(t,e,n){return function(t,e,n){var r=0,o=t.length,a=0,i=!1;for(;r<o;){var s=n(e,t[a=r+(o-r>>>1)]);s>0?r=a+1:(o=a,i=!s)}return i?r:-r-1}(t,e,n||Ko)}(t,e,n),o=r<0?-(r+1):r;t.splice(o,0,e)}function Ko(t,e){return t>e?1:t<e?-1:0}function jo(t,e,n,r,o){return Yo(t,e,n,r,o,0).selectedIndices}function Xo(t,e,n,r,o,a){var i=Yo(t,e,n,r,o,a,!0);return i.numValidOutputs.dispose(),{selectedIndices:i.selectedIndices,selectedScores:i.selectedScores}}function Yo(t,e,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s=!1);for(var u=Array.from(e).map((function(t,e){return{score:t,boxIndex:e,suppressBeginIndex:0}})).filter((function(t){return t.score>o})).sort(Jo),c=a>0?-.5/a:0,l=[],h=[];l.length<n&&u.length>0;){var f=u.pop(),d=f.score,p=f.boxIndex,v=f.suppressBeginIndex;if(d<o)break;for(var m=!1,g=l.length-1;g>=v;--g){var y=$o(t,p,l[g]);if(y>=r){m=!0;break}if(f.score=f.score*Qo(r,c,y),f.score<=o)break}f.suppressBeginIndex=l.length,m||(f.score===d?(l.push(p),h.push(f.score)):f.score>o&&qo(u,f,Jo))}var x=l.length;return s&&(l.fill(0,x),h.fill(0,x)),{selectedIndices:Mn(l,"int32"),selectedScores:Mn(h,"float32"),numValidOutputs:On(x,"int32")}}function $o(t,e,n){var r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(o[0],o[2]),l=Math.min(o[1],o[3]),h=Math.max(o[0],o[2]),f=Math.max(o[1],o[3]),d=(s-a)*(u-i),p=(h-c)*(f-l);if(d<=0||p<=0)return 0;var v=Math.max(a,c),m=Math.max(i,l),g=Math.min(s,h),y=Math.min(u,f),x=Math.max(g-v,0)*Math.max(y-m,0);return x/(d+p-x)}function Qo(t,e,n){var r=Math.exp(e*n*n);return n<=t?r:0}function Jo(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}function Zo(t,e,n){var r=new Array(t.rank).fill(0),o=t.shape.slice();return e.map((function(e){o[n]=e;var a=t.slice(r,o);return r[n]+=e,a}))}function ta(t,e){for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];var o=dr(n,t.dtype);for(r=0;r<o.values.length;++r){for(var a=o.indexToLoc(r),i=new Array(t.rank),s=0;s<i.length;s++)i[s]=a[s]%t.shape[s];var u=t.locToIndex(i);o.values[r]=t.values[u]}return o.toTensor()}function ea(t,e,n,r,o){for(var a=e[e.length-1],i=[t.length/a,a],s=i[0],u=i[1],c=B(n,s*r),l=B("int32",s*r),h=0;h<s;h++){for(var f=h*u,d=t.subarray(f,f+u),p=[],v=0;v<d.length;v++)p.push({value:d[v],index:v});p.sort((function(t,e){return e.value-t.value}));var m=h*r,g=c.subarray(m,m+r),y=l.subarray(m,m+r);for(v=0;v<r;v++)g[v]=p[v].value,y[v]=p[v].index}var x=e.slice();return x[x.length-1]=r,[Fn(c,x,n),Fn(l,x,"int32")]}function na(t,e){for(var n=[],r=0;r<e.length;r++)e[r]&&n.push(r);var o=dr(t,"int32"),a=dr([n.length,t.length],"int32");for(r=0;r<n.length;r++){var i=o.indexToLoc(n[r]),s=r*t.length;a.values.set(i,s)}return a.toTensor()}var ra=function(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((function(t,e){return"T"+e}));var n=[];this.variableNames.forEach((function(t){n.push("float v"+t+" = get"+t+"AtOutCoords();")}));var r=this.variableNames.map((function(t){return"v"+t})).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        float result = "+r+";\n        setOutput(result);\n      }\n    "},oa=function(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((function(t,e){return"T"+e}));var n=[];this.variableNames.forEach((function(t){n.push("vec4 v"+t+" = get"+t+"AtOutCoords();")}));var r=this.variableNames.map((function(t){return"v"+t})).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        vec4 result = "+r+";\n        setOutput(result);\n      }\n    "},aa=function(t,e,n){this.variableNames=["A"];var r=t.windowSize,o=t.batchSize,a=t.inSize,i=Math.ceil(a/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var s="max"===e?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+u+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+s+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "};function ia(t,e){return["x","y","z","w","u","v"].slice(0,e).map((function(e){return t+"."+e}))}function sa(t,e){return 1===e?[t]:ia(t,e)}function ua(){var t,e,n,r,o,a,s,u,c,l;return 2===i().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",o="texture",a="outputColor",s="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",o="texture2D",a="gl_FragColor",s="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:o,output:a,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:c,defineRound:l}}function ca(t,e,n){void 0===n&&(n="index");var r=$(e);return r.map((function(e,o){return"int "+t[o]+" = "+n+" / "+e+"; "+(o===r.length-1?"int "+t[o+1]+" = "+n+" - "+t[o]+" * "+e:"index -= "+t[o]+" * "+e)+";"})).join("")}function la(t){var e=$(t).map((function(t){return t.toString()}));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+e[0]+" + coords.y * "+e[1]+" + coords.z;\n  }\n"}var ha="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";function fa(t,e,n,r){var o=[];t.forEach((function(t){var e=k(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?o.push("uniform float "+t.name+(e>1?"["+e+"]":"")+";"):(o.push("uniform sampler2D "+t.name+";"),o.push("uniform int offset"+t.name+";"))}));var a,i,s=o.join("\n"),u=t.map((function(t){return function(t,e,n){void 0===n&&(n=!1);var r="";r+=n?pa(t):da(t);var o=t.shapeInfo.logicalShape,a=e.logicalShape;o.length<=a.length&&(r+=n?function(t,e){var n,r=t.name,o=r.charAt(0).toUpperCase()+r.slice(1),a="get"+o+"AtOutCoords",i=t.shapeInfo.logicalShape.length,s=e.logicalShape.length,u=Co(t.shapeInfo.logicalShape,e.logicalShape),c=wa(s),l=s-i,h=["x","y","z","w","u","v"];n=0===i?"":s<2&&u.length>=1?"coords = 0;":u.map((function(t){return"coords."+h[t+l]+" = 0;"})).join("\n");var f="";f=s<2&&i>0?"coords":t.shapeInfo.logicalShape.map((function(t,e){return"coords."+h[e+l]})).join(", ");var d="return outputValue;",p=1===k(t.shapeInfo.logicalShape),v=1===k(e.logicalShape);if(1!==i||p||v){if(p&&!v)d=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){var m=i-2,g=i-1;u.indexOf(m)>-1&&u.indexOf(g)>-1?d="return vec4(outputValue.x);":u.indexOf(m)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(g)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}}else d="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+a+"() {\n      "+c+" coords = getOutputCoords();\n      "+n+"\n      vec4 outputValue = get"+o+"("+f+");\n      "+d+"\n    }\n  "}(t,e):function(t,e){var n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,s=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&s===u&&null==t.shapeInfo.flatOffset&&S(i,a))return"\n      float "+o+"() {\n        return sampleTexture("+n+", resultUV);\n      }\n    ";var c,l=wa(u),h=Co(t.shapeInfo.logicalShape,e.logicalShape),f=u-s,d=["x","y","z","w","u","v"];c=0===s?"":u<2&&h.length>=1?"coords = 0;":h.map((function(t){return"coords."+d[t+f]+" = 0;"})).join("\n");var p="";p=u<2&&s>0?"coords":t.shapeInfo.logicalShape.map((function(t,e){return"coords."+d[e+f]})).join(", ");return"\n    float "+o+"() {\n      "+l+" coords = getOutputCoords();\n      "+c+"\n      return get"+r+"("+p+");\n    }\n  "}(t,e));return r}(t,e,r)})).join("\n"),c=e.texShape,l=ua(),h=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+t.texture2D+"(textureSampler, uv).r;\n    }\n  "}(l),f=function(t){return t.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+t.varyingFs+" vec2 resultUV;\n    "+t.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+t.defineSpecialNaN+"\n    "+t.defineSpecialInf+"\n    "+t.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+va+"\n    "+ma+"\n    "+ga+"\n  "}(l);return e.isPacked?(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===n[0])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+n[1]+".0);\n      }\n    ";if(1===n[1])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+n[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      return 2 * (resTexRC.x * "+n[1]+" + resTexRC.y);\n    }\n  "}(0,e);case 2:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(S(t,e))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ";var r=Math.ceil(t[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=t,r=e,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=Math.ceil(n[2]/2),i=a*Math.ceil(n[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+o[0]+", "+o[1]+"));\n      int index = resTexRC.x * "+o[1]+" + resTexRC.y;\n\n      int b = index / "+i+";\n      index -= b * "+i+";\n\n      int r = 2 * (index / "+a+");\n      int c = imod(index, "+a+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(t,e){for(var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2),a=o,i="",s="b, r, c",u=2;u<t.length-1;u++)a*=t[t.length-u-1],i="\n      int b"+u+" = index / "+a+";\n      index -= b"+u+" * "+a+";\n    "+i,s="b"+u+", "+s;return"\n    ivec"+t.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+i+"\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec"+t.length+"("+s+");\n    }\n  "}(t,e)}var n,r,o,a,i}(e.logicalShape,c),i=function(t){return"\n    void setOutput(vec4 val) {\n      "+t.output+" = val;\n    }\n  "}(l)):(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){if(1===e[0])return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+e[1]+".0);\n      }\n    ";if(1===e[1])return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+e[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return resTexRC.x * "+e[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){if(S(t,e))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+e[0]+", "+e[1]+"));\n      }\n    ";if(1===t[1])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";if(1===t[0])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      int r = index / "+t[1]+";\n      int c = index - r * "+t[1]+";\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=e,r=ca(["r","c","d"],t),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      "+r+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return function(t,e){var n=ca(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      "+n+"\n      return ivec4(r, c, d, d2);\n    }\n  "}(t,e);case 5:return function(t,e){var n=ca(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+e[0]+",\n                             "+e[1]+"));\n\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}(t,e);case 6:return function(t,e){var n=ca(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}var n,r}(e.logicalShape,c),i=function(t){return"\n    void setOutput(float val) {\n      "+t.output+" = vec4(val, 0, 0, 0);\n    }\n  "}(l)),r&&(f+=ya),[f,h,i,s,a,u,n].join("\n")}function da(t){var e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"float "+n+"() {return "+e+";}";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===o&&1===a)return"\n      float "+n+"() {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=t.shapeInfo.texShape,s=i[0],u=i[1],c=xa(e);return"\n    float "+n+"() {\n      vec2 uv = uvFromFlat("+s+", "+u+", "+c+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"\n      float "+n+"(int index) {\n        "+ba(t)+"\n      }\n    ";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===a&&1===o)return"\n      float "+n+"(int index) {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=xa(e);if(1===a)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+i+") + 0.5) / "+o+".0);\n        return sampleTexture("+e+", uv);\n      }\n    ";if(1===o)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2((float(index + "+i+") + 0.5) / "+a+".0, 0.5);\n        return sampleTexture("+e+", uv);\n      }\n    ";return"\n    float "+n+"(int index) {\n      vec2 uv = uvFromFlat("+o+", "+a+", index + "+i+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape;if(null!=o&&S(e,o)){var a=o[0],i=o[1];return"\n    float "+r+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n      return sampleTexture("+n+", uv);\n    }\n  "}var s=M(e),u=s.newShape,c=s.keptDims,l=u;if(l.length<e.length){var h=Ca(t,l);return"\n      "+da(h)+"\n      float "+r+"(int row, int col) {\n        return "+r+"("+Ea(["row","col"],c)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+e[1]+", 1)));\n        "+ba(t)+"\n      }\n    ";var f=o[0],d=o[1],p=xa(n);if(1===d)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+p+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+f+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";if(1===f)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+p+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+d+".0, 0.5);\n      return sampleTexture("+n+", uv);\n    }\n  ";return"\n  float "+r+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+e[1]+" + col + "+p+";\n    vec2 uv = uvFromFlat("+f+", "+d+", index);\n    return sampleTexture("+n+", uv);\n  }\n"}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[1]*e[2],a=e[2],i=M(e),s=i.newShape,u=i.keptDims,c=s;if(c.length<e.length){var l=Ca(t,c);return"\n        "+da(l)+"\n        float "+r+"(int row, int col, int depth) {\n          return "+r+"("+Ea(["row","col","depth"],u)+");\n        }\n      "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+o+", "+a+", 1)));\n        "+ba(t)+"\n      }\n    ";var h=t.shapeInfo.texShape,f=h[0],d=h[1],p=t.shapeInfo.flatOffset;if(d===o&&null==p)return"\n        float "+r+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+a+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+d+".0, "+f+".0);\n          return sampleTexture("+n+", uv);\n        }\n      ";if(d===a&&null==p)return"\n    float "+r+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+e[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+d+".0, "+f+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";var v=xa(n);return"\n      float "+r+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+o+" + col * "+a+" + depth + "+v+";\n        vec2 uv = uvFromFlat("+f+", "+d+", index);\n        return sampleTexture("+n+", uv);\n      }\n  "}(t);case 4:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[3],a=e[2]*o,i=e[1]*a,s=M(e),u=s.newShape,c=s.keptDims;if(u.length<e.length){var l=Ca(t,u);return"\n      "+da(l)+"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        return "+r+"("+Ea(["row","col","depth","depth2"],c)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+i+", "+a+", "+o+", 1)));\n        "+ba(t)+"\n      }\n    ";var h=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],p=f[1];if(p===i&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+p+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(p===o&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+e[1]*e[2]+", "+e[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+p+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var v=xa(n);return"\n    float "+r+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+i+" + col * "+a+" +\n          depth * "+o+" + depth2;\n      vec2 uv = uvFromFlat("+d+", "+p+", index + "+v+");\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 5:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[4],a=e[3]*o,i=e[2]*a,s=e[1]*i,u=M(e),c=u.newShape,l=u.keptDims;if(c.length<e.length){var h=Ca(t,c);return"\n      "+da(h)+"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+r+"("+Ea(["row","col","depth","depth2","depth3"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+i+", "+a+", "+o+")) +\n          depth3;\n        "+ba(t)+"\n      }\n    ";var f=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],v=d[1];if(v===s&&null==f)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+i+", "+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+v+".0, "+p+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(v===o&&null==f)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]+",\n               "+e[2]*e[3]+", "+e[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+v+".0, "+p+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var m=xa(n);return"\n    float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+s+" + col * "+i+" + depth * "+a+" +\n          depth2 * "+o+" + depth3 + "+m+";\n      vec2 uv = uvFromFlat("+p+", "+v+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 6:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=M(e),a=o.newShape,i=o.keptDims;if(a.length<e.length){var s=Ca(t,a);return"\n      "+da(s)+"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+r+"("+Ea(["row","col","depth","depth2","depth3","depth4"],i)+");\n      }\n    "}var u=e[5],c=e[4]*u,l=e[3]*c,h=e[2]*l,f=e[1]*h;if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+f+", "+h+", "+l+", "+c+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+u+", 1)));\n        "+ba(t)+"\n      }\n    ";var d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,v=p[0],m=p[1];if(m===f&&null==d)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+h+", "+l+", "+c+", "+u+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(m===u&&null==d)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]*e[4]+",\n               "+e[2]*e[3]*e[4]+",\n               "+e[3]*e[4]+",\n               "+e[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var g=xa(n);return"\n    float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+f+" + col * "+h+" + depth * "+l+" +\n          depth2 * "+c+" + depth3 * "+u+" + depth4 + "+g+";\n      vec2 uv = uvFromFlat("+v+", "+m+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);default:throw new Error(e.length+"-D input sampling is not yet supported")}}function pa(t){var e,n,r;switch(t.shapeInfo.logicalShape.length){case 0:return e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ua(),"\n    vec4 "+n+"() {\n      return "+r.texture2D+"("+e+", halfCR);\n    }\n  ";case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=ua();return"\n    vec4 "+n+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+o[0]+", "+o[1]+", index);\n      return "+a.texture2D+"("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=o[0],i=o[1],s=ua();if(null!=o&&S(e,o))return"\n      vec4 "+r+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n\n        return "+s.texture2D+"("+n+", uv);\n      }\n    ";var u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(e[1]/2);return"\n    vec4 "+r+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+c+", "+u[0]+", "+u[1]+", row, col);\n      return "+s.texture2D+"("+n+", uv);\n    }\n  "}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){var i=e.slice(1),s=Ca(t,i);return"\n        "+pa(s)+"\n        vec4 "+r+"(int b, int row, int col) {\n          return "+r+"("+Ea(["b","row","col"],[1,2])+");\n        }\n      "}var u=a[0],c=a[1],l=Math.ceil(e[2]/2),h=l*Math.ceil(e[1]/2),f=ua();return"\n    vec4 "+r+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+u+", "+c+", "+h+", "+l+", b, row, col);\n      return "+f.texture2D+"("+n+", uv);\n    }\n  "}(t);default:return function(t){for(var e=t.shapeInfo.logicalShape,n=e.length,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],s=i[0],u=i[1],c=Math.ceil(e[n-1]/2),l=c*Math.ceil(e[n-2]/2),h="int b, int row, int col",f="b * "+l+" + (row / 2) * "+c+" + (col / 2)",d=2;d<n-1;d++)h="int b"+d+", "+h,l*=e[n-d-1],f="b"+d+" * "+l+" + "+f;var p=ua();return"\n    vec4 "+o+"("+h+") {\n      int index = "+f+";\n      int texR = index / "+u+";\n      int texC = index - texR * "+u+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+u+", "+s+");\n      return "+p.texture2D+"("+r+", uv);\n    }\n  "}(t)}}var va="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ma="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ga="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ya="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xa(t){return"offset"+t}function ba(t){var e=t.name,n=k(t.shapeInfo.logicalShape);return n<2?"return "+e+";":"\n    for (int i = 0; i < "+n+"; i++) {\n      if (i == index) {\n        return "+e+"[i];\n      }\n    }\n  "}function wa(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank "+t+" is not yet supported")}function Ca(t,e){var n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Ea(t,e){return e.map((function(e){return t[e]})).join(", ")}var Ra=function(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C(t.length>2,(function(){return"Packed arg"+(n.charAt(0).toUpperCase()+n.slice(1))+" supports only inputs with rank above 2."}));var o=t[t.length-1],a=Math.ceil(o/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");var i,s,u=this.outputShape,c=u.length,l=wa(c),h=sa("coords",c);if(1===a){var f=wa(s=c+1);i="\n        "+f+" sourceLocR = "+f+"("+h.join()+", 0);\n        ++"+h[c-1]+";\n        "+f+" sourceLocG = "+f+"("+h.join()+", 0);\n        ++"+h[c-2]+";\n        "+f+" sourceLocA = "+f+"("+h.join()+", 0);\n        --"+h[c-1]+";\n        "+f+" sourceLocB = "+f+"("+h.join()+", 0);\n        --"+h[c-2]+";"}else s=c,i="\n        "+l+" sourceLocR = coords;\n        ++"+h[c-1]+";\n        "+l+" sourceLocG = coords;\n        ++"+h[c-2]+";\n        "+l+" sourceLocA = coords;\n        --"+h[c-1]+";\n        "+l+" sourceLocB = coords;\n        --"+h[c-2]+";";var d=["x","y","z","w","u","v"].slice(0,s),p="."+d[s-1],v=d.map((function(t){return"int "+t})),m=sa("sourceLocR",s-1).concat("inIdx.r"),g=sa("sourceLocG",s-1).concat("inIdx.g"),y=sa("sourceLocB",s-1).concat("inIdx.b"),x=sa("sourceLocA",s-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",w=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+m.join()+"),\n                             getBestIndicesAChannel("+g.join()+"),\n                             getBestIndicesAChannel("+y.join()+"),\n                             getBestIndicesAChannel("+x.join()+")));",E="vec4(\n            getAChannel("+m.join()+"),\n            hasNextCol ? getAChannel("+g.join()+") : 0.,\n            hasNextRow ? getAChannel("+y.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+x.join()+") : 0.)",R=r?"":"\n      float getBestIndicesAChannel("+v.join()+") {\n        return getChannel(getBestIndicesA("+d.join()+"),\n                                          vec2("+d.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+v.join()+") {\n        return getChannel(getA("+d.join()+"),\n                               vec2("+d.slice(-2).join()+"));\n      }\n      "+R+"\n      void main() {\n        "+l+" coords = getOutputCoords();\n        bool hasNextCol = "+h[c-1]+" < "+(u[c-1]-1)+";\n        bool hasNextRow = "+h[c-2]+" < "+(u[c-2]-1)+";\n        "+i+"\n        ivec4 srcIdx = ivec4(sourceLocR"+p+", sourceLocG"+p+",\n          sourceLocB"+p+", sourceLocA"+p+") * "+e+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+E+";\n\n        for (int i = 0; i < "+e+"; i++) {\n          inIdx = srcIdx;\n          "+w+"\n          vec4 candidate = "+E+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+b+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "},Ia=function(t){this.variableNames=["dy"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=s-1-t.padInfo.top,l=u-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2("+c+", "+l+");\n      const float avgMultiplier = float("+h+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+";\n            wR += "+a+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+u+";\n            wC+= "+i+") {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ka=function(t){this.variableNames=["dy"],this.outputShape=t.inShape;var e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=l-1-t.padInfo.front,p=h-1-t.padInfo.top,v=f-1-t.padInfo.left,m=1/(e*n*r);this.userCode="\n      const ivec3 pads = ivec3("+d+", "+p+", "+v+");\n      const float avgMultiplier = float("+m+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+l+";\n            wD += "+s+") {\n          float dyD = float(dyDCorner + wD) / "+o+".0;\n\n          if (dyD < 0.0 || dyD >= "+t.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+h+";\n              wR += "+u+") {\n            float dyR = float(dyRCorner + wR) / "+a+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+f+";\n                wC += "+c+") {\n              float dyC = float(dyCCorner + wC) / "+i+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Sa=function(t,e,n,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Ro(t,e),Ro(t,n);var i="0.0";null!=r&&(Ro(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="1.0";null!=o&&(Ro(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+i+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+a+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "},Aa=function(t,e,n,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ro(t,e),Ro(t,n);var i="vec4(0.0)";null!=r&&(Ro(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="vec4(1.0)";null!=o&&(Ro(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = "+i+";\n        vec4 scale = "+s+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+a+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "},Da="return areal * breal - aimag * bimag;",Ta="return areal * bimag + aimag * breal;",Na=function(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ro(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+t+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "},Fa="return a + b;",_a="return a - b;",Oa="return a * b;",Ma="return (a < 0.) ? b * a : a;",Ba=function(t,e,n){this.variableNames=["A","B"],this.outputShape=Ro(e,n),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+t+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "},Pa="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",La=function(t,e,n,r){void 0===r&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ro(e,n);var o=this.outputShape.length,a="";if(r)if(0===o||1===k(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a="\n          "+wa(o)+" coords = getOutputCoords();\n        ",1===o)a+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var i=sa("coords",o);a+="\n            bool nextRowOutOfBounds =\n              ("+i[o-2]+" + 1) >= "+this.outputShape[o-2]+";\n            bool nextColOutOfBounds =\n              ("+i[o-1]+" + 1) >= "+this.outputShape[o-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+t+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+a+"\n\n        setOutput(result);\n      }\n    "},Wa=function(){function t(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"minVal"),n.maxLoc=r.getUniformLocationNoThrow(o,"maxVal")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Ua=function(){function t(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"minVal"),n.maxLoc=r.getUniformLocationNoThrow(o,"maxVal")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Va=function(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "},za=function(t){this.outputShape=[],this.outputShape=Sn(t,1),this.variableNames=t.map((function(t,e){return"T"+e}));var e=new Array(t.length-1);e[0]=t[0][1];for(var n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];var r=["if (yC < "+e[0]+") setOutput(getT0(yR, yC));"];for(n=1;n<e.length;n++){var o=e[n-1];r.push("else if (yC < "+e[n]+") setOutput(getT"+n+"(yR, yC-"+o+"));")}var a=e.length,i=e[e.length-1];r.push("else setOutput(getT"+a+"(yR, yC-"+i+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+r.join("\n        ")+"\n      }\n    "},Ga=function(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Sn(t,e);var n=this.outputShape,r=n.length,o=wa(r),a=sa("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((function(t,e){return"T"+e}));var s=new Array(t.length-1);s[0]=t[0][e];for(var u=1;u<s.length;u++)s[u]=s[u-1]+t[u][e];var c=i[e],l=i.slice(-2),h=i.join(),f="if ("+c+" < "+s[0]+") {\n        return getChannel(\n            getT0("+h+"), vec2("+l.join()+"));\n        }";for(u=1;u<s.length;u++){var d=s[u-1];f+="\n        if ("+c+" < "+s[u]+"  && "+c+" >= "+s[u-1]+") {\n          return getChannel(\n            getT"+u+"("+Ha(i,c,d)+"),\n            vec2("+Ha(l,c,d)+"));\n        }"}var p=s.length,v=s[s.length-1];f+="\n        return getChannel(\n          getT"+p+"("+Ha(i,c,v)+"),\n          vec2("+Ha(l,c,v)+"));",this.userCode="\n      float getValue("+i.map((function(t){return"int "+t}))+") {\n        "+f+"\n      }\n\n      void main() {\n        "+o+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+a+"), 0., 0., 0.);\n\n        "+a[r-1]+" = "+a[r-1]+" + 1;\n        if ("+a[r-1]+" < "+n[r-1]+") {\n          result.g = getValue("+a+");\n        }\n\n        "+a[r-2]+" = "+a[r-2]+" + 1;\n        if ("+a[r-2]+" < "+n[r-2]+") {\n          result.a = getValue("+a+");\n        }\n\n        "+a[r-1]+" = "+a[r-1]+" - 1;\n        if ("+a[r-2]+" < "+n[r-2]+" &&\n            "+a[r-1]+" < "+n[r-1]+") {\n          result.b = getValue("+a+");\n        }\n        setOutput(result);\n      }\n    "};function Ha(t,e,n){var r=t.indexOf(e);return t.map((function(t,e){return e===r?t+" - "+n:t})).join()}var qa=function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a="channelsLast"===t.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              if ("+a+") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ka=function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a="channelsLast"===t.dataFormat,i=e-1-t.padInfo.top,s=n-1-t.padInfo.left,u=a?1:2,c=a?2:3,l=a?3:1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords["+l+"];\n\n        ivec2 dyCorner = ivec2(coords["+u+"], coords["+c+"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n\n              if ("+a+") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ja=function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yF = 0; yF < "+t.outDepth+"; yF++) {\n            int xF = wF + yF * "+e+" - "+o+";\n\n            if (xF < 0 || xF >= "+t.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n              int xR = wR + yR * "+n+" - "+a+";\n\n              if (xR < 0 || xR >= "+t.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n                int xC = wC + yC * "+r+" - "+i+";\n\n                if (xC < 0 || xC >= "+t.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Xa=function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=e-1-t.padInfo.front,u=n-1-t.padInfo.top,c=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+s+", "+u+", "+c+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+e+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+o+".0;\n\n          if (dyF < 0.0 || dyF >= "+t.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+e+" - 1 - wF;\n\n          for (int wR = 0; wR < "+n+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+a+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+n+" - 1 - wR;\n\n            for (int wC = 0; wC < "+r+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+i+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+r+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ya=function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+a+" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},$a=function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+s+"; dm++) {\n              int d2 = d1 * "+s+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Qa=function(t,e,n,r){void 0===e&&(e=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.outputShape=t.outShape;var o=t.padInfo.top,a=t.padInfo.left,i=t.strideHeight,s=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,l=t.filterHeight,h=t.filterWidth,f=4*Math.floor(t.inChannels/4),d=t.inChannels%4,p="channelsLast"===t.dataFormat,v=p?1:2,m=p?2:3,g=p?3:1,y="",x="";n&&(y=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"\n          float activation(float x) {\n            "+n+"\n          }\n        ",x="result = activation(result);");var b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+y+"\n\n      const ivec2 strides = ivec2("+i+", "+s+");\n      const ivec2 pads = ivec2("+o+", "+a+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords["+g+"];\n\n        ivec2 xRCCorner =\n            ivec2(coords["+v+"], coords["+m+"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+l+"; wR++) {\n          int xR = xRCorner + wR * "+u+";\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+h+"; wC++) {\n            int xC = xCCorner + wC * "+c+";\n\n            if (xC < 0 || xC >= "+t.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+f+"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+p+") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if ("+(1===d)+") {\n\n              if ("+p+") {\n                dotProd +=\n                    getX(batch, xR, xC, "+f+") *\n                    getW(wR, wC, "+f+", d2);\n              } else {\n                dotProd +=\n                    getX(batch, "+f+", xR, xC) *\n                    getW(wR, wC, "+f+", d2);\n              }\n\n            } else if ("+(2===d)+") {\n              vec2 wValues = vec2(\n                getW(wR, wC, "+f+", d2),\n                getW(wR, wC, "+f+" + 1, d2)\n              );\n\n              if ("+p+") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, "+f+"),\n                  getX(batch, xR, xC, "+f+" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, "+f+", xR, xC),\n                  getX(batch, "+f+" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if ("+(3===d)+") {\n              vec3 wValues = vec3(\n                getW(wR, wC, "+f+", d2),\n                getW(wR, wC, "+f+" + 1, d2),\n                getW(wR, wC, "+f+" + 2, d2)\n              );\n\n              if ("+p+") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, "+f+"),\n                  getX(batch, xR, xC, "+f+" + 1),\n                  getX(batch, xR, xC, "+f+" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, "+f+", xR, xC),\n                  getX(batch, "+f+" + 1, xR, xC),\n                  getX(batch, "+f+" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        "+b+"\n        "+x+"\n        setOutput(result);\n      }\n    "},Ja=function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.filterDepth,h=t.filterHeight,f=t.filterWidth,d=4*Math.floor(t.inChannels/4),p=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+o+", "+a+", "+i+");\n      const ivec3 pads = ivec3("+e+", "+n+", "+r+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+l+"; wF++) {\n          int xF = xFCorner + wF * "+s+";\n\n          if (xF < 0 || xF >= "+t.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+"; wR++) {\n            int xR = xRCorner + wR * "+u+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+f+"; wC++) {\n              int xC = xCCorner + wC * "+c+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+d+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===p)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+d+") *\n                  getW(wF, wR, wC, "+d+", d2);\n              } else if ("+(2===p)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+d+"),\n                  getX(batch, xF, xR, xC, "+d+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+d+", d2),\n                  getW(wF, wR, wC, "+d+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===p)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+d+"),\n                  getX(batch, xF, xR, xC, "+d+" + 1),\n                  getX(batch, xF, xR, xC, "+d+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+d+", d2),\n                  getW(wF, wR, wC, "+d+" + 1, d2),\n                  getW(wF, wR, wC, "+d+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Za=function(t,e,n,r){void 0===e&&(e=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.outputShape=t.outShape;var o=t.inHeight,a=t.inWidth,i=t.padInfo.top,s=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,l=t.dilationHeight,h=t.dilationWidth,f=t.filterHeight,d=t.filterWidth,p=t.outChannels/t.inChannels,v="",m="";n&&(v=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"\n          float activation(float x) {\n            "+n+"\n          }\n        ",m="result = activation(result);");var g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+v+"\n\n      const ivec2 strides = ivec2("+u+", "+c+");\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+p+";\n        int q = d2 - d1 * "+p+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+f+"; wR++) {\n          int xR = xRCorner + wR * "+l+";\n\n          if (xR < 0 || xR >= "+o+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+d+"; wC++) {\n            int xC = xCCorner + wC * "+h+";\n\n            if (xC < 0 || xC >= "+a+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        "+g+"\n        "+m+"\n        setOutput(result);\n      }\n    "},ti=function(t,e,n,r){void 0===e&&(e=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;for(var o=t.inHeight,a=t.inWidth,i=t.padInfo.top,s=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,l=t.dilationHeight,h=t.dilationWidth,f=t.filterHeight,d=t.filterWidth,p=d,v="int xR; int xC; int xCOffset;",m=0;m<f;m++)for(var g=0;g<d;g++)v+="\n          vec4 xTexelR"+m+"C"+2*g+" = vec4(0.);\n          vec4 wR"+m+"C"+g+" = vec4(0.);\n          vec4 xR"+m+"C"+g+" = vec4(0.);";for(m=0;m<f;m++)for(var y=0;y<p;y++){if(v+="\n          xR = xRCorner + "+m*l+";\n          xC = xCCorner + "+(g=2*y)*h+";\n        ",1===c){if(g<d&&(v+=s%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+o+" && xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+a+") {\n                    xTexelR"+m+"C"+g+".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+o+" && xCOffset >= 0 && xCOffset < "+a+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+a+") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR"+m+"C"+g+" = vec4(previous.zw, xTexelR"+m+"C"+g+".xy);\n                } else {\n                  xR"+m+"C"+g+" = vec4(0, 0, xTexelR"+m+"C"+g+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+o+" && xC >= 0 && xC < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                xR"+m+"C"+g+" = xTexelR"+m+"C"+g+";\n              ",g+1<d)){var x=s%2==0?b(h):h;h%2==0&&s%2==1||h%2!=0&&s%2!=1?(v+="\n                  xCOffset = xC + "+s%2+" + "+x+";\n\n                  if(xR >= 0 && xR < "+o+" &&\n                    xCOffset >= 0 && xCOffset < "+a+") {\n                    xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",h>1&&(v+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+o+" &&\n                      xCOffset >= 0 && xCOffset < "+a+") {\n                      xTexelR"+m+"C"+g+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+m+"C"+g+" = vec4(0.);\n                    }\n                  "),v+="\n                  xR"+m+"C"+(g+1)+" = vec4(\n                    xTexelR"+m+"C"+g+".zw, xTexelR"+m+"C"+(g+2)+".xy);\n                "):v+="\n                  xCOffset = xC + "+x+";\n\n                  if(xR >= 0 && xR < "+o+" &&\n                    xCOffset >= 0 && xCOffset < "+a+") {\n                    xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+m+"C"+(g+1)+" = xTexelR"+m+"C"+(g+2)+";\n                "}}else g<d&&(v+="\n              if(xR >= 0 && xR < "+o+") {\n            ",s%2==1?(v+="\n                xCOffset = xC + 1 - "+c+";\n                if(xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+a+") {\n                  xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+m+"C"+(g+2)+" = vec4(0.);\n                }\n\n                xR"+m+"C"+g+" = vec4(\n                  xTexelR"+m+"C"+g+".zw, xTexelR"+m+"C"+(g+2)+".zw);\n              ",g+1<d&&(v+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+c+";\n                  if(xCOffset >= 0 && xCOffset < "+a+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+m+"C"+(g+1)+" = vec4(xTexelR"+m+"C"+(g+2)+".xy, final.xy);\n                ")):(v+="\n                if(xC >= 0 && xC < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+c+";\n                if(xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+m+"C"+(g+2)+" = vec4(0.);\n                }\n\n                xR"+m+"C"+g+" = vec4(\n                  xTexelR"+m+"C"+g+".xy, xTexelR"+m+"C"+(g+2)+".xy);\n              ",g+1<d&&(v+="\n                  xR"+m+"C"+(g+1)+" = vec4(\n                    xTexelR"+m+"C"+g+".zw, xTexelR"+m+"C"+(g+2)+".zw);\n                ")),v+="}");g<d&&(v+="\n            vec4 wTexelR"+m+"C"+g+" = getW("+m+", "+g+", d1, q);\n            wR"+m+"C"+g+" = vec4(wTexelR"+m+"C"+g+".xz, wTexelR"+m+"C"+g+".xz);\n          ",g+1<d&&(v+="\n              vec4 wTexelR"+m+"C"+(g+1)+" = getW("+m+", "+(g+1)+", d1, q);\n              wR"+m+"C"+(g+1)+" =\n                vec4(wTexelR"+m+"C"+(g+1)+".xz, wTexelR"+m+"C"+(g+1)+".xz);"))}for(m=0;m<f;m++)for(g=0;g<d;g++)v+="dotProd += xR"+m+"C"+g+" * wR"+m+"C"+g+";";var w="",C="";n&&(w=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"vec4 activation(vec4 x) {\n          "+n+"\n        }",C="result = activation(result);");var E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+w+"\n\n      const ivec2 strides = ivec2("+u+", "+c+");\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        "+v+"\n\n        vec4 result = dotProd;\n        "+E+"\n        "+C+"\n        setOutput(result);\n      }\n    "},ei=function(t,e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var a=t[0],i=t[1],s=t[2],u=t[3],c=e[0],l=n[0],h=n[1];this.outputShape=[c,l,h,u];var f="bilinear"===r?1:0,d=[i-1+".0",s-1+".0"],p=d[0],v=d[1],m=l>1?[""+(i-1)/(l-1),"(y2-y1) * height_ratio","y1*"+p+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+p],g=m[0],y=m[1],x=m[2],b=h>1?[""+(s-1)/(h-1),"(x2-x1) * width_ratio","x1*"+v+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+v],w=b[0],C=b[1],E=b[2];this.userCode="\n      const float height_ratio = float("+g+");\n      const float width_ratio = float("+w+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+a+") {\n          return;\n        }\n\n        float height_scale = "+y+";\n        float width_scale = "+C+";\n\n        float in_y = "+x+";\n        if( in_y < 0.0 || in_y > "+p+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n        float in_x = "+E+";\n        if( in_x < 0.0 || in_x > "+v+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+f+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "},ni=function(t,e,n){this.variableNames=["x"],this.outputShape=t;var r=t.length,o=t[t.length-1],a=n?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(n?"return "+o+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+wa(r)+" coords = getOutputCoords();\n        int end = "+ri(r,"coords")+";\n        float val = 0.0;\n        for (int i = "+o+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+a+" end) {\n            continue;\n          }\n          if (idx == end && "+e+") {\n            continue;\n          }\n          "+ri(r,"coords")+" = idx;\n          val += getX("+function(t,e){if(1===t)return""+e;if(2===t)return e+".x, "+e+".y";if(3===t)return e+".x, "+e+".y, "+e+".z";if(4===t)return e+".x, "+e+".y, "+e+".z, "+e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "};function ri(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}var oi=function(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Vt.DENSE;var e=Yt(t),n=ua();this.outputShape=t,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],t)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+e[0]+", "+e[1]+"));\n        int index = 4 * (resTexRC.x * "+e[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        "+n.output+" = result;\n      }\n    "},ai=function(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Vt.DENSE;var e=Yt(t),n=ua();this.outputShape=t,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],t)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+e[0]+", "+e[1]+"));\n        int index = 4 * (resTexRC.x * "+e[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+n.output+" = result;\n      }\n    "},ii=function(){function t(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+e+";\n      int offset_h = imod(h, "+e+");\n      int in_w = w / "+e+";\n      int offset_w = imod(w, "+e+");\n      int offset_d = (offset_h * "+e+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),si=function(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "},ui=function(t){this.variableNames=["A"],this.outTexUsage=zt.DOWNLOAD;var e=ua();this.outputShape=t,this.userCode="\n      "+ha+"\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+e.output+" = encode_float(x);\n      }\n    "},ci=function(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=zt.DOWNLOAD;var e=ua();this.outputShape=t,this.userCode="\n      "+ha+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+e.output+" = encode_float(x);\n      }\n    "},li=function(t,e,n){void 0===n&&(n=!1),this.variableNames=["A"];var r=ua(),o=e[0],a=e[1];this.outputShape=t;var i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode="\n      "+la(t)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / "+a+";\n        int c = imod(flatIndex, "+a+");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2("+a+".0, "+o+".0);\n        vec4 values = "+r.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        "+r.output+" = vec4("+i+", 0., 0., 0.);\n      }\n    "},hi=function(t,e,n){void 0===n&&(n=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var r=ua(),o=e[0],a=e[1];this.outputShape=t;var i="",s="result";n&&(s="floor(result * 255. + 0.5)");for(var u=0;u<=1;u++)for(var c=0;c<=1;c++){var l=2*u+c;i+="\n          localCoords = coords;\n          if(localCoords[2] + "+c+" < "+t[2]+") {\n            localCoords[2] += "+c+";\n            if(localCoords[1] + "+u+" < "+t[1]+") {\n              localCoords[1] += "+u+";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / "+a+";\n              c = imod(flatIndex, "+a+");\n              uv = (vec2(c, r) + halfCR) / vec2("+a+".0, "+o+".0);\n              values = "+r.texture2D+"(A, uv);\n\n              if(offset == 0) {\n                result["+l+"] = values[0];\n              } else if(offset == 1) {\n                result["+l+"] = values[1];\n              } else if(offset == 2) {\n                result["+l+"] = values[2];\n              } else {\n                result["+l+"] = values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+la(t)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+i+"\n\n        "+r.output+" = "+s+";\n      }\n    "},fi="return real * expR - imag * expI;",di="return real * expI + imag * expR;",pi=function(t,e,n){this.variableNames=["real","imag"];var r=e[1];this.outputShape=e;var o=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=n?r+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+o+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+t+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+r+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+r+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+a+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "},vi=function(){function t(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.valueLoc&&(e.valueLoc=n.getUniformLocationNoThrow(r,"value")),n.gl.uniform1f(e.valueLoc,t)}},t}(),mi=function(t,e,n){this.variableNames=["A","indices"];var r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;var o=wa(this.rank),a=function(t,e){var n=t.length;if(n>4)throw Error("Gather for rank "+n+" is not yet supported");if(1===n)return"int(getIndices(resRC))";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=0;a<t.length;a++)a===e?o.push("int(getIndices("+r[a]+"))"):o.push(""+r[a]);return o.join()}(t,n);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "};var gi=function(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;var r=wa(e.length),o=wa(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+r+" strides = "+r+"("+this.strides+");\n         void main() {\n          "+o+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+a+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "};function yi(t,e){var n=ua();return oe(t,e,n.version+"\n    precision highp float;\n    "+n.attribute+" vec3 clipSpacePos;\n    "+n.attribute+" vec2 uv;\n    "+n.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function xi(t,e){return fe(t,e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function bi(t,e){return de(t,e,new Uint16Array([0,1,2,2,1,3]))}function wi(t,e,n,r,o,a,i){ve(n,r);var s=pe(t,e),u=t.TEXTURE_2D;return Jt(t,e,(function(){return t.bindTexture(u,s)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST)})),Jt(t,e,(function(){return t.texImage2D(u,0,o,n,r,0,a,i,null)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)})),s}function Ci(t,e,n,r,o){var a=Xt(n,r);return wi(t,e,a[0],a[1],o.internalFormatFloat,o.textureFormatFloat,t.FLOAT)}function Ei(t,e,n,r,o){var a=Xt(n,r);return wi(t,e,a[0],a[1],o.internalFormatHalfFloat,o.textureFormatFloat,o.textureTypeHalfFloat)}function Ri(t,e,n,r,o){var a=Xt(n,r);return wi(t,e,a[0],a[1],t.RGBA,t.RGBA,t.UNSIGNED_BYTE)}function Ii(t,e,n,r,o){var a=$t(n,r);return wi(t,e,a[0],a[1],o.internalFormatPackedFloat,t.RGBA,t.FLOAT)}function ki(t,e,n,r,o){var a=$t(n,r);return wi(t,e,a[0],a[1],o.internalFormatPackedHalfFloat,t.RGBA,o.textureTypeHalfFloat)}function Si(t,e,n,r){return Jt(t,e,(function(){return t.bindBuffer(t.ARRAY_BUFFER,r)})),ge(t,e,n,"clipSpacePos",r,3,20,0)&&ge(t,e,n,"uv",r,2,20,12)}function Ai(t,e,n,r,o,a,i){var s,u,c;Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,n)})),a instanceof Uint8Array?(s=new Uint8Array(r*o*4),u=t.UNSIGNED_BYTE,c=t.RGBA):(s=new Float32Array(r*o*4),u=t.FLOAT,c=i.internalFormatPackedFloat),s.set(a),Jt(t,e,(function(){return t.texImage2D(t.TEXTURE_2D,0,c,r,o,0,t.RGBA,u,s)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)}))}function Di(t,e,n,r){Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,n)})),r.data instanceof Uint8Array?Jt(t,e,(function(){return t.texImage2D(t.TEXTURE_2D,0,t.RGBA,r.width,r.height,0,t.RGBA,t.UNSIGNED_BYTE,r.data)})):Jt(t,e,(function(){return t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,r)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)}))}function Ti(t,e,n,r,o){var a=t.createBuffer();Jt(t,e,(function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,a)}));var i=16*n*r;return Jt(t,e,(function(){return t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)})),Jt(t,e,(function(){return t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,0)})),Jt(t,e,(function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,null)})),a}function Ni(t,e,n){var r=t,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function Fi(t,e,n,r,o){var a=Xt(n,r),i=a[0],s=a[1],u=new Uint8Array(n*r*4);return Jt(t,e,(function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.UNSIGNED_BYTE,u)})),new Float32Array(u.buffer)}function _i(t,e,n,r,o,a,i,s){var u=t,c=new Float32Array(function(t,e){var n=$t(t,e);return n[0]*n[1]*4}(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function Oi(t,e,n,r){var o=new Float32Array(n*r*4);return Jt(t,e,(function(){return t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,o)})),o}var Mi=Object.freeze({createVertexShader:yi,createVertexBuffer:xi,createIndexBuffer:bi,createFloat32MatrixTexture:Ci,createFloat16MatrixTexture:Ei,createUnsignedBytesMatrixTexture:Ri,createPackedMatrixTexture:Ii,createFloat16PackedMatrixTexture:ki,bindVertexProgramAttributeStreams:Si,uploadDenseMatrixToTexture:Ai,uploadPixelDataToTexture:Di,createBufferFromOutputTexture:Ti,downloadFloat32MatrixFromBuffer:Ni,downloadByteEncodedFloatMatrixFromOutputTexture:Fi,downloadPackedMatrixFromBuffer:_i,downloadMatrixFromPackedOutputTexture:Oi}),Bi=function(){function t(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var e=i().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,Kt(e,t)):this.gl=jt(e);var n="WEBGL_color_buffer_float";if(1===i().getNumber("WEBGL_VERSION")){if(this.textureFloatExtension=re(this.gl,this.debug,"OES_texture_float"),Pe(this.gl,"OES_texture_half_float"))this.textureHalfFloatExtension=re(this.gl,this.debug,"OES_texture_half_float");else if(i().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Pe(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=re(this.gl,this.debug,"EXT_color_buffer_half_float");else if(i().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Pe(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Pe(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=xi(this.gl,this.debug),this.indexBuffer=bi(this.gl,this.debug),this.framebuffer=me(this.gl,this.debug),this.textureConfig=Qt(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(t.prototype,"debug",{get:function(){return i().getBool("DEBUG")},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var e=this.gl;Jt(e,this.debug,(function(){return e.finish()})),Jt(e,this.debug,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)})),Jt(e,this.debug,(function(){return e.deleteFramebuffer(t.framebuffer)})),Jt(e,this.debug,(function(){return e.bindBuffer(e.ARRAY_BUFFER,null)})),Jt(e,this.debug,(function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)})),Jt(e,this.debug,(function(){return e.deleteBuffer(t.indexBuffer)})),this.disposed=!0}},t.prototype.createFloat32MatrixTexture=function(t,e){return this.throwIfDisposed(),Ci(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(t,e){return this.throwIfDisposed(),Ei(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(t,e){return this.throwIfDisposed(),Ri(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(t,e){this.throwIfDisposed(),Di(this.gl,this.debug,t,e)},t.prototype.uploadDenseMatrixToTexture=function(t,e,n,r){this.throwIfDisposed(),Ai(this.gl,this.debug,t,e,n,r,this.textureConfig)},t.prototype.createFloat16PackedMatrixTexture=function(t,e){return this.throwIfDisposed(),ki(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Ii(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.deleteMatrixTexture=function(t){var e=this;this.throwIfDisposed(),this.outputTexture===t&&(Ee(this.gl,this.debug,this.framebuffer),this.outputTexture=null),Jt(this.gl,this.debug,(function(){return e.gl.deleteTexture(t)}))},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,(function(){return Fi(r.gl,r.debug,e,n,r.textureConfig)}))},t.prototype.downloadPackedMatrixFromBuffer=function(t,e,n,r,o,a){return _i(this.gl,t,0,0,0,o,a,this.textureConfig)},t.prototype.downloadFloat32MatrixFromBuffer=function(t,e){return Ni(this.gl,t,e)},t.prototype.createBufferFromTexture=function(t,e,n){this.bindTextureToFrameBuffer(t);var r=Ti(this.gl,this.debug,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},t.prototype.createAndWaitForFence=function(){var t=this.createFence(this.gl);return this.pollFence(t)},t.prototype.createFence=function(t){var e,n,r=this;if(i().getBool("WEBGL_FENCE_API_ENABLED")){var o=t,a=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=function(){var t=o.clientWaitSync(a,0,0);return t===o.ALREADY_SIGNALED||t===o.CONDITION_SATISFIED},e=a}else i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=function(){return r.isQueryAvailable(e,i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):n=function(){return!0};return{query:e,isFencePassed:n}},t.prototype.downloadMatrixFromPackedTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,(function(){return Oi(r.gl,r.debug,e,n)}))},t.prototype.createProgram=function(t){this.throwIfDisposed();var e=this.gl,n=ae(e,this.debug,t),r=yi(e,this.debug),o=ce(e,this.debug);return Jt(e,this.debug,(function(){return e.attachShader(o,r)})),Jt(e,this.debug,(function(){return e.attachShader(o,n)})),le(e,this.debug,o),this.debug&&he(e,this.debug,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=Si(e,this.debug,this.program,this.vertexBuffer)),o},t.prototype.deleteProgram=function(t){var e=this;this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Jt(this.gl,this.debug,(function(){return e.gl.deleteProgram(t)}))},t.prototype.setProgram=function(t){var e=this;this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&he(this.gl,this.debug,this.program),Jt(this.gl,this.debug,(function(){return e.gl.useProgram(t)}))},t.prototype.getUniformLocation=function(t,e,n){return void 0===n&&(n=!0),this.throwIfDisposed(),n?xe(this.gl,this.debug,t,e):be(this.gl,t,e)},t.prototype.getAttributeLocation=function(t,e){var n=this;return this.throwIfDisposed(),Jt(this.gl,this.debug,(function(){return n.gl.getAttribLocation(t,e)}))},t.prototype.getUniformLocationNoThrow=function(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)},t.prototype.setInputMatrixTexture=function(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),we(this.gl,this.debug,this.program,t,e,n)},t.prototype.setOutputMatrixTexture=function(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)},t.prototype.setOutputPackedMatrixTexture=function(t,e,n){this.throwIfDisposed();var r=$t(e,n),o=r[0],a=r[1];this.setOutputMatrixTextureDriver(t,o,a)},t.prototype.setOutputMatrixWriteRegion=function(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)},t.prototype.setOutputPackedMatrixWriteRegion=function(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&he(this.gl,this.debug,this.program),Re(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var t=this.gl;this.debug&&this.debugValidate(),Jt(t,this.debug,(function(){return t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)}))},t.prototype.blockUntilAllProgramsCompleted=function(){var t=this;this.throwIfDisposed(),Jt(this.gl,this.debug,(function(){return t.gl.finish()}))},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=re(this.gl,this.debug,2===i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}var r=this.getQueryTimerExtensionWebGL1(),o=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,o),o},t.prototype.endQuery=function(){if(2!==i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}else{var e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(t){return n(this,void 0,void 0,(function(){var e=this;return r(this,(function(n){switch(n.label){case 0:return[4,F((function(){return e.disposed||e.isQueryAvailable(t,i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}))];case 1:return n.sent(),[2,this.getQueryTime(t,i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}}))}))},t.prototype.getQueryTime=function(t,e){if(0===e)return null;if(2===e){var n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(t,e){if(0===e)return!0;if(2===e){var n=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint},t.prototype.pollFence=function(t){var e=this;return new Promise((function(n){e.addItemToPoll((function(){return t.isFencePassed()}),(function(){return n()}))}))},t.prototype.pollItems=function(){for(var t=function(t){for(var e=0;e<t.length;++e){if(!t[e]())break}return e-1}(this.itemsToPoll.map((function(t){return t.isDoneFn}))),e=0;e<=t;++e){(0,this.itemsToPoll[e].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(t+1)},t.prototype.addItemToPoll=function(t,e){var n=this;this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||F((function(){return n.pollItems(),0===n.itemsToPoll.length}))},t.prototype.bindTextureToFrameBuffer=function(t){this.throwIfDisposed(),Ce(this.gl,this.debug,t,this.framebuffer),this.debug&&Re(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(Ce(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&Re(this.gl)):Ee(this.gl,this.debug,this.framebuffer)},t.prototype.downloadMatrixDriver=function(t,e){this.bindTextureToFrameBuffer(t);var n=e();return this.unbindTextureToFrameBuffer(),n},t.prototype.setOutputMatrixTextureDriver=function(t,e,n){this.throwIfDisposed();var r=this.gl;Ce(r,this.debug,t,this.framebuffer),this.debug&&Re(r),this.outputTexture=t,Jt(r,this.debug,(function(){return r.viewport(0,0,e,n)})),Jt(r,this.debug,(function(){return r.scissor(0,0,e,n)}))},t.prototype.setOutputMatrixWriteRegionDriver=function(t,e,n,r){var o=this;this.throwIfDisposed(),Jt(this.gl,this.debug,(function(){return o.gl.scissor(t,e,n,r)}))},t.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},t}();function Pi(t,e){if(t.length!==e.length)throw Error("Binary was compiled with "+t.length+" inputs, but was executed with "+e.length+" inputs");t.forEach((function(t,n){var r=t.logicalShape,o=e[n],a=o.shape;if(!S(r,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+r+" and "+a+" must match");if(!t.isUniform||!o.isUniform){var i=t.texShape,s=o.isUniform?null:o.texData.texShape;if(!S(i,s))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+i+" and "+s+" must match")}}))}var Li=function(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;for(var r=n.filterWidth,o=n.inChannels,a=n.strideWidth,i=n.strideHeight,s=n.padInfo,u=n.outWidth,c=n.dilationWidth,l=n.dilationHeight,h=n.dataFormat,f=s.left,d=s.top,p=o*r,v=ua(),m="channelsLast"===h,g=m?0:1,y=m?1:2,x="",b=0;b<=1;b++)for(var w=0;w<=1;w++)x+="\n          blockIndex = rc.y + "+w+";\n          pos = rc.x + "+b+";\n\n          if(blockIndex < "+t[1]+" && pos < "+t[0]+") {\n            offsetY = int(blockIndex / ("+u+")) * "+i+" - "+d+";\n            d0 = offsetY + "+l+" * (pos / "+p+");\n\n            if(d0 < "+e[g]+" && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), "+u+".) * "+a+". - "+f+".);\n              d1 = offsetX + "+c+" * (int(mod(float(pos), "+p+".) / "+o+".));\n\n              if(d1 < "+e[y]+" && d1 >= 0) {\n\n                ch = int(mod(float(pos), "+o+".));\n\n                if ("+m+") {\n                  innerDims = vec2(d1, ch);\n                  result["+(2*b+w)+"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result["+(2*b+w)+"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+x+"\n\n        "+v.output+" = result;\n      }\n    "},Wi=function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[];var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+i+"; j <= "+i+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+s+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+a+";\n        setOutput(val);\n      }\n    "},Ui=function(t,e,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+e+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+e+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+n+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+o+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+o+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "},Vi=function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+i+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+i+"; j <= "+i+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+s+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+a+";\n        setOutput(result);\n      }\n    "},zi=function(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;var e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=o-1-t.padInfo.top,s=a-1-t.padInfo.left,u=o*a-1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+o+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+e+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+a+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+u+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+a+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Gi=function(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;var e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,l=s-1-t.padInfo.front,h=u-1-t.padInfo.top,f=c-1-t.padInfo.left,d=s*u*c-1;this.userCode="\n      const ivec3 pads = ivec3("+l+", "+h+", "+f+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+s+";\n           wD += "+o+") {\n          float dyD = float(dyDCorner + wD) / "+e+".0;\n\n          if (dyD < 0.0 || dyD >= "+t.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+a+") {\n            float dyR = float(dyRCorner + wR) / "+n+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+c+";\n                wC += "+i+") {\n              float dyC = float(dyCCorner + wC) / "+r+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = "+d+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * "+u+" * "+c+" +\n                  wR * "+c+" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Hi=function(t,e,n,r,o,a,i){void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===a&&(a=null),void 0===i&&(i=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;var s=n?t[1]:t[2],u=Math.ceil(s/2),c=n?"i * 2, rc.y":"rc.y, i * 2",l=r?"rc.z, i * 2":"i * 2, rc.z",h=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],d="",p="";a&&(d=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+a+"\n        }":"vec4 activation(vec4 x) {\n          "+a+"\n        }",p="result = activation(result);");var v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+d+"\n\n      const float sharedDimension = "+u+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+u+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+c+");\n          vec4 b = getMatrixB(rc.x, "+l+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += ("+h[0]+" * "+f[0]+");\n          result += ("+h[1]+" * "+f[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+v+"\n\n        "+p+"\n\n        setOutput(result);\n      }\n    "},qi=function(){function t(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(e-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(e-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.seedLoc&&(e.seedLoc=n.getUniformLocation(r,"seed")),n.gl.uniform1f(e.seedLoc,t)}},t}(),Ki=function(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+n+"),\n                      float(index == coords.y)));\n      }\n    "},ji=function(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;var e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var n=sa("rc",e),r=wa(e),o=function(t,e,n){if(1===t)return"rc > "+e[0];for(var r="",o=t-2;o<t;o++)r+=n[o]+" >= "+e[o],o<t-1&&(r+="||");return r}(e,t,n),a=function(t,e,n,r){if(1===t)return"";var o=r.slice(-2);return"\n    int r = "+o[0]+";\n    int c = "+o[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+e+";\n    bool rEdge = rp1 >= "+n+";\n  "}(e,t[t.length-1],t[t.length-2],n),i=function(t,e){var n=t.length,r=function(t,e){for(var n=[],r=0;r<=1;r++)for(var o=0;o<=1;o++){for(var a=(0===r?"r":"rp1")+", "+(0===o?"c":"cp1"),i=2;i<t;i++)a=e[e.length-1-i]+","+a;n.push(a)}return n}(n,e);return 1===n?"getA(rc),\n            rc + 1 >= "+t[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")"}(t,n);this.userCode="\n        void main() {\n          "+r+" rc = getOutputCoords();\n\n          if("+o+") {\n            setOutput(vec4(0));\n          } else {\n            "+a+"\n\n            setOutput(vec4("+i+"));\n          }\n        }\n      "}};var Xi=function(t,e,n){this.variableNames=["x"],this.outputShape=e.map((function(e,n){return e[0]+t[n]+e[1]}));var r=t.length,o=wa(r),a=e.map((function(t){return t[0]})).join(","),i=e.map((function(e,n){return e[0]+t[n]})).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      "+o+" start = "+o+"("+a+");\n      "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+n+"));\n        } else {\n          "+o+" coords = outC - start;\n          setOutput(getX("+s+"));\n        }\n      }\n    ":"\n        int start = "+a+";\n        int end = "+i+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+n+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "},Yi=function(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((function(e,n){return e[0]+t[n]+e[1]}));for(var r=t.length,o=wa(r),a=e.map((function(t){return t[0]})).join(","),i=e.map((function(e,n){return e[0]+t[n]})).join(","),s=sa("rc",r),u=sa("source",r),c=s[r-1]+" < "+this.outputShape[r-1],l=1===r?"source":"vec2("+u.slice(-2).join()+")",h=[o+" rc = outputLoc;",s[r-1]+" += 1;\n       if("+c+") {\n      ",1===r?"":"}\n       rc = outputLoc;\n       "+s[r-2]+" += 1;\n       if("+s[r-2]+" < "+this.outputShape[r-2]+") {",1===r?"":"  "+s[r-1]+" += 1;\n         if("+c+") {"],f=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="",p=0,v=1===r?2:4;p<v;p++)d+="\n        "+h[p]+"\n        if ("+f+") {\n          result["+p+"] = float("+n+");\n        } else {\n          "+o+" source = rc - start;\n          result["+p+"] = getChannel(getX("+u.join()+"), "+l+");\n        }\n      ";d+=1===r?"} ":"}}",this.userCode="\n      const "+o+" start = "+o+"("+a+");\n      const "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+d+"\n        setOutput(result);\n      }\n    "},$i=function(t,e,n){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");var r=t.filterWidth,o=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,s=t.dilationWidth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,l=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;var f="avg"===e,d="0.0";if(f||(d="-1.0 / 1e-20"),n)this.userCode="\n        const ivec2 strides = ivec2("+o+", "+a+");\n        const ivec2 pads = ivec2("+l+", "+h+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+i+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+c+";\n                wC += "+s+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+c+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var p=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(p="avgValue / count");var v=4*Math.floor(r/4),m=r%4,g="\n      if ("+f+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+o+", "+a+");\n      const ivec2 pads = ivec2("+l+", "+h+");\n      const float initializationValue = "+d+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+t.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+d+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+u+";\n            wR += "+i+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+v+"; wC += 4) {\n            int xC = xCCorner + wC * "+s+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              getValue(batch, xR, xC + 3 * "+s+", d)\n            );\n\n            "+g+"\n          }\n\n          int xC = xCCorner + "+v+";\n          if ("+(1===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(2===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(3===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              initializationValue\n            );\n\n            "+g+"\n          }\n        }\n        setOutput("+p+");\n      }\n    "}},Qi=function(t,e,n){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");var r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,v=t.padInfo.left;this.outputShape=t.outShape;var m="avg"===e,g="0.0";if(m||(g="-1.0 / 1e-20"),n)this.userCode="\n        const ivec3 strides =\n            ivec3("+o+", "+a+", "+i+");\n        const ivec3 pads = ivec3("+d+", "+p+", "+v+");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < "+l+";\n              wD += "+s+") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= "+t.inDepth+") {\n              continue;\n            }\n\n            for (int wR = 0; wR < "+h+";\n                wR += "+u+") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= "+t.inHeight+") {\n                continue;\n              }\n\n              for (int wC = 0; wC < "+f+";\n                  wC += "+c+") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= "+t.inWidth+") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * "+h+" * "+f+" +\n                      wR * "+f+" + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var y=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(y="avgValue / count");var x=4*Math.floor(r/4),b=r%4,w="\n      if ("+m+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec3 strides =\n        ivec3("+o+", "+a+", "+i+");\n      const ivec3 pads = ivec3("+d+", "+p+", "+v+");\n      const float initializationValue = "+g+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= "+t.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+g+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < "+l+";\n            wD += "+s+") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= "+t.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+";\n            wR += "+u+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+x+"; wC += 4) {\n              int xC = xCCorner + wC * "+c+";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+c+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+c+", ch)\n              );\n\n              "+w+"\n            }\n\n            int xC = xCCorner + "+x+";\n            if ("+(1===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+w+"\n            } else if ("+(2===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+w+"\n            } else if ("+(3===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+c+", ch),\n                initializationValue\n              );\n\n              "+w+"\n            }\n          }\n          setOutput("+y+");\n        }\n      }\n    "}},Ji=function(t,e){this.variableNames=["x"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=Math.ceil(o/n);this.outputShape=[r,a];var i="0.0",s="";"prod"===e?i="1.0":"min"===e?(i="1.0 / 1e-20",s="min"):"max"===e&&(i="-1.0 / 1e-20",s="max");var u=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");var c=4*Math.floor(n/4),l=n%4,h="\n      if ("+("sum"===e)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===e)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+s+"(values, minMaxValue);\n      }\n    ",f="vec4";"all"===e?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");var d="";o%n>0&&(d="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+i+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+d+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+n+";\n\n        vec4 minMaxValue = vec4("+i+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+c+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+h+"\n        }\n\n        int inIdx = inOffset + "+c+";\n        if ("+(1===l)+") {\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(2===l)+") {\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(3===l)+") {\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+h+"\n        }\n        setOutput("+u+");\n      }\n    "},Zi=function(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;for(var n="",r=0;r<4;r++){var o="thisRC = rc;";r%2==1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),n+="\n        "+o+"\n        "+(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+r+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(r>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+ca(["r","c","d"],e)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+la(t)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+t[1]+";\n        int cols = "+t[2]+";\n\n        "+n+"\n\n        setOutput(result);\n      }\n    "};var ts=function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],c=[n&&s>1?o-1:o,n&&u>1?a-1:a],l=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=c[0]/l[0],f=c[1]/l[1],d=1/h,p=1/f,v=2*Math.ceil(d)+2,m=2*Math.ceil(p)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+f+");\n\n        const float invHeightScale = float("+d+");\n        const float invWidthScale = float("+p+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(o-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(a-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},es=function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/c[0]+",\n          "+u[1]/c[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "},ns=function(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+u[0]/c[0]+",\n          "+u[1]/c[1]+",\n          "+u[1]/c[1]+");\n      const vec3 inputShapeRC = vec3("+a+".0, "+i+".0,\n                                     "+i+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(s-1)+";\n        bool hasNextRow = coords.z < "+(n-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "},rs=function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],c=[n&&s>1?o-1:o,n&&u>1?a-1:a],l=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=c[0]/l[0],f=c[1]/l[1],d=1/h,p=1/f,v=2*Math.ceil(d)+2,m=2*Math.ceil(p)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+f+");\n\n        const float invHeightScale = float("+d+");\n        const float invWidthScale = float("+p+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+c[0]+") *\n                (float(dyR) / float("+l[0]+"));\n\n            float sourceFracCol =\n                float("+c[1]+") *\n                  (float(dyC) / float("+l[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+o+") - 1),\n                "+n+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+a+") - 1),\n                "+n+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},os=function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],l=r?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/c[0]+",\n          "+u[1]/c[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+l+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "},as=function(t,e){this.variableNames=["x"];var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");if(this.outputShape=t,1!==n){var r=t.map((function(n,r){return function(n){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - coords["+n+"] - 1":"coords["+n+"]"}(r)})).join(","),o=wa(n);this.userCode="\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+r+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+t[0]+" - coord - 1));\n        }\n      "},is=function(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");this.outputShape=t;var r=sa("rc",n),o=r[n-1]+" + 1 < "+this.outputShape[n-1],a=r[n-2]+" + 1 < "+this.outputShape[n-2],i=wa(n);function s(n){var r=t.map((function(r,o){return function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - "+r[n]+" - 1":""+r[n]}(o,n)}));return"getChannel(getX("+r.join(",")+"), vec2("+r.slice(-2).join(",")+"))"}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+t[0]+" - rc - 1),\n            "+t[0]+" - rc - 1);\n          if("+o+"){\n              result.g = getChannel(getX("+t[0]+" - (rc  + 1) - 1),\n                "+t[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+i+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+function(t){return s(t)}(r.slice())+";\n          if("+o+"){\n            result.g = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",s(t)}(r.slice())+";\n          }\n          if("+a+") {\n            result.b = "+function(t){return t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            if("+o+") {\n              result.a = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "},ss=function(t,e,n,r,o,a,i){void 0===i&&(i=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;var s=wa(o.length),u=wa(a.length),c="";1===n?c="i":2===n&&(c="i, j");var l="getIndices("+c+")",h="";1===r?h="i":2===r&&(h="i, coords[1]");var f="getUpdates("+h+")",d=e>1?"strides[j]":"strides";this.userCode="\n        "+s+" strides = "+s+"("+o+");\n\n        void main() {\n          "+u+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+t+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+e+"; j++) {\n              int index = round("+l+");\n              flattenedIndex += index * "+d+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+f+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "},us=function(t,e){this.variableNames=["x","segmentIds"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=t.numSegments,i=a*Math.ceil(o/n);this.outputShape=[r,i];var s=4*Math.floor(n/4),u=n%4,c="\n        sumValue += dot(values, segFilter);\n    ",l="";o%n>0&&(l="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      ");var h="";o%n>0&&(h="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+l+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+h+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+a+")) * float("+n+"));\n        int currentSeg = int(mod(float(outIdx), float("+a+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+s+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+c+"\n        }\n\n        int inIdx = inOffset + "+s+";\n        if ("+(1===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+c+"\n        } else if ("+(2===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+c+"\n        } else if ("+(3===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+c+"\n        }\n        setOutput(sumValue);\n      }\n    "},cs=function(t,e,n){var r,o;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank "+n+" is not yet supported");if(1===n)o="resRC",r="resRC";else{for(var a=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[],u=0;u<e.length;u++)s.push(""+a[u]),u<t&&i.push(""+a[u]);r=i.join(),o=s.join()}var c=wa(n);this.userCode="\n      void main() {\n        "+c+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+o+"));\n        } else {\n          setOutput(getB("+o+"));\n        }\n      }\n    "},ls=function(){function t(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;var e,n=wa(this.rank),r="uniform int start["+this.rank+"];",o=function(t){if(1===t)return"sourceLoc";if(t<=6)return hs.slice(0,t).map((function(t){return"sourceLoc."+t})).join(",");throw Error("Slicing for rank "+t+" is not yet supported")}(this.rank);e="\n        "+n+" sourceLoc;\n        "+n+" coords = getOutputCoords();\n        "+t.map((function(t,e){return"sourceLoc."+hs[e]+" = start["+e+"] + coords."+hs[e]+";"})).join("\n")+"\n      ",this.userCode="\n      "+r+"\n      void main() {\n        "+e+"\n        setOutput(getSource("+o+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),hs=["x","y","z","w","u","v"];var fs=function(){function t(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;var e=wa(this.rank),n=sa("coords",this.rank),r=sa("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":"vec2("+r.slice(-2).join()+")",a="getChannel(getSource("+r.join()+"), "+o+")",i="\n      result.x = "+a+";\n      if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n        ++"+r[this.rank-1]+";\n        result.y = "+a+";\n        --"+r[this.rank-1]+";\n      }\n    ",s=1===this.rank?"":"\n      --"+n[this.rank-1]+";\n      if (++"+n[this.rank-2]+" < "+t[this.rank-2]+") {\n        ++"+r[this.rank-2]+";\n        result.z = "+a+";\n        if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n          ++"+r[this.rank-1]+";\n          result.w = "+a+";\n        }\n      }\n    ",u=this.rank<=4?"sourceLoc = coords +\n            "+e+"("+t.map((function(t,e){return"start["+e+"]"})).join()+");":t.map((function(t,e){return r[e]+" = "+n[e]+" + start["+e+"];"})).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+e+" coords = getOutputCoords();\n        "+e+" sourceLoc;\n        "+u+"\n        vec4 result = vec4(0.);\n        "+i+"\n        "+s+"\n        setOutput(result);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),ds=function(t,e,n){this.variableNames=["x"],this.outputShape=n;var r=n.length,o=wa(n.length),a=wa(n.length),i="";if(1===r)i="coords * strides + begin";else{var s=0;i=n.map((function(t,e){return s++,1===n.length?"coords * strides["+e+"] + begin["+e+"]":"coords["+(s-1)+"] * strides["+e+"] + begin["+e+"]"})).join(",")}this.userCode="\n      "+o+" begin = "+o+"("+t+");\n      "+o+" strides = "+o+"("+e+");\n\n      void main() {\n        "+a+" coords = getOutputCoords();\n        setOutput(getX("+i+"));\n      }\n    "},ps=function(){function t(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(t,e,n){var r,o=vs(e,n),a=ms(t,o,n);if(a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]),this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[a].shift();return this.usedTextures[a].push(i),i}return this.numUsedTextures++,this.log(),o===Gt.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Gt.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Gt.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Gt.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Gt.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(r),r},t.prototype.releaseTexture=function(t,e,n,r){if(null!=this.freeTextures){var o=ms(e,vs(n,r),r);o in this.freeTextures||(this.freeTextures[o]=[]),this.freeTextures[o].push(t),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures[o],i=a.indexOf(t);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(i,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+t+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var t=this;if(null!=this.freeTextures){for(var e in this.freeTextures)this.freeTextures[e].forEach((function(e){t.gpgpu.deleteMatrixTexture(e)}));for(var e in this.usedTextures)this.usedTextures[e].forEach((function(e){t.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}();function vs(t,e){if(t===zt.UPLOAD)return Gt.PACKED_2X2_FLOAT32;if(t===zt.RENDER||null==t)return function(t){return i().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Gt.PACKED_2X2_FLOAT32:Gt.UNPACKED_FLOAT32:t?Gt.PACKED_2X2_FLOAT16:Gt.UNPACKED_FLOAT16}(e);if(t===zt.DOWNLOAD||t===zt.PIXELS)return Gt.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function ms(t,e,n){return t[0]+"_"+t[1]+"_"+e+"_"+n}var gs=function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;var o=wa(this.rank),a=function(t){var e=t.length;if(e>5)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"imod(resRC, "+t[0]+")";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],o=0;o<t.length;o++)r.push("imod("+n[o]+", "+t[o]+")");return r.join()}(t);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "};var ys=function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;var o=wa(this.rank),a=function(t){var e=t.length;if(e>6)throw Error("Transpose for rank "+e+" is not yet supported");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e),o=0;o<t.length;o++)r[t[o]]=n[o];return r.join()}(e);this.userCode="\n    void main() {\n      "+o+" resRC = getOutputCoords();\n      setOutput(getA("+a+"));\n    }\n    "};var xs=function(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var o=wa(this.rank),a=ia("rc",this.rank),i=new Array(this.rank);for(r=0;r<e.length;r++)i[e[r]]=a[r];var s="vec2("+i.slice(-2).join()+")",u="++"+a[this.rank-1]+" < "+n[this.rank-1],c="getChannel(getA("+i.join()+"), "+s+")";this.userCode="\n    void main() {\n      "+o+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+c+";\n      if("+u+") {\n        result[1] = "+c+";\n      }\n      --"+a[this.rank-1]+";\n      if(++"+a[this.rank-2]+" < "+n[this.rank-2]+") {\n        result[2] = "+c+";\n        if("+u+") {\n          result[3] = "+c+";\n        }\n      }\n      setOutput(result);\n    }\n    "},bs=1.7580993408473768,ws=1.0507009873554805,Cs=function(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      float unaryOperation(float x) {\n        "+e+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Es="if (isnan(x)) return x;",Rs="return x;",Is="return abs(x);",ks=Es+"\n  return (x < 0.0) ? 0.0 : x;\n",Ss=Es+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",As="return (x >= 0.0) ? x : (exp(x) - 1.0);",Ds="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+bs+";\n  float scale = "+ws+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";var Ts="return -x;",Ns="return ceil(x);",Fs="return floor(x);",_s="return exp(x);",Os="return exp(x) - 1.0;",Ms=Es+"\n  return sin(x);\n",Bs=Es+"\n  return cos(x);\n",Ps=Es+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",Ls=Es+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",Ws=Es+"\n  return atan(x);\n",Us=Es+"return log(x + sqrt(x * x + 1.0));",Vs=Es+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",zs=Es+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",Gs="return x;",Hs="return x;",qs="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Ks="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",js="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Xs=function(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+e+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Ys=function(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;var e=t.length,n=sa("rc",e),r=wa(e),o=function(t,e){if(1===t)return"rc";for(var n="",r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),a=n.slice(-2),i=e<=1?"rc":"vec2("+a.join(",")+")";this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n        vec4 packedInput = getA("+o+");\n\n        setOutput(getChannel(packedInput, "+i+"));\n      }\n    "},$s={};function Qs(t,e){if(void 0===e&&(e=!1),"linear"===t)return e?Hs:Rs;if("relu"===t)return e?qs:ks;if("elu"===t)return e?js:As;if("relu6"===t)return e?Ks:Ss;if("prelu"===t)return e?Pa:Ma;throw new Error("Activation "+t+" has not been implemented for the WebGL backend.")}var Js=600;var Zs=function(t){function o(e){var n,r=t.call(this)||this;if(r.pendingRead=new WeakMap,r.pendingDisposal=new WeakSet,r.dataRefCount=new WeakMap,r.numBytesInGPU=0,r.uploadWaitMs=0,r.downloadWaitMs=0,r.warnedAboutMemory=!1,r.pendingDeletes=0,r.disposed=!1,!i().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){var o=jt(i().getNumber("WEBGL_VERSION"));r.binaryCache=(n=i().getNumber("WEBGL_VERSION"))in $s?$s[n]:($s[n]={},$s[n]),r.gpgpu=new Bi(o),r.canvas=o.canvas,r.gpgpuCreatedLocally=!0}else r.gpgpu=e,r.binaryCache={},r.gpgpuCreatedLocally=!1,r.canvas=e.gl.canvas;return r.textureManager=new ps(r.gpgpu),r.numMBBeforeWarning=null==i().global.screen?1024:i().global.screen.height*i().global.screen.width*window.devicePixelRatio*Js/1024/1024,r.texData=new xo(r,Lt),r}return e(o,t),o.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes},o.prototype.write=function(t,e,n){if(i().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:zt.UPLOAD}),r},o.prototype.move=function(t,e,n,r){if(i().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:zt.UPLOAD})},o.prototype.readSync=function(t){var e=this.texData.get(t),n=e.values,r=e.dtype,o=e.complexTensors,a=e.slice,i=e.shape,s=e.isPacked;if(null!=a){var u=void 0;u=s?new Xs(i,Gs):new Cs(i,Gs);var c=this.runWebGLProgram(u,[{dataId:t,shape:i,dtype:r}],r),l=this.readSync(c.dataId);return this.disposeData(c.dataId),l}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;var h,f,d=null!=this.activeTimers;(d&&(h=et()),"complex64"===r)?f=Vo(o.real.dataSync(),o.imag.dataSync()):f=this.getValuesFromTexture(t);return d&&(this.downloadWaitMs+=et()-h),this.convertAndCacheOnCPU(t,f)},o.prototype.read=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,s,u,c,l,h,f,d,p,v,m,g,y,x,b,w,C,E,R;return r(this,(function(r){switch(r.label){case 0:if(this.pendingRead.has(t))return e=this.pendingRead.get(t),[2,new Promise((function(t){return e.push(t)}))];if(n=this.texData.get(t),o=n.values,a=n.shape,s=n.slice,u=n.dtype,c=n.complexTensors,l=n.isPacked,null!=s)return h=void 0,h=l?new Xs(a,Gs):new Cs(a,Gs),f=this.runWebGLProgram(h,[{dataId:t,shape:a,dtype:u}],u),d=this.read(f.dataId),this.disposeData(f.dataId),[2,d];if(null!=o)return[2,this.convertAndCacheOnCPU(t)];if(!i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===i().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return p=null,"complex64"!==u&&i().get("WEBGL_BUFFER_SUPPORTED")&&(v=this.decode(t),m=this.texData.get(v.dataId),p=(R=this.gpgpu).createBufferFromTexture.apply(R,[m.texture].concat(Yt(a)))),this.pendingRead.set(t,[]),"complex64"===u?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:r.sent(),r.label=2;case 2:return"complex64"!==u?[3,4]:[4,Promise.all([c.real.data(),c.imag.data()])];case 3:return y=r.sent(),x=y[0],b=y[1],g=Vo(x,b),[3,5];case 4:null==p?g=this.getValuesFromTexture(t):(w=k(a),g=this.gpgpu.downloadFloat32MatrixFromBuffer(p,w)),r.label=5;case 5:return null!=v&&this.disposeData(v.dataId),C=this.convertAndCacheOnCPU(t,g),E=this.pendingRead.get(t),this.pendingRead.delete(t),E.forEach((function(t){return t(C)})),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),[2,C]}}))}))},o.prototype.checkNumericalProblems=function(t){if(null!=t)for(var e=0;e<t.length;e++){var n=t[e];if(!ee(n)){if(i().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+n+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+n+" cannot be represented on this device.")}}},o.prototype.getValuesFromTexture=function(t){var e,n=this.texData.get(t),r=n.shape,o=n.dtype,a=n.isPacked,s=k(r);if(i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var u=this.decode(t),c=this.texData.get(u.dataId),l=(e=this.gpgpu).downloadMatrixFromPackedTexture.apply(e,[c.texture].concat(Yt(r))).subarray(0,s);return this.disposeData(u.dataId),l}var h=i().getBool("WEBGL_PACK")&&!0===a,f=h?Te(r):r,d=h?new ci(f):new ui(f),p=this.runWebGLProgram(d,[{shape:f,dtype:o,dataId:t}],"float32"),v=this.texData.get(p.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture,v.texShape[0],v.texShape[1]).subarray(0,s);return this.disposeData(p.dataId),m},o.prototype.time=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,s,u,c;return r(this,(function(r){switch(r.label){case 0:return e=this.activeTimers,n=[],o=!1,null==this.programTimersStack?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t(),a=I(this.activeTimers.map((function(t){return t.query}))).filter((function(t){return null!=t})),s=I(this.activeTimers.map((function(t){return t.name}))).filter((function(t){return null!=t})),this.activeTimers=e,o&&(this.programTimersStack=null),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[4,Promise.all(a)]:[3,2];case 1:return c=r.sent(),u.kernelMs=w(c),u.getExtraProfileInfo=function(){return c.map((function(t,e){return{name:s[e],ms:t}})).map((function(t){return t.name+": "+t.ms})).join(", ")},[3,3];case 2:u.kernelMs={error:"WebGL query timers are not supported in this environment."},r.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}}))}))},o.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},o.prototype.startTimer=function(){return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:et(),endMs:null}},o.prototype.endTimer=function(t){return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=et(),t)},o.prototype.getQueryTime=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(t)]:[2,(e=t).endMs-e.startMs]}))}))},o.prototype.disposeData=function(t){if(!this.pendingDisposal.has(t)){if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(this.texData.has(t)){this.releaseGPUData(t);var e=this.texData.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}}},o.prototype.releaseGPUData=function(t){var e=this.texData.get(t),n=e.texture,r=e.dtype,o=e.texShape,a=e.usage,i=e.isPacked,s=e.slice,u=s&&s.origDataId||t,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=n&&(this.numBytesInGPU-=this.computeBytes(o,r),this.textureManager.releaseTexture(n,o,a,i)));var l=this.texData.get(t);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null},o.prototype.getTexture=function(t){return this.uploadToGPU(t),this.texData.get(t).texture},o.prototype.getDataInfo=function(t){return this.texData.get(t)},o.prototype.getCPUBackend=function(){return i().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Lt.findBackend("cpu")),this.cpuBackend):null},o.prototype.shouldExecuteOnCPU=function(t,e){var n=this;return void 0===e&&(e=128),null!=this.getCPUBackend()&&t.every((function(t){return null==n.texData.get(t.dataId).texture&&t.size<e}))},o.prototype.getGPGPUContext=function(){return this.gpgpu},o.prototype.complex=function(t,e){var n=this.makeOutput(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:Lt.keep(t.clone()),imag:Lt.keep(e.clone())},n},o.prototype.real=function(t){return this.texData.get(t.dataId).complexTensors.real.clone()},o.prototype.imag=function(t){return this.texData.get(t.dataId).complexTensors.imag.clone()},o.prototype.slice=function(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);if(0===k(n))return Fn([],n,t.dtype);var r=this.texData.get(t.dataId).isPacked,o=io(t.shape,e,n);if(r||!o){var a=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fs(n):new ls(n),s=a.getCustomSetupFunc(e);return this.compileAndRun(a,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)},o.prototype.shallowSlice=function(t,e,n){var r=this.texData.get(t.dataId),o=this.makeOutput(n,t.dtype),a=this.texData.get(o.dataId);Object.assign(a,r),a.shape=n,a.dtype=t.dtype;var i=so(e,t.strides);r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||t.dataId};var s=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,s+1),o},o.prototype.stridedSlice=function(t,e,n,r){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r);var o=ro(e,n,r);if(o.some((function(t){return 0===t})))return Fn([],o);var a=new ds(e,r,o);return this.compileAndRun(a,[t])},o.prototype.reverse=function(t,e){var n=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new is(t.shape,e):new as(t.shape,e);return this.compileAndRun(n,[t])},o.prototype.concat=function(t,e){if("complex64"===t[0].dtype){var n=t.map((function(t){return Tn(t)})),r=t.map((function(t){return Nn(t)}));return Dn(this.concat(n,e),this.concat(r,e))}if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>i().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var o=Math.floor(t.length/2),a=this.concat(t.slice(0,o),e),s=this.concat(t.slice(o),e);return this.concat([a,s],e)}if(i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){var u=new Ga(t.map((function(t){return t.shape})),e);return this.compileAndRun(u,t)}var c=Sn(t.map((function(t){return t.shape})),e),l=t.map((function(t){return t.as2D(-1,k(t.shape.slice(e)))})),h=new za(l.map((function(t){return t.shape})));return this.compileAndRun(h,l).reshape(c)},o.prototype.neg=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.neg(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Ts,t.dtype);var e=new Cs(t.shape,Ts);return this.compileAndRun(e,[t])},o.prototype.batchMatMul=function(t,e,n,r){var o=n?t.shape[2]:t.shape[1],a=r?e.shape[1]:e.shape[2],i=n?t.shape[1]:t.shape[2],s=t.shape[0];if((1===o||1===a)&&i>1e3){n&&(t=t.transpose([0,2,1])),r&&(e=e.transpose([0,2,1]));var u=1===a?t:t.as3D(s,i,1),c=1===a?2:1,l=1===a?e.as3D(s,1,i):e;return this.multiply(u,l).sum(c,!0)}var h=Dt(t.dtype,e.dtype),f=new Hi(t.shape,[s,o,a],n,r);return this.compileAndRun(f,[t,e],h)},o.prototype.fusedBatchMatMul=function(t){var e=t.a,n=t.b,r=t.transposeA,o=t.transposeB,a=t.bias,i=t.activation,s=t.preluActivationWeights,u=r?e.shape[2]:e.shape[1],c=o?n.shape[1]:n.shape[2],l=e.shape[0],h=Dt(e.dtype,n.dtype),f=null!=a,d=null!=s,p=i?Qs(i,!0):null,v=new Hi(e.shape,[l,u,c],r,o,f,p,d),m=[e,n];return a&&m.push(a),s&&m.push(s),this.compileAndRun(v,m,h)},o.prototype.multiply=function(t,e){if("complex64"===t.dtype){var n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),o=new Na(Da,t.shape,e.shape),a=new Na(Ta,t.shape,e.shape),s=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag),this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag)],u=this.compileAndRun(o,s),c=this.compileAndRun(a,s),l=this.complex(u,c);return u.dispose(),c.dispose(),l}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Oa,t.dtype);var h=new Ba(Oa,t.shape,e.shape);return this.compileAndRun(h,[t,e],t.dtype)},o.prototype.batchNormalization=function(t,e,n,r,o,a){var s=[t,e,n],u=null;null!=a&&(u=a.shape,s.push(a));var c=null;if(null!=o&&(c=o.shape,s.push(o)),i().getBool("WEBGL_PACK_NORMALIZATION")){var l=new Aa(t.shape,e.shape,n.shape,u,c,r);return this.compileAndRun(l,s)}var h=new Sa(t.shape,e.shape,n.shape,u,c,r);return this.compileAndRun(h,s)},o.prototype.localResponseNormalization4D=function(t,e,n,r,o){var a=i().getBool("WEBGL_PACK_NORMALIZATION")?new Vi(t.shape,e,n,r,o):new Wi(t.shape,e,n,r,o);return this.compileAndRun(a,[t])},o.prototype.LRNGrad=function(t,e,n,r,o,a,i){var s=new Ui(e.shape,r,o,a,i);return this.compileAndRun(s,[e,n,t])},o.prototype.tile=function(t,e){if("string"===t.dtype){var n=this.readSync(t.dataId).map((function(t){return ot(t)}));return ta(dr(t.shape,t.dtype,n),e)}var r=new gs(t.shape,e);return this.compileAndRun(r,[t])},o.prototype.pad=function(t,e,n){var r=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yi(t.shape,e,n):new Xi(t.shape,e,n);return this.compileAndRun(r,[t])},o.prototype.transpose=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.transpose(t,e);var n=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xs(t.shape,e):new ys(t.shape,e);return this.compileAndRun(n,[t])},o.prototype.gather=function(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);var r=new mi(t.shape,e.size,n);return this.compileAndRun(r,[t,e])},o.prototype.batchToSpaceND=function(t,e,n){C(t.rank<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"}));var r=e.reduce((function(t,e){return t*e})),o=zr(t.shape,e,r),a=Gr(o.length,e.length),i=Hr(t.shape,e,r),s=qr(n,e.length),u=Kr(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},o.prototype.spaceToBatchND=function(t,e,n){C(t.rank<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"}));var r=e.reduce((function(t,e){return t*e})),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=zr(i.shape,e,r,!1),u=Gr(s.length,e.length,!1),c=Hr(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(c)},o.prototype.reduce=function(t,e,n){var r=t.shape[0],o=t.shape[1],a=$r(o),i=new Ji({windowSize:a,inSize:o,batchSize:r},e),s=this.compileAndRun(i,[t],n);return 1===s.shape[1]?s:this.reduce(s,e,n)},o.prototype.argReduce=function(t,e,n){void 0===n&&(n=null);var r=t.shape[0],o=t.shape[1];null!=n&&(r=n.shape[0],o=n.shape[1]);var a=$r(o),i=new aa({windowSize:a,inSize:o,batchSize:r},e,null==n),s=[t];null!=n&&s.push(n);var u=this.compileAndRun(i,s,"int32");return 1===u.shape[1]?u:this.argReduce(t,e,u)},o.prototype.argReducePacked=function(t,e,n){void 0===n&&(n=null);var r=null!=n?n.shape:t.shape,o=$r(r[r.length-1]),a=new Ra(r,o,e,null==n),i=null==n?[t]:[t,n],s=this.compileAndRun(a,i,"int32");return s.rank===t.rank?this.argReducePacked(t,e,s):s},o.prototype.sum=function(t,e){Cn("sum",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o),i=Tt(t.dtype);return this.reduce(a,"sum",i).reshape(r)},o.prototype.prod=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o),i=Tt(t.dtype);return this.reduce(a,"prod",i).reshape(r)},o.prototype.unsortedSegmentSum=function(t,e,n){var r=0,o=En([r],t.rank),a=t;null!=o&&(a=t.transpose(o),r=In(1,t.rank)[0]);var i=function(t,e,n){for(var r=[],o=t.length,a=0;a<o;a++)a!==e?r.push(t[a]):r.push(n);return r}(a.shape,r,n),s=k([a.shape[r]]),u=a.as2D(-1,s),c=Tt(t.dtype),l=this.segOpCompute(u,"unsortedSegmentSum",e,c,n).reshape(i);return null!=o&&(l=l.transpose(Rn(o))),l},o.prototype.segOpCompute=function(t,e,n,r,o){var a=t.shape[0],i=t.shape[1],s=function(t,e){var n,r=!1;for(t<=Yr?(n=t,r=!0):n=Y(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=Y(t,n+1);return n}(i,o),u=new us({windowSize:s,inSize:i,batchSize:a,numSegments:o},e),c=this.compileAndRun(u,[t,n],r);return c.shape[1]===o?c:(n=Kn(0,o).tile([i/s]),this.segOpCompute(c,e,n,r,o))},o.prototype.argMinMaxReduce=function(t,e,n){var r=[e];if(Cn("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!i().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){var o=bn(t.shape,r),a=o[0],s=k(o[1]),u=t.as2D(-1,s);return this.argReduce(u,n).reshape(a)}return this.argReducePacked(t,n)},o.prototype.argMin=function(t,e){return this.argMinMaxReduce(t,e,"min")},o.prototype.argMax=function(t,e){return this.argMinMaxReduce(t,e,"max")},o.prototype.cumsum=function(t,e,n,r){if(e!==t.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(t.rank-1)+" but got axis="+e);var o=new ni(t.shape,n,r);return this.compileAndRun(o,[t])},o.prototype.equal=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");var n=new Ba("return float(a == b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.notEqual=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");var n=new Ba("return float(a != b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.less=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");var n=new Ba("return float(a < b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.lessEqual=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");var n=new Ba("return float(a <= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.greater=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");var n=new Ba("return float(a > b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.greaterEqual=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var n=new Ba("return float(a >= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.logicalNot=function(t){var e=new Cs(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])},o.prototype.logicalAnd=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var n=new Ba("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.logicalOr=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var n=new Ba("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.select=function(t,e,n){var r=new cs(t.rank,e.shape,e.rank);return this.compileAndRun(r,[t,e,n],Dt(e.dtype,n.dtype))},o.prototype.where=function(t){dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var e=t.dataSync();return na(t.shape,e)},o.prototype.topk=function(t,e,n){return ea(t.dataSync(),t.shape,t.dtype,e)},o.prototype.min=function(t,e){Cn("min",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(r)},o.prototype.minimum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.mod=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.max=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.max(t,e);Cn("max",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"max",a.dtype).reshape(r)},o.prototype.maximum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.all=function(t,e){Cn("all",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(r)},o.prototype.any=function(t,e){Cn("any",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(r)},o.prototype.realDivide=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS")){return this.packedBinaryOp(t,e,"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n","float32",!0)}var n=new Ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape);return this.compileAndRun(n,[t,e],"float32")},o.prototype.floorDiv=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var n=new Ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape);return this.compileAndRun(n,[t,e],"int32")},o.prototype.add=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Fa);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);var n=Dt(t.dtype,e.dtype);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Fa,n);var r=new Ba(Fa,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)},o.prototype.packedUnaryOp=function(t,e,n){var r=new Xs(t.shape,e);return this.compileAndRun(r,[t],n)},o.prototype.packedBinaryOp=function(t,e,n,r,o){void 0===o&&(o=!1);var a=new La(n,t.shape,e.shape,o);return this.compileAndRun(a,[t,e],r)},o.prototype.complexSeparableBinaryOp=function(t,e,n){var r=this,o=this.texData.get(t.dataId),a=this.texData.get(e.dataId),i=[[o.complexTensors.real,a.complexTensors.real],[o.complexTensors.imag,a.complexTensors.imag]].map((function(o){var a=o[0],i=o[1],s=r.makeComplexComponentTensorInfo(t,a),u=r.makeComplexComponentTensorInfo(e,i),c=new Ba(n,t.shape,e.shape);return r.compileAndRun(c,[s,u],Dt(a.dtype,i.dtype))})),s=i[0],u=i[1],c=this.complex(s,u);return s.dispose(),u.dispose(),c},o.prototype.makeComplexComponentTensorInfo=function(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}},o.prototype.addN=function(t){if(1===t.length)return t[0];if(t.length>i().get("WEBGL_MAX_TEXTURES_IN_SHADER")){var e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}var o=t.map((function(t){return t.dtype})).reduce((function(t,e){return Dt(t,e)})),a=t.map((function(t){return t.shape})),s=i().getBool("WEBGL_PACK")?new oa(t[0].shape,a):new ra(t[0].shape,a);return this.compileAndRun(s,t,o)},o.prototype.subtract=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,_a);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);var n=Dt(t.dtype,e.dtype);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,_a,t.dtype);var r=new Ba(_a,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)},o.prototype.pow=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),r=Dt(t.dtype,e.dtype);return this.compileAndRun(n,[t,e],r)},o.prototype.ceil=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.ceil(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Ns,t.dtype);var e=new Cs(t.shape,Ns);return this.compileAndRun(e,[t])},o.prototype.floor=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.floor(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Fs,t.dtype);var e=new Cs(t.shape,Fs);return this.compileAndRun(e,[t])},o.prototype.sign=function(t){var e=new Cs(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])},o.prototype.isNaN=function(t){var e=new Cs(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")},o.prototype.isInf=function(t){var e=new Cs(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")},o.prototype.isFinite=function(t){var e=new Cs(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")},o.prototype.round=function(t){var e=new Cs(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])},o.prototype.exp=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.exp(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,_s,t.dtype);var e=new Cs(t.shape,_s);return this.compileAndRun(e,[t])},o.prototype.expm1=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.expm1(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Os,t.dtype);var e=new Cs(t.shape,Os);return this.compileAndRun(e,[t])},o.prototype.softmax=function(t,e){var n=O([e],t.shape),r=this.max(t,n),o=wn(r.shape,n),a=this.subtract(t,r.reshape(o)),i=this.exp(a),s=this.sum(i,n).reshape(o);return this.realDivide(i,s)},o.prototype.log=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.log(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);var e=new Cs(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])},o.prototype.log1p=function(t){var e=new Cs(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])},o.prototype.sqrt=function(t){var e=new Cs(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])},o.prototype.rsqrt=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);var e=new Cs(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])},o.prototype.reciprocal=function(t){var e=new Cs(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])},o.prototype.relu=function(t){var e;return e=i().getBool("WEBGL_PACK")?new Xs(t.shape,qs):new Cs(t.shape,ks),this.compileAndRun(e,[t])},o.prototype.relu6=function(t){var e;return e=i().getBool("WEBGL_PACK")?new Xs(t.shape,Ks):new Cs(t.shape,Ss),this.compileAndRun(e,[t])},o.prototype.prelu=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La(Pa,t.shape,e.shape):new Ba(Ma,t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.elu=function(t){if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,js,t.dtype);var e=new Cs(t.shape,As);return this.compileAndRun(e,[t])},o.prototype.eluDer=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new Ba("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.selu=function(t){var e=new Cs(t.shape,Ds);return this.compileAndRun(e,[t])},o.prototype.int=function(t){var e=new Cs(t.shape,"return float(int(x));");return this.compileAndRun(e,[t],"int32")},o.prototype.clip=function(t,e,n){var r,o=(r=i().getBool("WEBGL_PACK_CLIP")?new Ua(t.shape):new Wa(t.shape)).getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,o)},o.prototype.abs=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.abs(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Is,t.dtype);var e=new Cs(t.shape,Is);return this.compileAndRun(e,[t])},o.prototype.complexAbs=function(t){var e=this.texData.get(t.dataId),n=new Va(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensors.real),this.makeComplexComponentTensorInfo(t,e.complexTensors.imag)];return this.compileAndRun(n,r)},o.prototype.sigmoid=function(t){var e=new Cs(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])},o.prototype.softplus=function(t){var e=new Cs(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])},o.prototype.sin=function(t){var e=new Cs(t.shape,Ms);return this.compileAndRun(e,[t])},o.prototype.cos=function(t){var e=new Cs(t.shape,Bs);return this.compileAndRun(e,[t])},o.prototype.tan=function(t){var e=new Cs(t.shape,"return tan(x);");return this.compileAndRun(e,[t])},o.prototype.asin=function(t){var e=new Cs(t.shape,Ps);return this.compileAndRun(e,[t])},o.prototype.acos=function(t){var e=new Cs(t.shape,Ls);return this.compileAndRun(e,[t])},o.prototype.atan=function(t){var e=new Cs(t.shape,Ws);return this.compileAndRun(e,[t])},o.prototype.atan2=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.sinh=function(t){var e=new Cs(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},o.prototype.cosh=function(t){var e=new Cs(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},o.prototype.tanh=function(t){var e=new Cs(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])},o.prototype.asinh=function(t){var e=new Cs(t.shape,Us);return this.compileAndRun(e,[t])},o.prototype.acosh=function(t){var e=new Cs(t.shape,Vs);return this.compileAndRun(e,[t])},o.prototype.atanh=function(t){var e=new Cs(t.shape,zs);return this.compileAndRun(e,[t])},o.prototype.erf=function(t){var e=new Cs(t.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');return this.compileAndRun(e,[t])},o.prototype.step=function(t,e){var n=new Cs(t.shape,function(t){return void 0===t&&(t=0),Es+"\n    return x > 0.0 ? 1.0 : float("+t+");\n  "}(e));return this.compileAndRun(n,[t])},o.prototype.conv2dByMatMul=function(t,e,n,r,o,a){var s=t.shape,u=this.texData.get(t.dataId),c=n.inChannels,l=s[0]*s[1]*s[2],h=n.outChannels,f="channelsLast"===n.dataFormat,d=(1===l||1===h)&&c>1e3,p=s[2]%2!=0&&!!u.isPacked;if(d||!i().getBool("WEBGL_LAZILY_UNPACK")||!i().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!p){var v=f?s[0]*s[1]*s[2]:s[0]*s[2]*s[3],m=this.reshape(t,[1,v,n.inChannels]),g=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.fusedBatchMatMul({a:m,b:g,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a}),n.outShape)}var y=f?s[0]*s[1]*(s[2]+1):s[0]*s[2]*(s[3]+1),x={dataId:t.dataId,shape:[1,y,n.inChannels],dtype:t.dtype},b=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,C(_e(u.shape,x.shape),(function(){return"packed reshape "+u.shape+" to "+x.shape+" isn't free"}));var w=this.reshape(e,[1,n.inChannels,n.outChannels]),E=this.fusedBatchMatMul({a:x,b:w,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a}),R=this.texData.get(E.dataId);return C(R.isPacked,(function(){return"batchMatMul result is expected to be packed"})),u.shape=b,R.shape=n.outShape,Lt.makeTensorFromDataId(E.dataId,n.outShape,E.dtype)},o.prototype.conv2dWithIm2Row=function(t,e,n,r,o,a){var i=n.filterWidth,s=n.filterHeight,u=n.inChannels,c=n.outWidth,l=n.outHeight,h="channelsLast"===n.dataFormat,f=i*s*u,d=l*c,p=[f,d],v=t.squeeze([0]),m=e.reshape([1,f,-1]),g=new Li(p,v.shape,n),y=this.compileAndRun(g,[v]).reshape([1,p[0],p[1]]),x=null!=r,b=null!=a,w=o?Qs(o,!0):null,C=new Hi(y.shape,[1,d,n.outChannels],!0,!1,x,w,b),E=[y,m];r&&E.push(r),b&&E.push(a);var R=this.compileAndRun(C,E);return h?R.reshape([1,l,c,n.outChannels]):R.reshape([1,n.outChannels,l,c])},o.prototype.fusedConv2d=function(t){var e=t.input,n=t.filter,r=t.convInfo,o=t.bias,a=t.activation,s=t.preluActivationWeights;if(1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type))return this.conv2dByMatMul(e,n,r,o,a,s);if(i().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,n,r,o,a,s);var u=null!=o,c=null!=s,l=a?Qs(a,!1):null,h=new Qa(r,u,l,c),f=[e,n];return o&&f.push(o),s&&f.push(s),this.compileAndRun(h,f)},o.prototype.conv2d=function(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(i().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);var r=new Qa(n);return this.compileAndRun(r,[t,e])},o.prototype.conv2dDerInput=function(t,e,n){var r=new Ka(n);return this.compileAndRun(r,[t,e])},o.prototype.conv2dDerFilter=function(t,e,n){var r=new qa(n);return this.compileAndRun(r,[t,e])},o.prototype.fusedDepthwiseConv2D=function(t){var e,n=t.input,r=t.filter,o=t.convInfo,a=t.bias,s=t.activation,u=t.preluActivationWeights,c=i().getBool("WEBGL_PACK_DEPTHWISECONV")&&o.strideWidth<=2&&o.outChannels/o.inChannels==1,l=s?Qs(s,c):null,h=[n,r],f=null!=a,d=null!=u;return f&&h.push(a),d&&h.push(u),c?(e=new ti(o,f,l,d),this.compileAndRun(e,h)):(e=new Za(o,f,l,d),this.compileAndRun(e,h))},o.prototype.depthwiseConv2D=function(t,e,n){var r;return i().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new ti(n),this.compileAndRun(r,[t,e])):(r=new Za(n),this.compileAndRun(r,[t,e]))},o.prototype.depthwiseConv2DDerInput=function(t,e,n){var r=new $a(n);return this.compileAndRun(r,[t,e])},o.prototype.depthwiseConv2DDerFilter=function(t,e,n){var r=new Ya(n);return this.compileAndRun(r,[t,e])},o.prototype.conv3d=function(t,e,n){var r=new Ja(n);return this.compileAndRun(r,[t,e])},o.prototype.conv3dDerInput=function(t,e,n){var r=new Xa(n);return this.compileAndRun(r,[t,e])},o.prototype.conv3dDerFilter=function(t,e,n){var r=new ja(n);return this.compileAndRun(r,[t,e])},o.prototype.maxPool=function(t,e){var n=new $i(e,"max",!1);return this.compileAndRun(n,[t])},o.prototype.avgPool=function(t,e){var n=new $i(e,"avg",!1);return this.compileAndRun(n,[t],"float32")},o.prototype.maxPoolBackprop=function(t,e,n,r){var o=new $i(r,"max",!0),a=this.compileAndRun(o,[e]),i=new zi(r),s=this.compileAndRun(i,[t,a],e.dtype);return a.dispose(),s},o.prototype.avgPoolBackprop=function(t,e,n){var r=new Ia(n);return this.compileAndRun(r,[t],e.dtype)},o.prototype.cast=function(t,e){return Po(t,e,this)},o.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},o.prototype.avgPool3d=function(t,e){var n=new Qi(e,"avg",!1);return this.compileAndRun(n,[t],"float32")},o.prototype.avgPool3dBackprop=function(t,e,n){var r=new ka(n);return this.compileAndRun(r,[t],e.dtype)},o.prototype.maxPool3d=function(t,e){var n=new Qi(e,"max",!1);return this.compileAndRun(n,[t],"float32")},o.prototype.maxPool3dBackprop=function(t,e,n,r){var o=new Qi(r,"max",!0),a=this.compileAndRun(o,[e]),i=new Gi(r),s=this.compileAndRun(i,[t,a],e.dtype);return a.dispose(),s},o.prototype.reshape=function(t,e){var n=this.texData.get(t.dataId);if(n.isPacked&&!_e(t.shape,e)&&(null===n.texture||!_e(n.shape,e))){var r=this.packedReshape(t,e);return Lt.makeTensorFromDataId(r.dataId,r.shape,r.dtype)}return Lo(t,e)},o.prototype.resizeBilinear=function(t,e,n,r){var o=i().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ns(t.shape,e,n,r):new es(t.shape,e,n,r);return this.compileAndRun(o,[t],"float32")},o.prototype.resizeBilinearBackprop=function(t,e,n){var r=new ts(t,e,n);return this.compileAndRun(r,[t])},o.prototype.resizeNearestNeighbor=function(t,e,n,r){var o=new os(t.shape,e,n,r);return this.compileAndRun(o,[t])},o.prototype.resizeNearestNeighborBackprop=function(t,e,n){var r=new rs(t,e,n);return this.compileAndRun(r,[t])},o.prototype.multinomial=function(t,e,n,r){var o=e?t:go(t),a=o.shape[0],i=o.shape[1],s=new qi(a,i,n),u=s.getCustomSetupFunc(r);return this.compileAndRun(s,[o],"int32",u)},o.prototype.oneHot=function(t,e,n,r){var o=new Ki(t.size,e,n,r);return this.compileAndRun(o,[t])},o.prototype.diag=function(t){var e=new si(t.size);return this.compileAndRun(e,[t])},o.prototype.nonMaxSuppression=function(t,e,n,r,o){return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),jo(t.dataSync(),e.dataSync(),n,r,o)},o.prototype.cropAndResize=function(t,e,n,r,o,a){var i=new ei(t.shape,e.shape,r,o,a);return this.compileAndRun(i,[t,e,n],"float32")},o.prototype.depthToSpace=function(t,e,n){C(e>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+e}));var r=t.shape[0],o="NHWC"===n?t.shape[1]:t.shape[2],a="NHWC"===n?t.shape[2]:t.shape[3],i="NHWC"===n?t.shape[3]:t.shape[1],s=o*e,u=a*e,c=i/(e*e),l=new ii("NHWC"===n?[r,s,u,c]:[r,c,s,u],e,n);return this.compileAndRun(l,[t])},o.prototype.split=function(t,e,n){return Zo(t,e,n)},o.prototype.scatterND=function(t,e,n){var r=Zr(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,c=[u/i,i],l=t.reshape([a,o]),h=e.reshape([a,i]);if(0===u)return Lo(Fn([]),n);var f=On(0),d=new ss(a,o,l.rank,h.rank,s,c);return this.compileAndRun(d,[h,l,f]).reshape(n)},o.prototype.sparseToDense=function(t,e,n,r){var o=Zr(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.strides,u=o.outputSize,c=new ss(i,a,t.rank,e.rank,s,[u,1],!1);return this.compileAndRun(c,[e,t,r]).reshape(n)},o.prototype.fft=function(t){return this.fftImpl(t,!1)},o.prototype.ifft=function(t){return this.fftImpl(t,!0)},o.prototype.fftImpl=function(t,e){var n=this.texData.get(t.dataId),r=new pi(fi,t.shape,e),o=new pi(di,t.shape,e),a=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag)],i=this.compileAndRun(r,a),s=this.compileAndRun(o,a),u=this.complex(i,s).as2D(t.shape[0],t.shape[1]);return i.dispose(),s.dispose(),u},o.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=jr(t,e),a=o[0],i=o[1],s=o[2],u=o[3],c=e.reshape([i,r]),l=t.reshape([t.size/s,s]),h=new gi(r,u,[i,s]);return this.compileAndRun(h,[l,c]).reshape(a)},o.prototype.fill=function(t,e,n){if("string"===(n=n||j(e))){var r=P(n,k(t));return r.fill(e),Lt.makeTensor(r,t,n,this)}var o=new vi(t,e),a=o.getCustomSetupFunc(e);return this.compileAndRun(o,[],n,a)},o.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)},o.prototype.zerosLike=function(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)},o.prototype.linspace=function(t,e,n){return Wo(t,e,n)},o.prototype.makeTensorInfo=function(t,e){var n=this.write(null,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}},o.prototype.makeOutput=function(t,e){var n=this.makeTensorInfo(t,e).dataId;return Lt.makeTensorFromDataId(n,t,e,this)},o.prototype.unpackTensor=function(t){var e=new Ys(t.shape);return this.runWebGLProgram(e,[t],t.dtype)},o.prototype.packTensor=function(t){var e=new ji(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)},o.prototype.packedReshape=function(t,e){var n=[Ae(t.shape)].concat(De(t.shape)),r={dtype:t.dtype,shape:n,dataId:t.dataId},o=[Ae(e)].concat(De(e)),a=new Zi(o,n),i=this.runWebGLProgram(a,[r],t.dtype,null,!0);return{dataId:i.dataId,shape:e,dtype:i.dtype}},o.prototype.decode=function(t){var e,n=this.texData.get(t),r=n.isPacked,o=n.shape,a=n.dtype,i=Te(o);e=r?new ai(i):new oi(i);return{dtype:a,shape:o,dataId:this.runWebGLProgram(e,[{shape:i,dtype:a,dataId:t}],a,null,!0).dataId}},o.prototype.runWebGLProgram=function(t,e,n,r,o){var a=this;void 0===o&&(o=!1);var s=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(s.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===Vt.DENSE){var c=Yt(t.outputShape);u.texShape=c.map((function(t){return 2*t}))}if(null!=t.outTexUsage&&(u.usage=t.outTexUsage),0===k(s.shape))return u.values=B(s.dtype,0),s;var l=[],h=e.map((function(e){if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var n=a.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&k(e.shape)<=i().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?a.unpackTensor(e):a.packTensor(e),l.push(e),n=a.texData.get(e.dataId);else if(n.isPacked&&!_e(n.shape,e.shape)){var r=e,o=e.shape;e.shape=n.shape,e=a.packedReshape(e,o),l.push(e),n=a.texData.get(e.dataId),r.shape=o}return a.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);var f,d={shape:s.shape,texData:u,isUniform:!1},p=function(t,e,n){var r="";e.concat(n).forEach((function(t){var e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;r+=t.shape+"_"+n+"_"+e}));var o=t.userCode,a=t.constructor.name;return a+="_"+r+"_"+o}(t,h,d),v=this.getAndSaveBinary(p,(function(){return function(t,e,n,r){var o=e.userCode,a=n.map((function(t,n){var r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),s=a.map((function(t){return t.shapeInfo})),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},c=fa(a,u,o,e.packedInputs),l=t.createProgram(c),h=null,f=t.getUniformLocation(l,"NAN",!1);1===i().getNumber("WEBGL_VERSION")&&(h=t.getUniformLocation(l,"INFINITY",!1));for(var d={},p=0;p<e.variableNames.length;p++){var v=e.variableNames[p];d[v]=t.getUniformLocation(l,v,!1),d["offset"+v]=t.getUniformLocation(l,"offset"+v,!1)}return{program:e,source:c,webGLProgram:l,uniformLocations:d,inShapeInfos:s,outShapeInfo:u,infLoc:h,nanLoc:f}}(a.gpgpu,t,h,d)})),m=null!=this.activeTimers;if(m&&(f=this.startTimer()),function(t,e,n,r,o){Pi(e.inShapeInfos,n),Pi([e.outShapeInfo],[r]);var a=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(a,s[0],s[1]):t.setOutputMatrixTexture(a,s[0],s[1]),t.setProgram(e.webGLProgram),1===i().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((function(n,r){var o=e.program.variableNames[r],a=e.uniformLocations[o],i=e.uniformLocations["offset"+o];if(null!=a)if(n.isUniform)if(k(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{var s=n.uniformValues;s instanceof Float32Array||(s=new Float32Array(s)),t.gl.uniform1fv(a,s)}else null!=n.texData.slice&&null!=i&&t.gl.uniform1i(i,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)})),null!=o&&o(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,v,h,d,r),l.forEach((function(t){return a.disposeData(t.dataId)})),m&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)})),!i().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===o){var g=this.unpackTensor(s);return this.disposeData(s.dataId),g}return s},o.prototype.compileAndRun=function(t,e,n,r,o){void 0===o&&(o=!1),n=n||e[0].dtype;var a=this.runWebGLProgram(t,e,n,r,o);return Lt.makeTensorFromDataId(a.dataId,a.shape,a.dtype)},o.prototype.getAndSaveBinary=function(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]},o.prototype.getTextureManager=function(){return this.textureManager},o.prototype.dispose=function(){var t=this;if(!this.disposed){if(!i().getBool("IS_TEST"))Object.keys(this.binaryCache).forEach((function(e){t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram),delete t.binaryCache[e]}));this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}},o.prototype.floatPrecision=function(){var t=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Ze((function(){if(!i().get("WEBGL_RENDER_FLOAT32_ENABLED")){var e=i().getBool("DEBUG");i().set("DEBUG",!1);var n=t.abs(On(1e-8)).dataSync()[0];if(i().set("DEBUG",e),n>0)return 32}return 16}))),this.floatPrecisionValue},o.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},o.prototype.uploadToGPU=function(t){var e,n=this.texData.get(t),r=n.shape,o=n.dtype,a=n.values,i=n.texture,s=n.usage,u=n.isPacked;if(null==i){var c,l=null!=this.activeTimers;l&&(c=et());var h=n.texShape;if(null==h&&(h=Ne(r,u),n.texShape=h),null!=a){var f=Te(r),d=void 0,p=h[1],v=h[0],m=a instanceof Uint8Array;u?(p=(e=$t(h[0],h[1]))[0],v=e[1],d=new hi(f,[v,p],m)):d=new li(f,[v,p],m);var g=this.makeTensorInfo([v,p],o);this.texData.get(g.dataId).usage=m?zt.PIXELS:zt.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),p,v,a);var y=this.runWebGLProgram(d,[g],o,null,!0),x=this.texData.get(y.dataId);n.texture=x.texture,n.texShape=x.texShape,n.isPacked=x.isPacked,n.usage=x.usage,this.disposeData(g.dataId),this.texData.delete(y.dataId),n.values=null,l&&(this.uploadWaitMs+=et()-c)}else{var b=this.acquireTexture(h,s,o,u);n.texture=b}}},o.prototype.convertAndCacheOnCPU=function(t,e){var n=this.texData.get(t),r=n.dtype;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){for(var n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length),r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values},o.prototype.acquireTexture=function(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+o+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)},o.prototype.computeBytes=function(t,e){return t[0]*t[1]*z(e)},o}(bo);Wt()&&Lt.registerBackend("webgl",(function(){return new Zs}),2);var tu=An({square_:function(t){var e=mn(t,"x","square"),n=[e];return Lt.runKernelFunc((function(t,n){return n([e]),t.square(e)}),{x:e},null,"Square",{},n,[])}}),eu="SquaredDifference";var nu=An({squaredDifference_:function(t,e){var n,r=mn(t,"a","squaredDifference"),o=mn(e,"b","squaredDifference");n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape);var a={a:r,b:o},i=[r,o];return Lt.runKernelFunc((function(t,e){var n=t.squaredDifference(r,o);return e([r,o]),n}),a,(function(t,e){var n=e[0],r=e[1],o=On(2);return{a:function(){return t.mul(n.sub(r).mul(o))},b:function(){return t.mul(r.sub(n).mul(o))}}}),eu,{},i,[])}});var ru=An({abs_:function(t){var e=mn(t,"x","abs");return"complex64"===e.dtype?Lt.runKernelFunc((function(t){return t.complexAbs(e)}),{$x:e}):Lt.runKernelFunc((function(t,n){var r=t.abs(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.mul(n.toFloat().step(-1))}}}),"Abs")}}),ou=An({acos_:function(t){var e=mn(t,"x","acos");return Lt.runKernelFunc((function(t,n){var r=t.acos(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(On(1).sub(n.toFloat().square()).sqrt()).neg()}}}))}}),au=An({acosh_:function(t){var e=mn(t,"x","acosh");return Lt.runKernelFunc((function(t,n){var r=t.acosh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(n.toFloat().square().sub(1).sqrt())}}}))}}),iu=An({asin_:function(t){var e=mn(t,"x","asin");return Lt.runKernelFunc((function(t,n){var r=t.asin(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(On(1).sub(n.toFloat().square()).sqrt())}}}))}}),su=An({asinh_:function(t){var e=mn(t,"x","asinh");return Lt.runKernelFunc((function(t,n){var r=t.asinh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(On(1).add(n.toFloat().square()).sqrt())}}}))}}),uu=An({atan_:function(t){var e=mn(t,"x","atan");return Lt.runKernelFunc((function(t,n){var r=t.atan(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().square().add(1))}}}))}}),cu=An({atanh_:function(t){var e=mn(t,"x","atanh");return Lt.runKernelFunc((function(t,n){var r=t.atanh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(On(1).sub(n.toFloat().square()))}}}))}}),lu=An({ceil_:function(t){var e=mn(t,"x","ceil");return Lt.runKernelFunc((function(t){return t.ceil(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),hu=An({clipByValue_:function(t,e,n){var r=mn(t,"x","clipByValue");C(e<=n,(function(){return"Error in clip: min ("+e+") must be less than or equal to max ("+n+")."}));var o=[r],a={min:e,max:n};return Lt.runKernelFunc((function(t,o){var a=t.clip(r,e,n);return o([r]),a}),{x:r},(function(t,r){var o=r[0];return{x:function(){return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)),Xn(t))}}}),"ClipByValue",a,o)}}),fu=An({cos_:function(t){var e=mn(t,"x","cos"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.cos(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return n.toFloat().sin().neg().mul(t)}}}),"Cos",{},n)}}),du=An({cosh_:function(t){var e=mn(t,"x","cosh");return Lt.runKernelFunc((function(t,n){var r=t.cosh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sinh().mulStrict(t)}}}))}}),pu=An({erf_:function(t){var e=mn(t,"x","erf");return C("int32"===e.dtype||"float32"===e.dtype,(function(){return"Input dtype must be `int32` or `float32`."})),"int32"===e.dtype&&(e=e.toFloat()),Lt.runKernelFunc((function(t,n){var r=t.erf(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}}))}}),vu=An({exp_:function(t){var e=mn(t,"x","exp");return Lt.runKernelFunc((function(t,n){var r=t.exp(e);return n([r]),r}),{x:e},(function(t,e){return{x:function(){return t.mulStrict(e[0])}}}),"Exp",{},[],[!0])}}),mu=An({expm1_:function(t){var e=mn(t,"x","expm1");return Lt.runKernelFunc((function(t,n){var r=t.expm1(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.exp())}}}))}}),gu=An({floor_:function(t){var e=mn(t,"x","floor");return Lt.runKernelFunc((function(t){return t.floor(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),yu=An({log_:function(t){var e=mn(t,"x","log"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.log(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.div(n.toFloat())}}}),"Log",{},n)}}),xu=An({log1p_:function(t){var e=mn(t,"x","log1p");return Lt.runKernelFunc((function(t,n){var r=t.log1p(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.add(1))}}}))}}),bu=An({logSigmoid_:function(t){var e=mn(t,"x","logSigmoid");return Lt.runKernelFunc((function(t,n){var r=t.softplus(e.neg()).neg();return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.neg().sigmoid())}}}))}}),wu=An({neg_:function(t){var e=mn(t,"x","neg"),n=[e];return Lt.runKernelFunc((function(t){return t.neg(e)}),{x:e},(function(t){return{x:function(){return t.neg()}}}),"Neg",{},n)}}),Cu=An({reciprocal_:function(t){var e=mn(t,"x","reciprocal");return Lt.runKernelFunc((function(t,n){var r=t.reciprocal(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.square().neg())}}}))}}),Eu=An({round_:function(t){var e=mn(t,"x","round");return Lt.runKernelFunc((function(t){return t.round(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Ru=An({rsqrt_:function(t){var e=mn(t,"x","rsqrt"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.rsqrt(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.div(n.pow(1.5).mul(2)).neg()}}}),"Rsqrt",{},n)}}),Iu=An({sigmoid_:function(t){var e=mn(t,"x","sigmoid");return Lt.runKernelFunc((function(t,n){var r=t.sigmoid(e);return n([r]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.mul(n.mul(On(1).sub(n)))}}}),"Sigmoid")}}),ku=An({sign_:function(t){var e=mn(t,"x","sign");return Lt.runKernelFunc((function(t){return t.sign(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Su=An({isNaN_:function(t){var e=mn(t,"x","isNaN");return Lt.runKernelFunc((function(t){return t.isNaN(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Au=An({isInf_:function(t){var e=mn(t,"x","isInf");return Lt.runKernelFunc((function(t){return t.isInf(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Du=An({isFinite_:function(t){var e=mn(t,"x","isFinite");return Lt.runKernelFunc((function(t){return t.isFinite(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Tu=An({sin_:function(t){var e=mn(t,"x","sin"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.sin(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return n.toFloat().cos().mul(t)}}}),"Sin",{},n)}}),Nu=An({sinh_:function(t){var e=mn(t,"x","sinh");return Lt.runKernelFunc((function(t,n){var r=t.sinh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cosh().mulStrict(t)}}}))}}),Fu=An({softplus_:function(t){var e=mn(t,"x","softplus");return Lt.runKernelFunc((function(t,n){var r=t.softplus(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.sigmoid())}}}))}}),_u=An({sqrt_:function(t){var e=mn(t,"x","sqrt");return Lt.runKernelFunc((function(t,n){var r=t.sqrt(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().sqrt().mul(2))}}}))}}),Ou=An({step_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","step");return Lt.runKernelFunc((function(t){return t.step(n,e)}),{$x:n},(function(t){return{$x:function(){return Xn(t)}}}))}}),Mu=An({tan_:function(t){var e=mn(t,"x","tan");return Lt.runKernelFunc((function(t,n){var r=t.tan(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.cos().square())}}}))}}),Bu=An({tanh_:function(t){var e=mn(t,"x","tanh");return Lt.runKernelFunc((function(t,n){var r=t.tanh(e);return n([r]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return On(1).sub(n.square()).mulStrict(t)}}}),"Tanh",{},null,[!0])}});function Pu(t,e,n,r,o,a){var i,s,u=mn(t,"x","batchNorm"),c=mn(e,"mean","batchNorm"),l=mn(n,"variance","batchNorm");return null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(2===u.rank,(function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."})),C(2===c.rank||1===c.rank,(function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+c.rank+"."})),C(2===l.rank||1===l.rank,(function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+l.rank+"."})),null!=i&&C(2===i.rank||1===i.rank,(function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+i.rank+"."})),null!=s&&C(2===s.rank||1===s.rank,(function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+s.rank+"."})),Uu(u,c,l,s,i,a)}function Lu(t,e,n,r,o,a){var i,s,u=mn(t,"x","batchNorm"),c=mn(e,"mean","batchNorm"),l=mn(n,"variance","batchNorm");return null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(3===u.rank,(function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."})),C(3===c.rank||1===c.rank,(function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+c.rank+"."})),C(3===l.rank||1===l.rank,(function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+l.rank+"."})),null!=i&&C(3===i.rank||1===i.rank,(function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+i.rank+"."})),null!=s&&C(3===s.rank||1===s.rank,(function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+s.rank+"."})),Uu(u,c,l,s,i,a)}function Wu(t,e,n,r,o,a){var i,s,u=mn(t,"x","batchNorm"),c=mn(e,"mean","batchNorm"),l=mn(n,"variance","batchNorm");return null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(4===u.rank,(function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+u.rank+"."})),C(4===c.rank||1===c.rank,(function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+c.rank+"."})),C(4===l.rank||1===l.rank,(function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+l.rank+"."})),null!=i&&C(4===i.rank||1===i.rank,(function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+i.rank+"."})),null!=s&&C(4===s.rank||1===s.rank,(function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+s.rank+"."})),Uu(u,c,l,s,i,a)}function Uu(t,e,n,r,o,a){null==a&&(a=.001);var i,s,u,c=mn(t,"x","batchNorm"),l=mn(e,"mean","batchNorm"),h=mn(n,"variance","batchNorm");null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(l.rank===h.rank,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),C(null==s||l.rank===s.rank,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),C(null==i||l.rank===i.rank,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."})),u=0===c.rank||1===c.rank?c.as4D(1,1,1,c.size):2===c.rank?c.as4D(1,1,c.shape[0],c.shape[1]):3===c.rank?c.as4D(1,c.shape[0],c.shape[1],c.shape[2]):c;var f=[c,l,h,i];return Lt.runKernelFunc((function(t,e){var n=t.batchNormalization(u,Vu(l),Vu(h),a,Vu(i),Vu(s));return e([c,l,h,i]),n}),{x:c,mean:l,variance:h,scale:i,offset:s},(function(t,e){var n=e,r=n[0],o=n[1],i=n[2],s=n[3],c=null==s?On(1):s,l=Eo(o.shape,u.shape),h=[];if(1===o.rank){for(var f=0;f<u.shape.length-1;++f)h.push(u.shape[f]);h.push(1)}var d=r.sub(o),p=t.mul(c),v=Ru(i.add(On(a))),m=v.mul(v).mul(v).mul(On(-.5));return{x:function(){return 1===o.rank?t.mul(Lr(v.as4D(1,1,1,o.shape[0]),h)).mul(c).reshape(r.shape):t.mul(v).mul(c).reshape(r.shape)},mean:function(){var t=v.mul(On(-1)).mul(p);return 1===o.rank&&(t=t.sum(l)),t.reshape(o.shape)},variance:function(){var t=m.mul(d).mul(p);return 1===o.rank&&(t=t.sum(l)),t.reshape(o.shape)},scale:function(){var e=d.mul(v),n=t.mul(e);return 1===o.rank&&(n=n.sum(l)),n.reshape(o.shape)},offset:function(){var e=t;return 1===o.rank&&(e=e.sum(l)),e.reshape(o.shape)}}}),"BatchNormalization",{varianceEpsilon:a},f).reshape(c.shape)}function Vu(t){return null==t?null:0===t.rank?t.as1D():1===t.rank?t:2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t}function zu(){Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var Gu=An({batchNormalization2d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Pu(t,e,n,a,o,r)}}),Hu=An({batchNormalization3d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Lu(t,e,n,a,o,r)}}),qu=An({batchNormalization4d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Wu(t,e,n,a,o,r)}}),Ku=An({batchNormalization_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Uu(t,e,n,a,o,r)}}),ju=An({batchNorm_:Uu}),Xu=An({batchNorm2d_:Pu}),Yu=An({batchNorm3d_:Lu}),$u=An({batchNorm4d_:Wu});var Qu=An({logicalAnd_:function(t,e){var n=mn(t,"a","logicalAnd","bool"),r=mn(e,"b","logicalAnd","bool");return Ro(n.shape,r.shape),Lt.runKernelFunc((function(t){return t.logicalAnd(n,r)}),{a:n,b:r},null,"LogicalAnd")}}),Ju=An({logicalNot_:function(t){var e=mn(t,"x","logicalNot","bool");return Lt.runKernelFunc((function(t){return t.logicalNot(e)}),{$x:e})}}),Zu=An({logicalOr_:function(t,e){var n=mn(t,"a","logicalOr","bool"),r=mn(e,"b","logicalOr","bool");return Ro(n.shape,r.shape),Lt.runKernelFunc((function(t){return t.logicalOr(n,r)}),{$a:n,$b:r})}}),tc=An({logicalXor_:function(t,e){var n=mn(t,"a","logicalXor","bool"),r=mn(e,"b","logicalXor","bool");return Ro(n.shape,r.shape),Zu(t,e).logicalAnd(Qu(t,e).logicalNot())}}),ec=An({where_:function(t,e,n){var r=mn(e,"a","where"),o=mn(n,"b","where"),a=mn(t,"condition","where","bool");return E(r.shape,o.shape,"Error in where: "),1===a.rank?C(a.shape[0]===r.shape[0],(function(){return"The first dimension of `a` must match the size of `condition`."})):E(a.shape,o.shape,"Error in where: "),Lt.runKernelFunc((function(t,e){var n=t.select(a,r,o);return e([a]),n}),{$condition:a,$a:r,$b:o},(function(t,e){var n=e[0];return{$condition:function(){return Xn(n).toFloat()},$a:function(){return t.mul(n.cast(t.dtype))},$b:function(){return t.mul(n.logicalNot().cast(t.dtype))}}}))}}),nc=function(t){return n(this,void 0,void 0,(function(){var e,n,o;return r(this,(function(r){switch(r.label){case 0:return[4,(e=mn(t,"condition","whereAsync","bool")).data()];case 1:return n=r.sent(),o=na(e.shape,n),t!==e&&e.dispose(),[2,o]}}))}))};var rc=An({add_:function(t,e){var n,r=mn(t,"a","add"),o=mn(e,"b","add");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t){return t.add(r,o)}),{a:r,b:o},(function(t){return{a:function(){var e=t,n=Eo(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},b:function(){var e=t,n=Eo(o.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(o.shape)}}}),"Add")}}),oc=An({addN_:function(t){C(Array.isArray(t),(function(){return"The argument passed to tf.addN() must be a list of tensors"})),C(t.length>=1,(function(){return"Must pass at least one tensor to tf.addN(), but got "+t.length}));var e=t.map((function(t,e){return mn(t,"tensors"+e,"addN")})),n=e[0];e.forEach((function(t){if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),e.forEach((function(t){if(!S(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));var r=e;return Lt.runKernelFunc((function(t){return t.addN(e)}),r,(function(t){var n={};return e.forEach((function(e,r){n[r]=function(){return t.clone()}})),n}),"AddN")}}),ac=An({addStrict_:function(t,e){var n=mn(t,"a","addStrict"),r=mn(e,"b","addStrict");return E(n.shape,r.shape,"Error in addStrict: "),n.add(r)}}),ic=An({atan2_:function(t,e){var n,r=mn(t,"a","atan2"),o=mn(e,"b","atan2");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.atan2(r,o);return e([r,o]),n}),{$a:r,$b:o},(function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=rc(n.square(),r.square()),o=t.mul(r.div(e)),i=Eo(n.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(n.shape)},$b:function(){var e=rc(n.square(),r.square()),o=wu(t.mul(n.div(e))),i=Eo(r.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(r.shape)}}}))}}),sc=An({div_:function(t,e){var n,r=mn(t,"a","div"),o=mn(e,"b","div");if(n=Nt(r,o),r=n[0],o=n[1],"int32"===r.dtype&&"int32"===o.dtype)return lc(r,o);var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.realDivide(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){var e=t.div(r.toFloat()),o=Eo(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},b:function(){var e=t.mul(n.toFloat()),o=Eo(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}}),"Div")}}),uc=An({divNoNan_:function(t,e){var n,r=mn(t,"a","div"),o=mn(e,"b","div");r=(n=Nt(r,o))[0],o=n[1];var a=sc(r,o),i=Xn(a),s=o.equal(i);return ec(s,i,a)}}),cc=An({divStrict_:function(t,e){var n=mn(t,"a","div"),r=mn(e,"b","div");return E(n.shape,r.shape,"Error in divideStrict: "),n.div(r)}}),lc=An({floorDiv_:function(t,e){var n,r=mn(t,"a","floorDiv"),o=mn(e,"b","floorDiv");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.floorDiv(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){var e=t.div(r.toFloat()),o=Eo(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},b:function(){var e=t.mul(n.toFloat()),o=Eo(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}}),"FloorDiv")}}),hc=An({maximum_:function(t,e){var n,r=mn(t,"a","maximum"),o=mn(e,"b","maximum");return n=Nt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.maximum(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){return t.mul(n.greaterEqual(r).toFloat())},b:function(){return t.mul(n.less(r).toFloat())}}}),"Maximum")}}),fc=An({maximumStrict_:function(t,e){var n=mn(t,"a","maximumStrict"),r=mn(e,"b","maximumStrict");return E(n.shape,r.shape,"Error in maximumStrict: "),n.maximum(r)}}),dc=An({minimum_:function(t,e){var n,r=mn(t,"a","minimum"),o=mn(e,"b","minimum");return n=Nt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.minimum(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){return t.mul(n.lessEqual(r).toFloat())},b:function(){return t.mul(n.greater(r).toFloat())}}}),"Minimum")}}),pc=An({minimumStrict_:function(t,e){var n=mn(t,"a","minimumStrict"),r=mn(e,"b","minimumStrict");return E(n.shape,r.shape,"Error in minimumStrict: "),n.minimum(r)}}),vc=An({mod_:function(t,e){var n,r=mn(t,"a","mod"),o=mn(e,"b","mod");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.mod(r,o);return e([r,o]),n}),{$a:r,$b:o},(function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=Eo(n.shape,a);return e.length>0?t.sum(e).reshape(n.shape):t},$b:function(){var e=t.mul(n.div(r).floor().neg()),o=Eo(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}}))}}),mc=An({modStrict_:function(t,e){var n=mn(t,"a","modStrict"),r=mn(e,"b","modStrict");return E(n.shape,r.shape,"Error in modStrict: "),n.mod(r)}}),gc=An({mul_:function(t,e){var n,r=mn(t,"a","mul"),o=mn(e,"b","mul");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.multiply(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){var e=t.mul(r.toFloat()),o=Eo(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},b:function(){var e=t.mul(n.toFloat()),o=Eo(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}}),"Mul")}}),yc=An({mulStrict_:function(t,e){var n=mn(t,"a","mul"),r=mn(e,"b","mul");return E(n.shape,r.shape,"Error in multiplyStrict: "),n.mul(r)}}),xc=An({pow_:function(t,e){var n,r=mn(t,"base","pow"),o=mn(e,"exp","pow");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape),i=[r,o];return Lt.runKernelFunc((function(t,e){var n=t.pow(r,o);return e([r,o,n]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1],o=e[2];return{a:function(){var e=r.toFloat(),o=t.mul(e.mul(n.pow(e.sub(On(1))))),i=Eo(n.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(n.shape)},b:function(){var e=n.greater(0),i=n.log().where(e,Xn(n)),s=t.mul(o.mul(i)),u=Eo(r.shape,a);return u.length>0&&(s=s.sum(u)),s.reshape(r.shape)}}}),"Pow",{},i,[!0])}}),bc=An({powStrict_:function(t,e){return E(t.shape,e.shape,"Error in powStrict: "),t.pow(e)}}),wc=An({squaredDifferenceStrict_:function(t,e){var n=mn(t,"a","squaredDifferenceStrict"),r=mn(e,"b","squaredDifferenceStrict");return E(n.shape,r.shape,"Error in squaredDifferenceStrict: "),n.squaredDifference(r)}}),Cc=An({sub_:function(t,e){var n,r=mn(t,"a","sub"),o=mn(e,"b","sub");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t){return t.subtract(r,o)}),{a:r,b:o},(function(t){return{a:function(){var e=t,n=Eo(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},b:function(){var e=t,n=Eo(o.shape,a);return n.length>0&&(e=e.sum(n)),e.neg().reshape(o.shape)}}}),"Sub")}}),Ec=An({subStrict_:function(t,e){var n=mn(t,"a","subStrict"),r=mn(e,"b","subStrict");return E(n.shape,r.shape,"Error in subStrict: "),n.sub(r)}});var Rc=An({equal_:function(t,e){var n,r=mn(t,"a","equal"),o=mn(e,"b","equal");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.equal(r,o)}),{$a:r,$b:o})}}),Ic=An({equalStrict_:function(t,e){var n=mn(t,"a","equalStrict"),r=mn(e,"b","equalStrict");return E(n.shape,r.shape,"Error in equalStrict: "),n.equal(r)}}),kc=An({greater_:function(t,e){var n,r=mn(t,"a","greater"),o=mn(e,"b","greater");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.greater(r,o)}),{a:r,b:o},null,"Greater")}}),Sc=An({greaterEqual_:function(t,e){var n,r=mn(t,"a","greaterEqual"),o=mn(e,"b","greaterEqual");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.greaterEqual(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){return Xn(n)},b:function(){return Xn(r)}}}),"GreaterEqual")}}),Ac=An({greaterEqualStrict_:function(t,e){var n=mn(t,"a","greaterEqualStrict"),r=mn(e,"b","greaterEqualStrict");return E(n.shape,r.shape,"Error in greaterEqualStrict: "),n.greaterEqual(r)}}),Dc=An({greaterStrict_:function(t,e){var n=mn(t,"a","greaterStrict"),r=mn(e,"b","greaterStrict");return E(n.shape,r.shape,"Error in greaterStrict: "),n.greater(r)}}),Tc=An({less_:function(t,e){var n,r=mn(t,"a","less"),o=mn(e,"b","less");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.less(r,o)}),{a:r,b:o},null,"Less")}}),Nc=An({lessEqual_:function(t,e){var n,r=mn(t,"a","lessEqual"),o=mn(e,"b","lessEqual");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.lessEqual(r,o);return e([r,o]),n}),{a:r,b:o},null,"LessEqual")}}),Fc=An({lessEqualStrict_:function(t,e){var n=mn(t,"a","lessEqualStrict"),r=mn(e,"b","lessEqualStrict");return E(n.shape,r.shape,"Error in lessEqualStrict: "),n.lessEqual(r)}}),_c=An({lessStrict_:function(t,e){var n=mn(t,"a","lessStrict"),r=mn(e,"b","lessStrict");return E(n.shape,r.shape,"Error in lessStrict: "),n.less(r)}}),Oc=An({notEqual_:function(t,e){var n,r=mn(t,"a","notEqual"),o=mn(e,"b","notEqual");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.notEqual(r,o)}),{a:r,b:o},null,"NotEqual")}}),Mc=An({notEqualStrict_:function(t,e){var n=mn(t,"a","notEqualStrict"),r=mn(e,"b","notEqualStrict");return E(n.shape,r.shape,"Error in notEqualStrict: "),n.notEqual(r)}});function Bc(t,e){for(var n=[],r=t;r<e;++r)n.push(r);return n}function Pc(t){for(var e=[],n=0;n<t.length;++n)for(var r=0;r<t[n].length;++r)e.push(t[n][r]);return e}var Lc=An({gather_:function(t,e,n){void 0===n&&(n=0);var r=mn(t,"x","gather"),o=mn(e,"indices","gather","int32");n=O(n,r.shape)[0];var a=function(t,e,n){for(var r=t.shape[n],o=[],a=1,i=1,s=0;s<n;s++)o.push(t.shape[s]),a*=t.shape[s];for(s=0;s<e.rank;s++)o.push(e.shape[s]);for(s=n+1;s<t.rank;s++)o.push(t.shape[s]),i*=t.shape[s];return{batchSize:a,sliceSize:i,dimSize:r,outputShape:o}}(r,o,n);return Lt.runKernelFunc((function(t,e){var a=t.gather(r,o.flatten(),n);return e([o]),a}),{x:r,indices:o},(function(t,e){var o=e[0];return{x:function(){var e=r.shape,a=o.size,i=e.slice(0,n),s=i.length,u=e.slice(n,e.length).slice(1),c=u.length,l=Bc(0,s),h=Bc(s+1,s+1+c),f=Pc([i,[a],u]),d=t.reshape(f),p=o.reshape([a]),v=Pc([[s],l,h]),m=d.transpose(v),g=Wc(m,p,r.shape[n]),y=Rn(v);return g=g.transpose(y)},indices:function(){return o}}}),"Gather",{axis:n}).reshape(a.outputShape)}}),Wc=An({unsortedSegmentSum_:function(t,e,n){var r=mn(t,"x","unsortedSegmentSum"),o=mn(e,"segmentIds","unsortedSegmentSum","int32");return C(A(n),(function(){return"numSegments must be of dtype int"})),Lt.runKernelFunc((function(t,e){var a=t.unsortedSegmentSum(r,o,n);return e([o]),a}),{$x:r},(function(t,e){var n=e[0];return{$x:function(){return function(t,e){for(var n=hc(e,Xn(e)),r=Lc(t,n),o=Sc(e,On(0,"int32")),a=r.rank-o.rank,i=0;i<a;++i)o=wr(o,i+1);o=Qu(o,zn(r.shape,"bool"));var s=Xn(r);return ec(o,r,s)}(t,n)}}}))}});var Uc=function(t,e,o){return n(this,void 0,void 0,(function(){var n,a,i,s,u,c,l,h,f,d,p,v,m;return r(this,(function(r){switch(r.label){case 0:for(n=mn(t,"tensor","boolMask"),a=mn(e,"mask","boolMask","bool"),i=null==o?0:o,s=a.rank,u=n.shape,C(s>0,(function(){return"mask cannot be scalar"})),E(u.slice(i,i+s),a.shape,"mask's shape must match the first K dimensions of tensor's shape,"),c=1,l=i;l<i+s;l++)c*=u[l];return h=u.slice(0,i).concat([c],u.slice(i+s)),f=n.reshape(h),d=a.reshape([-1]),[4,nc(d)];case 1:return p=r.sent(),v=p.squeeze([1]),m=Lc(f,v,i),t!==n&&n.dispose(),e!==a&&a.dispose(),v.dispose(),f.dispose(),d.dispose(),p.dispose(),[2,m]}}))}))};function Vc(t,e,n,r,o,a,i){void 0===a&&(a="NHWC"),C(t.length===e.rank,(function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"}));var s=t,u=e,c=!1;3===e.rank&&(c=!0,u=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]),s=[1,t[0],t[1],t[2]]),C(4===s.length,(function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+s.length+"."})),C(4===u.rank,(function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+u.rank})),C(4===n.rank,(function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank}));var l="NHWC"===a?s[3]:s[1],h="NHWC"===a?u.shape[3]:u.shape[1];C(l===n.shape[2],(function(){return"Error in conv2dDerInput: depth of input ("+l+") must match input depth for filter "+n.shape[2]+"."})),C(h===n.shape[3],(function(){return"Error in conv2dDerInput: depth of output ("+h+") must match output depth for filter "+n.shape[3]+"."})),null!=i&&C(A(o),(function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+o+"."}));var f=Bo(a),d=So(s,n.shape,r,1,o,i,!1,f),p=Lt.runKernelFunc((function(t,e){var r=t.conv2dDerInput(u,n,d);return e([n,u]),r}),{dy4D:u,filter:n},(function(t,e){var n=e[0],s=e[1];return{dy4D:function(){return qc(t,n,r,o,a,1,i)},filter:function(){return jc(t,s,n.shape,r,o,a,i)}}}));return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function zc(t){var e=function(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}(t),n=e[0],r=e[1],o=e[2];return 1===n&&1===r&&1===o}function Gc(t,e,n,r,o){C(t.length===e.rank,(function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"}));var a=t,i=e,s=!1;4===e.rank&&(s=!0,i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]),a=[1,t[0],t[1],t[2],t[3]]);var u=a[4],c=i.shape[4];C(5===a.length,(function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+a.length+"."})),C(5===i.rank,(function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+i.rank})),C(5===n.rank,(function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank})),C(u===n.shape[3],(function(){return"Error in conv3dDerInput: depth of input ("+u+") must match input depth for filter "+n.shape[3]+"."})),C(c===n.shape[4],(function(){return"Error in conv3dDerInput: depth of output ("+c+") must match output depth for filter "+n.shape[4]+"."}));var l=Ao(a,n.shape,r,1,o),h=Lt.runKernelFunc((function(t){return t.conv3dDerInput(i,n,l)}),{dy5D:i});return s?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}var Hc=An({conv1d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NWC"),void 0===a&&(a=1);var s=mn(t,"x","conv1d"),u=mn(e,"filter","conv1d"),c=s,l=!1;2===s.rank&&(l=!0,c=s.as3D(1,s.shape[0],s.shape[1])),C(3===c.rank,(function(){return"Error in conv1d: input must be rank 3, but got rank "+c.rank+"."})),C(3===u.rank,(function(){return"Error in conv1d: filter must be rank 3, but got rank "+u.rank+"."})),null!=i&&C(A(r),(function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."})),C(c.shape[2]===u.shape[1],(function(){return"Error in conv1d: depth of input ("+c.shape[2]+") must match input depth for filter "+u.shape[1]+"."})),C(Mo(n,a),(function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+n+" and dilation '"+a+"'"})),C("NWC"===o,(function(){return"Error in conv1d: got dataFormat of "+o+" but only NWC is currently supported."}));var h=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),f=c.as4D(c.shape[0],1,c.shape[1],c.shape[2]),d=qc(f,h,[1,n],r,"NHWC",[1,a],i);return l?d.as2D(d.shape[2],d.shape[3]):d.as3D(d.shape[0],d.shape[2],d.shape[3])}}),qc=An({conv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=mn(t,"x","conv2d"),u=mn(e,"filter","conv2d"),c=s,l=!1;3===s.rank&&(l=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),C(4===c.rank,(function(){return"Error in conv2d: input must be rank 4, but got rank "+c.rank+"."})),C(4===u.rank,(function(){return"Error in conv2d: filter must be rank 4, but got rank "+u.rank+"."})),null!=i&&C(A(r),(function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}));var h="NHWC"===o?c.shape[3]:c.shape[1];C(h===u.shape[2],(function(){return"Error in conv2d: depth of input ("+h+") must match input depth for filter "+u.shape[2]+"."})),C(Mo(n,a),(function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}));var f=Bo(o),d=So(c.shape,u.shape,n,a,r,i,!1,f),p=[u,c],v=Lt.runKernelFunc((function(t,e){var n=t.conv2d(c,u,d);return e([u,c]),n}),{x:c,filter:u},(function(t,e){var i=e,s=i[0],u=i[1];return C(Oo(a),(function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"})),{x:function(){return Xc(u.shape,t,s,n,r,o)},filter:function(){return jc(u,t,s.shape,n,r,o)}}}),"Conv2D",d,p);return l?v.as3D(v.shape[1],v.shape[2],v.shape[3]):v}}),Kc=An({conv3d_:function(t,e,n,r,o,a){void 0===o&&(o="NDHWC"),void 0===a&&(a=[1,1,1]);var i=mn(t,"x","conv3d"),s=mn(e,"filter","conv3d"),u=i,c=!1;4===i.rank&&(c=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),C(5===u.rank,(function(){return"Error in conv3d: input must be rank 5, but got rank "+u.rank+"."})),C(5===s.rank,(function(){return"Error in conv3d: filter must be rank 5, but got rank "+s.rank+"."})),C(u.shape[4]===s.shape[3],(function(){return"Error in conv3d: depth of input ("+u.shape[4]+") must match input depth for filter "+s.shape[3]+"."})),C(function(t,e){return zc(t)||zc(e)}(n,a),(function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"})),C("NDHWC"===o,(function(){return"Error in conv3d: got dataFormat of "+o+" but only NDHWC is currently supported."}));var l=Ao(u.shape,s.shape,n,a,r),h=Lt.runKernelFunc((function(t,e){var n=t.conv3d(u,s,l);return e([u,s]),n}),{x:u,$filter:s},(function(t,e){C(zc(a),(function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"}));var o=e[0],i=e[1];return{x:function(){return Gc(o.shape,t,i,n,r)},$filter:function(){return function(t,e,n,r,o){var a=t;4===t.rank&&(a=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]));var i=e;4===i.rank&&(i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]));C(5===a.rank,(function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+a.shape+"."})),C(5===i.rank,(function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+i.shape+"."})),C(5===n.length,(function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+"."})),C(a.shape[4]===n[3],(function(){return"Error in conv3dDerFilter: depth of input "+a.shape[4]+") must match input depth in filter ("+n[3]+"."})),C(i.shape[4]===n[4],(function(){return"Error in conv3dDerFilter: depth of dy ("+i.shape[4]+") must match output depth for filter ("+n[4]+")."}));var s=Ao(a.shape,n,r,1,o);return Lt.runKernelFunc((function(t){return t.conv3dDerFilter(a,i,s)}),{x5D:a,dy5D:i})}(o,t,i.shape,n,r)}}}));return c?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}}),jc=An({conv2dDerFilter_:function(t,e,n,r,o,a,i){void 0===a&&(a="NHWC");var s=t;3===t.rank&&(s=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var u=e;3===u.rank&&(u=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),C(4===s.rank,(function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+s.shape+"."})),C(4===u.rank,(function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+u.shape+"."})),C(4===n.length,(function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+"."}));var c="NHWC"===a?s.shape[3]:s.shape[1],l="NHWC"===a?u.shape[3]:u.shape[1];C(c===n[2],(function(){return"Error in conv2dDerFilter: depth of input "+c+") must match input depth in filter ("+n[2]+"."})),C(l===n[3],(function(){return"Error in conv2dDerFilter: depth of dy ("+l+") must match output depth for filter ("+n[3]+")."})),null!=i&&C(A(o),(function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+o+"."}));var h=Bo(a),f=So(s.shape,n,r,1,o,i,!1,h);return Lt.runKernelFunc((function(t){return t.conv2dDerFilter(s,u,f)}),{x4D:s,dy4D:u})}}),Xc=An({conv2dDerInput_:Vc}),Yc=An({depthwiseConv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=mn(t,"x","depthwiseConv2d"),u=mn(e,"filter","depthwiseConv2d"),c=s,l=!1;3===s.rank&&(l=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),C(4===c.rank,(function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+c.rank+"."})),C(4===u.rank,(function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+u.rank+"."})),C(c.shape[3]===u.shape[2],(function(){return"Error in depthwiseConv2d: number of input channels ("+c.shape[3]+") must match the inChannels dimension in filter "+u.shape[2]+"."})),null==a&&(a=[1,1]),C(Mo(n,a),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"})),null!=i&&C(A(r),(function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}));var h=So(c.shape,u.shape,n,a,r,i,!0),f=[c,u],d=Lt.runKernelFunc((function(t,e){var n=t.depthwiseConv2D(c,u,h);return e([c,u]),n}),{x:c,filter:u},(function(t,e){C(Oo(a),(function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+a+"'"}));var n=e[0],r=e[1];return{x:function(){return $c(n.shape,t,r,h)},filter:function(){return Qc(n,t,r.shape,h)}}}),"DepthwiseConv2dNative",h,f);return l?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}}),$c=An({depthwiseConv2dDerInput_:function(t,e,n,r){var o=e,a=!1;3===e.rank&&(a=!0,o=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var i=Lt.runKernelFunc((function(t){return t.depthwiseConv2DDerInput(o,n,r)}),{dy4D:o});return a?i.as3D(i.shape[1],i.shape[2],i.shape[3]):i}}),Qc=An({depthwiseConv2dDerFilter_:function(t,e,n,r){var o=t;3===t.rank&&(o=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var a=e;return 3===a.rank&&(a=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),Lt.runKernelFunc((function(t){return t.depthwiseConv2DDerFilter(o,a,r)}),{x4D:o,dy4D:a})}}),Jc=An({separableConv2d_:function(t,e,n,r,o,a,i){void 0===a&&(a=[1,1]),void 0===i&&(i="NHWC");var s=mn(t,"x","separableConv2d"),u=mn(e,"depthwiseFilter","separableConv2d"),c=mn(n,"pointwiseFilter","separableConv2d"),l=s,h=!1;if(3===s.rank&&(h=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(4===l.rank,(function(){return"Error in separableConv2d: input must be rank 4, but got rank "+l.rank+"."})),C(4===u.rank,(function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+u.rank+"."})),C(4===c.rank,(function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+u.rank+"."})),C(1===c.shape[0],(function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+c.shape[0]+"."})),C(1===c.shape[1],(function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+c.shape[1]+"."}));var f=u.shape[2],d=u.shape[3];C(c.shape[2]===f*d,(function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+f*d+", but got "+c.shape[2]+"."}));var p=Yc(l,u,r,o,i,a),v=qc(p,c,1,"valid",i);return h?v.as3D(v.shape[1],v.shape[2],v.shape[3]):v}}),Zc=An({conv2dTranspose_:function(t,e,n,r,o,a){return Vc(n,mn(t,"x","conv2dTranspose"),mn(e,"filter","conv2dTranspose"),r,o,"NHWC",a)}}),tl=An({conv3dTranspose_:function(t,e,n,r,o){return Gc(n,mn(t,"x","conv3dTranspose"),mn(e,"filter","conv3dTranspose"),r,o)}});var el=An({matMul_:function(t,e,n,r){var o;void 0===n&&(n=!1),void 0===r&&(r=!1);var a=mn(t,"a","matMul"),i=mn(e,"b","matMul");o=Nt(a,i),a=o[0],i=o[1];var s=n?a.shape[a.rank-2]:a.shape[a.rank-1],u=r?i.shape[i.rank-1]:i.shape[i.rank-2],c=n?a.shape[a.rank-1]:a.shape[a.rank-2],l=r?i.shape[i.rank-2]:i.shape[i.rank-1],h=a.shape.slice(0,-2),f=i.shape.slice(0,-2),d=k(h),p=k(f);C(a.rank>=2&&i.rank>=2&&a.rank===i.rank,(function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+a.rank+" and "+i.rank+"."})),C(S(h,f),(function(){return"Error in matMul: outer dimensions ("+h+") and ("+f+") of Tensors with shapes "+a.shape+" and "+i.shape+" must match."})),C(s===u,(function(){return"Error in matMul: inner shapes ("+s+") and ("+u+") of Tensors with shapes "+a.shape+" and "+i.shape+" and transposeA="+n+" and transposeB="+r+" must match."}));var v=a.shape.slice(0,-2).concat([c,l]),m=n?a.as3D(d,s,c):a.as3D(d,c,s),g=r?i.as3D(p,l,u):i.as3D(p,u,l),y={transposeA:n,transposeB:r};return Lt.runKernelFunc((function(t,e){var o=t.batchMatMul(m,g,n,r);return e([m,g]),o}),{a:m,b:g},(function(t,e){var o=e,a=o[0],i=o[1];return n||r?!n&&r?{a:function(){return t.matMul(i,!1,!1)},b:function(){return t.matMul(a,!0,!1)}}:n&&!r?{a:function(){return i.matMul(t,!1,!0)},b:function(){return a.matMul(t,!1,!1)}}:{a:function(){return i.matMul(t,!0,!0)},b:function(){return t.matMul(a,!0,!0)}}:{a:function(){return t.matMul(i,!1,!0)},b:function(){return a.matMul(t,!0,!1)}}}),"BatchMatMul",y).reshape(v)}}),nl=An({dot_:function(t,e){var n=mn(t,"t1","dot"),r=mn(e,"t2","dot");C(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+n.rank+" and "+r.rank+"."}));var o=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];return C(o===a,(function(){return"Error in dot: inner dimensions of inputs must match, but got "+o+" and "+a+"."})),1===n.rank&&1===r.rank?n.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():1===n.rank&&2===r.rank?n.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():2===n.rank&&1===r.rank?n.matMul(r.as2D(-1,1)).as1D():n.matMul(r.as2D(r.shape[0],r.shape[1]))}}),rl=An({outerProduct_:function(t,e){var n=mn(t,"v1","outerProduct"),r=mn(e,"v2","outerProduct");return C(1===n.rank&&1===r.rank,(function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+n.rank+" and "+r.rank+"."})),n.as2D(-1,1).matMul(r.as2D(1,-1))}});var ol=An({reverse_:function(t,e){var n=mn(t,"x","reverse");if(0===n.rank)return n.clone();var r=O(e,n.shape);return Lt.runKernelFunc((function(t){return t.reverse(n,r)}),{$x:n},(function(t){return{$x:function(){return t.reverse(r)}}})).reshapeAs(n)}}),al=An({reverse1d_:function(t){var e=mn(t,"x","reverse");return C(1===e.rank,(function(){return"Error in reverse1D: x must be rank 1 but got rank "+e.rank+"."})),ol(e,0)}}),il=An({reverse2d_:function(t,e){var n=mn(t,"x","reverse");return C(2===n.rank,(function(){return"Error in reverse2D: x must be rank 2 but got rank "+n.rank+"."})),ol(n,e)}}),sl=An({reverse3d_:function(t,e){var n=mn(t,"x","reverse");return C(3===n.rank,(function(){return"Error in reverse3D: x must be rank 3 but got rank "+n.rank+"."})),ol(n,e)}}),ul=An({reverse4d_:function(t,e){var n=mn(t,"x","reverse");return C(4===n.rank,(function(){return"Error in reverse4D: x must be rank 4 but got rank "+n.rank+"."})),ol(n,e)}});function cl(t,e,n,r,o,a){var i=mn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),null==r&&(r=[1,1]),C(4===s.rank,(function(){return"Error in maxPool: input must be rank 4 but got rank "+s.rank+"."})),C(Mo(n,r),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"})),null!=a&&C(A(o),(function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."}));var c=Io(s.shape,e,n,r,o,a);if(1===c.filterWidth&&1===c.filterHeight&&S(c.inShape,c.outShape))return i.clone();var l=[s],h=Lt.runKernelFunc((function(t,e){var n=t.maxPool(s,c);return e([s,n]),n}),{x:s},(function(t,a){var i=a[0],s=a[1];return{x:function(){return function(t,e,n,r,o,a,i,s){var u=mn(t,"dy","maxPoolBackprop"),c=mn(e,"input","maxPoolBackprop"),l=mn(n,"output","maxPoolBackprop");C(c.rank===u.rank,(function(){return"Rank of input ("+c.rank+") does not match rank of dy ("+u.rank+")"})),null==a&&(a=[1,1]);C(Mo(o,a),(function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"})),C(4===u.rank,(function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+u.rank+"."})),C(4===c.rank,(function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+c.rank+"."})),null!=s&&C(A(i),(function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+"."}));var h=Io(c.shape,r,o,a,i,s);return Lt.runKernelFunc((function(t){return t.maxPoolBackprop(u,c,l,h)}),{$dy:u,$input:c})}(t,i,s,e,n,r,o)}}}),"MaxPool",c,l);return u?h.as3D(h.shape[1],h.shape[2],h.shape[3]):h}function ll(t,e,n,r,o,a){var i=mn(t,"x","avgPool","float32");null==r&&(r=[1,1]),C(Mo(n,r),(function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"}));var s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),C(4===s.rank,(function(){return"Error in avgPool: x must be rank 4 but got rank "+s.rank+"."})),null!=a&&C(A(o),(function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."}));var c=Io(s.shape,e,n,r,o,a);if(1===c.filterWidth&&1===c.filterHeight&&S(c.inShape,c.outShape))return i.clone();var l=Lt.runKernelFunc((function(t){return t.avgPool(s,c)}),{x:s},(function(t){return{x:function(){return function(t,e,n,r,o,a){var i=mn(t,"dy","avgPoolBackprop"),s=mn(e,"input","avgPoolBackprop");C(s.rank===i.rank,(function(){return"Rank of input ("+s.rank+") does not match rank of dy ("+i.rank+")"})),null==o&&(o=[1,1]);C(Mo(r,o),(function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+o+"'"}));var u=s,c=i,l=!1;3===s.rank&&(l=!0,u=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),c=i.as4D(1,i.shape[0],i.shape[1],i.shape[2]));C(4===c.rank,(function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+c.rank+"."})),C(4===u.rank,(function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+u.rank+"."}));var h=Io(u.shape,n,r,o,a),f=Lt.runKernelFunc((function(t){return t.avgPoolBackprop(c,u,h)}),{dy4D:c,input4D:u});if(l)return f.as3D(f.shape[1],f.shape[2],f.shape[3]);return f}(t,s,e,n,r,o)}}}),"AvgPool",c);return l=l.cast(i.dtype),u?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}var hl=An({maxPool_:function(t,e,n,r,o){return cl(t,e,n,1,r,o)}}),fl=An({avgPool_:function(t,e,n,r,o){return ll(t,e,n,1,r,o)}}),dl=An({pool_:function(t,e,n,r,o,a){null==o&&(o=[1,1]),null==a&&(a=1),0===r&&(r="valid");var i=mn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),C(Mo(a,o),(function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+o+"'"}));var c,l=Io(s.shape,e,a,o,r),h=[l.dilationHeight,l.dilationWidth];c="same"===r?function(t,e){var n=t.map((function(t,n){return t+(t-1)*(e[n]-1)})).map((function(t){return t-1})),r=n.map((function(t){return Math.floor(t/2)})),o=n.map((function(t,e){return t-r[e]}));return n.map((function(t,e){return[r[e],o[e]]}))}([l.filterHeight,l.filterWidth],h):[[0,0],[0,0]];var f=1===h[0]&&1===h[1],d=function(t,e,n){var r=n.map((function(t){return t[0]})),o=n.map((function(t){return t[1]})),a=t.concat(r,o),i=e.map((function(t,e){return(t-a[e]%t)%t})),s=o.map((function(t,e){return t+i[e]})),u=e.map((function(t,e){return[r[e],s[e]]})),c=e.map((function(t,e){return[0,i[e]]}));return[u,c]}([l.inHeight,l.inWidth],h,c),p=d[0],v=d[1],m=f?r:"valid",g=f?s:Mr(s,h,p),y=("avg"===n?function(){return ll(g,e,a,1,m)}:function(){return cl(g,e,a,1,m)})(),x=f?y:vr(y,h,v);return u?x.as3D(x.shape[1],x.shape[2],x.shape[3]):x}}),pl=An({maxPool3d_:function(t,e,n,r,o,a,i){void 0===a&&(a="NDHWC");var s=mn(t,"x","maxPool3d"),u=s,c=!1;4===s.rank&&(c=!0,u=s.as5D(1,s.shape[0],s.shape[1],s.shape[2],s.shape[3])),null==i&&(i=[1,1,1]),C(5===u.rank,(function(){return"Error in maxPool3d: x must be rank 5 but got rank "+u.rank+"."})),C("NDHWC"===a,(function(){return"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+a})),C(Mo(n,i),(function(){return"Error in maxPool3d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'"})),null!=o&&C(A(r),(function(){return"Error in maxPool3d: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+r+"."}));var l=ko(u.shape,e,n,i,r,o,a),h=Lt.runKernelFunc((function(t,e){var n=t.maxPool3d(u,l);return e([u,n]),n}),{x:u},(function(t,a){var s=a[0],u=a[1];return{x:function(){return function(t,e,n,r,o,a,i,s){var u=mn(t,"dy","maxPool3dBackprop"),c=mn(e,"input","maxPool3dBackprop"),l=mn(n,"output","maxPool3dBackprop"),h=u,f=c,d=l,p=!1;4===c.rank&&(p=!0,h=u.as5D(1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]),f=c.as5D(1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]),d=l.as5D(1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]));C(5===h.rank,(function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+h.rank+"."})),C(5===f.rank,(function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+f.rank+"."})),C(5===d.rank,(function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+d.rank+"."})),null==a&&(a=[1,1,1]);C(Mo(o,a),(function(){return"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"})),null!=s&&C(A(i),(function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+"."}));var v=ko(f.shape,r,o,a,i,s),m=Lt.runKernelFunc((function(t){return t.maxPool3dBackprop(h,f,d,v)}),{dy5D:h,input5D:f});if(p)return m.as4D(m.shape[1],m.shape[2],m.shape[3],m.shape[4]);return m}(t,s,u,e,n,i,r,o)}}}));return c?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}}),vl=An({avgPool3d_:function(t,e,n,r,o,a,i){void 0===a&&(a="NDHWC");var s=mn(t,"x","avgPool3d","float32"),u=s,c=!1;4===s.rank&&(c=!0,u=s.as5D(1,s.shape[0],s.shape[1],s.shape[2],s.shape[3])),null==i&&(i=[1,1,1]),C(5===u.rank,(function(){return"Error in avgPool3d: x must be rank 5 but got rank "+u.rank+"."})),C("NDHWC"===a,(function(){return"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+a})),C(Mo(n,i),(function(){return"Error in avgPool3d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'"})),null!=o&&C(A(r),(function(){return"Error in avgPool3d: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+r+"."}));var l=ko(u.shape,e,n,i,r,o,a),h=Lt.runKernelFunc((function(t){return t.avgPool3d(u,l)}),{x:u},(function(t){return{x:function(){return function(t,e,n,r,o,a,i){var s=mn(t,"dy","avgPool3dBackprop"),u=mn(e,"input","avgPool3dBackprop"),c=s,l=u,h=!1;4===u.rank&&(h=!0,c=s.as5D(1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]),l=u.as5D(1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]));C(5===c.rank,(function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+c.rank+"."})),C(5===l.rank,(function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+l.rank+"."})),null==o&&(o=[1,1,1]);C(Mo(r,o),(function(){return"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+o+"'"})),null!=i&&C(A(a),(function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+a+"."}));var f=ko(l.shape,n,r,o,a,i),d=Lt.runKernelFunc((function(t){return t.avgPool3dBackprop(c,l,f)}),{dy5D:c,input5D:l});if(h)return d.as4D(d.shape[1],d.shape[2],d.shape[3],d.shape[4]);return d}(t,u,e,n,i,r,o)}}}));return h=h.cast(u.dtype),c?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}});var ml=An({slice_:function(t,e,n){var r,o,a=mn(t,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");(r="number"==typeof e?[e].concat(new Array(a.rank-1).fill(0)):e.length<a.rank?e.concat(new Array(a.rank-e.length).fill(0)):e.slice()).forEach((function(t){C(-1!==t,(function(){return"slice() does not support negative begin indexing."}))})),o=(o=null==n?new Array(a.rank).fill(-1):"number"==typeof n?[n].concat(new Array(a.rank-1).fill(-1)):n.length<a.rank?n.concat(new Array(a.rank-n.length).fill(-1)):n).map((function(t,e){return t>=0?t:(C(-1===t,(function(){return"Negative size values should be exactly -1 but got "+t+" for the slice() size at index "+e+"."})),a.shape[e]-r[e])})),eo(a,r,o);var i=a.shape,s={begin:r,size:o};return Lt.runKernelFunc((function(t){return t.slice(a,r,o)}),{x:a},(function(t){for(var e=[],n=0;n<t.rank;n++)e.push([r[n],i[n]-r[n]-o[n]]);return{x:function(){return t.pad(e)}}}),"Slice",s)}}),gl=An({slice1d_:function(t,e,n){var r=mn(t,"x","slice1d");return C(1===r.rank,(function(){return"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,[e],[n])}}),yl=An({slice2d_:function(t,e,n){var r=mn(t,"x","slice2d");return C(2===r.rank,(function(){return"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,e,n)}}),xl=An({slice3d_:function(t,e,n){var r=mn(t,"x","slice3d");return C(3===r.rank,(function(){return"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,e,n)}}),bl=An({slice4d_:function(t,e,n){var r=mn(t,"x","slice4d");return C(4===r.rank,(function(){return"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,e,n)}});function wl(t,e,n,r,o){return e.rank<n.rank&&(e=e.reshape(wn(e.shape,r))),t.rank<n.rank&&(t=t.reshape(wn(t.shape,r))),{x:function(){var r=t.mul(n.equal(e).cast(t.dtype));return null==o?r:r.transpose(o)}}}var Cl=An({all_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","all","bool"),o=O(e,r.shape),a=o,i=En(a,r.rank);null!=i&&(r=r.transpose(i),a=In(a.length,r.rank));var s=Lt.runKernelFunc((function(t){return t.all(r,a)}),{$x:r});if(n){var u=wn(s.shape,o);return s.reshape(u)}return s}}),El=An({any_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","any","bool"),o=O(e,r.shape),a=o,i=En(a,r.rank);null!=i&&(r=r.transpose(i),a=In(a.length,r.rank));var s=Lt.runKernelFunc((function(t){return t.any(r,a)}),{$x:r});if(n){var u=wn(s.shape,o);return s.reshape(u)}return s}}),Rl=An({argMax_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","argMax");null==e&&(e=0);var r=O(e,n.shape),o=En(r,n.rank);null!=o&&(n=n.transpose(o),r=In(r.length,n.rank));var a={axis:r[0]},i=[n];return Lt.runKernelFunc((function(t,e){var o=t.argMax(n,r[0]);return e([n]),o}),{x:n},(function(t,e){var n=e[0];return{x:function(){return Xn(n)}}}),"ArgMax",a,i)}}),Il=An({argMin_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","argMin");null==e&&(e=0);var r=O(e,n.shape),o=En(r,n.rank);return null!=o&&(n=n.transpose(o),r=In(r.length,n.rank)),Lt.runKernelFunc((function(t,e){var o=t.argMin(n,r[0]);return e([n]),o}),{$x:n},(function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}}))}}),kl=An({logSumExp_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","logSumExp"),o=O(e,r.shape),a=r.max(o,!0),i=r.sub(a).exp().sum(o).log(),s=a.reshape(i.shape).add(i);if(n){var u=wn(s.shape,o);return s.reshape(u)}return s}}),Sl=An({max_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","max"),o=r,a=O(e,r.shape),i=a,s=En(i,r.rank);null!=s&&(r=r.transpose(s),i=In(i.length,r.rank));var u=[r],c=Lt.runKernelFunc((function(t,e){var n=t.max(r,i);return e([o,n]),n}),{x:r},(function(t,e){return wl(t,e[1],e[0],a,s)}),"Max",{axes:i},u,[!0]);if(n){var l=wn(c.shape,a);c=c.reshape(l)}return c}}),Al=An({mean_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","mean"),o=O(e,r.shape),a=k(bn(r.shape,o)[1]);return vo((function(t){var r=On(a);return{value:(r.dtype===t.dtype?t:t.cast(r.dtype)).div(r).sum(e,n),gradFunc:function(e){var n=t.shape.slice();return o.forEach((function(t){n[t]=1})),e.reshape(n).mul(zn(t.shape,"float32")).div(a)}}}))(r)}}),Dl=An({min_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","min"),o=r,a=O(e,r.shape),i=a,s=En(i,r.rank);null!=s&&(r=r.transpose(s),i=In(i.length,r.rank));var u=[r],c=Lt.runKernelFunc((function(t,e){var n=t.min(r,i);return e([o,n]),n}),{x:r},(function(t,e){return wl(t,e[1],e[0],a,s)}),"Min",{axes:i},u,[!0]);if(n){var l=wn(c.shape,a);c=c.reshape(l)}return c}}),Tl=An({moments_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=O(e,(t=mn(t,"x","moments")).shape),o=t.mean(r,n),a=o.shape;n||(a=wn(o.shape,r));var i=t.toFloat().sub(o.reshape(a)).square();return{mean:o,variance:i.mean(r,n)}}}),Nl=An({sum_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","sum");"bool"===r.dtype&&(r=r.toInt());var o=O(e,r.shape);return vo((function(t){var e=En(o,t.rank),r=o,a=t;null!=e&&(a=t.transpose(e),r=In(r.length,t.rank));var i=function(e){var n=t.shape.slice();return o.forEach((function(t){n[t]=1})),e.reshape(n).mul(zn(t.shape,"float32"))},s={axes:r},u=Lt.runKernelFunc((function(t){return t.sum(a,r)}),{x:a},(function(t){return{x:function(){return i(t)}}}),"Sum",s);if(n){var c=wn(u.shape,o);u=u.reshape(c)}return{value:u,gradFunc:i}}))(r)}}),Fl=An({prod_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","prod");"bool"===r.dtype&&(r=r.toInt());var o=O(e,r.shape),a=En(o,r.rank),i=o,s=r;null!=a&&(s=r.transpose(a),i=In(i.length,r.rank));var u=Lt.runKernelFunc((function(t){return t.prod(s,i)}),{permutedX:s});if(n){var c=wn(u.shape,o);u=u.reshape(c)}return u}});var _l=An({elu_:function(t){var e=mn(t,"x","elu");return Lt.runKernelFunc((function(t,n){var r=t.elu(e);return n([r]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return Lt.runKernelFunc((function(e){return e.eluDer(t,n)}),{dy:t,y:n})}}}))}}),Ol=An({leakyRelu_:function(t,e){void 0===e&&(e=.2);var n=mn(t,"x","leakyRelu");return hc(On(e).mul(n),n)}}),Ml=An({prelu_:function(t,e){var n=mn(t,"x","prelu"),r=mn(e,"alpha","prelu");return Lt.runKernelFunc((function(t,e){var o=t.prelu(n,r);return e([n,r]),o}),{x:n,alpha:r},(function(t,e){var n=e[0],r=e[1],o=n.greater(0);return{x:function(){return ec(o,t,t.mul(r))},alpha:function(){var e=ec(o,Xn(t),t.mul(n)),a=Eo(r.shape,t.shape);return a.length>0&&(e=e.sum(a)),e.reshape(r.shape)}}}),"Prelu")}}),Bl=An({relu_:function(t){var e=mn(t,"x","relu");return"bool"===e.dtype?e.toInt():Lt.runKernelFunc((function(t,n){var r=t.relu(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.mulStrict(n.step().toFloat())}}}),"Relu")}}),Pl=An({relu6_:function(t){var e=mn(t,"x","relu6");return"bool"===e.dtype?e.toInt():Lt.runKernelFunc((function(t,n){var r=t.relu6(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0],r=n.lessEqual(6).mul(n.step());return{x:function(){return t.mulStrict(r.toFloat())}}}),"Relu6")}}),Ll=An({selu_:function(t){var e=mn(t,"x","selu");return Lt.runKernelFunc((function(t,n){var r=t.selu(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){var e=n.greater(On(0)),r=On(bs),o=On(ws),a=t.mul(o),i=t.mul(r).mul(n.toFloat().exp());return ec(e,a,i)}}}))}});var Wl=An({transpose_:function(t,e){var n=mn(t,"x","transpose");if(null==e&&(e=n.shape.map((function(t,e){return e})).reverse()),C(n.rank===e.length,(function(){return"Error in transpose: rank of input "+n.rank+" must match length of perm "+e+"."})),e.forEach((function(t){C(t>=0&&t<n.rank,(function(){return"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e}))})),n.rank<=1)return n.clone();var r={perm:e};return Lt.runKernelFunc((function(t){return t.transpose(n,e)}),{x:n},(function(t){var n=Rn(e);return{x:function(){return t.transpose(n)}}}),"Transpose",r)}});var Ul=An({localResponseNormalization_:function(t,e,n,r,o){void 0===e&&(e=5),void 0===n&&(n=1),void 0===r&&(r=1),void 0===o&&(o=.5);var a=mn(t,"x","localResponseNormalization");C(4===a.rank||3===a.rank,(function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+a.rank+"."})),C(A(e),(function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+e+"."}));var i=a,s=!1;3===a.rank&&(s=!0,i=a.as4D(1,a.shape[0],a.shape[1],a.shape[2]));var u=Lt.runKernelFunc((function(t,a){var s=t.localResponseNormalization4D(i,e,n,r,o);return a([i,s]),s}),{x4D:i},(function(t,a){var i=a[0],s=a[1];return{x4D:function(){return Lt.runKernelFunc((function(a){return a.LRNGrad(t,i,s,e,n,r,o)}),{})}}}));return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}});var Vl=An({norm_:function(t,e,n,r){void 0===e&&(e="euclidean"),void 0===n&&(n=null),void 0===r&&(r=!1);var o=function t(e,n,r){void 0===r&&(r=null);if(0===e.rank)return e.abs();if(1!==e.rank&&null===r)return t(e.reshape([-1]),n,r);if(1===e.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return e.abs().sum(r);if(n===1/0)return e.abs().max(r);if(n===-1/0)return e.abs().min(r);if("euclidean"===n||2===n)return e.abs().pow(On(2,"int32")).sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}if(Array.isArray(r)&&2===r.length){if(1===n)return e.abs().sum(r[0]).max(r[1]-1);if(n===1/0)return e.abs().sum(r[1]).max(r[0]);if(n===-1/0)return e.abs().sum(r[1]).min(r[0]);if("fro"===n||"euclidean"===n)return e.square().sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}throw new Error("Error in norm: invalid axis: "+r)}(t=mn(t,"x","norm"),e,n),a=o.shape;if(r){var i=O(n,t.shape);a=wn(o.shape,i)}return o.reshape(a)}});var zl=An({basicLSTMCell_:function(t,e,n,r,o,a){var i=mn(t,"forgetBias","basicLSTMCell"),s=mn(e,"lstmKernel","basicLSTMCell"),u=mn(n,"lstmBias","basicLSTMCell"),c=mn(r,"data","basicLSTMCell"),l=mn(o,"c","basicLSTMCell"),h=mn(a,"h","basicLSTMCell"),f=c.concat(h,1).matMul(s).add(u),d=f.shape[0],p=f.shape[1]/4,v=[d,p],m=f.slice([0,0],v),g=f.slice([0,p],v),y=f.slice([0,2*p],v),x=f.slice([0,3*p],v),b=m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(i.add(y).sigmoid())),w=b.tanh().mulStrict(x.sigmoid());return[b,w]}}),Gl=An({multiRNNCell_:function(t,e,n,r){for(var o=mn(e,"data","multiRNNCell"),a=gn(n,"c","multiRNNCell"),i=gn(r,"h","multiRNNCell"),s=o,u=[],c=0;c<t.length;c++){var l=t[c](s,a[c],i[c]);u.push(l[0]),u.push(l[1]),s=l[1]}var h=[],f=[];for(c=0;c<u.length;c+=2)h.push(u[c]),f.push(u[c+1]);return[h,f]}});var Hl=An({movingAverage_:function(t,e,n,r,o){void 0===o&&(o=!0);var a=mn(t,"v","movingAverage"),i=mn(e,"x","movingAverage"),s=mn(n,"decay","movingAverage");Ft(a,i),C(S(a.shape,i.shape),(function(){return"Shape mismatch in v and x"}));var u=On(1),c=u.sub(s),l=i.sub(a).mul(c);if(o){C(null!=r,(function(){return"When using zeroDebias: true, step is required."}));var h=mn(r,"step","movingAverage");l=l.div(u.sub(xc(s,h)))}return a.add(l)}});var ql=An({stridedSlice_:function(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),null==r&&(r=new Array(e.length)),0!==i)throw new Error("ellipsis mask is not yet supported");var c=mn(t,"x","stridedSlice"),l=no(s),h=c.shape.slice();l.forEach((function(t){e[t]=0,n[t]=1,h.splice(t,0,1)})),c=c.reshape(h);for(var f=0;f<c.rank;f++)e[f]=oo(o,e,r,c.shape,f),n[f]=ao(a,n,r,c.shape,f),r[f]=r[f]||1;var d=no(u);d.forEach((function(t){n[t]=e[t]+1,r[t]=1}));var p=ro(e,n,r),v=p.filter((function(t,e){return-1===d.indexOf(e)}));return r.every((function(t){return 1===t}))?ml(c,e,p).reshape(v):Lt.runKernelFunc((function(t){return t.stridedSlice(c,e,n,r)}),{$x:c}).reshape(v)}});var Kl=An({topk_:function(t,e,n){void 0===e&&(e=1),void 0===n&&(n=!0);var r=mn(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var o=r.shape[r.shape.length-1];if(e>o)throw new Error("'k' passed to topk() must be <= the last dimension ("+o+") but got "+e);var a=Lt.runKernelFunc((function(t){return t.topk(r,e,n)}),{$x:r});return{values:a[0],indices:a[1]}}});var jl=An({scatterND_:function(t,e,n){var r=mn(t,"indices","scatterND","int32"),o=mn(e,"updates","scatterND");return Jr(o,r,n),Lt.runKernelFunc((function(t){return t.scatterND(r,o,n)}),{indices:r,updates:o},null,"ScatterNd",{shape:n})}});var Xl=An({fft_:function(t){C("complex64"===t.dtype,(function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+t.dtype+"."}));var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Lt.runKernelFunc((function(t){return t.fft(r)}),{input:t}).reshape(t.shape)}}),Yl=An({ifft_:function(t){C("complex64"===t.dtype,(function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+t.dtype+"."}));var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Lt.runKernelFunc((function(t){return t.ifft(r)}),{input:t}).reshape(t.shape)}}),$l=An({rfft_:function(t,e){C("float32"===t.dtype,(function(){return"The dtype for rfft() must be real value but got "+t.dtype}));var n,r=t.shape[t.shape.length-1],o=t.size/r;if(null!=e&&e<r){var a=t.shape.map((function(t){return 0})),i=t.shape.map((function(t){return t}));i[t.shape.length-1]=e,n=t.slice(a,i),r=e}else if(null!=e&&e>r){var s=t.shape.map((function(t){return t}));s[t.shape.length-1]=e-r,n=t.concat(Gn(s),t.shape.length-1),r=e}else n=t;var u=n.zerosLike(),c=Dn(n,u).as2D(o,r),l=Xl(c),h=Math.floor(r/2)+1,f=Tn(l),d=Nn(l),p=f.split([h,r-h],f.shape.length-1),v=d.split([h,r-h],d.shape.length-1),m=n.shape.slice();return m[n.shape.length-1]=h,Dn(p[0],v[0]).reshape(m)}}),Ql=An({irfft_:function(t){var e=t.shape[t.shape.length-1],n=t.size/e;if(e<=2){var r=t.as2D(n,e),o=Yl(r);return Tn(o)}var a=[n,2*(e-1)],i=Tn(t).as2D(n,e),s=Nn(t).as2D(n,e),u=i.slice([0,1],[n,e-2]).reverse(1),c=s.slice([0,1],[n,e-2]).reverse(1).mul(On(-1)),l=i.concat(u,1),h=s.concat(c,1);return r=Dn(l,h).as2D(a[0],a[1]),o=Yl(r),Tn(o)}}),Jl=Object.freeze({fft:Xl,ifft:Yl,rfft:$l,irfft:Ql});var Zl=An({sparseToDense_:function(t,e,n,r){void 0===r&&(r=0);var o=mn(t,"sparseIndices","sparseToDense","int32"),a=mn(e,"sparseValues","sparseToDense"),i=mn(r,"defaultValue","sparseToDense",a.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+t.dtype+".");if(t.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+t.shape+".");var o=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error("outputShape has incorrect number of elements:, "+n.length+", should be: "+a+".");var i=e.size;if(0!==e.rank&&(1!==e.rank||i!==o))throw new Error("sparseValues has incorrect shape "+e.shape+", should be [] or ["+o+"]");if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,a,n,i),Lt.runKernelFunc((function(t){return t.sparseToDense(o,a,n,i)}),{$sparseIndices:o,$sparseValues:a,$defaultValue:i})}});var th=An({gatherND_:function(t,e){var n=mn(e,"indices","gatherND","int32"),r=mn(t,"x","gatherND");return Lt.runKernelFunc((function(t){return t.gatherND(r,n)}),{x:r,indices:n},null,"GatherNd")}});var eh=An({diag_:function(t){var e=mn(t,"x","diag").flatten(),n=t.shape.concat(t.shape);return Lt.runKernelFunc((function(t){return t.diag(e)}),{$x:e}).reshape(n)}});var nh=An({dropout_:function(t,e,n,r){var o=mn(t,"x","dropout");if(C("float32"===o.dtype,(function(){return"x has to be a floating point tensor since it's going to be scaled, but got a "+o.dtype+" tensor instead."})),C(e>=0&&e<1,(function(){return"rate must be a float in the range [0, 1), but got "+e+"."})),0===e)return t instanceof wt?o.clone():o;var a=function(t,e){if(null==e)return t.shape.slice();if(S(t.shape,e))return e;if(t.shape.length===e.length){for(var n=[],r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(o,n),i=1-e,s=_r(a,0,1,"float32",r).add(i).floor().div(i);return o.mul(s)}});function rh(t,e,n){for(var r=1-t%2,o=new Float32Array(t),a=0;a<t;++a){var i=2*Math.PI*a/(t+r-1);o[a]=e-n*Math.cos(i)}return Mn(o,"float32")}var oh=An({hannWindow_:function(t){return rh(t,.5,.5)}}),ah=An({hammingWindow_:function(t){return rh(t,.54,.46)}}),ih=An({frame_:function(t,e,n,r,o){void 0===r&&(r=!1),void 0===o&&(o=0);for(var a=0,i=[];a+e<=t.size;)i.push(ml(t,a,e)),a+=n;if(r)for(;a<t.size;){var s=a+e-t.size,u=Yn([ml(t,a,e-s),Hn([s],o)]);i.push(u),a+=n}return 0===i.length?Bn([],[0,e]):Yn(i).as2D(i.length,e)}}),sh=An({stft_:function(t,e,n,r,o){var a;void 0===o&&(o=oh),null==r&&(a=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(a)/Math.log(2)))));for(var i=ih(t,e,n),s=gc(i,o(e)),u=[],c=0;c<i.shape[0];c++)u.push($l(s.slice([c,0],[1,e]),r));return Yn(u)}}),uh=Object.freeze({hannWindow:oh,hammingWindow:ah,frame:ih,stft:sh});var ch,lh=function(t,e,o){return void 0===o&&(o=1),n(this,void 0,void 0,(function(){var n,a,i,s,u,c,l,h,f,d,p,v,m,g;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"predictions","inTopK"),a=mn(e,"targets","inTopK"),C(n.rank>1,(function(){return"inTopK() expects the predictions to be of rank 2 or higher, but got "+n.rank})),C(n.rank-1===a.rank,(function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+n.rank+" and targets rank "+a.rank})),E(n.shape.slice(0,n.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),i=n.shape[n.shape.length-1],C(o>0&&o<=i,(function(){return"'k' passed to inTopK() must be > 0 && <= the predictions last dimension ("+i+"), but got "+o})),[4,n.data()];case 1:return s=r.sent(),[4,a.data()];case 2:for(u=r.sent(),c=[s.length/i,i],h=c[1],f=B("bool",l=c[0]),d=0;d<l;d++){for(p=d*h,v=s.subarray(p,p+h),m=[],g=0;g<v.length;g++)m.push({value:v[g],index:g});for(m.sort((function(t,e){return e.value-t.value})),f[d]=0,g=0;g<o;g++)if(m[g].index===u[d]){f[d]=1;break}}return t!==n&&n.dispose(),e!==a&&a.dispose(),[2,Fn(f,a.shape,"bool")]}}))}))};!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ch||(ch={}));var hh=An({absoluteDifference_:function(t,e,n,r){void 0===r&&(r=ch.SUM_BY_NONZERO_WEIGHTS);var o=mn(t,"labels","absoluteDifference"),a=mn(e,"predictions","absoluteDifference"),i=null;null!=n&&(i=mn(n,"weights","absoluteDifference")),E(o.shape,a.shape,"Error in absoluteDifference: ");var s=o.sub(a).abs();return fh(s,i,r)}}),fh=An({computeWeightedLoss_:function(t,e,n){void 0===n&&(n=ch.SUM_BY_NONZERO_WEIGHTS);var r=mn(t,"losses","computeWeightedLoss"),o=null;null!=e&&(o=mn(e,"weights","computeWeightedLoss"));var a=null==o?r:r.mul(o);if(n===ch.NONE)return a;if(n===ch.SUM)return a.sum();if(n===ch.MEAN){if(null==o)return a.mean();var i=r.size/o.size,s=a.sum().div(o.sum());return i>1?s.div(On(i)):s}if(n===ch.SUM_BY_NONZERO_WEIGHTS){if(null==o)return a.sum().div(On(r.size));var u=o.mul(zn(r.shape)).notEqual(On(0)).sum().toFloat();return a.sum().div(u)}throw Error("Unknown reduction: "+n)}}),dh=An({cosineDistance_:function(t,e,n,r,o){void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"labels","cosineDistance"),i=mn(e,"predictions","cosineDistance"),s=null;null!=r&&(s=mn(r,"weights","cosineDistance")),E(a.shape,i.shape,"Error in cosineDistance: ");var u=On(1).sub(a.mul(i).sum(n,!0));return fh(u,s,o)}}),ph=An({hingeLoss_:function(t,e,n,r){void 0===r&&(r=ch.SUM_BY_NONZERO_WEIGHTS);var o=mn(t,"labels","hingeLoss"),a=mn(e,"predictions","hingeLoss"),i=null;null!=n&&(i=mn(n,"weights","hingeLoss")),E(o.shape,a.shape,"Error in hingeLoss: ");var s=On(1);o=On(2).mul(o).sub(s);var u=s.sub(o.mul(a)).relu();return fh(u,i,r)}}),vh=An({huberLoss_:function(t,e,n,r,o){void 0===r&&(r=1),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"labels","huberLoss"),i=mn(e,"predictions","huberLoss"),s=null;null!=n&&(s=mn(n,"weights","huberLoss")),E(a.shape,i.shape,"Error in huberLoss: ");var u=On(r),c=i.sub(a).abs(),l=dc(c,u),h=c.sub(l),f=On(.5).mul(l.square()).add(u.mul(h));return fh(f,s,o)}}),mh=An({logLoss_:function(t,e,n,r,o){void 0===r&&(r=1e-7),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"labels","logLoss"),i=mn(e,"predictions","logLoss"),s=null;null!=n&&(s=mn(n,"weights","logLoss")),E(a.shape,i.shape,"Error in logLoss: ");var u=On(1),c=On(r),l=a.mul(i.add(c).log()).neg().sub(u.sub(a).mul(u.sub(i).add(c).log()));return fh(l,s,o)}}),gh=An({meanSquaredError_:function(t,e,n,r){void 0===r&&(r=ch.SUM_BY_NONZERO_WEIGHTS);var o=mn(t,"labels","meanSquaredError"),a=mn(e,"predictions","meanSquaredError"),i=null;null!=n&&(i=mn(n,"weights","meanSquaredError")),E(o.shape,a.shape,"Error in meanSquaredError: ");var s=o.squaredDifference(a);return fh(s,i,r)}}),yh=An({sigmoidCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"multiClassLabels","sigmoidCrossEntropy"),i=mn(e,"logits","sigmoidCrossEntropy"),s=null;if(null!=n&&(s=mn(n,"weights","sigmoidCrossEntropy")),E(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){var u=On(r),c=On(1),l=On(.5);a=a.mul(c.sub(u)).add(l.mul(u))}var h=function(t,e){var n=mn(t,"labels","sigmoidCrossEntropyWithLogits"),r=mn(e,"logits","sigmoidCrossEntropyWithLogits");E(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");var o=r.relu(),a=r.mul(n),i=r.abs().neg().exp().log1p();return o.sub(a).add(i)}(a,i);return fh(h,s,o)}}),xh=An({softmaxCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"onehotLabels","softmaxCrossEntropy"),i=mn(e,"logits","softmaxCrossEntropy"),s=null;if(null!=n&&(s=mn(n,"weights","softmaxCrossEntropy")),E(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){var u=On(r),c=On(1),l=On(a.shape[1]);a=a.mul(c.sub(u)).add(u.div(l))}var h=function(t,e,n){if(void 0===n&&(n=-1),-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+e.rank+" and dim was "+n);return vo((function(t,e,r){var o=e.logSumExp([n],!0),a=e.toFloat().sub(o);r([t,a]);return{value:a.mul(t).neg().sum([n]),gradFunc:function(t,e){var r=e[0],o=e[1],a=wn(t.shape,[n]);return[t.reshape(a).mul(r.toFloat().sub(o.exp())),t.reshape(a).mul(o.exp().sub(r.toFloat()))]}}}))(t,e)}(a,i);return fh(h,s,o)}}),bh=Object.freeze({get Reduction(){return ch},absoluteDifference:hh,computeWeightedLoss:fh,cosineDistance:dh,hingeLoss:ph,huberLoss:vh,logLoss:mh,meanSquaredError:gh,sigmoidCrossEntropy:yh,softmaxCrossEntropy:xh});function wh(t,e){return void 0===e&&(e=!1),Lt.tidy((function(){if(2!==t.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+t.shape.length+"D Tensor.");for(var n=t.shape[0],r=t.shape[1],o=Cr(n),a=t.clone(),i=Bn([[1]],[1,1]),s=i.clone(),u=n>=r?r:n,c=function(t){var e,u=a,c=s,l=o;e=Lt.tidy((function(){var e=a.slice([t,t],[n-t,1]),u=e.norm(),c=a.slice([t,t],[1,1]),l=Bn([[-1]]).where(c.greater(0),Bn([[1]])),h=c.sub(l.mul(u)),f=e.div(h);s=1===f.shape[0]?i.clone():i.concat(f.slice([1,0],[f.shape[0]-1,f.shape[1]]),0);var d=l.matMul(h).div(u).neg(),p=a.slice([t,0],[n-t,r]),v=d.mul(s);if(0===t)a=p.sub(v.matMul(s.transpose().matMul(p)));else{var m=p.sub(v.matMul(s.transpose().matMul(p)));a=a.slice([0,0],[t,r]).concat(m,0)}var g=o.slice([0,t],[n,o.shape[1]-t]);if(0===t)o=g.sub(g.matMul(s).matMul(v.transpose()));else{var y=g.sub(g.matMul(s).matMul(v.transpose()));o=o.slice([0,0],[n,t]).concat(y,1)}return[s,a,o]})),s=e[0],a=e[1],o=e[2],tn([u,c,l])},l=0;l<u;++l)c(l);return!e&&n>r&&(o=o.slice([0,0],[n,r]),a=a.slice([0,0],[r,r])),[o,a]}))}var Ch=An({bandPart_:function(t,e,n){if(e%1!=0)throw new Error("bandPart(): numLower must be an integer, got "+e+".");if(n%1!=0)throw new Error("bandPart(): numUpper must be an integer, got "+n+".");var r=mn(t,"a","bandPart");if(r.rank<2)throw new Error("bandPart(): Rank must be at least 2, got "+r.rank+".");var o=r.shape,a=r.shape.slice(-2),i=a[0],s=a[1];if(!(e<=i))throw new Error("bandPart(): numLower ("+e+") must not be greater than the number of rows ("+i+").");if(!(n<=s))throw new Error("bandPart(): numUpper ("+n+") must not be greater than the number of columns ("+s+").");e<0&&(e=i),n<0&&(n=s);var u=Kn(0,i,1,"int32").reshape([-1,1]),c=Kn(0,s,1,"int32"),l=Cc(u,c),h=Qu(l.lessEqual(On(+e,"int32")),l.greaterEqual(On(-n,"int32"))),f=Gn([i,s],r.dtype);return Pr(Ur(r.reshape([-1,i,s])).map((function(t){return ec(h,t,f)}))).reshape(o)}}),Eh=An({gramSchmidt_:function(t){var e;if(Array.isArray(t)){e=!1,C(null!=t&&t.length>0,(function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"}));for(var n=t[0].shape[0],r=function(e){C(t[e].shape[0]===n,(function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+t[e].shape[0]+" vs. "+n+")"}))},o=1;o<t.length;++o)r(o)}else e=!0,t=tr(t,t.shape[0],0).map((function(t){return Br(t,[0])}));C(t.length<=t[0].shape[0],(function(){return"Gram-Schmidt: Number of vectors ("+t.length+") exceeds number of dimensions ("+t[0].shape[0]+")."}));var a=[],i=t,s=function(t){a.push(Lt.tidy((function(){var e=i[t];if(t>0)for(var n=0;n<t;++n){var r=Nl(a[n].mulStrict(e)).mul(a[n]);e=e.sub(r)}return e.div(Vl(e,"euclidean"))})))};for(o=0;o<t.length;++o)s(o);return e?Pr(a,0):a}}),Rh=An({qr_:function(t,e){if(void 0===e&&(e=!1),t.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+t.rank);if(2===t.rank)return wh(t,e);var n=t.shape.slice(0,t.shape.length-2).reduce((function(t,e){return t*e})),r=Ur(t.reshape([n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],a=[];return r.forEach((function(t){var n=wh(t,e),r=n[0],i=n[1];o.push(r),a.push(i)})),[Pr(o,0).reshape(t.shape),Pr(a,0).reshape(t.shape)]}}),Ih=Object.freeze({bandPart:Ch,gramSchmidt:Eh,qr:Rh});function kh(t,e,n,r,o,a){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==a&&(a=0);var i=t.shape[0];return n=Math.min(n,i),C(0<=r&&r<=1,(function(){return"iouThreshold must be in [0, 1], but was '"+r+"'"})),C(2===t.rank,(function(){return"boxes must be a 2D tensor, but was of rank '"+t.rank+"'"})),C(4===t.shape[1],(function(){return"boxes must have 4 columns, but 2nd dimension was "+t.shape[1]})),C(1===e.rank,(function(){return"scores must be a 1D tensor"})),C(e.shape[0]===i,(function(){return"scores has incompatible shape with boxes. Expected "+i+", but was "+e.shape[0]})),C(0<=a&&a<=1,(function(){return"softNmsSigma must be in [0, 1], but was '"+a+"'"})),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o,softNmsSigma:a}}var Sh=An({resizeBilinear_:function(t,e,n){void 0===n&&(n=!1);var r=mn(t,"images","resizeBilinear");C(3===r.rank||4===r.rank,(function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+r.rank+"."})),C(2===e.length,(function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+e+"."}));var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Lt.runKernelFunc((function(t,e){return e([o]),t.resizeBilinear(o,i,s,n)}),{x:o},(function(t,e){return{x:function(){return Lt.runKernelFunc((function(r){return r.resizeBilinearBackprop(t,e[0],n)}),{})}}}),"ResizeBilinear",{alignCorners:n,newHeight:i,newWidth:s});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),Ah=An({resizeNearestNeighbor_:function(t,e,n){void 0===n&&(n=!1);var r=mn(t,"images","resizeNearestNeighbor");C(3===r.rank||4===r.rank,(function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+r.rank+"."})),C(2===e.length,(function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."})),C("float32"===r.dtype||"int32"===r.dtype,(function(){return"`images` must have `int32` or `float32` as dtype"}));var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Lt.runKernelFunc((function(t,e){return e([o]),t.resizeNearestNeighbor(o,i,s,n)}),{batchImages:o},(function(t,e){return{batchImages:function(){return Lt.runKernelFunc((function(r){return r.resizeNearestNeighborBackprop(t,e[0],n)}),{})}}}));return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),Dh=An({nonMaxSuppression_:function(t,e,n,r,o){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY);var a=mn(t,"boxes","nonMaxSuppression"),i=mn(e,"scores","nonMaxSuppression"),s=kh(a,i,n,r,o);n=s.maxOutputSize,r=s.iouThreshold,o=s.scoreThreshold;var u={maxOutputSize:n,iouThreshold:r,scoreThreshold:o};return Lt.runKernelFunc((function(t){return t.nonMaxSuppression(a,i,n,r,o)}),{boxes:a,scores:i},null,"NonMaxSuppressionV3",u)}}),Th=function(t,e,o,a,i){return void 0===a&&(a=.5),void 0===i&&(i=Number.NEGATIVE_INFINITY),n(this,void 0,void 0,(function(){var n,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"boxes","nonMaxSuppressionAsync"),s=mn(e,"scores","nonMaxSuppressionAsync"),u=kh(n,s,o,a,i),o=u.maxOutputSize,a=u.iouThreshold,i=u.scoreThreshold,[4,Promise.all([n.data(),s.data()])];case 1:return c=r.sent(),l=c[0],h=c[1],f=jo(l,h,o,a,i),n!==t&&n.dispose(),s!==e&&s.dispose(),[2,f]}}))}))},Nh=An({nonMaxSuppressionWithScore_:function(t,e,n,r,o,a){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY),void 0===a&&(a=0);var i=mn(t,"boxes","nonMaxSuppression"),s=mn(e,"scores","nonMaxSuppression"),u=kh(i,s,n,r,o,a),c={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:o=u.scoreThreshold,softNmsSigma:a=u.softNmsSigma},l=Lt.runKernel("NonMaxSuppressionV5",{boxes:i,scores:s},c);return{selectedIndices:l[0],selectedScores:l[1]}}}),Fh=function(t,e,o,a,i,s){return void 0===a&&(a=.5),void 0===i&&(i=Number.NEGATIVE_INFINITY),void 0===s&&(s=0),n(this,void 0,void 0,(function(){var n,u,c,l,h,f,d;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"boxes","nonMaxSuppressionAsync"),u=mn(e,"scores","nonMaxSuppressionAsync"),c=kh(n,u,o,a,i,s),o=c.maxOutputSize,a=c.iouThreshold,i=c.scoreThreshold,s=c.softNmsSigma,[4,Promise.all([n.data(),u.data()])];case 1:return l=r.sent(),h=l[0],f=l[1],d=Xo(h,f,o,a,i,s),n!==t&&n.dispose(),u!==e&&u.dispose(),[2,d]}}))}))},_h=An({cropAndResize_:function(t,e,n,r,o,a){var i=mn(t,"image","cropAndResize"),s=mn(e,"boxes","cropAndResize","float32"),u=mn(n,"boxInd","cropAndResize","int32");o=o||"bilinear",a=a||0;var c=s.shape[0];return C(4===i.rank,(function(){return"Error in cropAndResize: image must be rank 4,but got rank "+i.rank+"."})),C(2===s.rank&&4===s.shape[1],(function(){return"Error in cropAndResize: boxes must be have size ["+c+",4] but had shape "+s.shape+"."})),C(1===u.rank&&u.shape[0]===c,(function(){return"Error in cropAndResize: boxInd must be have size ["+c+"] but had shape "+s.shape+"."})),C(2===r.length,(function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."})),C(r[0]>=1&&r[1]>=1,(function(){return"cropSize must be atleast [1,1], but was "+r})),C("bilinear"===o||"nearest"===o,(function(){return"method must be bilinear or nearest, but was "+o})),Lt.runKernelFunc((function(t,e){return t.cropAndResize(i,s,u,r,o,a)}),{images:i,boxes:s,boxInd:u},null,"CropAndResize",{method:o,extrapolationValue:a,cropSize:r})}}),Oh=Object.freeze({resizeBilinear:Sh,resizeNearestNeighbor:Ah,nonMaxSuppression:Dh,nonMaxSuppressionAsync:Th,nonMaxSuppressionWithScore:Nh,nonMaxSuppressionWithScoreAsync:Fh,cropAndResize:_h}),Mh=function(t,e){return!(t>0)||"linear"===e},Bh=function(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return t.mul(e.step());throw new Error("Gradient for activation "+n+" has not been implemented yet.")},Ph=function(t,e){var n=e,r=Eo(t.shape,e.shape);return r.length>0&&(n=n.sum(r)),n.reshape(t.shape)},Lh=function(t,e,n){if("linear"===e)return t;if("relu"===e)return Bl(t);if("elu"===e)return _l(t);if("relu6"===e)return Pl(t);if("prelu"===e)return Ml(t,n);throw new Error("Unknown fused activation "+e+".")};var Wh=An({fusedMatMul_:function(t){var e,n=t.a,r=t.b,o=t.transposeA,a=void 0!==o&&o,i=t.transposeB,s=void 0!==i&&i,u=t.bias,c=t.activation,l=void 0===c?"linear":c,h=t.preluActivationWeights;if(!1===Mh(Lt.state.gradientDepth,l)){var f=el(n,r,a,s);return null!=u&&(f=rc(f,u)),Lh(f,l,h)}var d=mn(n,"a","fused matMul"),p=mn(r,"b","fused matMul");e=Nt(d,p),d=e[0],p=e[1];var v=a?d.shape[d.rank-2]:d.shape[d.rank-1],m=s?p.shape[p.rank-1]:p.shape[p.rank-2],g=a?d.shape[d.rank-1]:d.shape[d.rank-2],y=s?p.shape[p.rank-2]:p.shape[p.rank-1],x=d.shape.slice(0,-2),b=p.shape.slice(0,-2),w=k(x),E=k(b);C(d.rank>=2&&p.rank>=2&&d.rank===p.rank,(function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+d.rank+" and "+p.rank+"."})),C(S(x,b),(function(){return"Error in fused matMul: outer dimensions ("+x+") and ("+b+") of Tensors with shapes "+d.shape+" and "+p.shape+" must match."})),C(v===m,(function(){return"Error in fused matMul: inner shapes ("+v+") and ("+m+") of Tensors with shapes "+d.shape+" and "+p.shape+" and transposeA="+a+" and transposeB="+s+" must match."}));var R,I,A=d.shape.slice(0,-2).concat([g,y]),D=a?d.as3D(w,v,g):d.as3D(w,g,v),T=s?p.as3D(E,y,m):p.as3D(E,m,y);null!=u&&Ro(A,(R=Nt(R=mn(u,"bias","fused matMul"),d)[0]).shape),null!=h&&(I=mn(h,"prelu weights","fused matMul"));var N={a:D,b:T};null!=u&&(N.bias=R),null!=h&&(N.preluActivationWeights=I);var F=[D,T];return Lt.runKernelFunc((function(t,e){var n=t.fusedBatchMatMul({a:D,b:T,transposeA:a,transposeB:s,bias:R,activation:l,preluActivationWeights:I});return e([D,T,n]),n}),N,(function(t,e){var n=e[0],r=e[1],o=e[2],i=Bh(t,o,l),c={};return null!=u&&(c={bias:function(){return Ph(R,i)}}),a||s?!a&&s?Object.assign({a:function(){return i.matMul(r,!1,!1)},b:function(){return i.matMul(n,!0,!1)}},c):a&&!s?Object.assign({a:function(){return r.matMul(i,!1,!0)},b:function(){return n.matMul(i,!1,!1)}},c):Object.assign({a:function(){return r.matMul(i,!0,!0)},b:function(){return i.matMul(n,!0,!0)}},c):Object.assign({a:function(){return i.matMul(r,!1,!0)},b:function(){return n.matMul(i,!0,!1)}},c)}),"_FusedMatMul",{transposeA:a,transposeB:s,activation:l},F,[!0]).reshape(A)}}),Uh=An({fusedConv2d_:function(t){var e=t.x,n=t.filter,r=t.strides,o=t.pad,a=t.dataFormat,i=void 0===a?"NHWC":a,s=t.dilations,u=void 0===s?[1,1]:s,c=t.dimRoundingMode,l=t.bias,h=t.activation,f=void 0===h?"linear":h,d=t.preluActivationWeights;if(f=f||"linear",!1===Mh(Lt.state.gradientDepth,f)){var p=qc(e,n,r,o,i,u,c);return null!=l&&(p=rc(p,l)),Lh(p,f,d)}var v=mn(e,"x","conv2d"),m=mn(n,"filter","conv2d"),g=v,y=!1;3===v.rank&&(y=!0,g=v.as4D(1,v.shape[0],v.shape[1],v.shape[2])),C(4===g.rank,(function(){return"Error in fused conv2d: input must be rank 4, but got rank "+g.rank+"."})),C(4===m.rank,(function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+m.rank+"."})),null!=c&&C(A(o),(function(){return"Error in fused conv2d: pad must be an integer when using, dimRoundingMode "+c+" but got pad "+o+"."})),C(g.shape[3]===m.shape[2],(function(){return"Error in conv2d: depth of input ("+g.shape[3]+") must match input depth for filter "+m.shape[2]+"."})),C(Mo(r,u),(function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+u+"'"})),C("NHWC"===i,(function(){return"Error in conv2d: got dataFormat of "+i+" but only NHWC is currently supported."}));var x,b,w=So(g.shape,m.shape,r,u,o,c);null!=l&&(x=Nt(x=mn(l,"bias","fused conv2d"),v)[0],Ro(w.outShape,x.shape)),null!=d&&(b=mn(d,"prelu weights","fused conv2d"));var E={x:g,filter:m};null!=l&&(E.bias=x),null!=d&&(E.preluActivationWeights=b);var R=[m,g],I=Lt.runKernelFunc((function(t,e){var n=t.fusedConv2d({input:g,filter:m,convInfo:w,bias:x,activation:f,preluActivationWeights:b});return e([m,g,n]),n}),E,(function(t,e){var n=e,a=n[0],i=n[1],s=n[2],c=Bh(t,s,f);C(Oo(u),(function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+u+"'"}));var h={};return null!=l&&(h={bias:function(){return Ph(x,c)}}),Object.assign({x:function(){return Xc(i.shape,c,a,r,o)},filter:function(){return jc(i,c,a.shape,r,o)}},h)}),"FusedConv2D",{convInfo:w,activation:f},R,[!0]);return y?I.as3D(I.shape[1],I.shape[2],I.shape[3]):I}}),Vh=An({fusedDepthwiseConv2d_:function(t){var e=t.x,n=t.filter,r=t.strides,o=t.pad,a=t.dataFormat,i=void 0===a?"NHWC":a,s=t.dilations,u=void 0===s?[1,1]:s,c=t.dimRoundingMode,l=t.bias,h=t.activation,f=void 0===h?"linear":h,d=t.preluActivationWeights;if(!1===Mh(Lt.state.gradientDepth,f)){var p=Yc(e,n,r,o,i,u,c);return null!=l&&(p=rc(p,l)),Lh(p,f,d)}var v=mn(e,"x","depthwiseConv2d"),m=mn(n,"filter","depthwiseConv2d"),g=v,y=!1;3===v.rank&&(y=!0,g=v.as4D(1,v.shape[0],v.shape[1],v.shape[2])),C(4===g.rank,(function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+g.rank+"."})),C(4===m.rank,(function(){return"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+m.rank+"."})),C(g.shape[3]===m.shape[2],(function(){return"Error in fused depthwiseConv2d: number of input channels ("+g.shape[3]+") must match the inChannels dimension in filter "+m.shape[2]+"."})),null==u&&(u=[1,1]),C(Mo(r,u),(function(){return"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+u+"'"})),null!=c&&C(A(o),(function(){return"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode "+c+" but got pad "+o+"."}));var x,b,w=So(g.shape,m.shape,r,u,o,c,!0);null!=l&&(x=Nt(x=mn(l,"bias","fused conv2d"),v)[0],Ro(w.outShape,x.shape)),null!=d&&(b=mn(d,"prelu weights","fused depthwiseConv2d"));var E={x:g,filter:m};null!=l&&(E.bias=x),null!=d&&(E.preluActivationWeights=b);var R=[m,g],I=Lt.runKernelFunc((function(t,e){var n=t.fusedDepthwiseConv2D({input:g,filter:m,convInfo:w,bias:x,activation:f,preluActivationWeights:b});return e([m,g,n]),n}),E,(function(t,e){C(Oo(u),(function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+u+"'"}));var n=e[0],r=e[1],o=e[2],a=Bh(t,o,f),i={};return null!=l&&(i={bias:function(){return Ph(x,a)}}),Object.assign({x:function(){return $c(r.shape,a,n,w)},filter:function(){return Qc(r,a,n.shape,w)}},i)}),"FusedDepthwiseConv2D",{convInfo:w,activation:f},R,[!0]);return y?I.as3D(I.shape[1],I.shape[2],I.shape[3]):I}}),zh=Object.freeze({matMul:Wh,conv2d:Uh,depthwiseConv2d:Vh}),Gh=Object.freeze({image:Oh,linalg:Ih,losses:bh,spectral:Jl,fused:zh,signal:uh,square:tu,squaredDifference:nu,conv1d:Hc,conv2d:qc,conv3d:Kc,depthwiseConv2d:Yc,separableConv2d:Jc,conv2dTranspose:Zc,conv3dTranspose:tl,op:An,batchNormalization2d:Gu,batchNormalization3d:Hu,batchNormalization4d:qu,batchNormalization:Ku,batchNorm:ju,batchNorm2d:Xu,batchNorm3d:Yu,batchNorm4d:$u,booleanMaskAsync:Uc,complex:Dn,real:Tn,imag:Nn,concat:Yn,concat1d:$n,concat2d:Qn,concat3d:Jn,concat4d:Zn,split:tr,matMul:el,dot:nl,outerProduct:rl,reverse:ol,reverse1d:al,reverse2d:il,reverse3d:sl,reverse4d:ul,maxPool:hl,avgPool:fl,pool:dl,maxPool3d:pl,avgPool3d:vl,slice:ml,slice1d:gl,slice2d:yl,slice3d:xl,slice4d:bl,abs:ru,acos:ou,acosh:au,asin:iu,asinh:su,atan:uu,atanh:cu,ceil:lu,clipByValue:hu,cos:fu,cosh:du,erf:pu,exp:vu,expm1:mu,floor:gu,log:yu,log1p:xu,logSigmoid:bu,neg:wu,reciprocal:Cu,round:Eu,rsqrt:Ru,sigmoid:Iu,sign:ku,isNaN:Su,isInf:Au,isFinite:Du,sin:Tu,sinh:Nu,softplus:Fu,sqrt:_u,step:Ou,tan:Mu,tanh:Bu,all:Cl,any:El,argMax:Rl,argMin:Il,logSumExp:kl,max:Sl,mean:Al,min:Dl,moments:Tl,sum:Nl,prod:Fl,equal:Rc,equalStrict:Ic,greater:kc,greaterEqual:Sc,greaterEqualStrict:Ac,greaterStrict:Dc,less:Tc,lessEqual:Nc,lessEqualStrict:Fc,lessStrict:_c,notEqual:Oc,notEqualStrict:Mc,add:rc,addN:oc,addStrict:ac,atan2:ic,div:sc,divNoNan:uc,divStrict:cc,floorDiv:lc,maximum:hc,maximumStrict:fc,minimum:dc,minimumStrict:pc,mod:vc,modStrict:mc,mul:gc,mulStrict:yc,pow:xc,powStrict:bc,squaredDifferenceStrict:wc,sub:Cc,subStrict:Ec,elu:_l,leakyRelu:Ol,prelu:Ml,relu:Bl,relu6:Pl,selu:Ll,logicalAnd:Qu,logicalNot:Ju,logicalOr:Zu,logicalXor:tc,where:ec,whereAsync:nc,buffer:dr,print:pr,batchToSpaceND:vr,broadcastTo:mr,cast:gr,clone:yr,cumsum:xr,depthToSpace:br,expandDims:wr,eye:Cr,multinomial:Er,oneHot:Rr,pad:Ir,pad1d:kr,pad2d:Sr,pad3d:Ar,pad4d:Dr,rand:Tr,randomNormal:Nr,randomGamma:Fr,randomUniform:_r,reshape:Or,spaceToBatchND:Mr,squeeze:Br,stack:Pr,tile:Lr,truncatedNormal:Wr,unstack:Ur,setdiff1dAsync:Vr,fill:Hn,linspace:qn,ones:zn,range:Kn,scalar:On,tensor:Fn,tensor1d:Mn,tensor2d:Bn,tensor3d:Pn,tensor4d:Ln,tensor5d:Wn,tensor6d:Un,variable:Vn,zeros:Gn,onesLike:jn,zerosLike:Xn,transpose:Wl,softmax:go,logSoftmax:yo,localResponseNormalization:Ul,norm:Vl,gather:Lc,unsortedSegmentSum:Wc,basicLSTMCell:zl,multiRNNCell:Gl,movingAverage:Hl,stridedSlice:ql,topk:Kl,scatterND:jl,fft:Xl,ifft:Yl,rfft:$l,irfft:Ql,sparseToDense:Zl,gatherND:th,diag:eh,dropout:nh,hannWindow:oh,hammingWindow:ah,frame:ih,stft:sh,inTopKAsync:lh});function Hh(t,e){Array.isArray(t)||(t=[t]),t.forEach((function(t){null!=t&&C("complex64"!==t.dtype,(function(){return e+" does not support complex64 tensors."}))}))}function qh(t,e,n,r){if("linear"===n)return t.linear(e);if("relu"===n)return t.relu(e);if("elu"===n)return t.elu(e);if("relu6"===n)return t.relu6(e);if("prelu"===n)return t.prelu(e,r);throw new Error("Activation "+n+" has not been implemented for the CPU backend.")}var Kh=function(t){function o(){var e=t.call(this)||this;return e.blockSize=48,e.firstUse=!0,e.data=new xo(e,Lt),e}return e(o,t),o.prototype.write=function(t,e,n){this.firstUse&&(this.firstUse=!1,i().get("IS_NODE")&&dn("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var r={};return this.data.set(r,{values:t,dtype:n}),r},o.prototype.move=function(t,e,n,r){this.data.set(t,{values:e,dtype:r})},o.prototype.numDataIds=function(){return this.data.numDataIds()},o.prototype.read=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){return[2,this.readSync(t)]}))}))},o.prototype.readSync=function(t){var e=this.data.get(t),n=e.dtype,r=e.complexTensors;return"complex64"===n?Vo(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.data.get(t).values},o.prototype.bufferSync=function(t){var e=this.readSync(t.dataId),n=e;if("string"===t.dtype)try{n=e.map((function(t){return ot(t)}))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return dr(t.shape,t.dtype,n)},o.prototype.makeOutput=function(t,e,n){var r=this.write(t,e,n);return Lt.makeTensorFromDataId(r,e,n,this)},o.prototype.disposeData=function(t){if(this.data.has(t)){var e=this.data.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}},o.prototype.time=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){return e=et(),t(),[2,{kernelMs:et()-e}]}))}))},o.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},o.prototype.complex=function(t,e){var n=this.makeOutput(null,t.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:Lt.keep(t.clone()),imag:Lt.keep(e.clone())},n},o.prototype.real=function(t){return this.data.get(t.dataId).complexTensors.real.clone()},o.prototype.imag=function(t){return this.data.get(t.dataId).complexTensors.imag.clone()},o.prototype.slice=function(t,e,n){if(Hh(t,"slice"),io(t.shape,e,n)){var r=so(e,t.strides),o=k(n);return Fn(this.readSync(t.dataId).subarray(r,r+o),n,t.dtype)}for(var a=dr(n,t.dtype),i=this.bufferSync(t),s=0;s<a.size;++s){var u=a.indexToLoc(s).map((function(t,n){return t+e[n]}));a.values[s]=i.get.apply(i,u)}return a.toTensor()},o.prototype.stridedSlice=function(t,e,n,r){Hh(t,"stridedSlice");var o=ro(e,n,r);if(o.some((function(t){return 0===t})))return Fn([],o);for(var a=dr(o,t.dtype),i=this.bufferSync(t),s=0;s<a.size;s++){for(var u=a.indexToLoc(s),c=new Array(u.length),l=0;l<c.length;l++)c[l]=u[l]*r[l]+e[l];a.set.apply(a,[i.get.apply(i,c)].concat(u))}return a.toTensor()},o.prototype.diag=function(t){for(var e=this.readSync(t.dataId),n=dr([t.size,t.size],t.dtype),r=n.values,o=0;o<e.length;o++)r[o*t.size+o]=e[o];return n.toTensor()},o.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},o.prototype.reverse=function(t,e){Hh(t,"reverse");for(var n=dr(t.shape,t.dtype),r=this.bufferSync(t),o=function(o){var a=n.indexToLoc(o),i=a.slice();e.forEach((function(e){return i[e]=t.shape[e]-1-i[e]})),n.set.apply(n,[r.get.apply(r,i)].concat(a))},a=0;a<n.size;a++)o(a);return n.toTensor()},o.prototype.concat=function(t,e){var n=this;if("complex64"===t[0].dtype){var r=t.map((function(t){return Tn(t)})),o=t.map((function(t){return Nn(t)}));return Dn(this.concat(r,e),this.concat(o,e))}var a=t.map((function(t){var n=k(t.shape.slice(e));return t.as2D(-1,n)})),i=Sn(a.map((function(t){return t.shape})),1),s=dr(i,t[0].dtype).values;if(1===a[0].shape[0]){var u=0;a.forEach((function(t){s.set(n.readSync(t.dataId),u),u+=t.size}))}else{var c=0;a.forEach((function(t){for(var e=n.readSync(t.dataId),r=0,o=0;o<t.shape[0];++o)for(var a=o*i[1]+c,u=0;u<t.shape[1];++u)s[a+u]=e[r++];c+=t.shape[1]}))}var l=Sn(t.map((function(t){return t.shape})),e);return Fn(s,l,t[0].dtype)},o.prototype.neg=function(t){return Hh(t,"neg"),this.multiply(On(-1),t)},o.prototype.add=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(function(t,e,n,r){return{real:t+n,imag:e+r}})):this.broadcastedBinaryOp(t,e,Dt(t.dtype,e.dtype),(function(t,e){return t+e}))},o.prototype.addN=function(t){var e=this;Hh(t,"addN");for(var n=t.map((function(t){return e.readSync(t.dataId)})),r=dr(t[0].shape,t[0].dtype),o=r.values,a=0;a<t.length;a++)for(var i=n[a],s=0;s<o.length;s++)o[s]+=i[s];return r.toTensor()},o.prototype.softmax=function(t,e){var n=O([e],t.shape),r=this.max(t,n),o=wn(r.shape,n),a=this.subtract(t,r.reshape(o)),i=this.exp(a),s=this.sum(i,n).reshape(o);return this.realDivide(i,s)},o.prototype.subtract=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(function(t,e,n,r){return{real:t-n,imag:e-r}})):this.broadcastedBinaryOp(t,e,Dt(t.dtype,e.dtype),(function(t,e){return t-e}))},o.prototype.pow=function(t,e){return Hh([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.pow(t,e)}))},o.prototype.batchMatMul=function(t,e,n,r){Hh([t,e],"matMul");for(var o=n?t.shape[1]:t.shape[2],a=n?t.shape[2]:t.shape[1],i=r?e.shape[1]:e.shape[2],s=t.shape[0],u=this.readSync(t.dataId),c=this.readSync(e.dataId),l=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],h=l[0],f=l[1],d=l[2],p=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],v=p[0],m=p[1],g=p[2],y=a*i,x=dr([s,a,i],t.dtype),b=x.values,w=this.blockSize,C=0;C<s;C++)for(var E=0;E<a;E+=w)for(var R=0;R<i;R+=w)for(var I=0;I<o;I+=w)for(var k=Math.min(E+w,a),S=Math.min(R+w,i),A=Math.min(I+w,o),D=E;D<k;D++)for(var T=R;T<S;T++){for(var N=0,F=I;F<A;F++)N+=u[C*h+D*f+F*d]*c[F*v+T*m+C*g];b[C*y+(D*i+T)]+=N}return x.toTensor()},o.prototype.fusedBatchMatMul=function(t){var e=t.a,n=t.b,r=t.transposeA,o=t.transposeB,a=t.bias,i=t.activation,s=t.preluActivationWeights,u=this.batchMatMul(e,n,r,o);return a&&(u=this.add(u,a)),i&&(u=qh(this,u,i,s)),u},o.prototype.multiply=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(function(t,e,n,r){return{real:t*n-e*r,imag:t*r+e*n}})):this.broadcastedBinaryOp(t,e,Dt(t.dtype,e.dtype),(function(t,e){return t*e}))},o.prototype.realDivide=function(t,e){Hh([t,e],"realDivide");return this.broadcastedBinaryOp(t,e,"float32",(function(t,e){return t/e}))},o.prototype.floorDiv=function(t,e){Hh([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",(function(t,e){return Math.floor(t/e)}))},o.prototype.sum=function(t,e){Hh(t,"sum"),Cn("sum",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,Dt(t.dtype,"int32")),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=0,f=0;f<i;++f)h+=u[l+f];s[c]=h}return a},o.prototype.prod=function(t,e){Hh(t,"sum");for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,Dt(t.dtype,"int32")),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=1,f=0;f<i;++f)h*=u[l+f];s[c]=h}return a},o.prototype.unsortedSegmentSum=function(t,e,n){Hh(t,"unsortedSegmentSum");for(var r=[],o=t.rank-e.rank,a=0;a<o;++a)e=e.expandDims(a+1);for(a=0;a<n;++a){var i=On(a,"int32"),s=Rc(i,e).asType("float32").mul(t).sum(0);r.push(s)}return Pr(r)},o.prototype.argMin=function(t,e){Hh(t,"argMin");var n=[e];Cn("argMin",n,t.rank);for(var r=bn(t.shape,n),o=r[0],a=r[1],i=Gn(o,"int32"),s=k(a),u=this.readSync(i.dataId),c=this.readSync(t.dataId),l=0;l<u.length;++l){for(var h=l*s,f=c[h],d=0,p=0;p<s;++p){var v=c[h+p];v<f&&(f=v,d=p)}u[l]=d}return i},o.prototype.argMax=function(t,e){Hh(t,"argMax");var n=[e];Cn("argMax",n,t.rank);for(var r=bn(t.shape,n),o=r[0],a=r[1],i=Gn(o,"int32"),s=k(a),u=this.readSync(i.dataId),c=this.readSync(t.dataId),l=0;l<u.length;++l){for(var h=l*s,f=c[h],d=0,p=0;p<s;++p){var v=c[h+p];v>f&&(f=v,d=p)}u[l]=d}return i},o.prototype.cumsum=function(t,e,n,r){if(Hh(t,"cumsum"),e!==t.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(t.rank-1)+" but got axis="+e);for(var o=Dt(t.dtype,"int32"),a=Gn(t.shape,o),i=this.readSync(a.dataId),s=this.readSync(t.dataId),u=t.shape[t.rank-1],c=r?function(t,e){return t+u-e-1}:function(t,e){return t+e},l=0;l<s.length;l+=u)for(var h=0;h<u;h++){var f=c(l,h);if(0===h)i[f]=n?0:s[f];else{var d=c(l,h-1);i[f]=n?s[d]+i[d]:s[f]+i[d]}}return a},o.prototype.equal=function(t,e){return Hh([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t===e?1:0}))},o.prototype.notEqual=function(t,e){return Hh([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t!==e?1:0}))},o.prototype.less=function(t,e){return Hh([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t<e?1:0}))},o.prototype.lessEqual=function(t,e){return Hh([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t<=e?1:0}))},o.prototype.greater=function(t,e){return Hh([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t>e?1:0}))},o.prototype.greaterEqual=function(t,e){return Hh([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t>=e?1:0}))},o.prototype.logicalNot=function(t){Hh(t,"logicalNot");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e[r]?0:1;return this.makeOutput(n,t.shape,"bool")},o.prototype.logicalAnd=function(t,e){return Hh([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t&&e}))},o.prototype.logicalOr=function(t,e){return Hh([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t||e}))},o.prototype.select=function(t,e,n){Hh([t,e,n],"select");for(var r=this.readSync(t.dataId),o=this.readSync(e.dataId),a=this.readSync(n.dataId),i=Gn(e.shape,Dt(e.dtype,n.dtype)),s=this.readSync(i.dataId),u=0,c=0===t.rank||t.rank>1||1===e.rank?1:k(e.shape.slice(1)),l=0;l<r.length;l++)for(var h=0;h<c;h++)1===r[l]?s[u++]=o[l]:s[u++]=a[l];return i},o.prototype.where=function(t){Hh([t],"where");var e=this.readSync(t.dataId);return na(t.shape,e)},o.prototype.topk=function(t,e,n){return Hh(t,"topk"),ea(this.readSync(t.dataId),t.shape,t.dtype,e)},o.prototype.min=function(t,e){Hh(t,"min"),Cn("min",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];d<h&&(h=d)}s[c]=h}return a},o.prototype.minimum=function(t,e){return Hh([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.min(t,e)}))},o.prototype.mod=function(t,e){return Hh([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){var n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}))},o.prototype.max=function(t,e){Hh(t,"max"),Cn("max",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];d>h&&(h=d)}s[c]=h}return a},o.prototype.maximum=function(t,e){return Hh([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.max(t,e)}))},o.prototype.all=function(t,e){Hh(t,"all"),Cn("all",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];h=h&&d}s[c]=h}return a},o.prototype.any=function(t,e){Hh(t,"any"),Cn("any",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];h=h||d}s[c]=h}return a},o.prototype.squaredDifference=function(t,e){return Hh([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){var n=t-e;return n*n}))},o.prototype.ceil=function(t){Hh(t,"ceil");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.floor=function(t){Hh(t,"floor");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.sign=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)e[r]<0?n[r]=-1:e[r]>0?n[r]=1:n[r]=0;return this.makeOutput(n,t.shape,"float32")},o.prototype.isNaN=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")},o.prototype.isInf=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")},o.prototype.isFinite=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")},o.prototype.round=function(t){Hh(t,"round");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=Math.floor(e[r]);e[r]-o<.5?n[r]=Math.floor(e[r]):e[r]-o>.5?n[r]=Math.ceil(e[r]):n[r]=o%2==0?o:o+1}return this.makeOutput(n,t.shape,"float32")},o.prototype.exp=function(t){Hh(t,"exp");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.expm1=function(t){Hh(t,"expm1");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.log=function(t){Hh(t,"log");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.log1p=function(t){Hh(t,"log1p");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log1p(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.sqrt=function(t){Hh(t,"sqrt");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.sqrt(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.rsqrt=function(t){Hh(t,"rsqrt");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=1/Math.sqrt(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.reciprocal=function(t){Hh(t,"reciprocal");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=1/e[r];return this.makeOutput(n,t.shape,"float32")},o.prototype.linear=function(t){return t},o.prototype.relu=function(t){Hh(t,"relu");for(var e=Gn(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId),o=0;o<r.length;++o)n[o]=Math.max(0,r[o]);return e},o.prototype.relu6=function(t){Hh(t,"relu");for(var e=Gn(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId),o=0;o<r.length;++o)n[o]=Math.min(Math.max(0,r[o]),6);return e},o.prototype.prelu=function(t,e){return Hh([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return t<0?e*t:t}))},o.prototype.elu=function(t){Hh(t,"elu");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r){var o=n[r];e[r]=o>=0?o:Math.exp(o)-1}return this.makeOutput(e,t.shape,"float32")},o.prototype.eluDer=function(t,e){Hh([t,e],"eluDer");for(var n=new Float32Array(e.size),r=this.readSync(e.dataId),o=this.readSync(t.dataId),a=0;a<r.length;++a){var i=r[a];n[a]=i>=1?o[a]:o[a]*(i+1)}return this.makeOutput(n,e.shape,"float32")},o.prototype.selu=function(t){Hh(t,"selu");for(var e=bs,n=ws,r=new Float32Array(t.size),o=this.readSync(t.dataId),a=0;a<o.length;++a){var i=o[a];r[a]=i>=0?n*i:e*(Math.exp(i)-1)}return this.makeOutput(r,t.shape,"float32")},o.prototype.clip=function(t,e,n){Hh(t,"clip");for(var r=new Float32Array(t.size),o=this.readSync(t.dataId),a=0;a<o.length;++a){var i=o[a];r[a]=i>n?n:i<e?e:i}return this.makeOutput(r,t.shape,"float32")},o.prototype.abs=function(t){for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.complexAbs=function(t){for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<t.size;++r){var o=n[2*r],a=n[2*r+1];e[r]=Math.hypot(o,a)}return this.makeOutput(e,t.shape,"float32")},o.prototype.int=function(t){Hh(t,"int");for(var e=new Int32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=n[r];return this.makeOutput(e,t.shape,"int32")},o.prototype.sigmoid=function(t){Hh(t,"sigmoid");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return this.makeOutput(e,t.shape,"float32")},o.prototype.softplus=function(t){Hh(t,"softplus");for(var e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=this.readSync(t.dataId),o=0;o<r.length;++o){var a=r[o]>-e,i=r[o]<e,s=Math.exp(r[o]),u=void 0;u=i?s:a?r[o]:Math.log(1+s),n[o]=u}return this.makeOutput(n,t.shape,"float32")},o.prototype.sin=function(t){Hh(t,"sin");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.cos=function(t){Hh(t,"cos");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.tan=function(t){Hh(t,"tan");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.asin=function(t){Hh(t,"asin");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.acos=function(t){Hh(t,"acos");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.atan=function(t){Hh(t,"atan");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.atan2=function(t,e){return Hh([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.atan2(t,e)}))},o.prototype.sinh=function(t){Hh(t,"sinh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.cosh=function(t){Hh(t,"cosh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.tanh=function(t){Hh(t,"tanh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=D(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.asinh=function(t){Hh(t,"asinh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.acosh=function(t){Hh(t,"acosh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.atanh=function(t){Hh(t,"atanh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.erf=function(t){Hh(t,"erf");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r){var o=Math.sign(n[r]),a=Math.abs(n[r]),i=1/(1+.3275911*a);e[r]=o*(1-((((1.061405429*i-1.453152027)*i+1.421413741)*i-.284496736)*i+.254829592)*i*Math.exp(-a*a))}return this.makeOutput(e,t.shape,"float32")},o.prototype.step=function(t,e){void 0===e&&(e=0),Hh(t,"step");for(var n=new Float32Array(t.size),r=this.readSync(t.dataId),o=0;o<r.length;++o){var a=r[o];isNaN(a)?n[o]=NaN:n[o]=a>0?1:e}return this.makeOutput(n,t.shape,"float32")},o.prototype.fusedConv2d=function(t){var e=t.input,n=t.filter,r=t.convInfo,o=t.bias,a=t.activation,i=t.preluActivationWeights,s=this.conv2d(e,n,r);return o&&(s=this.add(s,o)),a&&(s=qh(this,s,a,i)),s},o.prototype.conv2d=function(t,e,n){Hh([t,e],"conv2d");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,c="channelsLast"===n.dataFormat,l=dr(n.outShape,t.dtype),h=t.strides[0],f=c?t.strides[1]:t.strides[2],d=c?t.strides[2]:1,p=c?1:t.strides[1],v=l.strides[0],m=c?l.strides[1]:l.strides[2],g=c?l.strides[2]:1,y=c?1:l.strides[1],x=this.readSync(t.dataId),b=this.readSync(e.dataId),w=l.values,C=0;C<n.batchSize;++C)for(var E=C*h,R=C*v,I=0;I<n.outHeight;++I)for(var k=R+I*m,S=I*n.strideHeight-u,A=0;A<r;A++){var D=S+A*a;if(!(D<0||D>=n.inHeight))for(var T=A*e.strides[0],N=E+D*f,F=0;F<n.outWidth;++F)for(var _=k+F*g,O=F*n.strideWidth-s,M=0;M<o;M++){var B=O+M*i;if(!(B<0||B>=n.inWidth))for(var P=N+B*d,L=T+M*e.strides[1],W=0;W<n.inChannels;++W){for(var U=x[P+W*p],V=0;V<n.outChannels;++V)w[_+V*y]+=U*b[L+V];L+=n.outChannels}}}return l.toTensor()},o.prototype.conv3d=function(t,e,n){for(var r=n.filterDepth,o=n.filterHeight,a=n.filterWidth,i=n.dilationDepth,s=n.dilationHeight,u=n.dilationWidth,c=n.padInfo.front,l=n.padInfo.left,h=n.padInfo.top,f=dr(n.outShape,t.dtype),d=this.readSync(t.dataId),p=this.readSync(e.dataId),v=f.values,m=0;m<n.batchSize;++m)for(var g=m*t.strides[0],y=m*f.strides[0],x=0;x<n.outDepth;++x)for(var b=y+x*f.strides[1],w=x*n.strideDepth-c,C=0;C<r;C++){var E=w+C*i;if(!(E<0||E>=n.inDepth))for(var R=C*e.strides[0],I=g+E*t.strides[1],k=0;k<n.outHeight;++k)for(var S=b+k*f.strides[2],A=k*n.strideHeight-h,D=0;D<o;D++){var T=A+D*s;if(!(T<0||T>=n.inHeight))for(var N=R+D*e.strides[1],F=I+T*t.strides[2],_=0;_<n.outWidth;++_)for(var O=S+_*n.outChannels,M=_*n.strideWidth-l,B=0;B<a;B++){var P=M+B*u;if(!(P<0||P>=n.inWidth))for(var L=N+B*e.strides[2],W=F+P*n.inChannels,U=L,V=0;V<n.inChannels;++V){for(var z=d[W+V],G=0;G<n.outChannels;++G)v[O+G]+=z*p[U+G];U+=n.outChannels}}}}return f.toTensor()},o.prototype.conv2dDerInput=function(t,e,n){Hh([t,e],"conv2dDerInput");for(var r=dr(n.inShape,"float32"),o=r.values,a=this.readSync(t.dataId),i=this.readSync(e.dataId),s=e.strides,u=s[0],c=s[1],l=s[2],h=n.batchSize,f=n.filterHeight,d=n.filterWidth,p=n.inChannels,v=n.inHeight,m=n.inWidth,g=n.outChannels,y=n.outHeight,x=n.outWidth,b=n.strideHeight,w=n.strideWidth,C=n.dataFormat,E=f-1-n.padInfo.top,R=d-1-n.padInfo.left,I="channelsLast"===C,k=r.strides[0],S=I?r.strides[1]:r.strides[2],A=I?r.strides[2]:1,D=I?1:r.strides[1],T=t.strides[0],N=I?t.strides[1]:t.strides[2],F=I?t.strides[2]:1,_=I?1:t.strides[1],O=0;O<h;++O)for(var M=0;M<p;++M)for(var B=0;B<v;++B)for(var P=B-E,L=Math.max(0,Math.ceil(P/b)),W=Math.min(y,(f+P)/b),U=0;U<m;++U){for(var V=U-R,z=Math.max(0,Math.ceil(V/w)),G=Math.min(x,(d+V)/w),H=0,q=L;q<W;++q)for(var K=q*b-P,j=z;j<G;++j)for(var X=T*O+N*q+F*j,Y=u*(f-1-K)+c*(d-1-(j*w-V))+l*M,$=0;$<g;++$){H+=a[X+_*$]*i[Y+$]}o[k*O+S*B+A*U+D*M]=H}return r.toTensor()},o.prototype.conv3dDerInput=function(t,e,n){for(var r=dr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],c=a[3],l=this.readSync(t.dataId),h=t.strides,f=h[0],d=h[1],p=h[2],v=h[3],m=this.readSync(e.dataId),g=e.strides,y=g[0],x=g[1],b=g[2],w=g[3],C=n.batchSize,E=n.filterDepth,R=n.filterHeight,I=n.filterWidth,k=n.inChannels,S=n.inDepth,A=n.inHeight,D=n.inWidth,T=n.outChannels,N=n.outDepth,F=n.outHeight,_=n.outWidth,O=n.strideDepth,M=n.strideHeight,B=n.strideWidth,P=E-1-n.padInfo.front,L=R-1-n.padInfo.top,W=I-1-n.padInfo.left,U=0;U<C;++U)for(var V=0;V<k;++V)for(var z=0;z<S;++z)for(var G=z-P,H=Math.max(0,Math.ceil(G/O)),q=Math.min(N,(E+G)/O),K=0;K<A;++K)for(var j=K-L,X=Math.max(0,Math.ceil(j/M)),Y=Math.min(F,(R+j)/M),$=0;$<D;++$){for(var Q=$-W,J=Math.max(0,Math.ceil(Q/B)),Z=Math.min(_,(I+Q)/B),tt=0,et=H;et<q;++et)for(var nt=et*O-G,rt=X;rt<Y;++rt)for(var ot=rt*M-j,at=J;at<Z;++at)for(var it=f*U+d*et+p*rt+v*at,st=y*(E-1-nt)+x*(R-1-ot)+b*(I-1-(at*B-Q))+w*V,ut=0;ut<T;++ut){tt+=l[it+ut]*m[st+ut]}o[i*U+s*z+u*K+c*$+V]=tt}return r.toTensor()},o.prototype.conv2dDerFilter=function(t,e,n){Hh([t,e],"conv2dDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s="channelsLast"===n.dataFormat,u=dr(n.filterShape,"float32"),c=n.padInfo.left,l=n.padInfo.top,h=this.bufferSync(t),f=this.bufferSync(e),d=0;d<a;++d)for(var p=Math.max(0,Math.ceil((l-d)/r)),v=Math.min(n.outHeight,(n.inHeight+l-d)/r),m=0;m<i;++m)for(var g=Math.max(0,Math.ceil((c-m)/o)),y=Math.min(n.outWidth,(n.inWidth+c-m)/o),x=0;x<n.inChannels;++x)for(var b=0;b<n.outChannels;++b){for(var w=0,C=0;C<n.batchSize;++C)for(var E=p;E<v;++E)for(var R=d+E*r-l,I=g;I<y;++I){var k=m+I*o-c;w+=s?h.get(C,R,k,x)*f.get(C,E,I,b):h.get(C,x,R,k)*f.get(C,b,E,I)}u.set(w,d,m,x,b)}return u.toTensor()},o.prototype.conv3dDerFilter=function(t,e,n){for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,c=dr(n.filterShape,"float32"),l=c.values,h=c.strides,f=h[0],d=h[1],p=h[2],v=h[3],m=this.readSync(e.dataId),g=e.strides,y=g[0],x=g[1],b=g[2],w=g[3],C=this.readSync(t.dataId),E=t.strides,R=E[0],I=E[1],k=E[2],S=E[3],A=n.padInfo.front,D=n.padInfo.left,T=n.padInfo.top,N=0;N<i;++N)for(var F=Math.max(0,Math.ceil((A-N)/r)),_=Math.min(n.outDepth,(n.inDepth+A-N)/r),O=N*f,M=0;M<s;++M)for(var B=Math.max(0,Math.ceil((T-M)/o)),P=Math.min(n.outHeight,(n.inHeight+T-M)/o),L=M*d+O,W=0;W<u;++W)for(var U=Math.max(0,Math.ceil((D-W)/a)),V=Math.min(n.outWidth,(n.inWidth+D-W)/a),z=W*p+L,G=0;G<n.inChannels;++G)for(var H=G*v+z,q=0;q<n.outChannels;++q){for(var K=0,j=0;j<n.batchSize;++j)for(var X=j*R,Y=j*y,$=F;$<_;++$)for(var Q=(N+$*r-A)*I+X,J=$*x+Y,Z=B;Z<P;++Z)for(var tt=(M+Z*o-T)*k+Q,et=Z*b+J,nt=U;nt<V;++nt){var rt=nt*w+et;K+=C[(W+nt*a-D)*S+tt+G]*m[rt+q]}l[H+q]=K}return c.toTensor()},o.prototype.fusedDepthwiseConv2D=function(t){var e=t.input,n=t.filter,r=t.convInfo,o=t.bias,a=t.activation,i=t.preluActivationWeights,s=this.depthwiseConv2D(e,n,r);return o&&(s=this.add(s,o)),a&&(s=qh(this,s,a,i)),s},o.prototype.depthwiseConv2D=function(t,e,n){Hh([t,e],"depthwiseConv2D");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,c=n.outChannels/n.inChannels,l=dr(n.outShape,t.dtype),h=this.readSync(t.dataId),f=this.readSync(e.dataId),d=l.values,p=0;p<n.batchSize;++p)for(var v=p*t.strides[0],m=p*l.strides[0],g=0;g<n.outHeight;++g)for(var y=m+g*l.strides[1],x=g*n.strideHeight-s,b=0;b<r;++b){var w=x+b*a;if(!(w<0||w>=n.inHeight))for(var C=b*e.strides[0],E=v+w*t.strides[1],R=0;R<n.outWidth;++R)for(var I=y+R*l.strides[2],k=R*n.strideWidth-u,S=0;S<o;++S){var A=k+S*i;if(!(A<0||A>=n.inWidth))for(var D=C+S*e.strides[1],T=E+A*n.inChannels,N=I,F=D,_=0;_<n.inChannels;++_){for(var O=h[T+_],M=0;M<c;++M)d[N+M]+=O*f[F+M];N+=c,F+=c}}}return l.toTensor()},o.prototype.depthwiseConv2DDerInput=function(t,e,n){Hh([t,e],"depthwiseConv2DDerInput");for(var r=dr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],c=this.readSync(t.dataId),l=t.strides,h=l[0],f=l[1],d=l[2],p=this.readSync(e.dataId),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,b=n.filterHeight,w=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,I=n.outChannels,k=n.outHeight,S=n.outWidth,A=n.strideHeight,D=n.strideWidth,T=b-1-n.padInfo.top,N=w-1-n.padInfo.left,F=I/C,_=0;_<x;++_)for(var O=0;O<C;++O)for(var M=0;M<E;++M)for(var B=M-T,P=Math.max(0,Math.ceil(B/A)),L=Math.min(k,(b+B)/A),W=0;W<R;++W){for(var U=W-N,V=Math.max(0,Math.ceil(U/D)),z=Math.min(S,(w+U)/D),G=0,H=P;H<L;++H)for(var q=H*A-B,K=V;K<z;++K)for(var j=h*_+f*H+d*K,X=m*(b-1-q)+g*(w-1-(K*D-U))+y*O,Y=0;Y<F;++Y){G+=c[j+(O*F+Y)]*p[X+Y]}o[i*_+s*M+u*W+O]=G}return r.toTensor()},o.prototype.depthwiseConv2DDerFilter=function(t,e,n){Hh([t,e],"depthwiseConv2DDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=dr(n.filterShape,"float32"),u=n.padInfo.left,c=n.padInfo.top,l=n.outChannels/n.inChannels,h=this.bufferSync(t),f=this.bufferSync(e),d=0;d<a;++d)for(var p=Math.max(0,Math.ceil((c-d)/r)),v=Math.min(n.outHeight,(n.inHeight+c-d)/r),m=0;m<i;++m)for(var g=Math.max(0,Math.ceil((u-m)/o)),y=Math.min(n.outWidth,(n.inWidth+u-m)/o),x=0;x<n.outChannels;++x){for(var b=Math.trunc(x/l),w=x%l,C=0,E=0;E<n.batchSize;++E)for(var R=p;R<v;++R)for(var I=d+R*r-c,k=g;k<y;++k){var S=m+k*o-u;C+=h.get(E,I,S,b)*f.get(E,R,k,x)}s.set(C,d,m,b,w)}return s.toTensor()},o.prototype.tile=function(t,e){return Hh(t,"tile"),ta(this.bufferSync(t),e)},o.prototype.pad=function(t,e,n){Hh(t,"pad");var r=e.map((function(e,n){return e[0]+t.shape[n]+e[1]})),o=e.map((function(t){return t[0]})),a=this.bufferSync(t),i=dr(r,t.dtype);0!==n&&i.values.fill(n);for(var s=0;s<t.size;s++){var u=a.indexToLoc(s),c=u.map((function(t,e){return t+o[e]}));i.set.apply(i,[a.get.apply(a,u)].concat(c))}return i.toTensor()},o.prototype.transpose=function(t,e){Hh(t,"transpose");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[e[r]];var o=this.readSync(t.dataId),a=dr(n,t.dtype),i=this.bufferSync(t);for(r=0;r<t.size;++r){for(var s=i.indexToLoc(r),u=new Array(s.length),c=0;c<u.length;c++)u[c]=s[e[c]];var l=a.locToIndex(u);a.values[l]=o[r]}return a.toTensor()},o.prototype.gather=function(t,e,n){Hh([t,e],"gather");var r=t.shape.slice(),o=this.readSync(e.dataId);r[n]=o.length;for(var a=dr(r,t.dtype),i=this.bufferSync(t),s=0;s<a.size;++s){var u=a.indexToLoc(s),c=u.slice();c[n]=o[u[n]];var l=i.locToIndex(c);a.values[s]=i.values[l]}return a.toTensor()},o.prototype.batchToSpaceND=function(t,e,n){Hh([t],"batchToSpaceND");var r=e.reduce((function(t,e){return t*e})),o=zr(t.shape,e,r),a=Gr(o.length,e.length),i=Hr(t.shape,e,r),s=qr(n,e.length),u=Kr(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},o.prototype.spaceToBatchND=function(t,e,n){Hh([t],"spaceToBatchND");var r=e.reduce((function(t,e){return t*e})),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=zr(i.shape,e,r,!1),u=Gr(s.length,e.length,!1),c=Hr(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(c)},o.prototype.pool=function(t,e,n){Hh(t,"pool");for(var r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=e.padInfo.top,l=e.padInfo.left,h="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,f=this.readSync(t.dataId),d=dr(e.outShape,t.dtype),p=d.values,v=e.outShape[1]*e.outShape[2]*e.outShape[3],m=e.outShape[2]*e.outShape[3],g=e.outShape[3],y=0;y<e.batchSize;++y)for(var x=y*v,b=y*t.strides[0],w=0;w<e.inChannels;++w)for(var C=0;C<e.outHeight;++C)for(var E=C*r-c,R=Math.max(0,E),I=Math.min(e.inHeight,s+E),k=x+C*m,S=0;S<e.outWidth;++S){for(var A=S*o-l,D=Math.max(0,A),T=Math.min(e.inWidth,u+A),N=h,F=0,_=0,O=R;O<I;O+=a){for(var M=b+O*t.strides[1],B=D;B<T;B+=i){var P=f[M+B*t.strides[2]+w];"max"===n&&P>N?N=P:"avg"===n&&(F+=P,_++)}if(isNaN(N))break}p[k+S*g+w]="avg"===n?F/_:N}return d.toTensor()},o.prototype.maxPool=function(t,e){return this.pool(t,e,"max")},o.prototype.maxPoolPositions=function(t,e){for(var n=dr(e.outShape,"int32"),r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=e.padInfo.top,l=e.padInfo.left,h=this.bufferSync(t),f=0;f<e.batchSize;++f)for(var d=0;d<e.inChannels;++d)for(var p=0;p<e.outHeight;++p){for(var v=p*r-c,m=v;m<0;)m+=a;for(var g=Math.min(e.inHeight,s+v),y=0;y<e.outWidth;++y){for(var x=y*o-l,b=x;b<0;)b+=i;for(var w=Math.min(e.inWidth,u+x),C=Number.NEGATIVE_INFINITY,E=-1,R=m;R<g;R+=a)for(var I=R-v,k=b;k<w;k+=i){var S=k-x,A=h.get(f,R,k,d);A>C&&(C=A,E=I*u+S)}n.set(E,f,p,y,d)}}return n.toTensor()},o.prototype.maxPoolBackprop=function(t,e,n,r){Hh([e,n],"maxPoolBackprop");for(var o=this.maxPoolPositions(e,r),a=r.strideHeight,i=r.strideWidth,s=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,l=r.effectiveFilterWidth,h=l-1-r.padInfo.left,f=c-1-r.padInfo.top,d=dr(e.shape,"float32"),p=this.bufferSync(o),v=this.bufferSync(t),m=0;m<r.batchSize;++m)for(var g=0;g<r.inChannels;++g)for(var y=0;y<r.inHeight;++y)for(var x=0;x<r.inWidth;++x){for(var b=y-f,w=x-h,C=0,E=0;E<c;E+=s){var R=(b+E)/a;if(!(R<0||R>=r.outHeight||Math.floor(R)!==R))for(var I=0;I<l;I+=u){var k=(w+I)/i;if(!(k<0||k>=r.outWidth||Math.floor(k)!==k)){var S=c*l-1-p.get(m,R,k,g)===E*l+I?1:0;if(0!==S)C+=v.get(m,R,k,g)*S}}}d.set(C,m,y,x,g)}return d.toTensor()},o.prototype.avgPoolBackprop=function(t,e,n){Hh([t,e],"avgPoolBackprop");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,u=n.dilationWidth,c=n.effectiveFilterHeight,l=n.effectiveFilterWidth,h=l-1-n.padInfo.left,f=c-1-n.padInfo.top,d=dr(e.shape,"float32"),p=1/(a*i),v=this.bufferSync(t),m=0;m<n.batchSize;++m)for(var g=0;g<n.inChannels;++g)for(var y=0;y<n.inHeight;++y)for(var x=0;x<n.inWidth;++x){for(var b=y-f,w=x-h,C=0,E=0;E<c;E+=s){var R=(b+E)/r;if(!(R<0||R>=n.outHeight||Math.floor(R)!==R))for(var I=0;I<l;I+=u){var k=(w+I)/o;if(!(k<0||k>=n.outWidth||Math.floor(k)!==k))C+=v.get(m,R,k,g)}}d.set(C*p,m,y,x,g)}return d.toTensor()},o.prototype.pool3d=function(t,e,n){Hh(t,"pool3d");for(var r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,s=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left,v="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=this.readSync(t.dataId),g=dr(e.outShape,t.dtype),y=g.values,x=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],b=e.outShape[2]*e.outShape[3]*e.outShape[4],w=e.outShape[3]*e.outShape[4],C=e.outShape[4],E=0;E<e.batchSize;++E)for(var R=E*x,I=E*t.strides[0],k=0;k<e.inChannels;++k)for(var S=0;S<e.outDepth;++S){for(var A=S*r-f,D=A;D<0;)D+=i;for(var T=Math.min(e.inDepth,c+A),N=R+S*b,F=0;F<e.outHeight;++F){for(var _=F*o-d,O=_;O<0;)O+=s;for(var M=Math.min(e.inHeight,l+_),B=N+F*w,P=0;P<e.outWidth;++P){for(var L=P*a-p,W=L;W<0;)W+=u;for(var U=Math.min(e.inWidth,h+L),V=B+P*C,z=v,G=0,H=0,q=D;q<T;q+=i){for(var K=I+q*t.strides[1],j=O;j<M;j+=s){for(var X=K+j*t.strides[2],Y=W;Y<U;Y+=u){var $=m[X+Y*t.strides[3]+k];if("max"===n&&$>z?z=$:"avg"===n&&(G+=$,H++),isNaN(z))break}if(isNaN(z))break}if(isNaN(z))break}y[V+k]="avg"===n?G/H:z}}}return g.toTensor()},o.prototype.avgPool3d=function(t,e){return Hh(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()},o.prototype.avgPool3dBackprop=function(t,e,n){Hh([t,e],"avgPool3dBackprop");for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,c=n.dilationDepth,l=n.dilationHeight,h=n.dilationWidth,f=n.effectiveFilterDepth,d=n.effectiveFilterHeight,p=n.effectiveFilterWidth,v=f-1-n.padInfo.front,m=p-1-n.padInfo.left,g=d-1-n.padInfo.top,y=dr(e.shape,"float32"),x=1/(i*s*u),b=this.bufferSync(t),w=0;w<n.batchSize;++w)for(var C=0;C<n.inChannels;++C)for(var E=0;E<n.inDepth;++E)for(var R=0;R<n.inHeight;++R)for(var I=0;I<n.inWidth;++I){for(var k=E-v,S=R-g,A=I-m,D=0,T=0;T<f;T+=c){var N=(k+T)/r;if(!(N<0||N>=n.outDepth||Math.floor(N)!==N))for(var F=0;F<d;F+=l){var _=(S+F)/o;if(!(_<0||_>=n.outHeight||Math.floor(_)!==_))for(var O=0;O<p;O+=h){var M=(A+O)/a;if(!(M<0||M>=n.outWidth||Math.floor(M)!==M))D+=b.get(w,N,_,M,C)}}}y.set(D*x,w,E,R,I,C)}return y.toTensor()},o.prototype.maxPool3d=function(t,e){return Hh(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()},o.prototype.maxPool3dPositions=function(t,e){for(var n=dr(e.outShape,"int32"),r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,s=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left,v=this.bufferSync(t),m=0;m<e.batchSize;++m)for(var g=0;g<e.inChannels;++g)for(var y=0;y<e.outDepth;++y){for(var x=y*r-f,b=x;b<0;)b+=i;for(var w=Math.min(e.inDepth,c+x),C=0;C<e.outHeight;++C){for(var E=C*o-d,R=E;R<0;)R+=s;for(var I=Math.min(e.inHeight,l+E),k=0;k<e.outWidth;++k){for(var S=k*a-p,A=S;A<0;)A+=u;for(var D=Math.min(e.inWidth,h+S),T=Number.NEGATIVE_INFINITY,N=-1,F=b;F<w;F+=i)for(var _=F-x,O=R;O<I;O+=s)for(var M=O-E,B=A;B<D;B+=u){var P=B-S,L=v.get(m,F,O,B,g);L>=T&&(T=L,N=_*l*h+M*l+P)}n.set(N,m,y,C,k,g)}}}return n.toTensor()},o.prototype.maxPool3dBackprop=function(t,e,n,r){Hh([e,n],"maxPool3dBackprop");for(var o=this.maxPool3dPositions(e,r),a=r.strideDepth,i=r.strideHeight,s=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,l=r.dilationWidth,h=r.effectiveFilterDepth,f=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=h-1-r.padInfo.front,v=d-1-r.padInfo.left,m=f-1-r.padInfo.top,g=dr(e.shape,"float32"),y=this.bufferSync(o),x=this.bufferSync(t),b=0;b<r.batchSize;++b)for(var w=0;w<r.inChannels;++w)for(var C=0;C<r.inDepth;++C)for(var E=0;E<r.inHeight;++E)for(var R=0;R<r.inWidth;++R){for(var I=C-p,k=E-m,S=R-v,A=0,D=0;D<h;D+=u){var T=(I+D)/a;if(!(T<0||T>=r.outDepth||Math.floor(T)!==T))for(var N=0;N<f;N+=c){var F=(k+N)/i;if(!(F<0||F>=r.outHeight||Math.floor(F)!==F))for(var _=0;_<d;_+=l){var O=(S+_)/s;if(!(O<0||O>=r.outWidth||Math.floor(O)!==O)){var M=h*f*d-1-y.get(b,T,F,O,w)===D*f*d+N*d+_?1:0;if(0!==M)A+=x.get(b,T,F,O,w)*M}}}}g.set(A,b,C,E,R,w)}return g.toTensor()},o.prototype.cast=function(t,e){return Po(t,e,this)},o.prototype.reshape=function(t,e){return Lo(t,e)},o.prototype.avgPool=function(t,e){return Hh(t,"avgPool"),this.pool(t,e,"avg").toFloat()},o.prototype.resizeBilinear=function(t,e,n,r){Hh(t,"resizeBilinear");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],c=this.readSync(t.dataId),l=new Float32Array(k([a,e,n,u])),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],f=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=0,p=h[0]/f[0],v=h[1]/f[1],m=0;m<a;m++)for(var g=0;g<e;g++)for(var y=p*g,x=Math.floor(y),b=y-x,w=Math.min(i-1,Math.ceil(y)),C=m*t.strides[0]+x*t.strides[1],E=m*t.strides[0]+w*t.strides[1],R=0;R<n;R++)for(var I=v*R,S=Math.floor(I),A=I-S,D=Math.min(s-1,Math.ceil(I)),T=C+S*t.strides[2],N=E+S*t.strides[2],F=C+D*t.strides[2],_=E+D*t.strides[2],O=0;O<u;O++){var M=c[T+O],B=c[N+O],P=M+(c[F+O]-M)*A,L=P+(B+(c[_+O]-B)*A-P)*b;l[d++]=L}return Fn(l,[a,e,n,u])},o.prototype.resizeBilinearBackprop=function(t,e,n){Hh([t,e],"resizeBilinearBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,c=u[1],l=u[2],h=new Float32Array(o*a*i*s),f=[n&&c>1?a-1:a,n&&l>1?i-1:i],d=[n&&c>1?c-1:c,n&&l>1?l-1:l],p=f[0]/d[0],v=f[1]/d[1],m=this.readSync(t.dataId),g=0,y=0;y<o;y++)for(var x=y*e.strides[0],b=0;b<c;b++)for(var w=b*p,C=Math.floor(w),E=Math.min(Math.ceil(w),a-1),R=x+C*e.strides[1],I=x+E*e.strides[1],k=w-C,S=1-k,A=0;A<l;A++)for(var D=A*v,T=Math.floor(D),N=Math.min(Math.ceil(D),i-1),F=D-T,_=1-F,O=R+T*e.strides[2],M=R+N*e.strides[2],B=I+T*e.strides[2],P=I+N*e.strides[2],L=S*_,W=S*F,U=k*_,V=k*F,z=0;z<s;z++){var G=m[g++];h[O+z]+=G*L,h[M+z]+=G*W,h[B+z]+=G*U,h[P+z]+=G*V}return Ln(h,[o,i,a,s],e.dtype)},o.prototype.resizeNearestNeighbor=function(t,e,n,r){Hh(t,"resizeNearestNeighbor");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],c=this.readSync(t.dataId),l=new Float32Array(a*e*n*u),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],f=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=h[0]/f[0],p=h[1]/f[1],v=0,m=0;m<a;m++)for(var g=m*t.strides[0],y=0;y<e;y++)for(var x=d*y,b=g+Math.min(i-1,r?Math.round(x):Math.floor(x))*t.strides[1],w=0;w<n;w++)for(var C=p*w,E=b+Math.min(s-1,r?Math.round(C):Math.floor(C))*t.strides[2],R=0;R<u;R++){var I=c[E+R];l[v++]=I}return Fn(l,[a,e,n,u],t.dtype)},o.prototype.resizeNearestNeighborBackprop=function(t,e,n){Hh([t,e],"resizeNearestNeighborBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,c=u[1],l=u[2],h=new Float32Array(o*a*i*s),f=this.readSync(t.dataId),d=[n&&c>1?a-1:a,n&&l>1?i-1:i],p=[n&&c>1?c-1:c,n&&l>1?l-1:l],v=d[0]/p[0],m=d[1]/p[1],g=1/v,y=1/m,x=2*Math.ceil(g)+2,b=2*Math.ceil(y)+2,w=0;w<o;w++)for(var C=w*e.strides[0],E=0;E<a;E++)for(var R=C+E*e.strides[1],I=Math.floor(E*g),k=Math.floor(I-x/2),S=0;S<i;S++)for(var A=R+S*e.strides[2],D=Math.floor(S*y),T=Math.floor(D-b/2),N=0;N<s;N++){for(var F=0,_=0;_<x;_++){var O=_+k;if(!(O<0||O>=c)){var M=C+O*t.strides[1],B=O*v;if(E===Math.min(a-1,n?Math.round(B):Math.floor(B)))for(var P=0;P<b;P++){var L=P+T;if(!(L<0||L>=l)){var W=M+L*t.strides[2],U=L*m;S===Math.min(i-1,n?Math.round(U):Math.floor(U))&&(F+=f[W+N])}}}}h[A+N]=F}return Ln(h,e.shape,e.dtype)},o.prototype.batchNormalization=function(t,e,n,r,o,a){Hh([t,e,n,o,a],"batchNorm");for(var i=this.readSync(t.dataId),s=this.readSync(e.dataId),u=this.readSync(n.dataId),c=o?this.readSync(o.dataId):new Float32Array([1]),l=a?this.readSync(a.dataId):new Float32Array([0]),h=new Float32Array(i.length),f=l.length,d=c.length,p=u.length,v=s.length,m=0,g=0,y=0,x=0,b=0;b<i.length;++b)h[b]=l[m++]+(i[b]-s[g++])*c[y++]/Math.sqrt(u[x++]+r),m>=f&&(m=0),g>=v&&(g=0),y>=d&&(y=0),x>=p&&(x=0);return Ln(h,t.shape)},o.prototype.localResponseNormalization4D=function(t,e,n,r,o){Hh(t,"localResponseNormalization4D");var a=t.shape[3],i=a-1,s=this.readSync(t.dataId),u=t.size,c=new Float32Array(u);function l(t){for(var n=t%a,r=t-n+Math.max(0,n-e),o=t-n+Math.min(n+e,i),u=0;r<=o;r++){var c=s[r];u+=c*c}return u}for(var h=0;h<u;h++){var f=l(h),d=s[h]*Math.pow(n+r*f,-o);c[h]=d}return Ln(c,t.shape)},o.prototype.LRNGrad=function(t,e,n,r,o,a,i){Hh(t,"LRNGrad");for(var s=t.shape[3],u=this.readSync(t.dataId),c=this.readSync(e.dataId),l=this.readSync(n.dataId),h=new Float32Array(t.size),f=t.size,d=0;d<f;d++){for(var p=d%s,v=d-p+Math.max(0,p-r),m=d-p+Math.min(s,p+r+1),g=0,y=v;y<m;y++)g+=Math.pow(c[y],2);g=a*g+o;for(y=v;y<m;y++){var x=-2*a*i*c[y]*l[d]/g;d===y&&(x+=Math.pow(g,-i)),x*=u[d],h[y]+=x}}return Ln(h,t.shape)},o.prototype.multinomial=function(t,e,n,r){Hh(t,"multinomial");for(var o=e?t:go(t),a=o.shape[0],i=o.shape[1],s=Gn([a,n],"int32"),u=this.readSync(s.dataId),c=this.readSync(o.dataId),l=0;l<a;++l){var h=l*i,f=new Float32Array(i-1);f[0]=c[h];for(var d=1;d<f.length;++d)f[d]=f[d-1]+c[h+d];for(var p=cr(r.toString()),v=l*n,m=0;m<n;++m){var g=p();u[v+m]=f.length;for(var y=0;y<f.length;y++)if(g<f[y]){u[v+m]=y;break}}}return s},o.prototype.oneHot=function(t,e,n,r){Hh(t,"oneHot");var o=new Float32Array(t.size*e);o.fill(r);for(var a=this.readSync(t.dataId),i=0;i<t.size;++i)a[i]>=0&&a[i]<e&&(o[i*e+a[i]]=n);return Bn(o,[t.size,e],"int32")},o.prototype.nonMaxSuppression=function(t,e,n,r,o){return Hh(t,"nonMaxSuppression"),jo(this.readSync(t.dataId),this.readSync(e.dataId),n,r,o)},o.prototype.fft=function(t){return this.fftBatch(t,!1)},o.prototype.ifft=function(t){return this.fftBatch(t,!0)},o.prototype.fftBatch=function(t,e){for(var n=t.shape[0],r=t.shape[1],o=dr(t.shape,"float32"),a=dr(t.shape,"float32"),i=Tn(t).as2D(n,r),s=Nn(t).as2D(n,r),u=0;u<n;u++)for(var c=i.slice([u,0],[1,r]),l=s.slice([u,0],[1,r]),h=Dn(c,l),f=this.readSync(this.fftImpl(h,e).dataId),d=0;d<r;d++){var p=zo(f,d);o.values[u*r+d]=p.real,a.values[u*r+d]=p.imag}return Dn(o.toTensor(),a.toTensor()).as2D(n,r)},o.prototype.fftImpl=function(t,e){var n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){var o=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(o=Dn(Tn(o).div(On(r)),Nn(o).div(On(r)))),o}var a=this.readSync(t.dataId),i=function(t){for(var e=new Float32Array(t.length/2),n=new Float32Array(t.length/2),r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}(this.fourierTransformByMatmul(a,r,e));return Dn(i.real,i.imag).as2D(t.shape[0],t.shape[1])},o.prototype.isExponentOf2=function(t){return 0==(t&t-1)},o.prototype.fftRadix2=function(t,e,n){if(1===e)return t;var r=this.readSync(t.dataId),o=e/2,a=function(t){for(var e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=0;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),i=Dn(a.real,a.imag).as1D(),s=function(t){for(var e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=2;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),u=Dn(s.real,s.imag).as1D();i=this.fftRadix2(i,o,n),u=this.fftRadix2(u,o,n);var c=function(t,e){for(var n=new Float32Array(t/2),r=new Float32Array(t/2),o=0;o<Math.ceil(t/2);o++){var a=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(a),r[o]=Math.sin(a)}return{real:n,imag:r}}(e,n),l=Dn(c.real,c.imag).mul(u),h=i.add(l),f=i.sub(l),d=Tn(h).concat(Tn(f)),p=Nn(h).concat(Nn(f));return Dn(d,p).as1D()},o.prototype.fourierTransformByMatmul=function(t,e,n){for(var r=new Float32Array(2*e),o=0;o<e;o++){for(var a=0,i=0,s=0;s<e;s++){var u=Ho(o*s,e,n),c=zo(t,s);a+=c.real*u.real-c.imag*u.imag,i+=c.real*u.imag+c.imag*u.real}n&&(a/=e,i/=e),Go(r,a,i,o)}return r},o.prototype.depthToSpace=function(t,e,n){C("NHWC"===n,(function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n})),C(e>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+e}));for(var r=t.shape[0],o=t.shape[1],a=t.shape[2],i=t.shape[3],s=o*e,u=a*e,c=i/(e*e),l=this.readSync(t.dataId),h=new Float32Array(r*s*u*c),f=0,d=0;d<r;++d)for(var p=0;p<s;++p)for(var v=Math.floor(p/e),m=p%e,g=0;g<u;++g)for(var y=Math.floor(g/e),x=(m*e+g%e)*c,b=0;b<c;++b){var w=b+x+i*(y+a*(v+o*d));h[f++]=l[w]}return Ln(h,[r,s,u,c])},o.prototype.broadcastedBinaryOp=function(t,e,n,r){var o=Ro(t.shape,e.shape),a=dr(o,n),i=this.readSync(t.dataId),s=this.readSync(e.dataId),u=Co(t.shape,o),c=Co(e.shape,o),l=a.values;if(u.length+c.length===0)for(var h=0;h<l.length;++h)l[h]=r(i[h%i.length],s[h%s.length]);else{var f=this.bufferSync(t),d=this.bufferSync(e),p=function(n){var o=a.indexToLoc(n),h=o.slice(-t.rank);u.forEach((function(t){return h[t]=0}));var p=f.locToIndex(h),v=o.slice(-e.rank);c.forEach((function(t){return v[t]=0}));var m=d.locToIndex(v);l[n]=r(i[p],s[m])};for(h=0;h<l.length;++h)p(h)}return a.toTensor()},o.prototype.broadcastedBinaryComplexOp=function(t,e,n){var r=Ro(t.shape,e.shape),o=dr(r,"float32"),a=dr(r,"float32"),i=this.readSync(t.dataId),s=this.readSync(e.dataId),u=Co(t.shape,r),c=Co(e.shape,r),l=o.values,h=a.values;if(u.length+c.length===0)for(var f=0;f<l.length;f++){var d=f%i.length,p=f%s.length,v=n(i[2*d],i[2*d+1],s[2*p],s[2*p+1]);l[f]=v.real,h[f]=v.imag}else{var m=this.bufferSync(this.data.get(t.dataId).complexTensors.real),g=this.bufferSync(this.data.get(e.dataId).complexTensors.real),y=function(r){var a=o.indexToLoc(r),f=a.slice(-t.rank);u.forEach((function(t){return f[t]=0}));var d=m.locToIndex(f),p=a.slice(-e.rank);c.forEach((function(t){return p[t]=0}));var v=g.locToIndex(p),y=n(i[2*d],i[2*d+1],s[2*v],s[2*v+1]);l[r]=y.real,h[r]=y.imag};for(f=0;f<l.length;f++)y(f)}return this.complex(o.toTensor(),a.toTensor())},o.prototype.split=function(t,e,n){return Zo(t,e,n)},o.prototype.dispose=function(){},o.prototype.floatPrecision=function(){return 32},o.prototype.epsilon=function(){return 1e-7},o.prototype.cropAndResize=function(t,e,n,r,o,a){for(var i=t.shape,s=i[0],u=i[1],c=i[2],l=i[3],h=e.shape[0],f=r[0],d=r[1],p=dr([h,f,d,l],"float32"),v=this.readSync(e.dataId),m=this.readSync(n.dataId),g=this.readSync(t.dataId),y=t.strides,x=p.strides,b=0;b<h;b++){var w=4*b,C=v[w],E=v[w+1],R=v[w+2],I=v[w+3],k=m[b];if(!(k>=s))for(var S=f>1?(R-C)*(u-1)/(f-1):0,A=d>1?(I-E)*(c-1)/(d-1):0,D=0;D<f;D++){var T=f>1?C*(u-1)+D*S:.5*(C+R)*(u-1);if(T<0||T>u-1)for(var N=0;N<d;N++)for(var F=0;F<l;F++){var _=F+N*x[2]+D*x[1]+b*x[0];p.values[_]=a}else if("bilinear"===o){var O=Math.floor(T),M=Math.ceil(T),B=T-O;for(N=0;N<d;N++){if((q=d>1?E*(c-1)+N*A:.5*(E+I)*(c-1))<0||q>c-1)for(F=0;F<l;F++){_=F+N*x[2]+D*x[1]+b*x[0];p.values[_]=a}else{var P=Math.floor(q),L=Math.ceil(q),W=q-P;for(F=0;F<l;F++){var U=g[_=F+P*y[2]+O*y[1]+k*y[0]],V=g[_=F+L*y[2]+O*y[1]+k*y[0]],z=g[_=F+P*y[2]+M*y[1]+k*y[0]],G=U+(V-U)*W,H=z+(g[_=F+L*y[2]+M*y[1]+k*y[0]]-z)*W;_=F+N*x[2]+D*x[1]+b*x[0],p.values[_]=G+(H-G)*B}}}}else for(N=0;N<d;++N){var q;if((q=d>1?E*(c-1)+N*A:.5*(E+I)*(c-1))<0||q>c-1)for(F=0;F<l;F++){_=F+N*x[2]+D*x[1]+b*x[0];p.values[_]=a}else{var K=Math.round(q),j=Math.round(T);for(F=0;F<l;F++){var X=F+K*y[2]+j*y[1]+k*y[0],Y=F+N*x[2]+D*x[1]+b*x[0];p.values[Y]=g[X]}}}}}return p.toTensor()},o.prototype.sparseToDense=function(t,e,n,r){var o=Zr(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.sliceSize,u=o.strides,c=o.outputSize;return this.scatter(t,e,n,c,s,i,a,u,r,!1)},o.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=jr(t,e),a=o[0],i=o[1],s=o[2],u=o[3];if(0===i)return Fn([],a,t.dtype);for(var c=new gt([i,s],t.dtype),l=this.readSync(e.dataId),h=this.readSync(t.dataId),f=0;f<i;f++){for(var d=[],p=0,v=0;v<r;v++){var m=l[f*r+v];p+=m*u[v],d.push(m)}if(p<0||p>=t.size/s)throw new Error("Invalid indices: "+d+" does not index into "+t.shape);for(var g=0;g<s;g++)c.values[f*s+g]=h[p*s+g]}return c.toTensor().reshape(a)},o.prototype.scatterND=function(t,e,n){var r=Zr(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,c=On(0);return this.scatter(t,e,n,u,i,a,o,s,c,!0)},o.prototype.fill=function(t,e,n){var r=P(n=n||j(e),k(t));return r.fill(e),Lt.makeTensor(r,t,n,this)},o.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)},o.prototype.zerosLike=function(t){var e=P(t.dtype,k(t.shape));return this.makeOutput(e,t.shape,t.dtype)},o.prototype.linspace=function(t,e,n){return Wo(t,e,n)},o.prototype.scatter=function(t,e,n,r,o,a,i,s,u,c){var l=[r/o,o],h=this.readSync(t.dataId),f=this.readSync(e.dataId);if(0===r)return Fn([],n,e.dtype);var d=new gt(l,e.dtype);d.values.fill(this.readSync(u.dataId)[0]);for(var p=0;p<a;p++){for(var v=[],m=0,g=0;g<i;g++){var y=h[p*i+g];v.push(y),m+=y*s[g]}if(m<0||m>=r/o)throw new Error("Invalid indices: "+v+" does not index into "+n);for(var x=0;x<o;x++)c?d.values[m*o+x]+=f[p*o+x]:d.values[m*o+x]=0===e.rank?f[0]:f[p*o+x]}return d.toTensor().reshape(n)},o}(bo);Lt.registerBackend("cpu",(function(){return new Kh}),1);for(var jh=0,Xh=[{kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=t.attrs,o=e,a=o.boxes,i=o.scores,s=r,u=s.maxOutputSize,c=s.iouThreshold,l=s.scoreThreshold,h=s.softNmsSigma,f=n;Hh(a,"NonMaxSuppressionWithScore");var d=Xo(f.data.get(a.dataId).values,f.data.get(i.dataId).values,u,c,l,h);return[d.selectedIndices,d.selectedScores]}},{kernelName:"Square",backendName:"cpu",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e.x,o=n;Hh(r,"square");for(var a=o.data.get(r.dataId).values,i=new Float32Array(a.length),s=0;s<a.length;++s){var u=a[s];i[s]=u*u}return{dataId:o.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:eu,backendName:"cpu",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e,o=r.a,a=r.b,i=n;Hh([o,a],eu);var s=i.data.get(o.dataId).values,u=i.data.get(a.dataId).values,c=function(t,e,n,r,o,a){var i=Ro(t,e),s=i.length,u=$(i),c=B(o,k(i)),l=t.length,h=e.length,f=$(t),d=$(e),p=Co(t,i),v=Co(e,i);if(p.length+v.length===0)for(var m=0;m<c.length;++m)c[m]=a(n[m%n.length],r[m%r.length]);else{var g=function(t){var e=it(t,s,u),o=e.slice(-l);p.forEach((function(t){return o[t]=0}));var i=at(o,l,f),m=e.slice(-h);v.forEach((function(t){return m[t]=0}));var g=at(m,h,d);c[t]=a(n[i],r[g])};for(m=0;m<c.length;++m)g(m)}return[c,i]}(o.shape,a.shape,s,u,o.dtype,(function(t,e){var n=t-e;return n*n})),l=c[0],h=c[1];return{dataId:i.write(l,h,o.dtype),shape:h,dtype:o.dtype}}}];jh<Xh.length;jh++){d(Xh[jh])}var Yh,$h=function(t){this.variableNames=["A"];var e=ua(),n=t[0],r=t[1];this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+n+".0);\n\n        vec4 values = "+e.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "},Qh=function(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var e=ua(),n=t[0],r=t[1];this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2("+r+".0, "+n+".0);\n            vec4 values = "+e.texture2D+"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+e.output+" = result;\n      }\n    "};for(var Jh=0,Zh=[{kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=t.attrs,o=e.pixels,a=r.numChannels,s="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,c=s?[o.videoWidth,o.videoHeight]:[o.width,o.height],l=c[0],h=c[1],f=[h,l],d=[h,l,a];(u||s)&&(null==Yh&&(Yh=document.createElement("canvas").getContext("2d")),Yh.canvas.width=l,Yh.canvas.height=h,Yh.drawImage(o,0,0,l,h),o=Yh.canvas);var p=n.makeTensorInfo(f,"int32");n.texData.get(p.dataId).usage=zt.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),o);var v=i().getBool("WEBGL_PACK")?new Qh(d):new $h(d),m=n.runWebGLProgram(v,[p],"int32");return n.disposeData(p.dataId),m}},{kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=t.attrs;dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var o=e,a=o.boxes,i=o.scores,s=r,u=s.maxOutputSize,c=s.iouThreshold,l=s.scoreThreshold,h=s.softNmsSigma,f=n,d=Xo(f.readSync(a.dataId),f.readSync(i.dataId),u,c,l,h);return[d.selectedIndices,d.selectedScores]}},{kernelName:"Square",backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e.x,o=n,a=new Cs(r.shape,"return x * x;");return o.runWebGLProgram(a,[r],r.dtype)}},{kernelName:eu,backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e,o=r.a,a=r.b,s=n,u=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("return (a - b) * (a - b);",o.shape,a.shape):new Ba("return (a - b) * (a - b);",o.shape,a.shape);return s.compileAndRun(u,[o,a])}}];Jh<Zh.length;Jh++){d(Zh[Jh])}for(var tf=0,ef=[{kernelName:"Square",gradFunc:function(t,e){var n=e[0];return{x:function(){return t.mul(n.toFloat().mul(2))}}}},{kernelName:eu,gradFunc:function(t,e){var n=e[0],r=e[1],o=On(2);return{a:function(){return gc(t,gc(o,Cc(n,r)))},b:function(){return gc(t,gc(o,Cc(r,n)))}}}}];tf<ef.length;tf++){p(ef[tf])}var nf=function(){function t(){}return t.prototype.fetch=function(t,e){return fetch(t,e)},t.prototype.now=function(){return performance.now()},t.prototype.encode=function(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got "+e);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)},t.prototype.decode=function(t,e){return new TextDecoder(e).decode(t)},t}();i().get("IS_BROWSER")&&i().setPlatform("browser",new nf);var rf,of=function(){return __webpack_require__(/*! node-fetch */ 1)},af=function(){function t(){this.util=__webpack_require__(/*! util */ 2),this.textEncoder=new this.util.TextEncoder}return t.prototype.fetch=function(t,e){return null!=i().global.fetch?i().global.fetch(t,e):(null==rf&&(rf=of()),rf(t,e))},t.prototype.now=function(){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6},t.prototype.encode=function(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got "+e);return this.textEncoder.encode(t)},t.prototype.decode=function(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)},t}();i().get("IS_NODE")&&i().setPlatform("node",new af);var sf={float32:4,int32:4,uint16:2,uint8:1,bool:1},uf=4;function cf(t,e){for(var n={},r=0,o=function(e){var o=e.name,a=e.dtype,i=e.shape,s=k(i),u=void 0;if("quantization"in e){var c=e.quantization;if("uint8"!==c.dtype&&"uint16"!==c.dtype)throw new Error("Weight "+e.name+" has unknown quantization dtype "+c.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var l=sf[c.dtype],h=t.slice(r,r+s*l),f="uint8"===c.dtype?new Uint8Array(h):new Uint16Array(h);if("float32"===a)u=Float32Array.from(f,(function(t){return t*c.scale+c.min}));else{if("int32"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=Int32Array.from(f,(function(t){return Math.round(t*c.scale+c.min)}))}r+=s*l}else if("string"===a){var d=k(e.shape);u=[];for(var p=0;p<d;p++){var v=new Uint32Array(t.slice(r,r+uf))[0];r+=uf;var m=new Uint8Array(t.slice(r,r+v));u.push(m),r+=v}}else{var g=sf[a];h=t.slice(r,r+s*g);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=new Uint8Array(h)}r+=s*g}n[o]=Fn(u,i,a)},a=0,i=e;a<i.length;a++){o(i[a])}return n}function lf(t){if(null===t)throw new Error("Invalid input value: "+JSON.stringify(t));var e=0,n=[];t.forEach((function(t){if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)}));var r=new Uint8Array(e),o=0;return n.forEach((function(t){r.set(new Uint8Array(t.buffer),o),o+=t.byteLength})),r.buffer}var hf="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function ff(t){return hf?Buffer.byteLength(t):new Blob([t]).size}function df(t){var e=0;t.forEach((function(t){e+=t.byteLength}));var n=new Uint8Array(e),r=0;return t.forEach((function(t){n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function pf(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);var e=t.split("/");return e[e.length-1]}function vf(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:ff(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:ff(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}var mf=function(){function t(){this.saveRouters=[],this.loadRouters=[]}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerSaveRouter=function(e){t.getInstance().saveRouters.push(e)},t.registerLoadRouter=function(e){t.getInstance().loadRouters.push(e)},t.getSaveHandlers=function(e){return t.getHandlers(e,"save")},t.getLoadHandlers=function(e,n){return t.getHandlers(e,"load",n)},t.getHandlers=function(e,n,r){var o=[];return("load"===n?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach((function(t){var n=t(e,r);null!==n&&o.push(n)})),o},t}(),gf="://",yf=function(){function t(){this.managers={}}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerManager=function(e,n){C(null!=e,(function(){return"scheme must not be undefined or null."})),e.endsWith(gf)&&(e=e.slice(0,e.indexOf(gf))),C(e.length>0,(function(){return"scheme must not be an empty string."}));var r=t.getInstance();C(null==r.managers[e],(function(){return"A model store manager is already registered for scheme '"+e+"'."})),r.managers[e]=n},t.getManager=function(t){var e=this.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '"+t+"'");return e},t.getSchemes=function(){return Object.keys(this.getInstance().managers)},t}();function xf(t){if(-1===t.indexOf(gf))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+yf.getSchemes().join(","));return{scheme:t.split(gf)[0],path:t.split(gf)[1]}}function bf(t,e,o){return void 0===o&&(o=!1),n(this,void 0,void 0,(function(){var n,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return C(t!==e,(function(){return"Old path and new path are the same: '"+t+"'"})),C((n=mf.getLoadHandlers(t)).length>0,(function(){return"Copying failed because no load handler is found for source URL "+t+"."})),C(n.length<2,(function(){return"Copying failed because more than one ("+n.length+") load handlers for source URL "+t+"."})),a=n[0],C((i=mf.getSaveHandlers(e)).length>0,(function(){return"Copying failed because no save handler is found for destination URL "+e+"."})),C(i.length<2,(function(){return"Copying failed because more than one ("+n.length+") save handlers for destination URL "+e+"."})),s=i[0],u=xf(t).scheme,c=xf(t).path,l=u===xf(t).scheme,[4,a.load()];case 1:return h=r.sent(),o&&l?[4,yf.getManager(u).removeModel(c)]:[3,3];case 2:r.sent(),r.label=3;case 3:return[4,s.save(h)];case 4:return f=r.sent(),!o||l?[3,6]:[4,yf.getManager(u).removeModel(c)];case 5:r.sent(),r.label=6;case 6:return[2,f.modelArtifactsInfo]}}))}))}var wf="models_store",Cf="model_info_store";function Ef(){if(!i().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var t=window||self,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Rf(t){var e=t.result;e.createObjectStore(wf,{keyPath:"modelPath"}),e.createObjectStore(Cf,{keyPath:"modelPath"})}var If=function(){function t(t){if(this.indexedDB=Ef(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,t)]}))}))},t.prototype.load=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){return[2,this.databaseAction(this.modelPath)]}))}))},t.prototype.databaseAction=function(t,e){var n=this;return new Promise((function(t,r){var o=n.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Rf(o)},o.onsuccess=function(){var a=o.result;if(null==e){var i=a.transaction(wf,"readonly"),s=i.objectStore(wf).get(n.modelPath);s.onsuccess=function(){if(null==s.result)return a.close(),r(new Error("Cannot find model with path '"+n.modelPath+"' in IndexedDB."));t(s.result.modelArtifacts)},s.onerror=function(t){return a.close(),r(s.error)},i.oncomplete=function(){return a.close()}}else{var u,c=vf(e),l=a.transaction(Cf,"readwrite"),h=l.objectStore(Cf),f=h.put({modelPath:n.modelPath,modelArtifactsInfo:c});f.onsuccess=function(){var o=(u=a.transaction(wf,"readwrite")).objectStore(wf).put({modelPath:n.modelPath,modelArtifacts:e,modelArtifactsInfo:c});o.onsuccess=function(){return t({modelArtifactsInfo:c})},o.onerror=function(t){var e=(h=l.objectStore(Cf)).delete(n.modelPath);e.onsuccess=function(){return a.close(),r(o.error)},e.onerror=function(t){return a.close(),r(o.error)}}},f.onerror=function(t){return a.close(),r(f.error)},l.oncomplete=function(){null==u?a.close():u.oncomplete=function(){return a.close()}}}},o.onerror=function(t){return r(o.error)}}))},t.URL_SCHEME="indexeddb://",t}(),kf=function(t){return i().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(If.URL_SCHEME)?(e=t.slice(If.URL_SCHEME.length),new If(e)):null;var e};mf.registerSaveRouter(kf),mf.registerLoadRouter(kf);var Sf=function(){function t(){this.indexedDB=Ef()}return t.prototype.listModels=function(){return n(this,void 0,void 0,(function(){var t=this;return r(this,(function(e){return[2,new Promise((function(e,n){var r=t.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=function(){return Rf(r)},r.onsuccess=function(){var t=r.result,o=t.transaction(Cf,"readonly"),a=o.objectStore(Cf).getAll();a.onsuccess=function(){for(var t={},n=0,r=a.result;n<r.length;n++){var o=r[n];t[o.modelPath]=o.modelArtifactsInfo}e(t)},a.onerror=function(e){return t.close(),n(a.error)},o.oncomplete=function(){return t.close()}},r.onerror=function(t){return n(r.error)}}))]}))}))},t.prototype.removeModel=function(t){return n(this,void 0,void 0,(function(){var e=this;return r(this,(function(n){var r;return t=(r=t).startsWith(If.URL_SCHEME)?r.slice(If.URL_SCHEME.length):r,[2,new Promise((function(n,r){var o=e.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Rf(o)},o.onsuccess=function(){var e,a=o.result,i=a.transaction(Cf,"readwrite"),s=i.objectStore(Cf),u=s.get(t);u.onsuccess=function(){if(null==u.result)return a.close(),r(new Error("Cannot find model with path '"+t+"' in IndexedDB."));var o=s.delete(t),i=function(){var o=(e=a.transaction(wf,"readwrite")).objectStore(wf).delete(t);o.onsuccess=function(){return n(u.result.modelArtifactsInfo)},o.onerror=function(t){return r(u.error)}};o.onsuccess=i,o.onerror=function(t){return i(),a.close(),r(u.error)}},u.onerror=function(t){return a.close(),r(u.error)},i.oncomplete=function(){null==e?a.close():e.oncomplete=function(){return a.close()}}},o.onerror=function(t){return r(o.error)}}))]}))}))},t}();if(i().getBool("IS_BROWSER"))try{yf.registerManager(If.URL_SCHEME,new Sf)}catch(t){}var Af="/",Df="tensorflowjs_models",Tf="info",Nf="model_topology",Ff="weight_specs",_f="weight_data",Of="model_metadata";function Mf(t){return{info:[Df,t,Tf].join(Af),topology:[Df,t,Nf].join(Af),weightSpecs:[Df,t,Ff].join(Af),weightData:[Df,t,_f].join(Af),modelMetadata:[Df,t,Of].join(Af)}}function Bf(t){var e=t.split(Af);if(e.length<3)throw new Error("Invalid key format: "+t);return e.slice(1,e.length-1).join(Af)}var Pf=function(){function t(t){if(!i().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Mf(this.modelPath)}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){var e,n,o;return r(this,(function(r){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=vf(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(hf)return Buffer.from(t).toString("base64");for(var e=new Uint8Array(t),n="",r=0,o=e.length;r<o;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),[2,{modelArtifactsInfo:o}]}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+o.modelTopologyBytes+", weightSpecsBytes="+o.weightSpecsBytes+", weightDataBytes="+o.weightDataBytes+".")}return[2]}))}))},t.prototype.load=function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i,s;return r(this,(function(r){if(null==(t=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(e={},null==(n=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(e.modelTopology=n,null==(o=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(e.weightSpecs=o,null!=(a=this.LS.getItem(this.keys.modelMetadata))&&(i=JSON.parse(a),e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy,e.userDefinedMetadata=i.userDefinedMetadata),null==(s=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return e.weightData=function(t){if(hf){var e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}for(var n=atob(t),r=new Uint8Array(n.length),o=0;o<n.length;++o)r.set([n.charCodeAt(o)],o);return r.buffer}(s),[2,e]}))}))},t.URL_SCHEME="localstorage://",t}(),Lf=function(t){return i().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Pf.URL_SCHEME)?(e=t.slice(Pf.URL_SCHEME.length),new Pf(e)):null;var e};mf.registerSaveRouter(Lf),mf.registerLoadRouter(Lf);var Wf=function(){function t(){C(i().getBool("IS_BROWSER"),(function(){return"Current environment is not a web browser"})),C("undefined"==typeof window||void 0!==window.localStorage,(function(){return"Current browser does not appear to support localStorage"})),this.LS=window.localStorage}return t.prototype.listModels=function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i;return r(this,(function(r){for(t={},e=Df+Af,n=Af+Tf,o=0;o<this.LS.length;++o)(a=this.LS.key(o)).startsWith(e)&&a.endsWith(n)&&(i=Bf(a),t[i]=JSON.parse(this.LS.getItem(a)));return[2,t]}))}))},t.prototype.removeModel=function(t){return n(this,void 0,void 0,(function(){var e,n;return r(this,(function(r){var o;if(t=(o=t).startsWith(Pf.URL_SCHEME)?o.slice(Pf.URL_SCHEME.length):o,e=Mf(t),null==this.LS.getItem(e.info))throw new Error("Cannot find model at path '"+t+"'");return n=JSON.parse(this.LS.getItem(e.info)),this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),[2,n]}))}))},t}();if(i().getBool("IS_BROWSER"))try{yf.registerManager(Pf.URL_SCHEME,new Wf)}catch(t){}var Uf="model",Vf=".json",zf=".weights.bin";function Gf(t){return new Promise((function(t){return setTimeout(t)})).then(t)}var Hf=function(){function t(e){if(!i().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),null!=e&&0!==e.length||(e=Uf),this.modelTopologyFileName=e+Vf,this.weightDataFileName=e+zf}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,i,s;return r(this,(function(r){switch(r.label){case 0:if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");if(e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"})),!(t.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),(i=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,i.href=a,[4,Gf((function(){return i.dispatchEvent(new MouseEvent("click"))}))];case 2:return r.sent(),null==t.weightData?[3,4]:((s=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,s.href=e,[4,Gf((function(){return s.dispatchEvent(new MouseEvent("click"))}))]);case 3:r.sent(),r.label=4;case 4:return[2,{modelArtifactsInfo:vf(t)}]}}))}))},t.URL_SCHEME="downloads://",t}(),qf=function(){function t(t){if(null==t||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}return t.prototype.load=function(){return n(this,void 0,void 0,(function(){var t,e,n=this;return r(this,(function(r){return t=this.files[0],e=this.files.slice(1),[2,new Promise((function(r,o){var a=new FileReader;a.onload=function(a){var i=JSON.parse(a.target.result),s=i.modelTopology;if(null!=s){0===e.length&&r({modelTopology:s});var u=i.weightsManifest;if(null!=u){var c;try{c=n.checkManifestAndWeightFiles(u,e)}catch(t){return void o(t)}var l=[],h=[],f=[];u.forEach((function(t){t.paths.forEach((function(t){h.push(t),f.push(null)})),l.push.apply(l,t.weights)})),u.forEach((function(t){t.paths.forEach((function(t){var e=new FileReader;e.onload=function(e){var n=e.target.result,o=h.indexOf(t);f[o]=n,-1===f.indexOf(null)&&r({modelTopology:s,weightSpecs:l,weightData:df(f),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy,userDefinedMetadata:i.userDefinedMetadata})},e.onerror=function(e){return o("Failed to weights data from file of path '"+t+"'.")},e.readAsArrayBuffer(c[t])}))}))}else o(new Error("weightManifest field is missing from file "+t.name))}else o(new Error("modelTopology field is missing from file "+t.name))},a.onerror=function(e){return o("Failed to read model topology and weights manifest JSON from file '"+t.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},a.readAsText(t)}))]}))}))},t.prototype.checkManifestAndWeightFiles=function(t,e){for(var n=[],r=e.map((function(t){return pf(t.name)})),o={},a=0,i=t;a<i.length;a++){i[a].paths.forEach((function(t){var a=pf(t);if(-1!==n.indexOf(a))throw new Error("Duplicate file basename found in weights manifest: '"+a+"'");if(n.push(a),-1===r.indexOf(a))throw new Error("Weight file with basename '"+a+"' is not provided.");o[t]=e[r.indexOf(a)]}))}if(n.length!==e.length)throw new Error("Mismatch in the number of files in weights manifest ("+n.length+") and the number of weight files provided ("+e.length+").");return o},t}();function Kf(t,e,n,r){!function(t){C(null!=t&&Array.isArray(t)&&t.length>0,(function(){return"promises must be a none empty array"}))}(t),function(t,e){C(t>=0&&t<=1,(function(){return"Progress fraction must be in range [0, 1], but got startFraction "+t})),C(e>=0&&e<=1,(function(){return"Progress fraction must be in range [0, 1], but got endFraction "+e})),C(e>=t,(function(){return"startFraction must be no more than endFraction, but got startFraction "+t+" and endFraction "+e}))}(n=null==n?0:n,r=null==r?1:r);var o=0;return Promise.all(t.map((function(a){return a.then((function(a){var i=n+ ++o/t.length*(r-n);return e(i),a})),a})))}function jf(t,e){return n(this,void 0,void 0,(function(){var n,o,a,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return null==e&&(e={}),n=null==e.fetchFunc?i().platform.fetch:e.fetchFunc,o=t.map((function(t){return n(t,e.requestInit,{isBinary:!0})})),a=0,s=.5,null!=e.onProgress?[3,2]:[4,Promise.all(o)];case 1:return u=r.sent(),[3,4];case 2:return[4,Kf(o,e.onProgress,a,s)];case 3:u=r.sent(),r.label=4;case 4:return c=u.map((function(t){return t.arrayBuffer()})),l=.5,h=1,null!=e.onProgress?[3,6]:[4,Promise.all(c)];case 5:return f=r.sent(),[3,8];case 6:return[4,Kf(c,e.onProgress,l,h)];case 7:f=r.sent(),r.label=8;case 8:return[2,f]}}))}))}function Xf(t){var e=this;return function(o,a,i){return void 0===a&&(a=""),n(e,void 0,void 0,(function(){var e,n,s,u,c,l,h,f,d,p;return r(this,(function(r){switch(r.label){case 0:if(e=o.map((function(){return!1})),n={},s=null!=i?i.map((function(){return!1})):[],u=[],o.forEach((function(t,r){var o=0;t.weights.forEach((function(t){var a="quantization"in t?t.quantization.dtype:t.dtype,c=sf[a]*k(t.shape),l=function(){e[r]=!0,null==n[r]&&(n[r]=[]),n[r].push({manifestEntry:t,groupOffset:o,sizeBytes:c})};null!=i?i.forEach((function(e,n){e===t.name&&(l(),s[n]=!0)})):l(),u.push(t.name),o+=c}))})),!s.every((function(t){return t})))throw c=i.filter((function(t,e){return!s[e]})),new Error("Could not find weights in manifest with names: "+c.join(", ")+". \nManifest JSON has weights with names: "+u.join(", ")+".");return l=e.reduce((function(t,e,n){return e&&t.push(n),t}),[]),h=[],l.forEach((function(t){o[t].paths.forEach((function(t){var e=a+(a.endsWith("/")?"":"/")+t;h.push(e)}))})),[4,t(h)];case 1:return f=r.sent(),d={},p=0,l.forEach((function(t){for(var e=o[t].paths.length,r=0,a=0;a<e;a++)r+=f[p+a].byteLength;for(var i=new ArrayBuffer(r),s=new Uint8Array(i),u=0,c=0;c<e;c++){var l=new Uint8Array(f[p+c]);s.set(l,u),u+=l.byteLength}n[t].forEach((function(t){var e=cf(i.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(var n in e)d[n]=e[n]})),p+=e})),[2,d]}}))}))}}mf.registerSaveRouter((function(t){return i().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Hf.URL_SCHEME)?function(t){void 0===t&&(t="model");return new Hf(t)}(t.slice(Hf.URL_SCHEME.length)):null}));var Yf=function(){function t(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(C("function"==typeof e.fetchFunc,(function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"})),this.fetch=e.fetchFunc):this.fetch=i().platform.fetch,C(null!=t&&t.length>0,(function(){return"URL path for http must not be null, undefined or empty."})),Array.isArray(t)&&C(2===t.length,(function(){return"URL paths for http must have a length of 2, (actual length is "+t.length+")."})),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a;return r(this,(function(r){switch(r.label){case 0:if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:n},e.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,e)];case 1:if((a=r.sent()).ok)return[2,{modelArtifactsInfo:vf(t),responses:[a]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+a.status+".")}}))}))},t.prototype.load=function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(t=r.sent()).ok)throw new Error("Request to "+this.path+" failed with status code "+t.status+". Please verify this URL points to the model JSON of the model to load.");r.label=2;case 2:return r.trys.push([2,4,,5]),[4,t.json()];case 3:return e=r.sent(),[3,5];case 4:throw r.sent(),n="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?n+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":n+=" Please make sure the server is serving valid JSON for this request.",new Error(n);case 5:if(o=e.modelTopology,a=e.weightsManifest,i=e.generatedBy,s=e.convertedBy,u=e.format,c=e.userDefinedMetadata,null==o&&null==a)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==a?[3,7]:[4,this.loadWeights(a)];case 6:f=r.sent(),l=f[0],h=f[1],r.label=7;case 7:return[2,{modelTopology:o,weightSpecs:l,weightData:h,userDefinedMetadata:c,generatedBy:i,convertedBy:s,format:u}]}}))}))},t.prototype.loadWeights=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:for(e=Array.isArray(this.path)?this.path[1]:this.path,n=function(t){var e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),o=n>e?t.substring(n):"";return[r+"/",o]}(e),o=n[0],a=n[1],i=this.weightPathPrefix||o,s=[],u=0,c=t;u<c.length;u++)l=c[u],s.push.apply(s,l.weights);return h=[],t.forEach((function(t){t.paths.forEach((function(t){h.push(i+t+a)}))})),[4,jf(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return f=r.sent(),[2,[s,df(f)]]}}))}))},t.URL_SCHEME_REGEX=/^https?:\/\//,t}();function $f(t){return null!=t.match(Yf.URL_SCHEME_REGEX)}var Qf=function(t,e){if("undefined"==typeof fetch)return null;return(Array.isArray(t)?t.every((function(t){return $f(t)})):$f(t))?Jf(t,{onProgress:e}):null};function Jf(t,e){return new Yf(t,e)}mf.registerSaveRouter(Qf),mf.registerLoadRouter(Qf);var Zf=function(){function t(t){this.modelArtifacts=t}return t.prototype.load=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){return[2,this.modelArtifacts]}))}))},t}(),td=function(){function t(t){this.saveHandler=t}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){return[2,this.saveHandler(t)]}))}))},t}();var ed=Object.freeze({browserFiles:function(t){return new qf(t)},browserHTTPRequest:function(t,e){return Jf(t,e)},concatenateArrayBuffers:df,decodeWeights:cf,encodeWeights:function(t,e){return n(this,void 0,void 0,(function(){var o,a,i,s,u,c=this;return r(this,(function(l){switch(l.label){case 0:for(o=[],a=[],i=Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t),s=function(s){var u=i[s],l=Array.isArray(t)?t[s].tensor:t[u];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype)throw new Error("Unsupported dtype in weight '"+u+"': "+l.dtype);var h={name:u,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){var f=new Promise((function(t){return n(c,void 0,void 0,(function(){var e,n,o,a,i,s,u;return r(this,(function(r){switch(r.label){case 0:return[4,l.bytes()];case 1:for(e=r.sent(),n=e.reduce((function(t,e){return t+e.length}),0)+uf*e.length,o=new Uint8Array(n),a=0,i=0;i<e.length;i++)s=e[i],u=new Uint8Array(new Uint32Array([s.length]).buffer),o.set(u,a),a+=uf,o.set(s,a),a+=s.length;return t(o),[2]}}))}))}));a.push(f)}else a.push(l.data());null!=e&&(h.group=e),o.push(h)},u=0;u<i.length;++u)s(u);return[4,Promise.all(a)];case 1:return[2,{data:lf(l.sent()),specs:o}]}}))}))},fromMemory:function(t,e,n,r){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new Zf(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zf({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zf({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))},getLoadHandlers:function(t,e){return mf.getLoadHandlers(t,e)},getModelArtifactsInfoForJSON:vf,getSaveHandlers:function(t){return mf.getSaveHandlers(t)},http:Jf,isHTTPScheme:$f,loadWeights:function(t,e,o,a){return void 0===e&&(e=""),n(this,void 0,void 0,(function(){return r(this,(function(n){return[2,Xf((function(t){return jf(t,{requestInit:a})}))(t,e,o)]}))}))},registerLoadRouter:function(t){return mf.registerLoadRouter(t)},registerSaveRouter:function(t){return mf.registerSaveRouter(t)},weightsLoaderFactory:Xf,withSaveHandler:function(t){return new td(t)},copyModel:function(t,e){return n(this,void 0,void 0,(function(){return r(this,(function(n){return!1,[2,bf(t,e,!1)]}))}))},listModels:function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i,s;return r(this,(function(r){switch(r.label){case 0:t=yf.getSchemes(),e={},n=0,o=t,r.label=1;case 1:return n<o.length?(a=o[n],[4,yf.getManager(a).listModels()]):[3,4];case 2:for(s in i=r.sent())e[a+gf+s]=i[s];r.label=3;case 3:return n++,[3,1];case 4:return[2,e]}}))}))},moveModel:function(t,e){return n(this,void 0,void 0,(function(){return r(this,(function(n){return!0,[2,bf(t,e,!0)]}))}))},removeModel:function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){return e=xf(t),[2,yf.getManager(e.scheme).removeModel(e.path)]}))}))}});var nd,rd=An({confusionMatrix_:function(t,e,n){var r=mn(t,"labels","confusionMatrix"),o=mn(e,"predictions","confusionMatrix");C(null==n||n>0&&Number.isInteger(n),(function(){return"If provided, numClasses must be a positive integer, but got "+n})),C(1===r.rank,(function(){return"Expected the rank of labels to be 1, but got "+r.rank})),C(1===o.rank,(function(){return"Expected the rank of predictions to be 1, but got "+o.rank})),C(r.shape[0]===o.shape[0],(function(){return"Mismatch in the number of examples: "+r.shape[0]+" vs. "+o.shape[0]+". Labels and predictions should have the same number of elements."})),C(n>0&&Number.isInteger(n),(function(){return"numClasses is required to be a positive integer, but got "+n}));var a=Rr(r.asType("int32"),n),i=Rr(o.asType("int32"),n);return a.transpose().matMul(i).asType("int32")}}),od=Object.freeze({confusionMatrix:rd});var ad=An({fromPixels_:function(t,e){if(void 0===e&&(e=3),e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n=!1,r=!1,o=!1,a=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)a=!0;else{if(null==t.getContext)throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+t.constructor.name);i=!0}if(o){if(o&&t.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=l("FromPixels",Lt.backendName))return Lt.runKernel("FromPixels",{pixels:t},{numChannels:e});var s,u,c=o?[t.videoWidth,t.videoHeight]:[t.width,t.height],h=c[0],f=c[1];if(i?s=t.getContext("2d").getImageData(0,0,h,f).data:r||n?s=t.data:(a||o)&&(null==nd&&(nd=document.createElement("canvas").getContext("2d")),nd.canvas.width=h,nd.canvas.height=f,nd.drawImage(t,0,0,h,f),s=nd.getImageData(0,0,h,f).data),4===e)u=new Int32Array(s);else{var d=h*f;u=new Int32Array(d*e);for(var p=0;p<d;p++)for(var v=0;v<e;++v)u[p*e+v]=s[4*p+v]}return Pn(u,[f,h,e],"int32")}}),id=Object.freeze({toPixels:function(t,e){return n(this,void 0,void 0,(function(){var n,o,a,i,s,u,c,l,h,f,d,p,v,m,g,y,x,b,w,C,E,R,I;return r(this,(function(r){switch(r.label){case 0:if(n=mn(t,"img","toPixels"),t instanceof wt||(n=n.toInt()),2!==n.rank&&3!==n.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+n.rank+".");if(o=n.shape.slice(0,2),a=o[0],i=o[1],(s=2===n.rank?1:n.shape[2])>4||2===s)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+s);return[4,n.data()];case 1:return u=r.sent(),c=n.min(),l=n.max(),[4,Promise.all([c.data(),l.data()])];case 2:if(h=r.sent(),f=h[0],d=h[1],p=f[0],v=d[0],c.dispose(),l.dispose(),"float32"===n.dtype){if(p<0||v>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+p+" - "+v+"].")}else{if("int32"!==n.dtype)throw new Error("Unsupported type for toPixels: "+n.dtype+". Please use float32 or int32 tensors.");if(p<0||v>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+p+" - "+v+"].")}for(m="float32"===n.dtype?255:1,g=new Uint8ClampedArray(i*a*4),y=0;y<a*i;++y)x=void 0,b=void 0,w=void 0,C=void 0,1===s?(x=u[y]*m,b=u[y]*m,w=u[y]*m,C=255):3===s?(x=u[3*y]*m,b=u[3*y+1]*m,w=u[3*y+2]*m,C=255):4===s&&(x=u[4*y]*m,b=u[4*y+1]*m,w=u[4*y+2]*m,C=u[4*y+3]*m),g[(E=4*y)+0]=Math.round(x),g[E+1]=Math.round(b),g[E+2]=Math.round(w),g[E+3]=Math.round(C);return null!=e&&(e.width=i,e.height=a,R=e.getContext("2d"),I=new ImageData(g,i,a),R.putImageData(I,0,0)),n!==t&&n.dispose(),[2,g]}}))}))},fromPixels:ad}),sd=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(t,e){return new t(e)},t}(),ud=function(){function t(){this.classNameMap={}}return t.getMap=function(){return null==t.instance&&(t.instance=new t),t.instance},t.register=function(e){t.getMap().classNameMap[e.className]=[e,e.fromConfig]},t}();function cd(t){C(null!=t.className,(function(){return"Class being registered does not have the static className property defined."})),C("string"==typeof t.className,(function(){return"className is required to be a string, but got type "+typeof t.className})),C(t.className.length>0,(function(){return"Class being registered has an empty-string as its className, which is disallowed."})),ud.register(t)}var ld=Object.freeze({Serializable:sd,SerializationMap:ud,registerClass:cd}),hd=.001,fd=.1;function dd(){return 32===Lt.backend.floatPrecision()?hd:fd}function pd(t,e,n){var r=!0;if((V(t)||V(e))&&(r=!1),V(t)&&V(e)&&(r=!0),r){var o=t.constructor.name,a=e.constructor.name;if(o!==a)throw new Error("Arrays are of different type. Actual: "+o+". Expected: "+a)}if(Array.isArray(t)&&Array.isArray(e)){var i=pn(t),s=pn(e);if(!S(i,s))throw new Error("Arrays have different shapes. Actual: ["+i+"]. Expected: ["+s+"]")}var u=V(t)?t:I(t),c=V(e)?e:I(e);if(u.length!==c.length)throw new Error("Arrays have different lengths actual: "+u.length+" vs expected: "+c.length+".\nActual:   "+u+".\nExpected: "+c+".");for(var l=0;l<c.length;++l){var h=u[l],f=c[l];if(!n(h,f))throw new Error("Arrays differ: actual["+l+"] = "+h+", expected["+l+"] = "+f+".\nActual:   "+u+".\nExpected: "+c+".")}}function vd(t,e,n){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}var md=Object.freeze({TEST_EPSILON_FLOAT16:fd,expectArraysClose:function(t,e,n){return null==n&&(n=dd()),pd(t,e,(function(t,e){return vd(t,e,n)}))},testEpsilon:dd,expectPromiseToFail:function(t,e){t().then((function(){return e.fail()}),(function(){return e()}))},expectArraysEqual:function(t,e){var n="string"==typeof e||"number"==typeof e||"boolean"==typeof e?[e]:e;return H(t)||H(t[0])||H(e)||H(e[0])?pd(t,n,(function(t,e){return t==e})):pd(t,e,(function(t,e){return vd(t,e,0)}))},expectNumbersClose:function(t,e,n){if(null==n&&(n=dd()),!vd(t,e,n))throw new Error("Numbers differ: actual === "+t+", expected === "+e)},expectValuesInRange:function(t,e,n){for(var r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error("Value out of range:"+t[r]+" low: "+e+", high: "+n)},expectArrayBuffersEqual:function(t,e){expect(new Float32Array(t)).toEqual(new Float32Array(e))}}),gd="1.7.0";var yd=Object.freeze({gpgpu_util:Mi,webgl_util:Ge,forceHalfFloat:function(){i().set("WEBGL_FORCE_F16_TEXTURES",!0)},MathBackendWebGL:Zs,setWebGLContext:Kt,GPGPUContext:Bi}),xd=function(t){function o(){return null!==t&&t.apply(this,arguments)||this}return e(o,t),o.prototype.minimize=function(t,e,n){void 0===e&&(e=!1);var r=this.computeGradients(t,n),o=r.value,a=r.grads;if(null!=n){var i=n.map((function(t){return{name:t.name,tensor:a[t.name]}}));this.applyGradients(i)}else this.applyGradients(a);return tn(a),e?o:(o.dispose(),null)},Object.defineProperty(o.prototype,"iterations",{get:function(){return null==this.iterations_&&(this.iterations_=0),this.iterations_},enumerable:!0,configurable:!0}),o.prototype.incrementIterations=function(){this.iterations_=this.iterations+1},o.prototype.computeGradients=function(t,e){return po(t,e)},o.prototype.dispose=function(){null!=this.iterations_&&tn(this.iterations_)},o.prototype.saveIterations=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){return null==this.iterations_&&(this.iterations_=0),[2,{name:"iter",tensor:On(this.iterations_,"int32")}]}))}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("getWeights() is not implemented for this optimizer yet.")}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}))}))},o.prototype.extractIterations=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){switch(n.label){case 0:return e=this,[4,t[0].tensor.data()];case 1:return e.iterations_=n.sent()[0],[2,t.slice(1)]}}))}))},o}(sd);Object.defineProperty(xd,Symbol.hasInstance,{value:function(t){return null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients}});var bd=function(t){function o(e,n,r){void 0===r&&(r=null);var o=t.call(this)||this;return o.learningRate=e,o.rho=n,o.epsilon=r,o.accumulatedGrads=[],o.accumulatedUpdates=[],null==r&&(o.epsilon=Lt.backend.epsilon()),o}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];null==e.accumulatedGrads[r]&&(e.accumulatedGrads[r]={originalName:n+"/accum_grad",variable:Ze((function(){return Xn(o).variable(!1)}))}),null==e.accumulatedUpdates[r]&&(e.accumulatedUpdates[r]={originalName:n+"/accum_var",variable:Ze((function(){return Xn(o).variable(!1)}))});var a=Array.isArray(t)?t[r].tensor:t[n];if(null!=a){var i=e.accumulatedGrads[r].variable,s=e.accumulatedUpdates[r].variable;Ze((function(){var t=i.mul(e.rho).add(a.square().mul(1-e.rho)),n=s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),r=s.mul(e.rho).add(n.square().mul(1-e.rho));i.assign(t),s.assign(r);var u=n.mul(-e.learningRate).add(o);o.assign(u)}))}})),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedUpdates&&(tn(this.accumulatedGrads.map((function(t){return t.variable}))),tn(this.accumulatedUpdates.map((function(t){return t.variable}))))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return t=this.accumulatedGrads.concat(this.accumulatedUpdates),[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(t.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){switch(n.label){case 0:return[4,this.extractIterations(t)];case 1:return t=n.sent(),e=t.length/2,!1,this.accumulatedGrads=t.slice(0,e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.accumulatedUpdates=t.slice(e,2*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},o.fromConfig=function(t,e){return new t(e.learningRate,e.rho,e.epsilon)},o.className="Adadelta",o}(xd);cd(bd);var wd=function(t){function o(e,n){void 0===n&&(n=.1);var r=t.call(this)||this;return r.learningRate=e,r.initialAccumulatorValue=n,r.accumulatedGrads=[],r}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];if(null==e.accumulatedGrads[r]){e.accumulatedGrads[r]={originalName:n+"/accumulator",variable:Ze((function(){return Hn(o.shape,e.initialAccumulatorValue).variable(!1)}))}}var a=Array.isArray(t)?t[r].tensor:t[n];if(null!=a){var i=e.accumulatedGrads[r].variable;Ze((function(){var t=i.add(a.square());i.assign(t);var n=a.div(t.add(Lt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);o.assign(n)}))}})),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedGrads&&tn(this.accumulatedGrads.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return[4,this.saveIterations()];case 1:return[2,[t.sent()].concat(this.accumulatedGrads.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){switch(e.label){case 0:return[4,this.extractIterations(t)];case 1:return t=e.sent(),!1,this.accumulatedGrads=t.map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},o.fromConfig=function(t,e){return new t(e.learningRate,e.initialAccumulatorValue)},o.className="Adagrad",o}(xd);cd(wd);var Cd=function(t){function o(e,n,r,o){void 0===o&&(o=null);var a=t.call(this)||this;return a.learningRate=e,a.beta1=n,a.beta2=r,a.epsilon=o,a.accumulatedFirstMoment=[],a.accumulatedSecondMoment=[],Ze((function(){a.accBeta1=On(n).variable(),a.accBeta2=On(r).variable()})),null==o&&(a.epsilon=Lt.backend.epsilon()),a}return e(o,t),o.prototype.applyGradients=function(t){var e=this,n=Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t);Ze((function(){var r=Cc(1,e.accBeta1),o=Cc(1,e.accBeta2);n.forEach((function(n,a){var i=Lt.registeredVariables[n];null==e.accumulatedFirstMoment[a]&&(e.accumulatedFirstMoment[a]={originalName:n+"/m",variable:Ze((function(){return Xn(i).variable(!1)}))}),null==e.accumulatedSecondMoment[a]&&(e.accumulatedSecondMoment[a]={originalName:n+"/v",variable:Ze((function(){return Xn(i).variable(!1)}))});var s=Array.isArray(t)?t[a].tensor:t[n];if(null!=s){var u=e.accumulatedFirstMoment[a].variable,c=e.accumulatedSecondMoment[a].variable,l=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=c.mul(e.beta2).add(s.square().mul(1-e.beta2)),f=l.div(r),d=h.div(o);u.assign(l),c.assign(h);var p=f.div(d.sqrt().add(e.epsilon)).mul(-e.learningRate).add(i);i.assign(p)}})),e.accBeta1.assign(e.accBeta1.mul(e.beta1)),e.accBeta2.assign(e.accBeta2.mul(e.beta2))})),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map((function(t){return t.variable}))),null!=this.accumulatedSecondMoment&&tn(this.accumulatedSecondMoment.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return t=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(t.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){var e,n=this;return r(this,(function(r){switch(r.label){case 0:return[4,this.extractIterations(t)];case 1:return t=r.sent(),Ze((function(){n.accBeta1.assign(xc(n.beta1,n.iterations_+1)),n.accBeta2.assign(xc(n.beta2,n.iterations_+1))})),e=t.length/2,!1,this.accumulatedFirstMoment=t.slice(0,e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.accumulatedSecondMoment=t.slice(e,2*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},o.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)},o.className="Adam",o}(xd);cd(Cd);var Ed=function(t){function o(e,n,r,o,a){void 0===o&&(o=null),void 0===a&&(a=0);var i=t.call(this)||this;return i.learningRate=e,i.beta1=n,i.beta2=r,i.epsilon=o,i.decay=a,i.accumulatedFirstMoment=[],i.accumulatedWeightedInfNorm=[],Ze((function(){i.iteration=On(0).variable(),i.accBeta1=On(n).variable()})),null==o&&(i.epsilon=Lt.backend.epsilon()),i}return e(o,t),o.prototype.applyGradients=function(t){var e=this,n=Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t);Ze((function(){var r=Cc(1,e.accBeta1),o=sc(-e.learningRate,e.iteration.mul(e.decay).add(1));n.forEach((function(n,a){var i=Lt.registeredVariables[n];null==e.accumulatedFirstMoment[a]&&(e.accumulatedFirstMoment[a]={originalName:n+"/m",variable:Xn(i).variable(!1)}),null==e.accumulatedWeightedInfNorm[a]&&(e.accumulatedWeightedInfNorm[a]={originalName:n+"/v",variable:Xn(i).variable(!1)});var s=Array.isArray(t)?t[a].tensor:t[n];if(null!=s){var u=e.accumulatedFirstMoment[a].variable,c=e.accumulatedWeightedInfNorm[a].variable,l=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=c.mul(e.beta2),f=s.abs(),d=h.maximum(f);u.assign(l),c.assign(d);var p=o.div(r).mul(l.div(d.add(e.epsilon))).add(i);i.assign(p)}})),e.iteration.assign(e.iteration.add(1)),e.accBeta1.assign(e.accBeta1.mul(e.beta1))})),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map((function(t){return t.variable}))),null!=this.accumulatedWeightedInfNorm&&tn(this.accumulatedWeightedInfNorm.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("getWeights() is not implemented for Adamax yet.")}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("setWeights() is not implemented for Adamax yet.")}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},o.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)},o.className="Adamax",o}(xd);cd(Ed);var Rd=function(t){function o(e){var n=t.call(this)||this;return n.learningRate=e,n.setLearningRate(e),n}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Array.isArray(t)?t[r].tensor:t[n];if(null!=o){var a=Lt.registeredVariables[n];Ze((function(){var t=e.c.mul(o).add(a);a.assign(t)}))}})),this.incrementIterations()},o.prototype.setLearningRate=function(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=en(On(-t))},o.prototype.dispose=function(){this.c.dispose()},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return[4,this.saveIterations()];case 1:return[2,[t.sent()]]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){switch(e.label){case 0:return[4,this.extractIterations(t)];case 1:if(0!==(t=e.sent()).length)throw new Error("SGD optimizer does not have settable weights.");return[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate}},o.fromConfig=function(t,e){return new t(e.learningRate)},o.className="SGD",o}(xd);cd(Rd);var Id=function(t){function o(e,n,r){void 0===r&&(r=!1);var o=t.call(this,e)||this;return o.learningRate=e,o.momentum=n,o.useNesterov=r,o.accumulations=[],o.m=On(o.momentum),o}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];if(null==e.accumulations[r]){e.accumulations[r]={originalName:n+"/momentum",variable:Ze((function(){return Xn(o).variable(!1)}))}}var a=e.accumulations[r].variable,i=Array.isArray(t)?t[r].tensor:t[n];null!=i&&Ze((function(){var t,n=e.m.mul(a).add(i);t=e.useNesterov?e.c.mul(i.add(n.mul(e.m))).add(o):e.c.mul(n).add(o),a.assign(n),o.assign(t)}))})),this.incrementIterations()},o.prototype.dispose=function(){this.m.dispose(),null!=this.accumulations&&tn(this.accumulations.map((function(t){return t.variable})))},o.prototype.setMomentum=function(t){this.momentum=t},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return[4,this.saveIterations()];case 1:return[2,[t.sent()].concat(this.accumulations.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){switch(e.label){case 0:return[4,this.extractIterations(t)];case 1:return t=e.sent(),!1,this.accumulations=t.map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},o.fromConfig=function(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)},o.className="Momentum",o}(Rd);cd(Id);var kd=function(t){function o(e,n,r,o,a){void 0===n&&(n=.9),void 0===r&&(r=0),void 0===o&&(o=null),void 0===a&&(a=!1);var i=t.call(this)||this;if(i.learningRate=e,i.decay=n,i.momentum=r,i.epsilon=o,i.accumulatedMeanSquares=[],i.accumulatedMoments=[],i.accumulatedMeanGrads=[],i.centered=a,null==o&&(i.epsilon=Lt.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.");return i}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];null==e.accumulatedMeanSquares[r]&&(e.accumulatedMeanSquares[r]={originalName:n+"/rms",variable:Ze((function(){return Xn(o).variable(!1)}))}),null==e.accumulatedMoments[r]&&(e.accumulatedMoments[r]={originalName:n+"/momentum",variable:Ze((function(){return Xn(o).variable(!1)}))}),null==e.accumulatedMeanGrads[r]&&e.centered&&(e.accumulatedMeanGrads[r]={originalName:n+"/mg",variable:Ze((function(){return Xn(o).variable(!1)}))});var a=Array.isArray(t)?t[r].tensor:t[n];if(null!=a){var i=e.accumulatedMeanSquares[r].variable,s=e.accumulatedMoments[r].variable;Ze((function(){var t=i.mul(e.decay).add(a.square().mul(1-e.decay));if(e.centered){var n=e.accumulatedMeanGrads[r].variable,u=n.mul(e.decay).add(a.mul(1-e.decay)),c=s.mul(e.momentum).add(a.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));i.assign(t),n.assign(u),s.assign(c);var l=o.sub(c);o.assign(l)}else{var h=i.mul(e.decay).add(a.square().mul(1-e.decay));c=s.mul(e.momentum).add(a.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));i.assign(h),s.assign(c);l=o.sub(c);o.assign(l)}}))}})),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedMeanSquares&&tn(this.accumulatedMeanSquares.map((function(t){return t.variable}))),null!=this.accumulatedMeanGrads&&this.centered&&tn(this.accumulatedMeanGrads.map((function(t){return t.variable}))),null!=this.accumulatedMoments&&tn(this.accumulatedMoments.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return t=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&t.push.apply(t,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(t.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){switch(n.label){case 0:return[4,this.extractIterations(t)];case 1:return t=n.sent(),e=this.centered?t.length/3:t.length/2,!1,this.accumulatedMeanSquares=t.slice(0,e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.accumulatedMoments=t.slice(e,2*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}}))),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},o.fromConfig=function(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)},o.className="RMSProp",o}(xd);cd(kd);var Sd=function(){function t(){}return t.sgd=function(t){return new Rd(t)},t.momentum=function(t,e,n){return void 0===n&&(n=!1),new Id(t,e,n)},t.rmsprop=function(t,e,n,r,o){return void 0===e&&(e=.9),void 0===n&&(n=0),void 0===r&&(r=null),void 0===o&&(o=!1),new kd(t,e,n,r,o)},t.adam=function(t,e,n,r){return void 0===t&&(t=.001),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),new Cd(t,e,n,r)},t.adadelta=function(t,e,n){return void 0===t&&(t=.001),void 0===e&&(e=.95),void 0===n&&(n=null),new bd(t,e,n)},t.adamax=function(t,e,n,r,o){return void 0===t&&(t=.002),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),void 0===o&&(o=0),new Ed(t,e,n,r,o)},t.adagrad=function(t,e){return void 0===e&&(e=.1),new wd(t,e)},t}(),Ad={sgd:Sd.sgd,momentum:Sd.momentum,adadelta:Sd.adadelta,adagrad:Sd.adagrad,rmsprop:Sd.rmsprop,adamax:Sd.adamax,adam:Sd.adam},Dd="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:function(t){return t()};function Td(){return new Promise((function(t){return Dd((function(){return t()}))}))}wt.prototype.squaredDifference=function(t){return nu(this,t)},xt=Gh;
//# sourceMappingURL=tf-core.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/NeuralNetwork.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/NeuralNetwork.js ***!
  \*************************************************************/
/*! exports provided: NeuralNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeuralNetwork", function() { return NeuralNetwork; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_getModelUris__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/getModelUris */ "./node_modules/face-api.js/build/es6/common/getModelUris.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env */ "./node_modules/face-api.js/build/es6/env/index.js");





var NeuralNetwork = /** @class */ (function () {
    function NeuralNetwork(_name) {
        this._name = _name;
        this._params = undefined;
        this._paramMappings = [];
    }
    Object.defineProperty(NeuralNetwork.prototype, "params", {
        get: function () { return this._params; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NeuralNetwork.prototype, "paramMappings", {
        get: function () { return this._paramMappings; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NeuralNetwork.prototype, "isLoaded", {
        get: function () { return !!this.params; },
        enumerable: true,
        configurable: true
    });
    NeuralNetwork.prototype.getParamFromPath = function (paramPath) {
        var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;
        return obj[objProp];
    };
    NeuralNetwork.prototype.reassignParamFromPath = function (paramPath, tensor) {
        var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;
        obj[objProp].dispose();
        obj[objProp] = tensor;
    };
    NeuralNetwork.prototype.getParamList = function () {
        var _this = this;
        return this._paramMappings.map(function (_a) {
            var paramPath = _a.paramPath;
            return ({
                path: paramPath,
                tensor: _this.getParamFromPath(paramPath)
            });
        });
    };
    NeuralNetwork.prototype.getTrainableParams = function () {
        return this.getParamList().filter(function (param) { return param.tensor instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Variable"]; });
    };
    NeuralNetwork.prototype.getFrozenParams = function () {
        return this.getParamList().filter(function (param) { return !(param.tensor instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Variable"]); });
    };
    NeuralNetwork.prototype.variable = function () {
        var _this = this;
        this.getFrozenParams().forEach(function (_a) {
            var path = _a.path, tensor = _a.tensor;
            _this.reassignParamFromPath(path, tensor.variable());
        });
    };
    NeuralNetwork.prototype.freeze = function () {
        var _this = this;
        this.getTrainableParams().forEach(function (_a) {
            var path = _a.path, variable = _a.tensor;
            var tensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tensor"](variable.dataSync());
            variable.dispose();
            _this.reassignParamFromPath(path, tensor);
        });
    };
    NeuralNetwork.prototype.dispose = function (throwOnRedispose) {
        if (throwOnRedispose === void 0) { throwOnRedispose = true; }
        this.getParamList().forEach(function (param) {
            if (throwOnRedispose && param.tensor.isDisposed) {
                throw new Error("param tensor has already been disposed for path " + param.path);
            }
            param.tensor.dispose();
        });
        this._params = undefined;
    };
    NeuralNetwork.prototype.serializeParams = function () {
        return new Float32Array(this.getParamList()
            .map(function (_a) {
            var tensor = _a.tensor;
            return Array.from(tensor.dataSync());
        })
            .reduce(function (flat, arr) { return flat.concat(arr); }));
    };
    NeuralNetwork.prototype.load = function (weightsOrUrl) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (weightsOrUrl instanceof Float32Array) {
                            this.extractWeights(weightsOrUrl);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.loadFromUri(weightsOrUrl)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    NeuralNetwork.prototype.loadFromUri = function (uri) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var weightMap;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (uri && typeof uri !== 'string') {
                            throw new Error(this._name + ".loadFromUri - expected model uri");
                        }
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_3__["loadWeightMap"])(uri, this.getDefaultModelName())];
                    case 1:
                        weightMap = _a.sent();
                        this.loadFromWeightMap(weightMap);
                        return [2 /*return*/];
                }
            });
        });
    };
    NeuralNetwork.prototype.loadFromDisk = function (filePath) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var readFile, _a, manifestUri, modelBaseUri, fetchWeightsFromDisk, loadWeights, manifest, _b, _c, weightMap;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (filePath && typeof filePath !== 'string') {
                            throw new Error(this._name + ".loadFromDisk - expected model file path");
                        }
                        readFile = _env__WEBPACK_IMPORTED_MODULE_4__["env"].getEnv().readFile;
                        _a = Object(_common_getModelUris__WEBPACK_IMPORTED_MODULE_2__["getModelUris"])(filePath, this.getDefaultModelName()), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;
                        fetchWeightsFromDisk = function (filePaths) { return Promise.all(filePaths.map(function (filePath) { return readFile(filePath).then(function (buf) { return buf.buffer; }); })); };
                        loadWeights = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["io"].weightsLoaderFactory(fetchWeightsFromDisk);
                        _c = (_b = JSON).parse;
                        return [4 /*yield*/, readFile(manifestUri)];
                    case 1:
                        manifest = _c.apply(_b, [(_d.sent()).toString()]);
                        return [4 /*yield*/, loadWeights(manifest, modelBaseUri)];
                    case 2:
                        weightMap = _d.sent();
                        this.loadFromWeightMap(weightMap);
                        return [2 /*return*/];
                }
            });
        });
    };
    NeuralNetwork.prototype.loadFromWeightMap = function (weightMap) {
        var _a = this.extractParamsFromWeigthMap(weightMap), paramMappings = _a.paramMappings, params = _a.params;
        this._paramMappings = paramMappings;
        this._params = params;
    };
    NeuralNetwork.prototype.extractWeights = function (weights) {
        var _a = this.extractParams(weights), paramMappings = _a.paramMappings, params = _a.params;
        this._paramMappings = paramMappings;
        this._params = params;
    };
    NeuralNetwork.prototype.traversePropertyPath = function (paramPath) {
        if (!this.params) {
            throw new Error("traversePropertyPath - model has no loaded params");
        }
        var result = paramPath.split('/').reduce(function (res, objProp) {
            if (!res.nextObj.hasOwnProperty(objProp)) {
                throw new Error("traversePropertyPath - object does not have property " + objProp + ", for path " + paramPath);
            }
            return { obj: res.nextObj, objProp: objProp, nextObj: res.nextObj[objProp] };
        }, { nextObj: this.params });
        var obj = result.obj, objProp = result.objProp;
        if (!obj || !objProp || !(obj[objProp] instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) {
            throw new Error("traversePropertyPath - parameter is not a tensor, for path " + paramPath);
        }
        return { obj: obj, objProp: objProp };
    };
    return NeuralNetwork;
}());

//# sourceMappingURL=NeuralNetwork.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js":
/*!*************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js ***!
  \*************************************************************************/
/*! exports provided: AgeGenderNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgeGenderNet", function() { return AgeGenderNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _faceProcessor_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../faceProcessor/util */ "./node_modules/face-api.js/build/es6/faceProcessor/util.js");
/* harmony import */ var _xception_TinyXception__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../xception/TinyXception */ "./node_modules/face-api.js/build/es6/xception/TinyXception.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");










var AgeGenderNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(AgeGenderNet, _super);
    function AgeGenderNet(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _xception_TinyXception__WEBPACK_IMPORTED_MODULE_4__["TinyXception"](2); }
        var _this = _super.call(this, 'AgeGenderNet') || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
    }
    Object.defineProperty(AgeGenderNet.prototype, "faceFeatureExtractor", {
        get: function () {
            return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
    });
    AgeGenderNet.prototype.runNet = function (input) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error(this._name + " - load model before inference");
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var bottleneckFeatures = input instanceof _dom__WEBPACK_IMPORTED_MODULE_9__["NetInput"]
                ? _this.faceFeatureExtractor.forwardInput(input)
                : input;
            var pooled = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](bottleneckFeatures, [7, 7], [2, 2], 'valid').as2D(bottleneckFeatures.shape[0], -1);
            var age = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(pooled, params.fc.age).as1D();
            var gender = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(pooled, params.fc.gender);
            return { age: age, gender: gender };
        });
    };
    AgeGenderNet.prototype.forwardInput = function (input) {
        var _this = this;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var _a = _this.runNet(input), age = _a.age, gender = _a.gender;
            return { age: age, gender: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["softmax"](gender) };
        });
    };
    AgeGenderNet.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_9__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    AgeGenderNet.prototype.predictAgeAndGender = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, out, ages, genders, ageAndGenderTensors, predictionsByBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_9__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        return [4 /*yield*/, this.forwardInput(netInput)];
                    case 2:
                        out = _a.sent();
                        ages = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out.age);
                        genders = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out.gender);
                        ageAndGenderTensors = ages.map(function (ageTensor, i) { return ({
                            ageTensor: ageTensor,
                            genderTensor: genders[i]
                        }); });
                        return [4 /*yield*/, Promise.all(ageAndGenderTensors.map(function (_a) {
                                var ageTensor = _a.ageTensor, genderTensor = _a.genderTensor;
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                    var age, probMale, isMale, gender, genderProbability;
                                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4 /*yield*/, ageTensor.data()];
                                            case 1:
                                                age = (_b.sent())[0];
                                                return [4 /*yield*/, genderTensor.data()];
                                            case 2:
                                                probMale = (_b.sent())[0];
                                                isMale = probMale > 0.5;
                                                gender = isMale ? _types__WEBPACK_IMPORTED_MODULE_7__["Gender"].MALE : _types__WEBPACK_IMPORTED_MODULE_7__["Gender"].FEMALE;
                                                genderProbability = isMale ? probMale : (1 - probMale);
                                                ageTensor.dispose();
                                                genderTensor.dispose();
                                                return [2 /*return*/, { age: age, gender: gender, genderProbability: genderProbability }];
                                        }
                                    });
                                });
                            }))];
                    case 3:
                        predictionsByBatch = _a.sent();
                        out.age.dispose();
                        out.gender.dispose();
                        return [2 /*return*/, netInput.isBatchInput
                                ? predictionsByBatch
                                : predictionsByBatch[0]];
                }
            });
        });
    };
    AgeGenderNet.prototype.getDefaultModelName = function () {
        return 'age_gender_model';
    };
    AgeGenderNet.prototype.dispose = function (throwOnRedispose) {
        if (throwOnRedispose === void 0) { throwOnRedispose = true; }
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
    };
    AgeGenderNet.prototype.loadClassifierParams = function (weights) {
        var _a = this.extractClassifierParams(weights), params = _a.params, paramMappings = _a.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
    };
    AgeGenderNet.prototype.extractClassifierParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_5__["extractParams"])(weights);
    };
    AgeGenderNet.prototype.extractParamsFromWeigthMap = function (weightMap) {
        var _a = Object(_faceProcessor_util__WEBPACK_IMPORTED_MODULE_3__["seperateWeightMaps"])(weightMap), featureExtractorMap = _a.featureExtractorMap, classifierMap = _a.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__["extractParamsFromWeigthMap"])(classifierMap);
    };
    AgeGenderNet.prototype.extractParams = function (weights) {
        var classifierWeightSize = (512 * 1 + 1) + (512 * 2 + 2);
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
    };
    return AgeGenderNet;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_8__["NeuralNetwork"]));

//# sourceMappingURL=AgeGenderNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js ***!
  \**************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParams(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractFCParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractFCParamsFactory"])(extractWeights, paramMappings);
    var age = extractFCParams(512, 1, 'fc/age');
    var gender = extractFCParams(512, 2, 'fc/gender');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { fc: { age: age, gender: gender } }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js ***!
  \***************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractFcParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { weights: weights, bias: bias };
    }
    var params = {
        fc: {
            age: extractFcParams('fc/age'),
            gender: extractFcParams('fc/gender')
        }
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/index.js ***!
  \******************************************************************/
/*! exports provided: AgeGenderNet, Gender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AgeGenderNet */ "./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AgeGenderNet", function() { return _AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__["AgeGenderNet"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gender", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Gender"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/types.js ***!
  \******************************************************************/
/*! exports provided: Gender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gender", function() { return Gender; });
var Gender;
(function (Gender) {
    Gender["FEMALE"] = "female";
    Gender["MALE"] = "male";
})(Gender || (Gender = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/BoundingBox.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/BoundingBox.js ***!
  \*******************************************************************/
/*! exports provided: BoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return BoundingBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");


var BoundingBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(BoundingBox, _super);
    function BoundingBox(left, top, right, bottom, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }
        return _super.call(this, { left: left, top: top, right: right, bottom: bottom }, allowNegativeDimensions) || this;
    }
    return BoundingBox;
}(_Box__WEBPACK_IMPORTED_MODULE_1__["Box"]));

//# sourceMappingURL=BoundingBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Box.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Box.js ***!
  \***********************************************************/
/*! exports provided: Box */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point */ "./node_modules/face-api.js/build/es6/classes/Point.js");


var Box = /** @class */ (function () {
    function Box(_box, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = true; }
        var box = (_box || {});
        var isBbox = [box.left, box.top, box.right, box.bottom].every(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"]);
        var isRect = [box.x, box.y, box.width, box.height].every(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"]);
        if (!isRect && !isBbox) {
            throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have " + JSON.stringify(box));
        }
        var _a = isRect
            ? [box.x, box.y, box.width, box.height]
            : [box.left, box.top, box.right - box.left, box.bottom - box.top], x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        Box.assertIsValidBox({ x: x, y: y, width: width, height: height }, 'Box.constructor', allowNegativeDimensions);
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
    }
    Box.isRect = function (rect) {
        return !!rect && [rect.x, rect.y, rect.width, rect.height].every(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"]);
    };
    Box.assertIsValidBox = function (box, callee, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }
        if (!Box.isRect(box)) {
            throw new Error(callee + " - invalid box: " + JSON.stringify(box) + ", expected object with properties x, y, width, height");
        }
        if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {
            throw new Error(callee + " - width (" + box.width + ") and height (" + box.height + ") must be positive numbers");
        }
    };
    Object.defineProperty(Box.prototype, "x", {
        get: function () { return this._x; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "y", {
        get: function () { return this._y; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "width", {
        get: function () { return this._width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "height", {
        get: function () { return this._height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "left", {
        get: function () { return this.x; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "top", {
        get: function () { return this.y; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "right", {
        get: function () { return this.x + this.width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottom", {
        get: function () { return this.y + this.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "area", {
        get: function () { return this.width * this.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "topLeft", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.left, this.top); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "topRight", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.right, this.top); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottomLeft", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.left, this.bottom); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottomRight", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.right, this.bottom); },
        enumerable: true,
        configurable: true
    });
    Box.prototype.round = function () {
        var _a = [this.x, this.y, this.width, this.height]
            .map(function (val) { return Math.round(val); }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.floor = function () {
        var _a = [this.x, this.y, this.width, this.height]
            .map(function (val) { return Math.floor(val); }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.toSquare = function () {
        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        var diff = Math.abs(width - height);
        if (width < height) {
            x -= (diff / 2);
            width += diff;
        }
        if (height < width) {
            y -= (diff / 2);
            height += diff;
        }
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.rescale = function (s) {
        var scaleX = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isDimensions"])(s) ? s.width : s;
        var scaleY = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isDimensions"])(s) ? s.height : s;
        return new Box({
            x: this.x * scaleX,
            y: this.y * scaleY,
            width: this.width * scaleX,
            height: this.height * scaleY
        });
    };
    Box.prototype.pad = function (padX, padY) {
        var _a = [
            this.x - (padX / 2),
            this.y - (padY / 2),
            this.width + padX,
            this.height + padY
        ], x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.clipAtImageBorders = function (imgWidth, imgHeight) {
        var _a = this, x = _a.x, y = _a.y, right = _a.right, bottom = _a.bottom;
        var clippedX = Math.max(x, 0);
        var clippedY = Math.max(y, 0);
        var newWidth = right - clippedX;
        var newHeight = bottom - clippedY;
        var clippedWidth = Math.min(newWidth, imgWidth - clippedX);
        var clippedHeight = Math.min(newHeight, imgHeight - clippedY);
        return (new Box({ x: clippedX, y: clippedY, width: clippedWidth, height: clippedHeight })).floor();
    };
    Box.prototype.shift = function (sx, sy) {
        var _a = this, width = _a.width, height = _a.height;
        var x = this.x + sx;
        var y = this.y + sy;
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.padAtBorders = function (imageHeight, imageWidth) {
        var w = this.width + 1;
        var h = this.height + 1;
        var dx = 1;
        var dy = 1;
        var edx = w;
        var edy = h;
        var x = this.left;
        var y = this.top;
        var ex = this.right;
        var ey = this.bottom;
        if (ex > imageWidth) {
            edx = -ex + imageWidth + w;
            ex = imageWidth;
        }
        if (ey > imageHeight) {
            edy = -ey + imageHeight + h;
            ey = imageHeight;
        }
        if (x < 1) {
            edy = 2 - x;
            x = 1;
        }
        if (y < 1) {
            edy = 2 - y;
            y = 1;
        }
        return { dy: dy, edy: edy, dx: dx, edx: edx, y: y, ey: ey, x: x, ex: ex, w: w, h: h };
    };
    Box.prototype.calibrate = function (region) {
        return new Box({
            left: this.left + (region.left * this.width),
            top: this.top + (region.top * this.height),
            right: this.right + (region.right * this.width),
            bottom: this.bottom + (region.bottom * this.height)
        }).toSquare().round();
    };
    return Box;
}());

//# sourceMappingURL=Box.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Dimensions.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Dimensions.js ***!
  \******************************************************************/
/*! exports provided: Dimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dimensions", function() { return Dimensions; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");

var Dimensions = /** @class */ (function () {
    function Dimensions(width, height) {
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(width) || !Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(height)) {
            throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have " + JSON.stringify({ width: width, height: height }));
        }
        this._width = width;
        this._height = height;
    }
    Object.defineProperty(Dimensions.prototype, "width", {
        get: function () { return this._width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dimensions.prototype, "height", {
        get: function () { return this._height; },
        enumerable: true,
        configurable: true
    });
    Dimensions.prototype.reverse = function () {
        return new Dimensions(1 / this.width, 1 / this.height);
    };
    return Dimensions;
}());

//# sourceMappingURL=Dimensions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceDetection.js ***!
  \*********************************************************************/
/*! exports provided: FaceDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceDetection", function() { return FaceDetection; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _ObjectDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectDetection */ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js");


var FaceDetection = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceDetection, _super);
    function FaceDetection(score, relativeBox, imageDims) {
        return _super.call(this, score, score, '', relativeBox, imageDims) || this;
    }
    FaceDetection.prototype.forSize = function (width, height) {
        var _a = _super.prototype.forSize.call(this, width, height), score = _a.score, relativeBox = _a.relativeBox, imageDims = _a.imageDims;
        return new FaceDetection(score, relativeBox, imageDims);
    };
    return FaceDetection;
}(_ObjectDetection__WEBPACK_IMPORTED_MODULE_1__["ObjectDetection"]));

//# sourceMappingURL=FaceDetection.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js ***!
  \*********************************************************************/
/*! exports provided: FaceLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks", function() { return FaceLandmarks; });
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");
/* harmony import */ var _Dimensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");
/* harmony import */ var _FaceDetection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point */ "./node_modules/face-api.js/build/es6/classes/Point.js");
/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Rect */ "./node_modules/face-api.js/build/es6/classes/Rect.js");







// face alignment constants
var relX = 0.5;
var relY = 0.43;
var relScale = 0.45;
var FaceLandmarks = /** @class */ (function () {
    function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {
        if (shift === void 0) { shift = new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](0, 0); }
        var width = imgDims.width, height = imgDims.height;
        this._imgDims = new _Dimensions__WEBPACK_IMPORTED_MODULE_3__["Dimensions"](width, height);
        this._shift = shift;
        this._positions = relativeFaceLandmarkPositions.map(function (pt) { return pt.mul(new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](width, height)).add(shift); });
    }
    Object.defineProperty(FaceLandmarks.prototype, "shift", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](this._shift.x, this._shift.y); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "imageWidth", {
        get: function () { return this._imgDims.width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "imageHeight", {
        get: function () { return this._imgDims.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "positions", {
        get: function () { return this._positions; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "relativePositions", {
        get: function () {
            var _this = this;
            return this._positions.map(function (pt) { return pt.sub(_this._shift).div(new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](_this.imageWidth, _this.imageHeight)); });
        },
        enumerable: true,
        configurable: true
    });
    FaceLandmarks.prototype.forSize = function (width, height) {
        return new this.constructor(this.relativePositions, { width: width, height: height });
    };
    FaceLandmarks.prototype.shiftBy = function (x, y) {
        return new this.constructor(this.relativePositions, this._imgDims, new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](x, y));
    };
    FaceLandmarks.prototype.shiftByPoint = function (pt) {
        return this.shiftBy(pt.x, pt.y);
    };
    /**
     * Aligns the face landmarks after face detection from the relative positions of the faces
     * bounding box, or it's current shift. This function should be used to align the face images
     * after face detection has been performed, before they are passed to the face recognition net.
     * This will make the computed face descriptor more accurate.
     *
     * @param detection (optional) The bounding box of the face or the face detection result. If
     * no argument was passed the position of the face landmarks are assumed to be relative to
     * it's current shift.
     * @returns The bounding box of the aligned face.
     */
    FaceLandmarks.prototype.align = function (detection, options) {
        if (options === void 0) { options = {}; }
        if (detection) {
            var box = detection instanceof _FaceDetection__WEBPACK_IMPORTED_MODULE_4__["FaceDetection"]
                ? detection.box.floor()
                : new _Box__WEBPACK_IMPORTED_MODULE_2__["Box"](detection);
            return this.shiftBy(box.x, box.y).align(null, options);
        }
        var _a = Object.assign({}, { useDlibAlignment: false, minBoxPadding: 0.2 }, options), useDlibAlignment = _a.useDlibAlignment, minBoxPadding = _a.minBoxPadding;
        if (useDlibAlignment) {
            return this.alignDlib();
        }
        return this.alignMinBbox(minBoxPadding);
    };
    FaceLandmarks.prototype.alignDlib = function () {
        var centers = this.getRefPointsForAlignment();
        var leftEyeCenter = centers[0], rightEyeCenter = centers[1], mouthCenter = centers[2];
        var distToMouth = function (pt) { return mouthCenter.sub(pt).magnitude(); };
        var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;
        var size = Math.floor(eyeToMouthDist / relScale);
        var refPoint = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getCenterPoint"])(centers);
        // TODO: pad in case rectangle is out of image bounds
        var x = Math.floor(Math.max(0, refPoint.x - (relX * size)));
        var y = Math.floor(Math.max(0, refPoint.y - (relY * size)));
        return new _Rect__WEBPACK_IMPORTED_MODULE_6__["Rect"](x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));
    };
    FaceLandmarks.prototype.alignMinBbox = function (padding) {
        var box = Object(_ops__WEBPACK_IMPORTED_MODULE_0__["minBbox"])(this.positions);
        return box.pad(box.width * padding, box.height * padding);
    };
    FaceLandmarks.prototype.getRefPointsForAlignment = function () {
        throw new Error('getRefPointsForAlignment not implemented by base class');
    };
    return FaceLandmarks;
}());

//# sourceMappingURL=FaceLandmarks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js ***!
  \**********************************************************************/
/*! exports provided: FaceLandmarks5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks5", function() { return FaceLandmarks5; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");



var FaceLandmarks5 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmarks5, _super);
    function FaceLandmarks5() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmarks5.prototype.getRefPointsForAlignment = function () {
        var pts = this.positions;
        return [
            pts[0],
            pts[1],
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getCenterPoint"])([pts[3], pts[4]])
        ];
    };
    return FaceLandmarks5;
}(_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__["FaceLandmarks"]));

//# sourceMappingURL=FaceLandmarks5.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js ***!
  \***********************************************************************/
/*! exports provided: FaceLandmarks68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks68", function() { return FaceLandmarks68; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");



var FaceLandmarks68 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmarks68, _super);
    function FaceLandmarks68() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmarks68.prototype.getJawOutline = function () {
        return this.positions.slice(0, 17);
    };
    FaceLandmarks68.prototype.getLeftEyeBrow = function () {
        return this.positions.slice(17, 22);
    };
    FaceLandmarks68.prototype.getRightEyeBrow = function () {
        return this.positions.slice(22, 27);
    };
    FaceLandmarks68.prototype.getNose = function () {
        return this.positions.slice(27, 36);
    };
    FaceLandmarks68.prototype.getLeftEye = function () {
        return this.positions.slice(36, 42);
    };
    FaceLandmarks68.prototype.getRightEye = function () {
        return this.positions.slice(42, 48);
    };
    FaceLandmarks68.prototype.getMouth = function () {
        return this.positions.slice(48, 68);
    };
    FaceLandmarks68.prototype.getRefPointsForAlignment = function () {
        return [
            this.getLeftEye(),
            this.getRightEye(),
            this.getMouth()
        ].map(_utils__WEBPACK_IMPORTED_MODULE_1__["getCenterPoint"]);
    };
    return FaceLandmarks68;
}(_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__["FaceLandmarks"]));

//# sourceMappingURL=FaceLandmarks68.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceMatch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceMatch.js ***!
  \*****************************************************************/
/*! exports provided: FaceMatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceMatch", function() { return FaceMatch; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");

var FaceMatch = /** @class */ (function () {
    function FaceMatch(label, distance) {
        this._label = label;
        this._distance = distance;
    }
    Object.defineProperty(FaceMatch.prototype, "label", {
        get: function () { return this._label; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceMatch.prototype, "distance", {
        get: function () { return this._distance; },
        enumerable: true,
        configurable: true
    });
    FaceMatch.prototype.toString = function (withDistance) {
        if (withDistance === void 0) { withDistance = true; }
        return "" + this.label + (withDistance ? " (" + Object(_utils__WEBPACK_IMPORTED_MODULE_0__["round"])(this.distance) + ")" : '');
    };
    return FaceMatch;
}());

//# sourceMappingURL=FaceMatch.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/LabeledBox.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/LabeledBox.js ***!
  \******************************************************************/
/*! exports provided: LabeledBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabeledBox", function() { return LabeledBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");



var LabeledBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(LabeledBox, _super);
    function LabeledBox(box, label) {
        var _this = _super.call(this, box) || this;
        _this._label = label;
        return _this;
    }
    LabeledBox.assertIsValidLabeledBox = function (box, callee) {
        _Box__WEBPACK_IMPORTED_MODULE_2__["Box"].assertIsValidBox(box, callee);
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidNumber"])(box.label)) {
            throw new Error(callee + " - expected property label (" + box.label + ") to be a number");
        }
    };
    Object.defineProperty(LabeledBox.prototype, "label", {
        get: function () { return this._label; },
        enumerable: true,
        configurable: true
    });
    return LabeledBox;
}(_Box__WEBPACK_IMPORTED_MODULE_2__["Box"]));

//# sourceMappingURL=LabeledBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js":
/*!******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js ***!
  \******************************************************************************/
/*! exports provided: LabeledFaceDescriptors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabeledFaceDescriptors", function() { return LabeledFaceDescriptors; });
var LabeledFaceDescriptors = /** @class */ (function () {
    function LabeledFaceDescriptors(label, descriptors) {
        if (!(typeof label === 'string')) {
            throw new Error('LabeledFaceDescriptors - constructor expected label to be a string');
        }
        if (!Array.isArray(descriptors) || descriptors.some(function (desc) { return !(desc instanceof Float32Array); })) {
            throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array');
        }
        this._label = label;
        this._descriptors = descriptors;
    }
    Object.defineProperty(LabeledFaceDescriptors.prototype, "label", {
        get: function () { return this._label; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabeledFaceDescriptors.prototype, "descriptors", {
        get: function () { return this._descriptors; },
        enumerable: true,
        configurable: true
    });
    LabeledFaceDescriptors.prototype.toJSON = function () {
        return {
            label: this.label,
            descriptors: this.descriptors.map(function (d) { return Array.from(d); })
        };
    };
    LabeledFaceDescriptors.fromJSON = function (json) {
        var descriptors = json.descriptors.map(function (d) {
            return new Float32Array(d);
        });
        return new LabeledFaceDescriptors(json.label, descriptors);
    };
    return LabeledFaceDescriptors;
}());

//# sourceMappingURL=LabeledFaceDescriptors.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/ObjectDetection.js ***!
  \***********************************************************************/
/*! exports provided: ObjectDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectDetection", function() { return ObjectDetection; });
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");
/* harmony import */ var _Dimensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");


var ObjectDetection = /** @class */ (function () {
    function ObjectDetection(score, classScore, className, relativeBox, imageDims) {
        this._imageDims = new _Dimensions__WEBPACK_IMPORTED_MODULE_1__["Dimensions"](imageDims.width, imageDims.height);
        this._score = score;
        this._classScore = classScore;
        this._className = className;
        this._box = new _Box__WEBPACK_IMPORTED_MODULE_0__["Box"](relativeBox).rescale(this._imageDims);
    }
    Object.defineProperty(ObjectDetection.prototype, "score", {
        get: function () { return this._score; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "classScore", {
        get: function () { return this._classScore; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "className", {
        get: function () { return this._className; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "box", {
        get: function () { return this._box; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "imageDims", {
        get: function () { return this._imageDims; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "imageWidth", {
        get: function () { return this.imageDims.width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "imageHeight", {
        get: function () { return this.imageDims.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "relativeBox", {
        get: function () { return new _Box__WEBPACK_IMPORTED_MODULE_0__["Box"](this._box).rescale(this.imageDims.reverse()); },
        enumerable: true,
        configurable: true
    });
    ObjectDetection.prototype.forSize = function (width, height) {
        return new ObjectDetection(this.score, this.classScore, this.className, this.relativeBox, { width: width, height: height });
    };
    return ObjectDetection;
}());

//# sourceMappingURL=ObjectDetection.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Point.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Point.js ***!
  \*************************************************************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
var Point = /** @class */ (function () {
    function Point(x, y) {
        this._x = x;
        this._y = y;
    }
    Object.defineProperty(Point.prototype, "x", {
        get: function () { return this._x; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Point.prototype, "y", {
        get: function () { return this._y; },
        enumerable: true,
        configurable: true
    });
    Point.prototype.add = function (pt) {
        return new Point(this.x + pt.x, this.y + pt.y);
    };
    Point.prototype.sub = function (pt) {
        return new Point(this.x - pt.x, this.y - pt.y);
    };
    Point.prototype.mul = function (pt) {
        return new Point(this.x * pt.x, this.y * pt.y);
    };
    Point.prototype.div = function (pt) {
        return new Point(this.x / pt.x, this.y / pt.y);
    };
    Point.prototype.abs = function () {
        return new Point(Math.abs(this.x), Math.abs(this.y));
    };
    Point.prototype.magnitude = function () {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
    };
    Point.prototype.floor = function () {
        return new Point(Math.floor(this.x), Math.floor(this.y));
    };
    return Point;
}());

//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/PredictedBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/PredictedBox.js ***!
  \********************************************************************/
/*! exports provided: PredictedBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictedBox", function() { return PredictedBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _LabeledBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LabeledBox */ "./node_modules/face-api.js/build/es6/classes/LabeledBox.js");



var PredictedBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictedBox, _super);
    function PredictedBox(box, label, score, classScore) {
        var _this = _super.call(this, box, label) || this;
        _this._score = score;
        _this._classScore = classScore;
        return _this;
    }
    PredictedBox.assertIsValidPredictedBox = function (box, callee) {
        _LabeledBox__WEBPACK_IMPORTED_MODULE_2__["LabeledBox"].assertIsValidLabeledBox(box, callee);
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidProbablitiy"])(box.score)
            || !Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidProbablitiy"])(box.classScore)) {
            throw new Error(callee + " - expected properties score (" + box.score + ") and (" + box.classScore + ") to be a number between [0, 1]");
        }
    };
    Object.defineProperty(PredictedBox.prototype, "score", {
        get: function () { return this._score; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PredictedBox.prototype, "classScore", {
        get: function () { return this._classScore; },
        enumerable: true,
        configurable: true
    });
    return PredictedBox;
}(_LabeledBox__WEBPACK_IMPORTED_MODULE_2__["LabeledBox"]));

//# sourceMappingURL=PredictedBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Rect.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Rect.js ***!
  \************************************************************/
/*! exports provided: Rect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return Rect; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");


var Rect = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(Rect, _super);
    function Rect(x, y, width, height, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }
        return _super.call(this, { x: x, y: y, width: width, height: height }, allowNegativeDimensions) || this;
    }
    return Rect;
}(_Box__WEBPACK_IMPORTED_MODULE_1__["Box"]));

//# sourceMappingURL=Rect.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/index.js ***!
  \*************************************************************/
/*! exports provided: BoundingBox, Box, Dimensions, FaceDetection, FaceLandmarks, FaceLandmarks5, FaceLandmarks68, FaceMatch, LabeledBox, LabeledFaceDescriptors, ObjectDetection, Point, PredictedBox, Rect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox */ "./node_modules/face-api.js/build/es6/classes/BoundingBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return _BoundingBox__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"]; });

/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return _Box__WEBPACK_IMPORTED_MODULE_1__["Box"]; });

/* harmony import */ var _Dimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Dimensions", function() { return _Dimensions__WEBPACK_IMPORTED_MODULE_2__["Dimensions"]; });

/* harmony import */ var _FaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceDetection", function() { return _FaceDetection__WEBPACK_IMPORTED_MODULE_3__["FaceDetection"]; });

/* harmony import */ var _FaceLandmarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks", function() { return _FaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks"]; });

/* harmony import */ var _FaceLandmarks5__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FaceLandmarks5 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks5", function() { return _FaceLandmarks5__WEBPACK_IMPORTED_MODULE_5__["FaceLandmarks5"]; });

/* harmony import */ var _FaceLandmarks68__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FaceLandmarks68 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks68", function() { return _FaceLandmarks68__WEBPACK_IMPORTED_MODULE_6__["FaceLandmarks68"]; });

/* harmony import */ var _FaceMatch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./FaceMatch */ "./node_modules/face-api.js/build/es6/classes/FaceMatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatch", function() { return _FaceMatch__WEBPACK_IMPORTED_MODULE_7__["FaceMatch"]; });

/* harmony import */ var _LabeledBox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LabeledBox */ "./node_modules/face-api.js/build/es6/classes/LabeledBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledBox", function() { return _LabeledBox__WEBPACK_IMPORTED_MODULE_8__["LabeledBox"]; });

/* harmony import */ var _LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LabeledFaceDescriptors */ "./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledFaceDescriptors", function() { return _LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_9__["LabeledFaceDescriptors"]; });

/* harmony import */ var _ObjectDetection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ObjectDetection */ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectDetection", function() { return _ObjectDetection__WEBPACK_IMPORTED_MODULE_10__["ObjectDetection"]; });

/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Point */ "./node_modules/face-api.js/build/es6/classes/Point.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return _Point__WEBPACK_IMPORTED_MODULE_11__["Point"]; });

/* harmony import */ var _PredictedBox__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PredictedBox */ "./node_modules/face-api.js/build/es6/classes/PredictedBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PredictedBox", function() { return _PredictedBox__WEBPACK_IMPORTED_MODULE_12__["PredictedBox"]; });

/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Rect */ "./node_modules/face-api.js/build/es6/classes/Rect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return _Rect__WEBPACK_IMPORTED_MODULE_13__["Rect"]; });















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/convLayer.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/convLayer.js ***!
  \****************************************************************/
/*! exports provided: convLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convLayer", function() { return convLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function convLayer(x, params, padding, withRelu) {
    if (padding === void 0) { padding = 'same'; }
    if (withRelu === void 0) { withRelu = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, params.filters, [1, 1], padding), params.bias);
        return withRelu ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](out) : out;
    });
}
//# sourceMappingURL=convLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js ***!
  \*****************************************************************************/
/*! exports provided: depthwiseSeparableConv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseSeparableConv", function() { return depthwiseSeparableConv; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function depthwiseSeparableConv(x, params, stride) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"](x, params.depthwise_filter, params.pointwise_filter, stride, 'same');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.bias);
        return out;
    });
}
//# sourceMappingURL=depthwiseSeparableConv.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js ***!
  \*********************************************************************************/
/*! exports provided: disposeUnusedWeightTensors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeUnusedWeightTensors", function() { return disposeUnusedWeightTensors; });
function disposeUnusedWeightTensors(weightMap, paramMappings) {
    Object.keys(weightMap).forEach(function (path) {
        if (!paramMappings.some(function (pm) { return pm.originalPath === path; })) {
            weightMap[path].dispose();
        }
    });
}
//# sourceMappingURL=disposeUnusedWeightTensors.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js ***!
  \*******************************************************************************/
/*! exports provided: extractConvParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractConvParamsFactory", function() { return extractConvParamsFactory; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function extractConvParamsFactory(extractWeights, paramMappings) {
    return function (channelsIn, channelsOut, filterSize, mappedPrefix) {
        var filters = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/bias" });
        return { filters: filters, bias: bias };
    };
}
//# sourceMappingURL=extractConvParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js ***!
  \*****************************************************************************/
/*! exports provided: extractFCParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFCParamsFactory", function() { return extractFCParamsFactory; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function extractFCParamsFactory(extractWeights, paramMappings) {
    return function (channelsIn, channelsOut, mappedPrefix) {
        var fc_weights = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"](extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut]);
        var fc_bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/weights" }, { paramPath: mappedPrefix + "/bias" });
        return {
            weights: fc_weights,
            bias: fc_bias
        };
    };
}
//# sourceMappingURL=extractFCParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js ***!
  \****************************************************************************************/
/*! exports provided: extractSeparableConvParamsFactory, loadSeparableConvParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractSeparableConvParamsFactory", function() { return extractSeparableConvParamsFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadSeparableConvParamsFactory", function() { return loadSeparableConvParamsFactory; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/common/types.js");


function extractSeparableConvParamsFactory(extractWeights, paramMappings) {
    return function (channelsIn, channelsOut, mappedPrefix) {
        var depthwise_filter = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);
        var pointwise_filter = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/depthwise_filter" }, { paramPath: mappedPrefix + "/pointwise_filter" }, { paramPath: mappedPrefix + "/bias" });
        return new _types__WEBPACK_IMPORTED_MODULE_1__["SeparableConvParams"](depthwise_filter, pointwise_filter, bias);
    };
}
function loadSeparableConvParamsFactory(extractWeightEntry) {
    return function (prefix) {
        var depthwise_filter = extractWeightEntry(prefix + "/depthwise_filter", 4);
        var pointwise_filter = extractWeightEntry(prefix + "/pointwise_filter", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return new _types__WEBPACK_IMPORTED_MODULE_1__["SeparableConvParams"](depthwise_filter, pointwise_filter, bias);
    };
}
//# sourceMappingURL=extractSeparableConvParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js ***!
  \********************************************************************************/
/*! exports provided: extractWeightEntryFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractWeightEntryFactory", function() { return extractWeightEntryFactory; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");

function extractWeightEntryFactory(weightMap, paramMappings) {
    return function (originalPath, paramRank, mappedPath) {
        var tensor = weightMap[originalPath];
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isTensor"])(tensor, paramRank)) {
            throw new Error("expected weightMap[" + originalPath + "] to be a Tensor" + paramRank + "D, instead have " + tensor);
        }
        paramMappings.push({ originalPath: originalPath, paramPath: mappedPath || originalPath });
        return tensor;
    };
}
//# sourceMappingURL=extractWeightEntryFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js ***!
  \****************************************************************************/
/*! exports provided: extractWeightsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractWeightsFactory", function() { return extractWeightsFactory; });
function extractWeightsFactory(weights) {
    var remainingWeights = weights;
    function extractWeights(numWeights) {
        var ret = remainingWeights.slice(0, numWeights);
        remainingWeights = remainingWeights.slice(numWeights);
        return ret;
    }
    function getRemainingWeights() {
        return remainingWeights;
    }
    return {
        extractWeights: extractWeights,
        getRemainingWeights: getRemainingWeights
    };
}
//# sourceMappingURL=extractWeightsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js ***!
  \**************************************************************************/
/*! exports provided: fullyConnectedLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fullyConnectedLayer", function() { return fullyConnectedLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function fullyConnectedLayer(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"](x, params.weights), params.bias);
    });
}
//# sourceMappingURL=fullyConnectedLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/getModelUris.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/getModelUris.js ***!
  \*******************************************************************/
/*! exports provided: getModelUris */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModelUris", function() { return getModelUris; });
function getModelUris(uri, defaultModelName) {
    var defaultManifestFilename = defaultModelName + "-weights_manifest.json";
    if (!uri) {
        return {
            modelBaseUri: '',
            manifestUri: defaultManifestFilename
        };
    }
    if (uri === '/') {
        return {
            modelBaseUri: '/',
            manifestUri: "/" + defaultManifestFilename
        };
    }
    var protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';
    uri = uri.replace(protocol, '');
    var parts = uri.split('/').filter(function (s) { return s; });
    var manifestFile = uri.endsWith('.json')
        ? parts[parts.length - 1]
        : defaultManifestFilename;
    var modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/');
    modelBaseUri = uri.startsWith('/') ? "/" + modelBaseUri : modelBaseUri;
    return {
        modelBaseUri: modelBaseUri,
        manifestUri: modelBaseUri === '/' ? "/" + manifestFile : modelBaseUri + "/" + manifestFile
    };
}
//# sourceMappingURL=getModelUris.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/index.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/index.js ***!
  \************************************************************/
/*! exports provided: convLayer, depthwiseSeparableConv, disposeUnusedWeightTensors, extractConvParamsFactory, extractFCParamsFactory, extractSeparableConvParamsFactory, loadSeparableConvParamsFactory, extractWeightEntryFactory, extractWeightsFactory, getModelUris, SeparableConvParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _convLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convLayer */ "./node_modules/face-api.js/build/es6/common/convLayer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convLayer", function() { return _convLayer__WEBPACK_IMPORTED_MODULE_0__["convLayer"]; });

/* harmony import */ var _depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./depthwiseSeparableConv */ "./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthwiseSeparableConv", function() { return _depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"]; });

/* harmony import */ var _disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./disposeUnusedWeightTensors */ "./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeUnusedWeightTensors", function() { return _disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_2__["disposeUnusedWeightTensors"]; });

/* harmony import */ var _extractConvParamsFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractConvParamsFactory", function() { return _extractConvParamsFactory__WEBPACK_IMPORTED_MODULE_3__["extractConvParamsFactory"]; });

/* harmony import */ var _extractFCParamsFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractFCParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFCParamsFactory", function() { return _extractFCParamsFactory__WEBPACK_IMPORTED_MODULE_4__["extractFCParamsFactory"]; });

/* harmony import */ var _extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractSeparableConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractSeparableConvParamsFactory", function() { return _extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_5__["extractSeparableConvParamsFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadSeparableConvParamsFactory", function() { return _extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_5__["loadSeparableConvParamsFactory"]; });

/* harmony import */ var _extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractWeightEntryFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractWeightEntryFactory", function() { return _extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_6__["extractWeightEntryFactory"]; });

/* harmony import */ var _extractWeightsFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractWeightsFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractWeightsFactory", function() { return _extractWeightsFactory__WEBPACK_IMPORTED_MODULE_7__["extractWeightsFactory"]; });

/* harmony import */ var _getModelUris__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getModelUris */ "./node_modules/face-api.js/build/es6/common/getModelUris.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModelUris", function() { return _getModelUris__WEBPACK_IMPORTED_MODULE_8__["getModelUris"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/common/types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SeparableConvParams", function() { return _types__WEBPACK_IMPORTED_MODULE_9__["SeparableConvParams"]; });











//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js ***!
  \****************************************************************************/
/*! exports provided: loadConvParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConvParamsFactory", function() { return loadConvParamsFactory; });
function loadConvParamsFactory(extractWeightEntry) {
    return function (prefix) {
        var filters = extractWeightEntry(prefix + "/filters", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { filters: filters, bias: bias };
    };
}
//# sourceMappingURL=loadConvParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/types.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/types.js ***!
  \************************************************************/
/*! exports provided: SeparableConvParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SeparableConvParams", function() { return SeparableConvParams; });
var SeparableConvParams = /** @class */ (function () {
    function SeparableConvParams(depthwise_filter, pointwise_filter, bias) {
        this.depthwise_filter = depthwise_filter;
        this.pointwise_filter = pointwise_filter;
        this.bias = bias;
    }
    return SeparableConvParams;
}());

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/NetInput.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/NetInput.js ***!
  \************************************************************/
/*! exports provided: NetInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetInput", function() { return NetInput; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _ops_padToSquare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ops/padToSquare */ "./node_modules/face-api.js/build/es6/ops/padToSquare.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony import */ var _imageToSquare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./imageToSquare */ "./node_modules/face-api.js/build/es6/dom/imageToSquare.js");






var NetInput = /** @class */ (function () {
    function NetInput(inputs, treatAsBatchInput) {
        var _this = this;
        if (treatAsBatchInput === void 0) { treatAsBatchInput = false; }
        this._imageTensors = [];
        this._canvases = [];
        this._treatAsBatchInput = false;
        this._inputDimensions = [];
        if (!Array.isArray(inputs)) {
            throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have " + inputs);
        }
        this._treatAsBatchInput = treatAsBatchInput;
        this._batchSize = inputs.length;
        inputs.forEach(function (input, idx) {
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor3D"])(input)) {
                _this._imageTensors[idx] = input;
                _this._inputDimensions[idx] = input.shape;
                return;
            }
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(input)) {
                var batchSize = input.shape[0];
                if (batchSize !== 1) {
                    throw new Error("NetInput - tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
                }
                _this._imageTensors[idx] = input;
                _this._inputDimensions[idx] = input.shape.slice(1);
                return;
            }
            var canvas = input instanceof _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv().Canvas ? input : Object(_createCanvas__WEBPACK_IMPORTED_MODULE_4__["createCanvasFromMedia"])(input);
            _this._canvases[idx] = canvas;
            _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];
        });
    }
    Object.defineProperty(NetInput.prototype, "imageTensors", {
        get: function () {
            return this._imageTensors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "canvases", {
        get: function () {
            return this._canvases;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "isBatchInput", {
        get: function () {
            return this.batchSize > 1 || this._treatAsBatchInput;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "batchSize", {
        get: function () {
            return this._batchSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "inputDimensions", {
        get: function () {
            return this._inputDimensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "inputSize", {
        get: function () {
            return this._inputSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "reshapedInputDimensions", {
        get: function () {
            var _this = this;
            return Object(_utils__WEBPACK_IMPORTED_MODULE_3__["range"])(this.batchSize, 0, 1).map(function (_, batchIdx) { return _this.getReshapedInputDimensions(batchIdx); });
        },
        enumerable: true,
        configurable: true
    });
    NetInput.prototype.getInput = function (batchIdx) {
        return this.canvases[batchIdx] || this.imageTensors[batchIdx];
    };
    NetInput.prototype.getInputDimensions = function (batchIdx) {
        return this._inputDimensions[batchIdx];
    };
    NetInput.prototype.getInputHeight = function (batchIdx) {
        return this._inputDimensions[batchIdx][0];
    };
    NetInput.prototype.getInputWidth = function (batchIdx) {
        return this._inputDimensions[batchIdx][1];
    };
    NetInput.prototype.getReshapedInputDimensions = function (batchIdx) {
        if (typeof this.inputSize !== 'number') {
            throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');
        }
        var width = this.getInputWidth(batchIdx);
        var height = this.getInputHeight(batchIdx);
        return Object(_utils__WEBPACK_IMPORTED_MODULE_3__["computeReshapedDimensions"])({ width: width, height: height }, this.inputSize);
    };
    /**
     * Create a batch tensor from all input canvases and tensors
     * with size [batchSize, inputSize, inputSize, 3].
     *
     * @param inputSize Height and width of the tensor.
     * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
     * both sides of the minor dimension oof the image.
     * @returns The batch tensor.
     */
    NetInput.prototype.toBatchTensor = function (inputSize, isCenterInputs) {
        var _this = this;
        if (isCenterInputs === void 0) { isCenterInputs = true; }
        this._inputSize = inputSize;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
            var inputTensors = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["range"])(_this.batchSize, 0, 1).map(function (batchIdx) {
                var input = _this.getInput(batchIdx);
                if (input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]) {
                    var imgTensor = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(input) ? input : input.expandDims();
                    imgTensor = Object(_ops_padToSquare__WEBPACK_IMPORTED_MODULE_2__["padToSquare"])(imgTensor, isCenterInputs);
                    if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {
                        imgTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(imgTensor, [inputSize, inputSize]);
                    }
                    return imgTensor.as3D(inputSize, inputSize, 3);
                }
                if (input instanceof _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv().Canvas) {
                    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"].fromPixels(Object(_imageToSquare__WEBPACK_IMPORTED_MODULE_5__["imageToSquare"])(input, inputSize, isCenterInputs));
                }
                throw new Error("toBatchTensor - at batchIdx " + batchIdx + ", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have " + input);
            });
            var batchTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"](inputTensors.map(function (t) { return t.toFloat(); })).as4D(_this.batchSize, inputSize, inputSize, 3);
            return batchTensor;
        });
    };
    return NetInput;
}());

//# sourceMappingURL=NetInput.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js ***!
  \********************************************************************/
/*! exports provided: awaitMediaLoaded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "awaitMediaLoaded", function() { return awaitMediaLoaded; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _isMediaLoaded__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js");


function awaitMediaLoaded(media) {
    return new Promise(function (resolve, reject) {
        if (media instanceof _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().Canvas || Object(_isMediaLoaded__WEBPACK_IMPORTED_MODULE_1__["isMediaLoaded"])(media)) {
            return resolve();
        }
        function onLoad(e) {
            if (!e.currentTarget)
                return;
            e.currentTarget.removeEventListener('load', onLoad);
            e.currentTarget.removeEventListener('error', onError);
            resolve(e);
        }
        function onError(e) {
            if (!e.currentTarget)
                return;
            e.currentTarget.removeEventListener('load', onLoad);
            e.currentTarget.removeEventListener('error', onError);
            reject(e);
        }
        media.addEventListener('load', onLoad);
        media.addEventListener('error', onError);
    });
}
//# sourceMappingURL=awaitMediaLoaded.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/bufferToImage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/bufferToImage.js ***!
  \*****************************************************************/
/*! exports provided: bufferToImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToImage", function() { return bufferToImage; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function bufferToImage(buf) {
    return new Promise(function (resolve, reject) {
        if (!(buf instanceof Blob)) {
            return reject('bufferToImage - expected buf to be of type: Blob');
        }
        var reader = new FileReader();
        reader.onload = function () {
            if (typeof reader.result !== 'string') {
                return reject('bufferToImage - expected reader.result to be a string, in onload');
            }
            var img = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().createImageElement();
            img.onload = function () { return resolve(img); };
            img.onerror = reject;
            img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(buf);
    });
}
//# sourceMappingURL=bufferToImage.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/createCanvas.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/createCanvas.js ***!
  \****************************************************************/
/*! exports provided: createCanvas, createCanvasFromMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return createCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvasFromMedia", function() { return createCanvasFromMedia; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");
/* harmony import */ var _isMediaLoaded__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js");




function createCanvas(_a) {
    var width = _a.width, height = _a.height;
    var createCanvasElement = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().createCanvasElement;
    var canvas = createCanvasElement();
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
function createCanvasFromMedia(media, dims) {
    var ImageData = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().ImageData;
    if (!(media instanceof ImageData) && !Object(_isMediaLoaded__WEBPACK_IMPORTED_MODULE_3__["isMediaLoaded"])(media)) {
        throw new Error('createCanvasFromMedia - media has not finished loading yet');
    }
    var _a = dims || Object(_getMediaDimensions__WEBPACK_IMPORTED_MODULE_2__["getMediaDimensions"])(media), width = _a.width, height = _a.height;
    var canvas = createCanvas({ width: width, height: height });
    if (media instanceof ImageData) {
        Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__["getContext2dOrThrow"])(canvas).putImageData(media, 0, 0);
    }
    else {
        Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__["getContext2dOrThrow"])(canvas).drawImage(media, 0, 0, width, height);
    }
    return canvas;
}
//# sourceMappingURL=createCanvas.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/extractFaceTensors.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/extractFaceTensors.js ***!
  \**********************************************************************/
/*! exports provided: extractFaceTensors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFaceTensors", function() { return extractFaceTensors; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");




/**
 * Extracts the tensors of the image regions containing the detected faces.
 * Useful if you want to compute the face descriptors for the face images.
 * Using this method is faster then extracting a canvas for each face and
 * converting them to tensors individually.
 *
 * @param imageTensor The image tensor that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns Tensors of the corresponding image region for each detected face.
 */
function extractFaceTensors(imageTensor, detections) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor3D"])(imageTensor) && !Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imageTensor)) {
                throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');
            }
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imageTensor) && imageTensor.shape[0] > 1) {
                throw new Error('extractFaceTensors - batchSize > 1 not supported');
            }
            return [2 /*return*/, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                    var _a = imageTensor.shape.slice(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imageTensor) ? 1 : 0), imgHeight = _a[0], imgWidth = _a[1], numChannels = _a[2];
                    var boxes = detections.map(function (det) { return det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_2__["FaceDetection"]
                        ? det.forSize(imgWidth, imgHeight).box
                        : det; })
                        .map(function (box) { return box.clipAtImageBorders(imgWidth, imgHeight); });
                    var faceTensors = boxes.map(function (_a) {
                        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
                        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["slice3d"](imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);
                    });
                    return faceTensors;
                })];
        });
    });
}
//# sourceMappingURL=extractFaceTensors.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/extractFaces.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/extractFaces.js ***!
  \****************************************************************/
/*! exports provided: extractFaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFaces", function() { return extractFaces; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./imageTensorToCanvas */ "./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js");
/* harmony import */ var _toNetInput__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./toNetInput */ "./node_modules/face-api.js/build/es6/dom/toNetInput.js");







/**
 * Extracts the image regions containing the detected faces.
 *
 * @param input The image that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns The Canvases of the corresponding image region for each detected face.
 */
function extractFaces(input, detections) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    Canvas = _env__WEBPACK_IMPORTED_MODULE_2__["env"].getEnv().Canvas;
                    canvas = input;
                    if (!!(input instanceof Canvas)) return [3 /*break*/, 5];
                    return [4 /*yield*/, Object(_toNetInput__WEBPACK_IMPORTED_MODULE_6__["toNetInput"])(input)];
                case 1:
                    netInput = _b.sent();
                    if (netInput.batchSize > 1) {
                        throw new Error('extractFaces - batchSize > 1 not supported');
                    }
                    tensorOrCanvas = netInput.getInput(0);
                    if (!(tensorOrCanvas instanceof Canvas)) return [3 /*break*/, 2];
                    _a = tensorOrCanvas;
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, Object(_imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_5__["imageTensorToCanvas"])(tensorOrCanvas)];
                case 3:
                    _a = _b.sent();
                    _b.label = 4;
                case 4:
                    canvas = _a;
                    _b.label = 5;
                case 5:
                    ctx = Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_4__["getContext2dOrThrow"])(canvas);
                    boxes = detections.map(function (det) { return det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]
                        ? det.forSize(canvas.width, canvas.height).box.floor()
                        : det; })
                        .map(function (box) { return box.clipAtImageBorders(canvas.width, canvas.height); });
                    return [2 /*return*/, boxes.map(function (_a) {
                            var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
                            var faceImg = Object(_createCanvas__WEBPACK_IMPORTED_MODULE_3__["createCanvas"])({ width: width, height: height });
                            Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_4__["getContext2dOrThrow"])(faceImg)
                                .putImageData(ctx.getImageData(x, y, width, height), 0, 0);
                            return faceImg;
                        })];
            }
        });
    });
}
//# sourceMappingURL=extractFaces.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchImage.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchImage.js ***!
  \**************************************************************/
/*! exports provided: fetchImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchImage", function() { return fetchImage; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _bufferToImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bufferToImage */ "./node_modules/face-api.js/build/es6/dom/bufferToImage.js");
/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");



function fetchImage(uri) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var res, blob;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Object(_fetchOrThrow__WEBPACK_IMPORTED_MODULE_2__["fetchOrThrow"])(uri)];
                case 1:
                    res = _a.sent();
                    return [4 /*yield*/, (res).blob()];
                case 2:
                    blob = _a.sent();
                    if (!blob.type.startsWith('image/')) {
                        throw new Error("fetchImage - expected blob type to be of type image/*, instead have: " + blob.type + ", for url: " + res.url);
                    }
                    return [2 /*return*/, Object(_bufferToImage__WEBPACK_IMPORTED_MODULE_1__["bufferToImage"])(blob)];
            }
        });
    });
}
//# sourceMappingURL=fetchImage.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchJson.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchJson.js ***!
  \*************************************************************/
/*! exports provided: fetchJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return fetchJson; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");


function fetchJson(uri) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Object(_fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__["fetchOrThrow"])(uri)];
                case 1: return [2 /*return*/, (_a.sent()).json()];
            }
        });
    });
}
//# sourceMappingURL=fetchJson.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchNetWeights.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchNetWeights.js ***!
  \*******************************************************************/
/*! exports provided: fetchNetWeights */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchNetWeights", function() { return fetchNetWeights; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");


function fetchNetWeights(uri) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var _a;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = Float32Array.bind;
                    return [4 /*yield*/, Object(_fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__["fetchOrThrow"])(uri)];
                case 1: return [4 /*yield*/, (_b.sent()).arrayBuffer()];
                case 2: return [2 /*return*/, new (_a.apply(Float32Array, [void 0, _b.sent()]))()];
            }
        });
    });
}
//# sourceMappingURL=fetchNetWeights.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js ***!
  \****************************************************************/
/*! exports provided: fetchOrThrow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchOrThrow", function() { return fetchOrThrow; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");


function fetchOrThrow(url, init) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var fetch, res;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fetch = _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv().fetch;
                    return [4 /*yield*/, fetch(url, init)];
                case 1:
                    res = _a.sent();
                    if (!(res.status < 400)) {
                        throw new Error("failed to fetch: (" + res.status + ") " + res.statusText + ", from url: " + res.url);
                    }
                    return [2 /*return*/, res];
            }
        });
    });
}
//# sourceMappingURL=fetchOrThrow.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js ***!
  \***********************************************************************/
/*! exports provided: getContext2dOrThrow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext2dOrThrow", function() { return getContext2dOrThrow; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _resolveInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");


function getContext2dOrThrow(canvasArg) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Canvas = _a.Canvas, CanvasRenderingContext2D = _a.CanvasRenderingContext2D;
    if (canvasArg instanceof CanvasRenderingContext2D) {
        return canvasArg;
    }
    var canvas = Object(_resolveInput__WEBPACK_IMPORTED_MODULE_1__["resolveInput"])(canvasArg);
    if (!(canvas instanceof Canvas)) {
        throw new Error('resolveContext2d - expected canvas to be of instance of Canvas');
    }
    var ctx = canvas.getContext('2d');
    if (!ctx) {
        throw new Error('resolveContext2d - canvas 2d context is null');
    }
    return ctx;
}
//# sourceMappingURL=getContext2dOrThrow.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js ***!
  \**********************************************************************/
/*! exports provided: getMediaDimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMediaDimensions", function() { return getMediaDimensions; });
/* harmony import */ var _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");


function getMediaDimensions(input) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv(), Image = _a.Image, Video = _a.Video;
    if (input instanceof Image) {
        return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](input.naturalWidth, input.naturalHeight);
    }
    if (input instanceof Video) {
        return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](input.videoWidth, input.videoHeight);
    }
    return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](input.width, input.height);
}
//# sourceMappingURL=getMediaDimensions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js ***!
  \***********************************************************************/
/*! exports provided: imageTensorToCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imageTensorToCanvas", function() { return imageTensorToCanvas; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");




function imageTensorToCanvas(imgTensor, canvas) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var targetCanvas, _a, height, width, numChannels, imgTensor3D;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    targetCanvas = canvas || _env__WEBPACK_IMPORTED_MODULE_2__["env"].getEnv().createCanvasElement();
                    _a = imgTensor.shape.slice(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imgTensor) ? 1 : 0), height = _a[0], width = _a[1], numChannels = _a[2];
                    imgTensor3D = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return imgTensor.as3D(height, width, numChannels).toInt(); });
                    return [4 /*yield*/, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["browser"].toPixels(imgTensor3D, targetCanvas)];
                case 1:
                    _b.sent();
                    imgTensor3D.dispose();
                    return [2 /*return*/, targetCanvas];
            }
        });
    });
}
//# sourceMappingURL=imageTensorToCanvas.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/imageToSquare.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/imageToSquare.js ***!
  \*****************************************************************/
/*! exports provided: imageToSquare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imageToSquare", function() { return imageToSquare; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");




function imageToSquare(input, inputSize, centerImage) {
    if (centerImage === void 0) { centerImage = false; }
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Image = _a.Image, Canvas = _a.Canvas;
    if (!(input instanceof Image || input instanceof Canvas)) {
        throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement');
    }
    var dims = Object(_getMediaDimensions__WEBPACK_IMPORTED_MODULE_3__["getMediaDimensions"])(input);
    var scale = inputSize / Math.max(dims.height, dims.width);
    var width = scale * dims.width;
    var height = scale * dims.height;
    var targetCanvas = Object(_createCanvas__WEBPACK_IMPORTED_MODULE_1__["createCanvas"])({ width: inputSize, height: inputSize });
    var inputCanvas = input instanceof Canvas ? input : Object(_createCanvas__WEBPACK_IMPORTED_MODULE_1__["createCanvasFromMedia"])(input);
    var offset = Math.abs(width - height) / 2;
    var dx = centerImage && width < height ? offset : 0;
    var dy = centerImage && height < width ? offset : 0;
    Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);
    return targetCanvas;
}
//# sourceMappingURL=imageToSquare.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/index.js ***!
  \*********************************************************/
/*! exports provided: awaitMediaLoaded, bufferToImage, createCanvas, createCanvasFromMedia, extractFaces, extractFaceTensors, fetchImage, fetchJson, fetchNetWeights, fetchOrThrow, getContext2dOrThrow, getMediaDimensions, imageTensorToCanvas, imageToSquare, isMediaElement, isMediaLoaded, loadWeightMap, matchDimensions, NetInput, resolveInput, toNetInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./awaitMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "awaitMediaLoaded", function() { return _awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_0__["awaitMediaLoaded"]; });

/* harmony import */ var _bufferToImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bufferToImage */ "./node_modules/face-api.js/build/es6/dom/bufferToImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToImage", function() { return _bufferToImage__WEBPACK_IMPORTED_MODULE_1__["bufferToImage"]; });

/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return _createCanvas__WEBPACK_IMPORTED_MODULE_2__["createCanvas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvasFromMedia", function() { return _createCanvas__WEBPACK_IMPORTED_MODULE_2__["createCanvasFromMedia"]; });

/* harmony import */ var _extractFaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractFaces */ "./node_modules/face-api.js/build/es6/dom/extractFaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaces", function() { return _extractFaces__WEBPACK_IMPORTED_MODULE_3__["extractFaces"]; });

/* harmony import */ var _extractFaceTensors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractFaceTensors */ "./node_modules/face-api.js/build/es6/dom/extractFaceTensors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaceTensors", function() { return _extractFaceTensors__WEBPACK_IMPORTED_MODULE_4__["extractFaceTensors"]; });

/* harmony import */ var _fetchImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fetchImage */ "./node_modules/face-api.js/build/es6/dom/fetchImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchImage", function() { return _fetchImage__WEBPACK_IMPORTED_MODULE_5__["fetchImage"]; });

/* harmony import */ var _fetchJson__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fetchJson */ "./node_modules/face-api.js/build/es6/dom/fetchJson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return _fetchJson__WEBPACK_IMPORTED_MODULE_6__["fetchJson"]; });

/* harmony import */ var _fetchNetWeights__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fetchNetWeights */ "./node_modules/face-api.js/build/es6/dom/fetchNetWeights.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchNetWeights", function() { return _fetchNetWeights__WEBPACK_IMPORTED_MODULE_7__["fetchNetWeights"]; });

/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchOrThrow", function() { return _fetchOrThrow__WEBPACK_IMPORTED_MODULE_8__["fetchOrThrow"]; });

/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContext2dOrThrow", function() { return _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_9__["getContext2dOrThrow"]; });

/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMediaDimensions", function() { return _getMediaDimensions__WEBPACK_IMPORTED_MODULE_10__["getMediaDimensions"]; });

/* harmony import */ var _imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./imageTensorToCanvas */ "./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageTensorToCanvas", function() { return _imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_11__["imageTensorToCanvas"]; });

/* harmony import */ var _imageToSquare__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./imageToSquare */ "./node_modules/face-api.js/build/es6/dom/imageToSquare.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageToSquare", function() { return _imageToSquare__WEBPACK_IMPORTED_MODULE_12__["imageToSquare"]; });

/* harmony import */ var _isMediaElement__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isMediaElement */ "./node_modules/face-api.js/build/es6/dom/isMediaElement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaElement", function() { return _isMediaElement__WEBPACK_IMPORTED_MODULE_13__["isMediaElement"]; });

/* harmony import */ var _isMediaLoaded__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaLoaded", function() { return _isMediaLoaded__WEBPACK_IMPORTED_MODULE_14__["isMediaLoaded"]; });

/* harmony import */ var _loadWeightMap__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./loadWeightMap */ "./node_modules/face-api.js/build/es6/dom/loadWeightMap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadWeightMap", function() { return _loadWeightMap__WEBPACK_IMPORTED_MODULE_15__["loadWeightMap"]; });

/* harmony import */ var _matchDimensions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./matchDimensions */ "./node_modules/face-api.js/build/es6/dom/matchDimensions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matchDimensions", function() { return _matchDimensions__WEBPACK_IMPORTED_MODULE_16__["matchDimensions"]; });

/* harmony import */ var _NetInput__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./NetInput */ "./node_modules/face-api.js/build/es6/dom/NetInput.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NetInput", function() { return _NetInput__WEBPACK_IMPORTED_MODULE_17__["NetInput"]; });

/* harmony import */ var _resolveInput__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveInput", function() { return _resolveInput__WEBPACK_IMPORTED_MODULE_18__["resolveInput"]; });

/* harmony import */ var _toNetInput__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./toNetInput */ "./node_modules/face-api.js/build/es6/dom/toNetInput.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toNetInput", function() { return _toNetInput__WEBPACK_IMPORTED_MODULE_19__["toNetInput"]; });





















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/isMediaElement.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/isMediaElement.js ***!
  \******************************************************************/
/*! exports provided: isMediaElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMediaElement", function() { return isMediaElement; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function isMediaElement(input) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Image = _a.Image, Canvas = _a.Canvas, Video = _a.Video;
    return input instanceof Image
        || input instanceof Canvas
        || input instanceof Video;
}
//# sourceMappingURL=isMediaElement.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js ***!
  \*****************************************************************/
/*! exports provided: isMediaLoaded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMediaLoaded", function() { return isMediaLoaded; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function isMediaLoaded(media) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Image = _a.Image, Video = _a.Video;
    return (media instanceof Image && media.complete)
        || (media instanceof Video && media.readyState >= 3);
}
//# sourceMappingURL=isMediaLoaded.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/loadWeightMap.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/loadWeightMap.js ***!
  \*****************************************************************/
/*! exports provided: loadWeightMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadWeightMap", function() { return loadWeightMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_getModelUris__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/getModelUris */ "./node_modules/face-api.js/build/es6/common/getModelUris.js");
/* harmony import */ var _fetchJson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetchJson */ "./node_modules/face-api.js/build/es6/dom/fetchJson.js");




function loadWeightMap(uri, defaultModelName) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var _a, manifestUri, modelBaseUri, manifest;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = Object(_common_getModelUris__WEBPACK_IMPORTED_MODULE_2__["getModelUris"])(uri, defaultModelName), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;
                    return [4 /*yield*/, Object(_fetchJson__WEBPACK_IMPORTED_MODULE_3__["fetchJson"])(manifestUri)];
                case 1:
                    manifest = _b.sent();
                    return [2 /*return*/, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["io"].loadWeights(manifest, modelBaseUri)];
            }
        });
    });
}
//# sourceMappingURL=loadWeightMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/matchDimensions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/matchDimensions.js ***!
  \*******************************************************************/
/*! exports provided: matchDimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchDimensions", function() { return matchDimensions; });
/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");

function matchDimensions(input, reference, useMediaDimensions) {
    if (useMediaDimensions === void 0) { useMediaDimensions = false; }
    var _a = useMediaDimensions
        ? Object(_getMediaDimensions__WEBPACK_IMPORTED_MODULE_0__["getMediaDimensions"])(reference)
        : reference, width = _a.width, height = _a.height;
    input.width = width;
    input.height = height;
    return { width: width, height: height };
}
//# sourceMappingURL=matchDimensions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/resolveInput.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/resolveInput.js ***!
  \****************************************************************/
/*! exports provided: resolveInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveInput", function() { return resolveInput; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function resolveInput(arg) {
    if (!_env__WEBPACK_IMPORTED_MODULE_0__["env"].isNodejs() && typeof arg === 'string') {
        return document.getElementById(arg);
    }
    return arg;
}
//# sourceMappingURL=resolveInput.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/toNetInput.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/toNetInput.js ***!
  \**************************************************************/
/*! exports provided: toNetInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toNetInput", function() { return toNetInput; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./awaitMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js");
/* harmony import */ var _isMediaElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isMediaElement */ "./node_modules/face-api.js/build/es6/dom/isMediaElement.js");
/* harmony import */ var _NetInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NetInput */ "./node_modules/face-api.js/build/es6/dom/NetInput.js");
/* harmony import */ var _resolveInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");






/**
 * Validates the input to make sure, they are valid net inputs and awaits all media elements
 * to be finished loading.
 *
 * @param input The input, which can be a media element or an array of different media elements.
 * @returns A NetInput instance, which can be passed into one of the neural networks.
 */
function toNetInput(inputs) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var inputArgArray, getIdxHint, inputArray;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (inputs instanceof _NetInput__WEBPACK_IMPORTED_MODULE_4__["NetInput"]) {
                        return [2 /*return*/, inputs];
                    }
                    inputArgArray = Array.isArray(inputs)
                        ? inputs
                        : [inputs];
                    if (!inputArgArray.length) {
                        throw new Error('toNetInput - empty array passed as input');
                    }
                    getIdxHint = function (idx) { return Array.isArray(inputs) ? " at input index " + idx + ":" : ''; };
                    inputArray = inputArgArray.map(_resolveInput__WEBPACK_IMPORTED_MODULE_5__["resolveInput"]);
                    inputArray.forEach(function (input, i) {
                        if (!Object(_isMediaElement__WEBPACK_IMPORTED_MODULE_3__["isMediaElement"])(input) && !Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor3D"])(input) && !Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor4D"])(input)) {
                            if (typeof inputArgArray[i] === 'string') {
                                throw new Error("toNetInput -" + getIdxHint(i) + " string passed, but could not resolve HTMLElement for element id " + inputArgArray[i]);
                            }
                            throw new Error("toNetInput -" + getIdxHint(i) + " expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id");
                        }
                        if (Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor4D"])(input)) {
                            // if tf.Tensor4D is passed in the input array, the batch size has to be 1
                            var batchSize = input.shape[0];
                            if (batchSize !== 1) {
                                throw new Error("toNetInput -" + getIdxHint(i) + " tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
                            }
                        }
                    });
                    // wait for all media elements being loaded
                    return [4 /*yield*/, Promise.all(inputArray.map(function (input) { return Object(_isMediaElement__WEBPACK_IMPORTED_MODULE_3__["isMediaElement"])(input) && Object(_awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_2__["awaitMediaLoaded"])(input); }))];
                case 1:
                    // wait for all media elements being loaded
                    _a.sent();
                    return [2 /*return*/, new _NetInput__WEBPACK_IMPORTED_MODULE_4__["NetInput"](inputArray, Array.isArray(inputs))];
            }
        });
    });
}
//# sourceMappingURL=toNetInput.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/DrawBox.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/DrawBox.js ***!
  \************************************************************/
/*! exports provided: DrawBoxOptions, DrawBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawBoxOptions", function() { return DrawBoxOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawBox", function() { return DrawBox; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _DrawTextField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DrawTextField */ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js");



var DrawBoxOptions = /** @class */ (function () {
    function DrawBoxOptions(options) {
        if (options === void 0) { options = {}; }
        var boxColor = options.boxColor, lineWidth = options.lineWidth, label = options.label, drawLabelOptions = options.drawLabelOptions;
        this.boxColor = boxColor || 'rgba(0, 0, 255, 1)';
        this.lineWidth = lineWidth || 2;
        this.label = label;
        var defaultDrawLabelOptions = {
            anchorPosition: _DrawTextField__WEBPACK_IMPORTED_MODULE_2__["AnchorPosition"].BOTTOM_LEFT,
            backgroundColor: this.boxColor
        };
        this.drawLabelOptions = new _DrawTextField__WEBPACK_IMPORTED_MODULE_2__["DrawTextFieldOptions"](Object.assign({}, defaultDrawLabelOptions, drawLabelOptions));
    }
    return DrawBoxOptions;
}());

var DrawBox = /** @class */ (function () {
    function DrawBox(box, options) {
        if (options === void 0) { options = {}; }
        this.box = new _classes__WEBPACK_IMPORTED_MODULE_0__["Box"](box);
        this.options = new DrawBoxOptions(options);
    }
    DrawBox.prototype.draw = function (canvasArg) {
        var ctx = Object(_dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__["getContext2dOrThrow"])(canvasArg);
        var _a = this.options, boxColor = _a.boxColor, lineWidth = _a.lineWidth;
        var _b = this.box, x = _b.x, y = _b.y, width = _b.width, height = _b.height;
        ctx.strokeStyle = boxColor;
        ctx.lineWidth = lineWidth;
        ctx.strokeRect(x, y, width, height);
        var label = this.options.label;
        if (label) {
            new _DrawTextField__WEBPACK_IMPORTED_MODULE_2__["DrawTextField"]([label], { x: x - (lineWidth / 2), y: y }, this.options.drawLabelOptions).draw(canvasArg);
        }
    };
    return DrawBox;
}());

//# sourceMappingURL=DrawBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js ***!
  \**********************************************************************/
/*! exports provided: DrawFaceLandmarksOptions, DrawFaceLandmarks, drawFaceLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarksOptions", function() { return DrawFaceLandmarksOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarks", function() { return DrawFaceLandmarks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawFaceLandmarks", function() { return drawFaceLandmarks; });
/* harmony import */ var _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony import */ var _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceLandmarks68 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js");
/* harmony import */ var _dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom/getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");
/* harmony import */ var _drawContour__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawContour */ "./node_modules/face-api.js/build/es6/draw/drawContour.js");





var DrawFaceLandmarksOptions = /** @class */ (function () {
    function DrawFaceLandmarksOptions(options) {
        if (options === void 0) { options = {}; }
        var _a = options.drawLines, drawLines = _a === void 0 ? true : _a, _b = options.drawPoints, drawPoints = _b === void 0 ? true : _b, lineWidth = options.lineWidth, lineColor = options.lineColor, pointSize = options.pointSize, pointColor = options.pointColor;
        this.drawLines = drawLines;
        this.drawPoints = drawPoints;
        this.lineWidth = lineWidth || 1;
        this.pointSize = pointSize || 2;
        this.lineColor = lineColor || 'rgba(0, 255, 255, 1)';
        this.pointColor = pointColor || 'rgba(255, 0, 255, 1)';
    }
    return DrawFaceLandmarksOptions;
}());

var DrawFaceLandmarks = /** @class */ (function () {
    function DrawFaceLandmarks(faceLandmarks, options) {
        if (options === void 0) { options = {}; }
        this.faceLandmarks = faceLandmarks;
        this.options = new DrawFaceLandmarksOptions(options);
    }
    DrawFaceLandmarks.prototype.draw = function (canvasArg) {
        var ctx = Object(_dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(canvasArg);
        var _a = this.options, drawLines = _a.drawLines, drawPoints = _a.drawPoints, lineWidth = _a.lineWidth, lineColor = _a.lineColor, pointSize = _a.pointSize, pointColor = _a.pointColor;
        if (drawLines && this.faceLandmarks instanceof _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_1__["FaceLandmarks68"]) {
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineWidth;
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getJawOutline());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getLeftEyeBrow());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getRightEyeBrow());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getNose());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getLeftEye(), true);
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getRightEye(), true);
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getMouth(), true);
        }
        if (drawPoints) {
            ctx.strokeStyle = pointColor;
            ctx.fillStyle = pointColor;
            var drawPoint = function (pt) {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, pointSize, 0, 2 * Math.PI);
                ctx.fill();
            };
            this.faceLandmarks.positions.forEach(drawPoint);
        }
    };
    return DrawFaceLandmarks;
}());

function drawFaceLandmarks(canvasArg, faceLandmarks) {
    var faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks];
    faceLandmarksArray.forEach(function (f) {
        var landmarks = f instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_0__["FaceLandmarks"]
            ? f
            : (Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["isWithFaceLandmarks"])(f) ? f.landmarks : undefined);
        if (!landmarks) {
            throw new Error('drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof');
        }
        new DrawFaceLandmarks(landmarks).draw(canvasArg);
    });
}
//# sourceMappingURL=DrawFaceLandmarks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/DrawTextField.js ***!
  \******************************************************************/
/*! exports provided: AnchorPosition, DrawTextFieldOptions, DrawTextField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnchorPosition", function() { return AnchorPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawTextFieldOptions", function() { return DrawTextFieldOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawTextField", function() { return DrawTextField; });
/* harmony import */ var _dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _dom_resolveInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");


var AnchorPosition;
(function (AnchorPosition) {
    AnchorPosition["TOP_LEFT"] = "TOP_LEFT";
    AnchorPosition["TOP_RIGHT"] = "TOP_RIGHT";
    AnchorPosition["BOTTOM_LEFT"] = "BOTTOM_LEFT";
    AnchorPosition["BOTTOM_RIGHT"] = "BOTTOM_RIGHT";
})(AnchorPosition || (AnchorPosition = {}));
var DrawTextFieldOptions = /** @class */ (function () {
    function DrawTextFieldOptions(options) {
        if (options === void 0) { options = {}; }
        var anchorPosition = options.anchorPosition, backgroundColor = options.backgroundColor, fontColor = options.fontColor, fontSize = options.fontSize, fontStyle = options.fontStyle, padding = options.padding;
        this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT;
        this.backgroundColor = backgroundColor || 'rgba(0, 0, 0, 0.5)';
        this.fontColor = fontColor || 'rgba(255, 255, 255, 1)';
        this.fontSize = fontSize || 14;
        this.fontStyle = fontStyle || 'Georgia';
        this.padding = padding || 4;
    }
    return DrawTextFieldOptions;
}());

var DrawTextField = /** @class */ (function () {
    function DrawTextField(text, anchor, options) {
        if (options === void 0) { options = {}; }
        this.text = typeof text === 'string'
            ? [text]
            : (text instanceof DrawTextField ? text.text : text);
        this.anchor = anchor;
        this.options = new DrawTextFieldOptions(options);
    }
    DrawTextField.prototype.measureWidth = function (ctx) {
        var padding = this.options.padding;
        return this.text.map(function (l) { return ctx.measureText(l).width; }).reduce(function (w0, w1) { return w0 < w1 ? w1 : w0; }, 0) + (2 * padding);
    };
    DrawTextField.prototype.measureHeight = function () {
        var _a = this.options, fontSize = _a.fontSize, padding = _a.padding;
        return this.text.length * fontSize + (2 * padding);
    };
    DrawTextField.prototype.getUpperLeft = function (ctx, canvasDims) {
        var anchorPosition = this.options.anchorPosition;
        var isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT;
        var isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT;
        var textFieldWidth = this.measureWidth(ctx);
        var textFieldHeight = this.measureHeight();
        var x = (isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x);
        var y = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y;
        // adjust anchor if text box exceeds canvas borders
        if (canvasDims) {
            var width = canvasDims.width, height = canvasDims.height;
            var newX = Math.max(Math.min(x, width - textFieldWidth), 0);
            var newY = Math.max(Math.min(y, height - textFieldHeight), 0);
            return { x: newX, y: newY };
        }
        return { x: x, y: y };
    };
    DrawTextField.prototype.draw = function (canvasArg) {
        var canvas = Object(_dom_resolveInput__WEBPACK_IMPORTED_MODULE_1__["resolveInput"])(canvasArg);
        var ctx = Object(_dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_0__["getContext2dOrThrow"])(canvas);
        var _a = this.options, backgroundColor = _a.backgroundColor, fontColor = _a.fontColor, fontSize = _a.fontSize, fontStyle = _a.fontStyle, padding = _a.padding;
        ctx.font = fontSize + "px " + fontStyle;
        var maxTextWidth = this.measureWidth(ctx);
        var textHeight = this.measureHeight();
        ctx.fillStyle = backgroundColor;
        var upperLeft = this.getUpperLeft(ctx, canvas);
        ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight);
        ctx.fillStyle = fontColor;
        this.text.forEach(function (textLine, i) {
            var x = padding + upperLeft.x;
            var y = padding + upperLeft.y + ((i + 1) * fontSize);
            ctx.fillText(textLine, x, y);
        });
    };
    return DrawTextField;
}());

//# sourceMappingURL=DrawTextField.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/drawContour.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/drawContour.js ***!
  \****************************************************************/
/*! exports provided: drawContour */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawContour", function() { return drawContour; });
function drawContour(ctx, points, isClosed) {
    if (isClosed === void 0) { isClosed = false; }
    ctx.beginPath();
    points.slice(1).forEach(function (_a, prevIdx) {
        var x = _a.x, y = _a.y;
        var from = points[prevIdx];
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(x, y);
    });
    if (isClosed) {
        var from = points[points.length - 1];
        var to = points[0];
        if (!from || !to) {
            return;
        }
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
    }
    ctx.stroke();
}
//# sourceMappingURL=drawContour.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/drawDetections.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/drawDetections.js ***!
  \*******************************************************************/
/*! exports provided: drawDetections */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawDetections", function() { return drawDetections; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _DrawBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawBox */ "./node_modules/face-api.js/build/es6/draw/DrawBox.js");





function drawDetections(canvasArg, detections) {
    var detectionsArray = Array.isArray(detections) ? detections : [detections];
    detectionsArray.forEach(function (det) {
        var score = det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]
            ? det.score
            : (Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(det) ? det.detection.score : undefined);
        var box = det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]
            ? det.box
            : (Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(det) ? det.detection.box : new _classes__WEBPACK_IMPORTED_MODULE_0__["Box"](det));
        var label = score ? "" + Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round"])(score) : undefined;
        new _DrawBox__WEBPACK_IMPORTED_MODULE_4__["DrawBox"](box, { label: label }).draw(canvasArg);
    });
}
//# sourceMappingURL=drawDetections.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js ***!
  \************************************************************************/
/*! exports provided: drawFaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawFaceExpressions", function() { return drawFaceExpressions; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _faceExpressionNet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceExpressionNet */ "./node_modules/face-api.js/build/es6/faceExpressionNet/index.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceExpressions */ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _DrawTextField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawTextField */ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js");






function drawFaceExpressions(canvasArg, faceExpressions, minConfidence, textFieldAnchor) {
    if (minConfidence === void 0) { minConfidence = 0.1; }
    var faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [faceExpressions];
    faceExpressionsArray.forEach(function (e) {
        var expr = e instanceof _faceExpressionNet__WEBPACK_IMPORTED_MODULE_1__["FaceExpressions"]
            ? e
            : (Object(_factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_3__["isWithFaceExpressions"])(e) ? e.expressions : undefined);
        if (!expr) {
            throw new Error('drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof');
        }
        var sorted = expr.asSortedArray();
        var resultsToDisplay = sorted.filter(function (expr) { return expr.probability > minConfidence; });
        var anchor = Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(e)
            ? e.detection.box.bottomLeft
            : (textFieldAnchor || new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
        var drawTextField = new _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["DrawTextField"](resultsToDisplay.map(function (expr) { return expr.expression + " (" + Object(_utils__WEBPACK_IMPORTED_MODULE_4__["round"])(expr.probability) + ")"; }), anchor);
        drawTextField.draw(canvasArg);
    });
}
//# sourceMappingURL=drawFaceExpressions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/index.js ***!
  \**********************************************************/
/*! exports provided: drawContour, drawDetections, drawFaceExpressions, DrawBoxOptions, DrawBox, DrawFaceLandmarksOptions, DrawFaceLandmarks, drawFaceLandmarks, AnchorPosition, DrawTextFieldOptions, DrawTextField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drawContour__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawContour */ "./node_modules/face-api.js/build/es6/draw/drawContour.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawContour", function() { return _drawContour__WEBPACK_IMPORTED_MODULE_0__["drawContour"]; });

/* harmony import */ var _drawDetections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawDetections */ "./node_modules/face-api.js/build/es6/draw/drawDetections.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawDetections", function() { return _drawDetections__WEBPACK_IMPORTED_MODULE_1__["drawDetections"]; });

/* harmony import */ var _drawFaceExpressions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawFaceExpressions */ "./node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawFaceExpressions", function() { return _drawFaceExpressions__WEBPACK_IMPORTED_MODULE_2__["drawFaceExpressions"]; });

/* harmony import */ var _DrawBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DrawBox */ "./node_modules/face-api.js/build/es6/draw/DrawBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawBoxOptions", function() { return _DrawBox__WEBPACK_IMPORTED_MODULE_3__["DrawBoxOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawBox", function() { return _DrawBox__WEBPACK_IMPORTED_MODULE_3__["DrawBox"]; });

/* harmony import */ var _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawFaceLandmarks */ "./node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarksOptions", function() { return _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["DrawFaceLandmarksOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarks", function() { return _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["DrawFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawFaceLandmarks", function() { return _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["drawFaceLandmarks"]; });

/* harmony import */ var _DrawTextField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawTextField */ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnchorPosition", function() { return _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["AnchorPosition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawTextFieldOptions", function() { return _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["DrawTextFieldOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawTextField", function() { return _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["DrawTextField"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/createBrowserEnv.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/createBrowserEnv.js ***!
  \********************************************************************/
/*! exports provided: createBrowserEnv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBrowserEnv", function() { return createBrowserEnv; });
function createBrowserEnv() {
    var fetch = window['fetch'] || function () {
        throw new Error('fetch - missing fetch implementation for browser environment');
    };
    var readFile = function () {
        throw new Error('readFile - filesystem not available for browser environment');
    };
    return {
        Canvas: HTMLCanvasElement,
        CanvasRenderingContext2D: CanvasRenderingContext2D,
        Image: HTMLImageElement,
        ImageData: ImageData,
        Video: HTMLVideoElement,
        createCanvasElement: function () { return document.createElement('canvas'); },
        createImageElement: function () { return document.createElement('img'); },
        fetch: fetch,
        readFile: readFile
    };
}
//# sourceMappingURL=createBrowserEnv.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/createFileSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/createFileSystem.js ***!
  \********************************************************************/
/*! exports provided: createFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFileSystem", function() { return createFileSystem; });
function createFileSystem(fs) {
    var requireFsError = '';
    if (!fs) {
        try {
            fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
        }
        catch (err) {
            requireFsError = err.toString();
        }
    }
    var readFile = fs
        ? function (filePath) {
            return new Promise(function (res, rej) {
                fs.readFile(filePath, function (err, buffer) {
                    return err ? rej(err) : res(buffer);
                });
            });
        }
        : function () {
            throw new Error("readFile - failed to require fs in nodejs environment with error: " + requireFsError);
        };
    return {
        readFile: readFile
    };
}
//# sourceMappingURL=createFileSystem.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/createNodejsEnv.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/createNodejsEnv.js ***!
  \*******************************************************************/
/*! exports provided: createNodejsEnv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNodejsEnv", function() { return createNodejsEnv; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _createFileSystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createFileSystem */ "./node_modules/face-api.js/build/es6/env/createFileSystem.js");


function createNodejsEnv() {
    var Canvas = global['Canvas'] || global['HTMLCanvasElement'];
    var Image = global['Image'] || global['HTMLImageElement'];
    var createCanvasElement = function () {
        if (Canvas) {
            return new Canvas();
        }
        throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment');
    };
    var createImageElement = function () {
        if (Image) {
            return new Image();
        }
        throw new Error('createImageElement - missing Image implementation for nodejs environment');
    };
    var fetch = global['fetch'] || function () {
        throw new Error('fetch - missing fetch implementation for nodejs environment');
    };
    var fileSystem = Object(_createFileSystem__WEBPACK_IMPORTED_MODULE_1__["createFileSystem"])();
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ Canvas: Canvas || /** @class */ (function () {
            function Canvas() {
            }
            return Canvas;
        }()), CanvasRenderingContext2D: global['CanvasRenderingContext2D'] || /** @class */ (function () {
            function class_1() {
            }
            return class_1;
        }()), Image: Image || /** @class */ (function () {
            function Image() {
            }
            return Image;
        }()), ImageData: global['ImageData'] || /** @class */ (function () {
            function class_2() {
            }
            return class_2;
        }()), Video: global['HTMLVideoElement'] || /** @class */ (function () {
            function class_3() {
            }
            return class_3;
        }()), createCanvasElement: createCanvasElement,
        createImageElement: createImageElement,
        fetch: fetch }, fileSystem);
}
//# sourceMappingURL=createNodejsEnv.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/index.js ***!
  \*********************************************************/
/*! exports provided: env */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "env", function() { return env; });
/* harmony import */ var _createBrowserEnv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserEnv */ "./node_modules/face-api.js/build/es6/env/createBrowserEnv.js");
/* harmony import */ var _createFileSystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createFileSystem */ "./node_modules/face-api.js/build/es6/env/createFileSystem.js");
/* harmony import */ var _createNodejsEnv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createNodejsEnv */ "./node_modules/face-api.js/build/es6/env/createNodejsEnv.js");
/* harmony import */ var _isBrowser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isBrowser */ "./node_modules/face-api.js/build/es6/env/isBrowser.js");
/* harmony import */ var _isNodejs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isNodejs */ "./node_modules/face-api.js/build/es6/env/isNodejs.js");





var environment;
function getEnv() {
    if (!environment) {
        throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()');
    }
    return environment;
}
function setEnv(env) {
    environment = env;
}
function initialize() {
    // check for isBrowser() first to prevent electron renderer process
    // to be initialized with wrong environment due to isNodejs() returning true
    if (Object(_isBrowser__WEBPACK_IMPORTED_MODULE_3__["isBrowser"])()) {
        setEnv(Object(_createBrowserEnv__WEBPACK_IMPORTED_MODULE_0__["createBrowserEnv"])());
    }
    if (Object(_isNodejs__WEBPACK_IMPORTED_MODULE_4__["isNodejs"])()) {
        setEnv(Object(_createNodejsEnv__WEBPACK_IMPORTED_MODULE_2__["createNodejsEnv"])());
    }
}
function monkeyPatch(env) {
    if (!environment) {
        initialize();
    }
    if (!environment) {
        throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()');
    }
    var _a = env.Canvas, Canvas = _a === void 0 ? environment.Canvas : _a, _b = env.Image, Image = _b === void 0 ? environment.Image : _b;
    environment.Canvas = Canvas;
    environment.Image = Image;
    environment.createCanvasElement = env.createCanvasElement || (function () { return new Canvas(); });
    environment.createImageElement = env.createImageElement || (function () { return new Image(); });
    environment.ImageData = env.ImageData || environment.ImageData;
    environment.Video = env.Video || environment.Video;
    environment.fetch = env.fetch || environment.fetch;
    environment.readFile = env.readFile || environment.readFile;
}
var env = {
    getEnv: getEnv,
    setEnv: setEnv,
    initialize: initialize,
    createBrowserEnv: _createBrowserEnv__WEBPACK_IMPORTED_MODULE_0__["createBrowserEnv"],
    createFileSystem: _createFileSystem__WEBPACK_IMPORTED_MODULE_1__["createFileSystem"],
    createNodejsEnv: _createNodejsEnv__WEBPACK_IMPORTED_MODULE_2__["createNodejsEnv"],
    monkeyPatch: monkeyPatch,
    isBrowser: _isBrowser__WEBPACK_IMPORTED_MODULE_3__["isBrowser"],
    isNodejs: _isNodejs__WEBPACK_IMPORTED_MODULE_4__["isNodejs"]
};
initialize();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/isBrowser.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/isBrowser.js ***!
  \*************************************************************/
/*! exports provided: isBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
function isBrowser() {
    return typeof window === 'object'
        && typeof document !== 'undefined'
        && typeof HTMLImageElement !== 'undefined'
        && typeof HTMLCanvasElement !== 'undefined'
        && typeof HTMLVideoElement !== 'undefined'
        && typeof ImageData !== 'undefined'
        && typeof CanvasRenderingContext2D !== 'undefined';
}
//# sourceMappingURL=isBrowser.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/isNodejs.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/isNodejs.js ***!
  \************************************************************/
/*! exports provided: isNodejs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNodejs", function() { return isNodejs; });
function isNodejs() {
    return typeof global === 'object'
        && "function" === 'function'
        && typeof module !== 'undefined'
        // issues with gatsby.js: module.exports is undefined
        // && !!module.exports
        && typeof process !== 'undefined' && !!process.version;
}
//# sourceMappingURL=isNodejs.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/euclideanDistance.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/euclideanDistance.js ***!
  \*****************************************************************/
/*! exports provided: euclideanDistance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "euclideanDistance", function() { return euclideanDistance; });
function euclideanDistance(arr1, arr2) {
    if (arr1.length !== arr2.length)
        throw new Error('euclideanDistance: arr1.length !== arr2.length');
    var desc1 = Array.from(arr1);
    var desc2 = Array.from(arr2);
    return Math.sqrt(desc1
        .map(function (val, i) { return val - desc2[i]; })
        .reduce(function (res, diff) { return res + Math.pow(diff, 2); }, 0));
}
//# sourceMappingURL=euclideanDistance.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js ***!
  \***********************************************************************************/
/*! exports provided: FaceExpressionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceExpressionNet", function() { return FaceExpressionNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../faceFeatureExtractor/FaceFeatureExtractor */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js");
/* harmony import */ var _faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../faceProcessor/FaceProcessor */ "./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js");
/* harmony import */ var _FaceExpressions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FaceExpressions */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js");






var FaceExpressionNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceExpressionNet, _super);
    function FaceExpressionNet(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_3__["FaceFeatureExtractor"](); }
        return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;
    }
    FaceExpressionNet.prototype.forwardInput = function (input) {
        var _this = this;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["softmax"](_this.runNet(input)); });
    };
    FaceExpressionNet.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceExpressionNet.prototype.predictExpressions = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, out, probabilitesByBatch, predictionsByBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        return [4 /*yield*/, this.forwardInput(netInput)];
                    case 2:
                        out = _a.sent();
                        return [4 /*yield*/, Promise.all(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out).map(function (t) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                var data;
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, t.data()];
                                        case 1:
                                            data = _a.sent();
                                            t.dispose();
                                            return [2 /*return*/, data];
                                    }
                                });
                            }); }))];
                    case 3:
                        probabilitesByBatch = _a.sent();
                        out.dispose();
                        predictionsByBatch = probabilitesByBatch
                            .map(function (probabilites) { return new _FaceExpressions__WEBPACK_IMPORTED_MODULE_5__["FaceExpressions"](probabilites); });
                        return [2 /*return*/, netInput.isBatchInput
                                ? predictionsByBatch
                                : predictionsByBatch[0]];
                }
            });
        });
    };
    FaceExpressionNet.prototype.getDefaultModelName = function () {
        return 'face_expression_model';
    };
    FaceExpressionNet.prototype.getClassifierChannelsIn = function () {
        return 256;
    };
    FaceExpressionNet.prototype.getClassifierChannelsOut = function () {
        return 7;
    };
    return FaceExpressionNet;
}(_faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_4__["FaceProcessor"]));

//# sourceMappingURL=FaceExpressionNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js ***!
  \*********************************************************************************/
/*! exports provided: FACE_EXPRESSION_LABELS, FaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FACE_EXPRESSION_LABELS", function() { return FACE_EXPRESSION_LABELS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceExpressions", function() { return FaceExpressions; });
var FACE_EXPRESSION_LABELS = ['neutral', 'happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised'];
var FaceExpressions = /** @class */ (function () {
    function FaceExpressions(probabilities) {
        var _this = this;
        if (probabilities.length !== 7) {
            throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: " + probabilities.length);
        }
        FACE_EXPRESSION_LABELS.forEach(function (expression, idx) {
            _this[expression] = probabilities[idx];
        });
    }
    FaceExpressions.prototype.asSortedArray = function () {
        var _this = this;
        return FACE_EXPRESSION_LABELS
            .map(function (expression) { return ({ expression: expression, probability: _this[expression] }); })
            .sort(function (e0, e1) { return e1.probability - e0.probability; });
    };
    return FaceExpressions;
}());

//# sourceMappingURL=FaceExpressions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceExpressionNet/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceExpressionNet/index.js ***!
  \***********************************************************************/
/*! exports provided: FaceExpressionNet, FACE_EXPRESSION_LABELS, FaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _FaceExpressionNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FaceExpressionNet */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressionNet", function() { return _FaceExpressionNet__WEBPACK_IMPORTED_MODULE_0__["FaceExpressionNet"]; });

/* harmony import */ var _FaceExpressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FaceExpressions */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FACE_EXPRESSION_LABELS", function() { return _FaceExpressions__WEBPACK_IMPORTED_MODULE_1__["FACE_EXPRESSION_LABELS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressions", function() { return _FaceExpressions__WEBPACK_IMPORTED_MODULE_1__["FaceExpressions"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js ***!
  \*****************************************************************************************/
/*! exports provided: FaceFeatureExtractor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceFeatureExtractor", function() { return FaceFeatureExtractor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _denseBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./denseBlock */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js");








var FaceFeatureExtractor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceFeatureExtractor, _super);
    function FaceFeatureExtractor() {
        return _super.call(this, 'FaceFeatureExtractor') || this;
    }
    FaceFeatureExtractor.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('FaceFeatureExtractor - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_4__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](255));
            var out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(normalized, params.dense0, true);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(out, params.dense1);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(out, params.dense2);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(out, params.dense3);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](out, [7, 7], [2, 2], 'valid');
            return out;
        });
    };
    FaceFeatureExtractor.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceFeatureExtractor.prototype.getDefaultModelName = function () {
        return 'face_feature_extractor_model';
    };
    FaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__["extractParamsFromWeigthMap"])(weightMap);
    };
    FaceFeatureExtractor.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_6__["extractParams"])(weights);
    };
    return FaceFeatureExtractor;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__["NeuralNetwork"]));

//# sourceMappingURL=FaceFeatureExtractor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js ***!
  \*********************************************************************************************/
/*! exports provided: TinyFaceFeatureExtractor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyFaceFeatureExtractor", function() { return TinyFaceFeatureExtractor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _denseBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./denseBlock */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js");
/* harmony import */ var _extractParamsFromWeigthMapTiny__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParamsFromWeigthMapTiny */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js");
/* harmony import */ var _extractParamsTiny__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsTiny */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js");








var TinyFaceFeatureExtractor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyFaceFeatureExtractor, _super);
    function TinyFaceFeatureExtractor() {
        return _super.call(this, 'TinyFaceFeatureExtractor') || this;
    }
    TinyFaceFeatureExtractor.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('TinyFaceFeatureExtractor - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_4__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](255));
            var out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock3"])(normalized, params.dense0, true);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock3"])(out, params.dense1);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock3"])(out, params.dense2);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](out, [14, 14], [2, 2], 'valid');
            return out;
        });
    };
    TinyFaceFeatureExtractor.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    TinyFaceFeatureExtractor.prototype.getDefaultModelName = function () {
        return 'face_feature_extractor_tiny_model';
    };
    TinyFaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMapTiny__WEBPACK_IMPORTED_MODULE_6__["extractParamsFromWeigthMapTiny"])(weightMap);
    };
    TinyFaceFeatureExtractor.prototype.extractParams = function (weights) {
        return Object(_extractParamsTiny__WEBPACK_IMPORTED_MODULE_7__["extractParamsTiny"])(weights);
    };
    return TinyFaceFeatureExtractor;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__["NeuralNetwork"]));

//# sourceMappingURL=TinyFaceFeatureExtractor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js ***!
  \*******************************************************************************/
/*! exports provided: denseBlock3, denseBlock4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "denseBlock3", function() { return denseBlock3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "denseBlock4", function() { return denseBlock4; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/depthwiseSeparableConv */ "./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js");


function denseBlock3(x, denseBlockParams, isFirstLayer) {
    if (isFirstLayer === void 0) { isFirstLayer = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out1 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](isFirstLayer
            ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, denseBlockParams.conv0.filters, [2, 2], 'same'), denseBlockParams.conv0.bias)
            : Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(x, denseBlockParams.conv0, [2, 2]));
        var out2 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(out1, denseBlockParams.conv1, [1, 1]);
        var in3 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, out2));
        var out3 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(in3, denseBlockParams.conv2, [1, 1]);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out2, out3)));
    });
}
function denseBlock4(x, denseBlockParams, isFirstLayer, isScaleDown) {
    if (isFirstLayer === void 0) { isFirstLayer = false; }
    if (isScaleDown === void 0) { isScaleDown = true; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out1 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](isFirstLayer
            ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, denseBlockParams.conv0.filters, isScaleDown ? [2, 2] : [1, 1], 'same'), denseBlockParams.conv0.bias)
            : Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(x, denseBlockParams.conv0, isScaleDown ? [2, 2] : [1, 1]));
        var out2 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(out1, denseBlockParams.conv1, [1, 1]);
        var in3 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, out2));
        var out3 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(in3, denseBlockParams.conv2, [1, 1]);
        var in4 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out2, out3)));
        var out4 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(in4, denseBlockParams.conv3, [1, 1]);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out2, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out3, out4))));
    });
}
//# sourceMappingURL=denseBlock.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js ***!
  \**********************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _extractorsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extractorsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js");


function extractParams(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractDenseBlock4Params = Object(_extractorsFactory__WEBPACK_IMPORTED_MODULE_1__["extractorsFactory"])(extractWeights, paramMappings).extractDenseBlock4Params;
    var dense0 = extractDenseBlock4Params(3, 32, 'dense0', true);
    var dense1 = extractDenseBlock4Params(32, 64, 'dense1');
    var dense2 = extractDenseBlock4Params(64, 128, 'dense2');
    var dense3 = extractDenseBlock4Params(128, 256, 'dense3');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { dense0: dense0, dense1: dense1, dense2: dense2, dense3: dense3 }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js ***!
  \***********************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadParamsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js");


function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractDenseBlock4Params = Object(_loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadParamsFactory"])(weightMap, paramMappings).extractDenseBlock4Params;
    var params = {
        dense0: extractDenseBlock4Params('dense0', true),
        dense1: extractDenseBlock4Params('dense1'),
        dense2: extractDenseBlock4Params('dense2'),
        dense3: extractDenseBlock4Params('dense3')
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js ***!
  \***************************************************************************************************/
/*! exports provided: extractParamsFromWeigthMapTiny */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMapTiny", function() { return extractParamsFromWeigthMapTiny; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadParamsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js");


function extractParamsFromWeigthMapTiny(weightMap) {
    var paramMappings = [];
    var extractDenseBlock3Params = Object(_loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadParamsFactory"])(weightMap, paramMappings).extractDenseBlock3Params;
    var params = {
        dense0: extractDenseBlock3Params('dense0', true),
        dense1: extractDenseBlock3Params('dense1'),
        dense2: extractDenseBlock3Params('dense2')
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMapTiny.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js ***!
  \**************************************************************************************/
/*! exports provided: extractParamsTiny */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsTiny", function() { return extractParamsTiny; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _extractorsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extractorsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js");


function extractParamsTiny(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractDenseBlock3Params = Object(_extractorsFactory__WEBPACK_IMPORTED_MODULE_1__["extractorsFactory"])(extractWeights, paramMappings).extractDenseBlock3Params;
    var dense0 = extractDenseBlock3Params(3, 32, 'dense0', true);
    var dense1 = extractDenseBlock3Params(32, 64, 'dense1');
    var dense2 = extractDenseBlock3Params(64, 128, 'dense2');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { dense0: dense0, dense1: dense1, dense2: dense2 }
    };
}
//# sourceMappingURL=extractParamsTiny.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js ***!
  \**************************************************************************************/
/*! exports provided: extractorsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractorsFactory", function() { return extractorsFactory; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractConvParamsFactory"])(extractWeights, paramMappings);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractSeparableConvParamsFactory"])(extractWeights, paramMappings);
    function extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var conv0 = isFirstLayer
            ? extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv0")
            : extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/conv0");
        var conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv1");
        var conv2 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv2");
        return { conv0: conv0, conv1: conv1, conv2: conv2 };
    }
    function extractDenseBlock4Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var _a = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer), conv0 = _a.conv0, conv1 = _a.conv1, conv2 = _a.conv2;
        var conv3 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv3");
        return { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3 };
    }
    return {
        extractDenseBlock3Params: extractDenseBlock3Params,
        extractDenseBlock4Params: extractDenseBlock4Params
    };
}
//# sourceMappingURL=extractorsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js ***!
  \**************************************************************************************/
/*! exports provided: loadParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadParamsFactory", function() { return loadParamsFactory; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/loadConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js");


function loadParamsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    var extractConvParams = Object(_common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadConvParamsFactory"])(extractWeightEntry);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["loadSeparableConvParamsFactory"])(extractWeightEntry);
    function extractDenseBlock3Params(prefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var conv0 = isFirstLayer
            ? extractConvParams(prefix + "/conv0")
            : extractSeparableConvParams(prefix + "/conv0");
        var conv1 = extractSeparableConvParams(prefix + "/conv1");
        var conv2 = extractSeparableConvParams(prefix + "/conv2");
        return { conv0: conv0, conv1: conv1, conv2: conv2 };
    }
    function extractDenseBlock4Params(prefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var conv0 = isFirstLayer
            ? extractConvParams(prefix + "/conv0")
            : extractSeparableConvParams(prefix + "/conv0");
        var conv1 = extractSeparableConvParams(prefix + "/conv1");
        var conv2 = extractSeparableConvParams(prefix + "/conv2");
        var conv3 = extractSeparableConvParams(prefix + "/conv3");
        return { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3 };
    }
    return {
        extractDenseBlock3Params: extractDenseBlock3Params,
        extractDenseBlock4Params: extractDenseBlock4Params
    };
}
//# sourceMappingURL=loadParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js ***!
  \*********************************************************************************/
/*! exports provided: FaceLandmark68Net */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68Net", function() { return FaceLandmark68Net; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceFeatureExtractor/FaceFeatureExtractor */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js");
/* harmony import */ var _FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmark68NetBase */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js");



var FaceLandmark68Net = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmark68Net, _super);
    function FaceLandmark68Net(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__["FaceFeatureExtractor"](); }
        return _super.call(this, 'FaceLandmark68Net', faceFeatureExtractor) || this;
    }
    FaceLandmark68Net.prototype.getDefaultModelName = function () {
        return 'face_landmark_68_model';
    };
    FaceLandmark68Net.prototype.getClassifierChannelsIn = function () {
        return 256;
    };
    return FaceLandmark68Net;
}(_FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68NetBase"]));

//# sourceMappingURL=FaceLandmark68Net.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js ***!
  \*************************************************************************************/
/*! exports provided: FaceLandmark68NetBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68NetBase", function() { return FaceLandmark68NetBase; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/FaceLandmarks68 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../faceProcessor/FaceProcessor */ "./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");







var FaceLandmark68NetBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmark68NetBase, _super);
    function FaceLandmark68NetBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmark68NetBase.prototype.postProcess = function (output, inputSize, originalDimensions) {
        var inputDimensions = originalDimensions.map(function (_a) {
            var width = _a.width, height = _a.height;
            var scale = inputSize / Math.max(height, width);
            return {
                width: width * scale,
                height: height * scale
            };
        });
        var batchSize = inputDimensions.length;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var createInterleavedTensor = function (fillX, fillY) {
                return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["stack"]([
                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"]([68], fillX),
                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"]([68], fillY)
                ], 1).as2D(1, 136).as1D();
            };
            var getPadding = function (batchIdx, cond) {
                var _a = inputDimensions[batchIdx], width = _a.width, height = _a.height;
                return cond(width, height) ? Math.abs(width - height) / 2 : 0;
            };
            var getPaddingX = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return w < h; }); };
            var getPaddingY = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return h < w; }); };
            var landmarkTensors = output
                .mul(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"]([batchSize, 136], inputSize))
                .sub(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["stack"](Array.from(Array(batchSize), function (_, batchIdx) {
                return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));
            })))
                .div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["stack"](Array.from(Array(batchSize), function (_, batchIdx) {
                return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);
            })));
            return landmarkTensors;
        });
    };
    FaceLandmark68NetBase.prototype.forwardInput = function (input) {
        var _this = this;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var out = _this.runNet(input);
            return _this.postProcess(out, input.inputSize, input.inputDimensions.map(function (_a) {
                var height = _a[0], width = _a[1];
                return ({ height: height, width: width });
            }));
        });
    };
    FaceLandmark68NetBase.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceLandmark68NetBase.prototype.detectLandmarks = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, landmarkTensors, landmarksForBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        landmarkTensors = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](_this.forwardInput(netInput)); });
                        return [4 /*yield*/, Promise.all(landmarkTensors.map(function (landmarkTensor, batchIdx) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                var landmarksArray, _a, _b, xCoords, yCoords;
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            _b = (_a = Array).from;
                                            return [4 /*yield*/, landmarkTensor.data()];
                                        case 1:
                                            landmarksArray = _b.apply(_a, [_c.sent()]);
                                            xCoords = landmarksArray.filter(function (_, i) { return Object(_utils__WEBPACK_IMPORTED_MODULE_6__["isEven"])(i); });
                                            yCoords = landmarksArray.filter(function (_, i) { return !Object(_utils__WEBPACK_IMPORTED_MODULE_6__["isEven"])(i); });
                                            return [2 /*return*/, new _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_3__["FaceLandmarks68"](Array(68).fill(0).map(function (_, i) { return new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](xCoords[i], yCoords[i]); }), {
                                                    height: netInput.getInputHeight(batchIdx),
                                                    width: netInput.getInputWidth(batchIdx),
                                                })];
                                    }
                                });
                            }); }))];
                    case 2:
                        landmarksForBatch = _a.sent();
                        landmarkTensors.forEach(function (t) { return t.dispose(); });
                        return [2 /*return*/, netInput.isBatchInput
                                ? landmarksForBatch
                                : landmarksForBatch[0]];
                }
            });
        });
    };
    FaceLandmark68NetBase.prototype.getClassifierChannelsOut = function () {
        return 136;
    };
    return FaceLandmark68NetBase;
}(_faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_5__["FaceProcessor"]));

//# sourceMappingURL=FaceLandmark68NetBase.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js ***!
  \*************************************************************************************/
/*! exports provided: FaceLandmark68TinyNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68TinyNet", function() { return FaceLandmark68TinyNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _faceFeatureExtractor_TinyFaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceFeatureExtractor/TinyFaceFeatureExtractor */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js");
/* harmony import */ var _FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmark68NetBase */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js");



var FaceLandmark68TinyNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmark68TinyNet, _super);
    function FaceLandmark68TinyNet(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _faceFeatureExtractor_TinyFaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__["TinyFaceFeatureExtractor"](); }
        return _super.call(this, 'FaceLandmark68TinyNet', faceFeatureExtractor) || this;
    }
    FaceLandmark68TinyNet.prototype.getDefaultModelName = function () {
        return 'face_landmark_68_tiny_model';
    };
    FaceLandmark68TinyNet.prototype.getClassifierChannelsIn = function () {
        return 128;
    };
    return FaceLandmark68TinyNet;
}(_FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68NetBase"]));

//# sourceMappingURL=FaceLandmark68TinyNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/index.js ***!
  \*********************************************************************/
/*! exports provided: FaceLandmark68Net, FaceLandmark68TinyNet, FaceLandmarkNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarkNet", function() { return FaceLandmarkNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FaceLandmark68Net */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68Net", function() { return _FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_1__["FaceLandmark68Net"]; });

/* harmony import */ var _FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmark68TinyNet */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68TinyNet", function() { return _FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68TinyNet"]; });





var FaceLandmarkNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmarkNet, _super);
    function FaceLandmarkNet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FaceLandmarkNet;
}(_FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_1__["FaceLandmark68Net"]));

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js ***!
  \***************************************************************************/
/*! exports provided: FaceProcessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceProcessor", function() { return FaceProcessor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/faceProcessor/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util */ "./node_modules/face-api.js/build/es6/faceProcessor/util.js");








var FaceProcessor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceProcessor, _super);
    function FaceProcessor(_name, faceFeatureExtractor) {
        var _this = _super.call(this, _name) || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
    }
    Object.defineProperty(FaceProcessor.prototype, "faceFeatureExtractor", {
        get: function () {
            return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
    });
    FaceProcessor.prototype.runNet = function (input) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error(this._name + " - load model before inference");
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var bottleneckFeatures = input instanceof _dom__WEBPACK_IMPORTED_MODULE_3__["NetInput"]
                ? _this.faceFeatureExtractor.forwardInput(input)
                : input;
            return Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);
        });
    };
    FaceProcessor.prototype.dispose = function (throwOnRedispose) {
        if (throwOnRedispose === void 0) { throwOnRedispose = true; }
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
    };
    FaceProcessor.prototype.loadClassifierParams = function (weights) {
        var _a = this.extractClassifierParams(weights), params = _a.params, paramMappings = _a.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
    };
    FaceProcessor.prototype.extractClassifierParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_5__["extractParams"])(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());
    };
    FaceProcessor.prototype.extractParamsFromWeigthMap = function (weightMap) {
        var _a = Object(_util__WEBPACK_IMPORTED_MODULE_7__["seperateWeightMaps"])(weightMap), featureExtractorMap = _a.featureExtractorMap, classifierMap = _a.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__["extractParamsFromWeigthMap"])(classifierMap);
    };
    FaceProcessor.prototype.extractParams = function (weights) {
        var cIn = this.getClassifierChannelsIn();
        var cOut = this.getClassifierChannelsOut();
        var classifierWeightSize = (cOut * cIn) + cOut;
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
    };
    return FaceProcessor;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__["NeuralNetwork"]));

//# sourceMappingURL=FaceProcessor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/extractParams.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/extractParams.js ***!
  \***************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParams(weights, channelsIn, channelsOut) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractFCParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractFCParamsFactory"])(extractWeights, paramMappings);
    var fc = extractFCParams(channelsIn, channelsOut, 'fc');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { fc: fc }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js ***!
  \****************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractFcParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { weights: weights, bias: bias };
    }
    var params = {
        fc: extractFcParams('fc')
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/util.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/util.js ***!
  \******************************************************************/
/*! exports provided: seperateWeightMaps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "seperateWeightMaps", function() { return seperateWeightMaps; });
function seperateWeightMaps(weightMap) {
    var featureExtractorMap = {};
    var classifierMap = {};
    Object.keys(weightMap).forEach(function (key) {
        var map = key.startsWith('fc') ? classifierMap : featureExtractorMap;
        map[key] = weightMap[key];
    });
    return { featureExtractorMap: featureExtractorMap, classifierMap: classifierMap };
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js ***!
  \*************************************************************************************/
/*! exports provided: FaceRecognitionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceRecognitionNet", function() { return FaceRecognitionNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _convLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./convLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js");
/* harmony import */ var _residualLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./residualLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js");









var FaceRecognitionNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceRecognitionNet, _super);
    function FaceRecognitionNet() {
        return _super.call(this, 'FaceRecognitionNet') || this;
    }
    FaceRecognitionNet.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('FaceRecognitionNet - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(150, true).toFloat();
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_4__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](256));
            var out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_5__["convDown"])(normalized, params.conv32_down);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, 3, 2, 'valid');
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv32_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv32_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv32_3);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv64_down);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv64_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv64_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv64_3);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv128_down);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv128_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv128_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv256_down);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv256_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv256_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv256_down_out);
            var globalAvg = out.mean([1, 2]);
            var fullyConnected = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["matMul"](globalAvg, params.fc);
            return fullyConnected;
        });
    };
    FaceRecognitionNet.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceRecognitionNet.prototype.computeFaceDescriptor = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, faceDescriptorTensors, faceDescriptorsForBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        faceDescriptorTensors = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](_this.forwardInput(netInput)); });
                        return [4 /*yield*/, Promise.all(faceDescriptorTensors.map(function (t) { return t.data(); }))];
                    case 2:
                        faceDescriptorsForBatch = _a.sent();
                        faceDescriptorTensors.forEach(function (t) { return t.dispose(); });
                        return [2 /*return*/, netInput.isBatchInput
                                ? faceDescriptorsForBatch
                                : faceDescriptorsForBatch[0]];
                }
            });
        });
    };
    FaceRecognitionNet.prototype.getDefaultModelName = function () {
        return 'face_recognition_model';
    };
    FaceRecognitionNet.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__["extractParamsFromWeigthMap"])(weightMap);
    };
    FaceRecognitionNet.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_6__["extractParams"])(weights);
    };
    return FaceRecognitionNet;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__["NeuralNetwork"]));

//# sourceMappingURL=FaceRecognitionNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js ***!
  \****************************************************************************/
/*! exports provided: conv, convNoRelu, convDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv", function() { return conv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convNoRelu", function() { return convNoRelu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convDown", function() { return convDown; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _scaleLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scaleLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js");


function convLayer(x, params, strides, withRelu, padding) {
    if (padding === void 0) { padding = 'same'; }
    var _a = params.conv, filters = _a.filters, bias = _a.bias;
    var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, filters, strides, padding);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, bias);
    out = Object(_scaleLayer__WEBPACK_IMPORTED_MODULE_1__["scale"])(out, params.scale);
    return withRelu ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](out) : out;
}
function conv(x, params) {
    return convLayer(x, params, [1, 1], true);
}
function convNoRelu(x, params) {
    return convLayer(x, params, [1, 1], false);
}
function convDown(x, params) {
    return convLayer(x, params, [2, 2], true, 'valid');
}
//# sourceMappingURL=convLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js ***!
  \********************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");



function extractorsFactory(extractWeights, paramMappings) {
    function extractFilterValues(numFilterValues, numFilters, filterSize) {
        var weights = extractWeights(numFilterValues);
        var depth = weights.length / (numFilters * filterSize * filterSize);
        if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__["isFloat"])(depth)) {
            throw new Error("depth has to be an integer: " + depth + ", weights.length: " + weights.length + ", numFilters: " + numFilters + ", filterSize: " + filterSize);
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](weights, [numFilters, depth, filterSize, filterSize]), [2, 3, 1, 0]); });
    }
    function extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
        var filters = extractFilterValues(numFilterValues, numFilters, filterSize);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numFilters));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/bias" });
        return { filters: filters, bias: bias };
    }
    function extractScaleLayerParams(numWeights, mappedPrefix) {
        var weights = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numWeights));
        var biases = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numWeights));
        paramMappings.push({ paramPath: mappedPrefix + "/weights" }, { paramPath: mappedPrefix + "/biases" });
        return {
            weights: weights,
            biases: biases
        };
    }
    function extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
        var conv = extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv");
        var scale = extractScaleLayerParams(numFilters, mappedPrefix + "/scale");
        return { conv: conv, scale: scale };
    }
    function extractResidualLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix, isDown) {
        if (isDown === void 0) { isDown = false; }
        var conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, mappedPrefix + "/conv1");
        var conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv2");
        return { conv1: conv1, conv2: conv2 };
    }
    return {
        extractConvLayerParams: extractConvLayerParams,
        extractResidualLayerParams: extractResidualLayerParams
    };
}
function extractParams(weights) {
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvLayerParams = _b.extractConvLayerParams, extractResidualLayerParams = _b.extractResidualLayerParams;
    var conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down');
    var conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1');
    var conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2');
    var conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3');
    var conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true);
    var conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1');
    var conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2');
    var conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3');
    var conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true);
    var conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1');
    var conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2');
    var conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true);
    var conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1');
    var conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2');
    var conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out');
    var fc = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"](extractWeights(256 * 128), [128, 256]), [1, 0]); });
    paramMappings.push({ paramPath: "fc" });
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    var params = {
        conv32_down: conv32_down,
        conv32_1: conv32_1,
        conv32_2: conv32_2,
        conv32_3: conv32_3,
        conv64_down: conv64_down,
        conv64_1: conv64_1,
        conv64_2: conv64_2,
        conv64_3: conv64_3,
        conv128_down: conv128_down,
        conv128_1: conv128_1,
        conv128_2: conv128_2,
        conv256_down: conv256_down,
        conv256_1: conv256_1,
        conv256_2: conv256_2,
        conv256_down_out: conv256_down_out,
        fc: fc
    };
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js ***!
  \*********************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractScaleLayerParams(prefix) {
        var weights = extractWeightEntry(prefix + "/scale/weights", 1);
        var biases = extractWeightEntry(prefix + "/scale/biases", 1);
        return { weights: weights, biases: biases };
    }
    function extractConvLayerParams(prefix) {
        var filters = extractWeightEntry(prefix + "/conv/filters", 4);
        var bias = extractWeightEntry(prefix + "/conv/bias", 1);
        var scale = extractScaleLayerParams(prefix);
        return { conv: { filters: filters, bias: bias }, scale: scale };
    }
    function extractResidualLayerParams(prefix) {
        return {
            conv1: extractConvLayerParams(prefix + "/conv1"),
            conv2: extractConvLayerParams(prefix + "/conv2")
        };
    }
    return {
        extractConvLayerParams: extractConvLayerParams,
        extractResidualLayerParams: extractResidualLayerParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractConvLayerParams = _a.extractConvLayerParams, extractResidualLayerParams = _a.extractResidualLayerParams;
    var conv32_down = extractConvLayerParams('conv32_down');
    var conv32_1 = extractResidualLayerParams('conv32_1');
    var conv32_2 = extractResidualLayerParams('conv32_2');
    var conv32_3 = extractResidualLayerParams('conv32_3');
    var conv64_down = extractResidualLayerParams('conv64_down');
    var conv64_1 = extractResidualLayerParams('conv64_1');
    var conv64_2 = extractResidualLayerParams('conv64_2');
    var conv64_3 = extractResidualLayerParams('conv64_3');
    var conv128_down = extractResidualLayerParams('conv128_down');
    var conv128_1 = extractResidualLayerParams('conv128_1');
    var conv128_2 = extractResidualLayerParams('conv128_2');
    var conv256_down = extractResidualLayerParams('conv256_down');
    var conv256_1 = extractResidualLayerParams('conv256_1');
    var conv256_2 = extractResidualLayerParams('conv256_2');
    var conv256_down_out = extractResidualLayerParams('conv256_down_out');
    var fc = weightMap['fc'];
    paramMappings.push({ originalPath: 'fc', paramPath: 'fc' });
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor2D"])(fc)) {
        throw new Error("expected weightMap[fc] to be a Tensor2D, instead have " + fc);
    }
    var params = {
        conv32_down: conv32_down,
        conv32_1: conv32_1,
        conv32_2: conv32_2,
        conv32_3: conv32_3,
        conv64_down: conv64_down,
        conv64_1: conv64_1,
        conv64_2: conv64_2,
        conv64_3: conv64_3,
        conv128_down: conv128_down,
        conv128_1: conv128_1,
        conv128_2: conv128_2,
        conv256_down: conv256_down,
        conv256_1: conv256_1,
        conv256_2: conv256_2,
        conv256_down_out: conv256_down_out,
        fc: fc
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/index.js ***!
  \************************************************************************/
/*! exports provided: FaceRecognitionNet, createFaceRecognitionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFaceRecognitionNet", function() { return createFaceRecognitionNet; });
/* harmony import */ var _FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FaceRecognitionNet */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceRecognitionNet", function() { return _FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_0__["FaceRecognitionNet"]; });



function createFaceRecognitionNet(weights) {
    var net = new _FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_0__["FaceRecognitionNet"]();
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js ***!
  \********************************************************************************/
/*! exports provided: residual, residualDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "residual", function() { return residual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "residualDown", function() { return residualDown; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _convLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./convLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js");



function residual(x, params) {
    var out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["conv"])(x, params.conv1);
    out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["convNoRelu"])(out, params.conv2);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](out, x);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out);
    return out;
}
function residualDown(x, params) {
    var out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["convDown"])(x, params.conv1);
    out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["convNoRelu"])(out, params.conv2);
    var pooled = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](x, 2, 2, 'valid');
    var zeros = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["zeros"](pooled.shape);
    var isPad = pooled.shape[3] !== out.shape[3];
    var isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];
    if (isAdjustShape) {
        var padShapeX = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(out.shape);
        padShapeX[1] = 1;
        var zerosW = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["zeros"](padShapeX);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([out, zerosW], 1);
        var padShapeY = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(out.shape);
        padShapeY[2] = 1;
        var zerosH = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["zeros"](padShapeY);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([out, zerosH], 2);
    }
    pooled = isPad ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([pooled, zeros], 3) : pooled;
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](pooled, out);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out);
    return out;
}
//# sourceMappingURL=residualLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js ***!
  \*****************************************************************************/
/*! exports provided: scale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function scale(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](x, params.weights), params.biases);
}
//# sourceMappingURL=scaleLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithAge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithAge.js ***!
  \*****************************************************************/
/*! exports provided: isWithAge, extendWithAge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithAge", function() { return isWithAge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithAge", function() { return extendWithAge; });
function isWithAge(obj) {
    return typeof obj['age'] === 'number';
}
function extendWithAge(sourceObj, age) {
    var extension = { age: age };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithAge.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js ***!
  \****************************************************************************/
/*! exports provided: extendWithFaceDescriptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDescriptor", function() { return extendWithFaceDescriptor; });
function extendWithFaceDescriptor(sourceObj, descriptor) {
    var extension = { descriptor: descriptor };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceDescriptor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js ***!
  \***************************************************************************/
/*! exports provided: isWithFaceDetection, extendWithFaceDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithFaceDetection", function() { return isWithFaceDetection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDetection", function() { return extendWithFaceDetection; });
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");

function isWithFaceDetection(obj) {
    return obj['detection'] instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__["FaceDetection"];
}
function extendWithFaceDetection(sourceObj, detection) {
    var extension = { detection: detection };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceDetection.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js ***!
  \*****************************************************************************/
/*! exports provided: isWithFaceExpressions, extendWithFaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithFaceExpressions", function() { return isWithFaceExpressions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceExpressions", function() { return extendWithFaceExpressions; });
/* harmony import */ var _faceExpressionNet_FaceExpressions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../faceExpressionNet/FaceExpressions */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js");

function isWithFaceExpressions(obj) {
    return obj['expressions'] instanceof _faceExpressionNet_FaceExpressions__WEBPACK_IMPORTED_MODULE_0__["FaceExpressions"];
}
function extendWithFaceExpressions(sourceObj, expressions) {
    var extension = { expressions: expressions };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceExpressions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js ***!
  \***************************************************************************/
/*! exports provided: isWithFaceLandmarks, extendWithFaceLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithFaceLandmarks", function() { return isWithFaceLandmarks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceLandmarks", function() { return extendWithFaceLandmarks; });
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony import */ var _WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");



function isWithFaceLandmarks(obj) {
    return Object(_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(obj)
        && obj['landmarks'] instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_1__["FaceLandmarks"]
        && obj['unshiftedLandmarks'] instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_1__["FaceLandmarks"]
        && obj['alignedRect'] instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__["FaceDetection"];
}
function extendWithFaceLandmarks(sourceObj, unshiftedLandmarks) {
    var shift = sourceObj.detection.box;
    var landmarks = unshiftedLandmarks.shiftBy(shift.x, shift.y);
    var rect = landmarks.align();
    var imageDims = sourceObj.detection.imageDims;
    var alignedRect = new _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__["FaceDetection"](sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);
    var extension = {
        landmarks: landmarks,
        unshiftedLandmarks: unshiftedLandmarks,
        alignedRect: alignedRect
    };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceLandmarks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithGender.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithGender.js ***!
  \********************************************************************/
/*! exports provided: isWithGender, extendWithGender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithGender", function() { return isWithGender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithGender", function() { return extendWithGender; });
/* harmony import */ var _ageGenderNet_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ageGenderNet/types */ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function isWithGender(obj) {
    return (obj['gender'] === _ageGenderNet_types__WEBPACK_IMPORTED_MODULE_0__["Gender"].MALE || obj['gender'] === _ageGenderNet_types__WEBPACK_IMPORTED_MODULE_0__["Gender"].FEMALE)
        && Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidProbablitiy"])(obj['genderProbability']);
}
function extendWithGender(sourceObj, gender, genderProbability) {
    var extension = { gender: gender, genderProbability: genderProbability };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithGender.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/index.js ***!
  \***************************************************************/
/*! exports provided: extendWithFaceDescriptor, isWithFaceDetection, extendWithFaceDetection, isWithFaceExpressions, extendWithFaceExpressions, isWithFaceLandmarks, extendWithFaceLandmarks, isWithAge, extendWithAge, isWithGender, extendWithGender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WithFaceDescriptor */ "./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDescriptor", function() { return _WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_0__["extendWithFaceDescriptor"]; });

/* harmony import */ var _WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceDetection", function() { return _WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["isWithFaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDetection", function() { return _WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDetection"]; });

/* harmony import */ var _WithFaceExpressions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WithFaceExpressions */ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceExpressions", function() { return _WithFaceExpressions__WEBPACK_IMPORTED_MODULE_2__["isWithFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceExpressions", function() { return _WithFaceExpressions__WEBPACK_IMPORTED_MODULE_2__["extendWithFaceExpressions"]; });

/* harmony import */ var _WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceLandmarks", function() { return _WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["isWithFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceLandmarks", function() { return _WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceLandmarks"]; });

/* harmony import */ var _WithAge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WithAge */ "./node_modules/face-api.js/build/es6/factories/WithAge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithAge", function() { return _WithAge__WEBPACK_IMPORTED_MODULE_4__["isWithAge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithAge", function() { return _WithAge__WEBPACK_IMPORTED_MODULE_4__["extendWithAge"]; });

/* harmony import */ var _WithGender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WithGender */ "./node_modules/face-api.js/build/es6/factories/WithGender.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithGender", function() { return _WithGender__WEBPACK_IMPORTED_MODULE_5__["isWithGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithGender", function() { return _WithGender__WEBPACK_IMPORTED_MODULE_5__["extendWithGender"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js ***!
  \************************************************************************/
/*! exports provided: ComposableTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComposableTask", function() { return ComposableTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

var ComposableTask = /** @class */ (function () {
    function ComposableTask() {
    }
    ComposableTask.prototype.then = function (onfulfilled) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = onfulfilled;
                        return [4 /*yield*/, this.run()];
                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                }
            });
        });
    };
    ComposableTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                throw new Error('ComposableTask - run is not implemented');
            });
        });
    };
    return ComposableTask;
}());

//# sourceMappingURL=ComposableTask.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js ***!
  \*************************************************************************************/
/*! exports provided: ComputeFaceDescriptorsTaskBase, ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeFaceDescriptorsTaskBase", function() { return ComputeFaceDescriptorsTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeAllFaceDescriptorsTask", function() { return ComputeAllFaceDescriptorsTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeSingleFaceDescriptorTask", function() { return ComputeSingleFaceDescriptorTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithFaceDescriptor */ "./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractFacesAndComputeResults */ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");







var ComputeFaceDescriptorsTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(ComputeFaceDescriptorsTaskBase, _super);
    function ComputeFaceDescriptorsTaskBase(parentTask, input) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        return _this;
    }
    return ComputeFaceDescriptorsTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_2__["ComposableTask"]));

var ComputeAllFaceDescriptorsTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(ComputeAllFaceDescriptorsTask, _super);
    function ComputeAllFaceDescriptorsTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComputeAllFaceDescriptorsTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, descriptors;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _a.sent();
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_3__["extractAllFacesAndComputeResults"])(parentResults, this.input, function (faces) { return Promise.all(faces.map(function (face) {
                                return _nets__WEBPACK_IMPORTED_MODULE_4__["nets"].faceRecognitionNet.computeFaceDescriptor(face);
                            })); }, null, function (parentResult) { return parentResult.landmarks.align(null, { useDlibAlignment: true }); })];
                    case 2:
                        descriptors = _a.sent();
                        return [2 /*return*/, descriptors.map(function (descriptor, i) { return Object(_factories_WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDescriptor"])(parentResults[i], descriptor); })];
                }
            });
        });
    };
    ComputeAllFaceDescriptorsTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_6__["PredictAllFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    ComputeAllFaceDescriptorsTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_5__["PredictAllAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    return ComputeAllFaceDescriptorsTask;
}(ComputeFaceDescriptorsTaskBase));

var ComputeSingleFaceDescriptorTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(ComputeSingleFaceDescriptorTask, _super);
    function ComputeSingleFaceDescriptorTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComputeSingleFaceDescriptorTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, descriptor;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _a.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_3__["extractSingleFaceAndComputeResult"])(parentResult, this.input, function (face) { return _nets__WEBPACK_IMPORTED_MODULE_4__["nets"].faceRecognitionNet.computeFaceDescriptor(face); }, null, function (parentResult) { return parentResult.landmarks.align(null, { useDlibAlignment: true }); })];
                    case 2:
                        descriptor = _a.sent();
                        return [2 /*return*/, Object(_factories_WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDescriptor"])(parentResult, descriptor)];
                }
            });
        });
    };
    ComputeSingleFaceDescriptorTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_6__["PredictSingleFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    ComputeSingleFaceDescriptorTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_5__["PredictSingleAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    return ComputeSingleFaceDescriptorTask;
}(ComputeFaceDescriptorsTaskBase));

//# sourceMappingURL=ComputeFaceDescriptorsTasks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js ***!
  \**********************************************************************************/
/*! exports provided: DetectFaceLandmarksTaskBase, DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectFaceLandmarksTaskBase", function() { return DetectFaceLandmarksTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectAllFaceLandmarksTask", function() { return DetectAllFaceLandmarksTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceLandmarksTask", function() { return DetectSingleFaceLandmarksTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");









var DetectFaceLandmarksTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectFaceLandmarksTaskBase, _super);
    function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.useTinyLandmarkNet = useTinyLandmarkNet;
        return _this;
    }
    Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, "landmarkNet", {
        get: function () {
            return this.useTinyLandmarkNet
                ? _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].faceLandmark68TinyNet
                : _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].faceLandmark68Net;
        },
        enumerable: true,
        configurable: true
    });
    return DetectFaceLandmarksTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_4__["ComposableTask"]));

var DetectAllFaceLandmarksTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectAllFaceLandmarksTask, _super);
    function DetectAllFaceLandmarksTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectAllFaceLandmarksTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, detections, faces, _a, faceLandmarksByFace;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _b.sent();
                        detections = parentResults.map(function (res) { return res.detection; });
                        if (!(this.input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) return [3 /*break*/, 3];
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaceTensors"])(this.input, detections)];
                    case 2:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaces"])(this.input, detections)];
                    case 4:
                        _a = _b.sent();
                        _b.label = 5;
                    case 5:
                        faces = _a;
                        return [4 /*yield*/, Promise.all(faces.map(function (face) { return _this.landmarkNet.detectLandmarks(face); }))];
                    case 6:
                        faceLandmarksByFace = _b.sent();
                        faces.forEach(function (f) { return f instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"] && f.dispose(); });
                        return [2 /*return*/, parentResults.map(function (parentResult, i) {
                                return Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceLandmarks"])(parentResult, faceLandmarksByFace[i]);
                            })];
                }
            });
        });
    };
    DetectAllFaceLandmarksTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_8__["PredictAllFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    DetectAllFaceLandmarksTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_7__["PredictAllAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_5__["ComputeAllFaceDescriptorsTask"](this, this.input);
    };
    return DetectAllFaceLandmarksTask;
}(DetectFaceLandmarksTaskBase));

var DetectSingleFaceLandmarksTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectSingleFaceLandmarksTask, _super);
    function DetectSingleFaceLandmarksTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectSingleFaceLandmarksTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, detection, faces, _a, landmarks;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _b.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        detection = parentResult.detection;
                        if (!(this.input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) return [3 /*break*/, 3];
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaceTensors"])(this.input, [detection])];
                    case 2:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaces"])(this.input, [detection])];
                    case 4:
                        _a = _b.sent();
                        _b.label = 5;
                    case 5:
                        faces = _a;
                        return [4 /*yield*/, this.landmarkNet.detectLandmarks(faces[0])];
                    case 6:
                        landmarks = _b.sent();
                        faces.forEach(function (f) { return f instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"] && f.dispose(); });
                        return [2 /*return*/, Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceLandmarks"])(parentResult, landmarks)];
                }
            });
        });
    };
    DetectSingleFaceLandmarksTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_8__["PredictSingleFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    DetectSingleFaceLandmarksTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_7__["PredictSingleAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_5__["ComputeSingleFaceDescriptorTask"](this, this.input);
    };
    return DetectSingleFaceLandmarksTask;
}(DetectFaceLandmarksTaskBase));

//# sourceMappingURL=DetectFaceLandmarksTasks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js ***!
  \**************************************************************************/
/*! exports provided: DetectFacesTaskBase, DetectAllFacesTask, DetectSingleFaceTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectFacesTaskBase", function() { return DetectFacesTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectAllFacesTask", function() { return DetectAllFacesTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceTask", function() { return DetectSingleFaceTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mtcnn/MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony import */ var _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ssdMobilenetv1/SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");
/* harmony import */ var _tinyFaceDetector_TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tinyFaceDetector/TinyFaceDetectorOptions */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DetectFaceLandmarksTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");











var DetectFacesTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectFacesTaskBase, _super);
    function DetectFacesTaskBase(input, options) {
        if (options === void 0) { options = new _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_3__["SsdMobilenetv1Options"](); }
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.options = options;
        return _this;
    }
    return DetectFacesTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_6__["ComposableTask"]));

var DetectAllFacesTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectAllFacesTask, _super);
    function DetectAllFacesTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectAllFacesTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a, input, options, faceDetectionFunction;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, input = _a.input, options = _a.options;
                        if (!(options instanceof _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_2__["MtcnnOptions"])) return [3 /*break*/, 2];
                        return [4 /*yield*/, _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].mtcnn.forward(input, options)];
                    case 1: return [2 /*return*/, (_b.sent())
                            .map(function (result) { return result.detection; })];
                    case 2:
                        faceDetectionFunction = options instanceof _tinyFaceDetector_TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_4__["TinyFaceDetectorOptions"]
                            ? function (input) { return _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].tinyFaceDetector.locateFaces(input, options); }
                            : (options instanceof _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_3__["SsdMobilenetv1Options"]
                                ? function (input) { return _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].ssdMobilenetv1.locateFaces(input, options); }
                                : (options instanceof _tinyYolov2__WEBPACK_IMPORTED_MODULE_5__["TinyYolov2Options"]
                                    ? function (input) { return _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].tinyYolov2.locateFaces(input, options); }
                                    : null));
                        if (!faceDetectionFunction) {
                            throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');
                        }
                        return [2 /*return*/, faceDetectionFunction(input)];
                }
            });
        });
    };
    DetectAllFacesTask.prototype.runAndExtendWithFaceDetections = function () {
        var _this = this;
        return new Promise(function (res) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
            var detections;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.run()];
                    case 1:
                        detections = _a.sent();
                        return [2 /*return*/, res(detections.map(function (detection) { return Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDetection"])({}, detection); }))];
                }
            });
        }); });
    };
    DetectAllFacesTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) { useTinyLandmarkNet = false; }
        return new _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_7__["DetectAllFaceLandmarksTask"](this.runAndExtendWithFaceDetections(), this.input, useTinyLandmarkNet);
    };
    DetectAllFacesTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_10__["PredictAllFaceExpressionsTask"](this.runAndExtendWithFaceDetections(), this.input);
    };
    DetectAllFacesTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_9__["PredictAllAgeAndGenderTask"](this.runAndExtendWithFaceDetections(), this.input);
    };
    return DetectAllFacesTask;
}(DetectFacesTaskBase));

var DetectSingleFaceTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectSingleFaceTask, _super);
    function DetectSingleFaceTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectSingleFaceTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var faceDetections, faceDetectionWithHighestScore;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new DetectAllFacesTask(this.input, this.options)];
                    case 1:
                        faceDetections = _a.sent();
                        faceDetectionWithHighestScore = faceDetections[0];
                        faceDetections.forEach(function (faceDetection) {
                            if (faceDetection.score > faceDetectionWithHighestScore.score) {
                                faceDetectionWithHighestScore = faceDetection;
                            }
                        });
                        return [2 /*return*/, faceDetectionWithHighestScore];
                }
            });
        });
    };
    DetectSingleFaceTask.prototype.runAndExtendWithFaceDetection = function () {
        var _this = this;
        return new Promise(function (res) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
            var detection;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.run()];
                    case 1:
                        detection = _a.sent();
                        return [2 /*return*/, res(detection ? Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDetection"])({}, detection) : undefined)];
                }
            });
        }); });
    };
    DetectSingleFaceTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) { useTinyLandmarkNet = false; }
        return new _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_7__["DetectSingleFaceLandmarksTask"](this.runAndExtendWithFaceDetection(), this.input, useTinyLandmarkNet);
    };
    DetectSingleFaceTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_10__["PredictSingleFaceExpressionsTask"](this.runAndExtendWithFaceDetection(), this.input);
    };
    DetectSingleFaceTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_9__["PredictSingleAgeAndGenderTask"](this.runAndExtendWithFaceDetection(), this.input);
    };
    return DetectSingleFaceTask;
}(DetectFacesTaskBase));

//# sourceMappingURL=DetectFacesTasks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js ***!
  \*********************************************************************/
/*! exports provided: FaceMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceMatcher", function() { return FaceMatcher; });
/* harmony import */ var _classes_FaceMatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceMatch */ "./node_modules/face-api.js/build/es6/classes/FaceMatch.js");
/* harmony import */ var _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/LabeledFaceDescriptors */ "./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js");
/* harmony import */ var _euclideanDistance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../euclideanDistance */ "./node_modules/face-api.js/build/es6/euclideanDistance.js");



var FaceMatcher = /** @class */ (function () {
    function FaceMatcher(inputs, distanceThreshold) {
        if (distanceThreshold === void 0) { distanceThreshold = 0.6; }
        this._distanceThreshold = distanceThreshold;
        var inputArray = Array.isArray(inputs) ? inputs : [inputs];
        if (!inputArray.length) {
            throw new Error("FaceRecognizer.constructor - expected atleast one input");
        }
        var count = 1;
        var createUniqueLabel = function () { return "person " + count++; };
        this._labeledDescriptors = inputArray.map(function (desc) {
            if (desc instanceof _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"]) {
                return desc;
            }
            if (desc instanceof Float32Array) {
                return new _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"](createUniqueLabel(), [desc]);
            }
            if (desc.descriptor && desc.descriptor instanceof Float32Array) {
                return new _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"](createUniqueLabel(), [desc.descriptor]);
            }
            throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>");
        });
    }
    Object.defineProperty(FaceMatcher.prototype, "labeledDescriptors", {
        get: function () { return this._labeledDescriptors; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceMatcher.prototype, "distanceThreshold", {
        get: function () { return this._distanceThreshold; },
        enumerable: true,
        configurable: true
    });
    FaceMatcher.prototype.computeMeanDistance = function (queryDescriptor, descriptors) {
        return descriptors
            .map(function (d) { return Object(_euclideanDistance__WEBPACK_IMPORTED_MODULE_2__["euclideanDistance"])(d, queryDescriptor); })
            .reduce(function (d1, d2) { return d1 + d2; }, 0)
            / (descriptors.length || 1);
    };
    FaceMatcher.prototype.matchDescriptor = function (queryDescriptor) {
        var _this = this;
        return this.labeledDescriptors
            .map(function (_a) {
            var descriptors = _a.descriptors, label = _a.label;
            return new _classes_FaceMatch__WEBPACK_IMPORTED_MODULE_0__["FaceMatch"](label, _this.computeMeanDistance(queryDescriptor, descriptors));
        })
            .reduce(function (best, curr) { return best.distance < curr.distance ? best : curr; });
    };
    FaceMatcher.prototype.findBestMatch = function (queryDescriptor) {
        var bestMatch = this.matchDescriptor(queryDescriptor);
        return bestMatch.distance < this.distanceThreshold
            ? bestMatch
            : new _classes_FaceMatch__WEBPACK_IMPORTED_MODULE_0__["FaceMatch"]('unknown', bestMatch.distance);
    };
    FaceMatcher.prototype.toJSON = function () {
        return {
            distanceThreshold: this.distanceThreshold,
            labeledDescriptors: this.labeledDescriptors.map(function (ld) { return ld.toJSON(); })
        };
    };
    FaceMatcher.fromJSON = function (json) {
        var labeledDescriptors = json.labeledDescriptors
            .map(function (ld) { return _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"].fromJSON(ld); });
        return new FaceMatcher(labeledDescriptors, json.distanceThreshold);
    };
    return FaceMatcher;
}());

//# sourceMappingURL=FaceMatcher.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js ***!
  \*********************************************************************************/
/*! exports provided: PredictAgeAndGenderTaskBase, PredictAllAgeAndGenderTask, PredictSingleAgeAndGenderTask, PredictAllAgeAndGenderWithFaceAlignmentTask, PredictSingleAgeAndGenderWithFaceAlignmentTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAgeAndGenderTaskBase", function() { return PredictAgeAndGenderTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllAgeAndGenderTask", function() { return PredictAllAgeAndGenderTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleAgeAndGenderTask", function() { return PredictSingleAgeAndGenderTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllAgeAndGenderWithFaceAlignmentTask", function() { return PredictAllAgeAndGenderWithFaceAlignmentTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleAgeAndGenderWithFaceAlignmentTask", function() { return PredictSingleAgeAndGenderWithFaceAlignmentTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithAge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithAge */ "./node_modules/face-api.js/build/es6/factories/WithAge.js");
/* harmony import */ var _factories_WithGender__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/WithGender */ "./node_modules/face-api.js/build/es6/factories/WithGender.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony import */ var _extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractFacesAndComputeResults */ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");








var PredictAgeAndGenderTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAgeAndGenderTaskBase, _super);
    function PredictAgeAndGenderTaskBase(parentTask, input, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.extractedFaces = extractedFaces;
        return _this;
    }
    return PredictAgeAndGenderTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_3__["ComposableTask"]));

var PredictAllAgeAndGenderTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllAgeAndGenderTask, _super);
    function PredictAllAgeAndGenderTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllAgeAndGenderTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, ageAndGenderByFace;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _a.sent();
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_5__["extractAllFacesAndComputeResults"])(parentResults, this.input, function (faces) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, Promise.all(faces.map(function (face) { return _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].ageGenderNet.predictAgeAndGender(face); }))];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); }, this.extractedFaces)];
                    case 2:
                        ageAndGenderByFace = _a.sent();
                        return [2 /*return*/, parentResults.map(function (parentResult, i) {
                                var _a = ageAndGenderByFace[i], age = _a.age, gender = _a.gender, genderProbability = _a.genderProbability;
                                return Object(_factories_WithAge__WEBPACK_IMPORTED_MODULE_1__["extendWithAge"])(Object(_factories_WithGender__WEBPACK_IMPORTED_MODULE_2__["extendWithGender"])(parentResult, gender, genderProbability), age);
                            })];
                }
            });
        });
    };
    PredictAllAgeAndGenderTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictAllFaceExpressionsTask"](this, this.input);
    };
    return PredictAllAgeAndGenderTask;
}(PredictAgeAndGenderTaskBase));

var PredictSingleAgeAndGenderTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleAgeAndGenderTask, _super);
    function PredictSingleAgeAndGenderTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleAgeAndGenderTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, _a, age, gender, genderProbability;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _b.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_5__["extractSingleFaceAndComputeResult"])(parentResult, this.input, function (face) { return _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].ageGenderNet.predictAgeAndGender(face); }, this.extractedFaces)];
                    case 2:
                        _a = _b.sent(), age = _a.age, gender = _a.gender, genderProbability = _a.genderProbability;
                        return [2 /*return*/, Object(_factories_WithAge__WEBPACK_IMPORTED_MODULE_1__["extendWithAge"])(Object(_factories_WithGender__WEBPACK_IMPORTED_MODULE_2__["extendWithGender"])(parentResult, gender, genderProbability), age)];
                }
            });
        });
    };
    PredictSingleAgeAndGenderTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictSingleFaceExpressionsTask"](this, this.input);
    };
    return PredictSingleAgeAndGenderTask;
}(PredictAgeAndGenderTaskBase));

var PredictAllAgeAndGenderWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllAgeAndGenderWithFaceAlignmentTask, _super);
    function PredictAllAgeAndGenderWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllAgeAndGenderWithFaceAlignmentTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictAllFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    PredictAllAgeAndGenderWithFaceAlignmentTask.prototype.withFaceDescriptors = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_4__["ComputeAllFaceDescriptorsTask"](this, this.input);
    };
    return PredictAllAgeAndGenderWithFaceAlignmentTask;
}(PredictAllAgeAndGenderTask));

var PredictSingleAgeAndGenderWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleAgeAndGenderWithFaceAlignmentTask, _super);
    function PredictSingleAgeAndGenderWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleAgeAndGenderWithFaceAlignmentTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictSingleFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    PredictSingleAgeAndGenderWithFaceAlignmentTask.prototype.withFaceDescriptor = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_4__["ComputeSingleFaceDescriptorTask"](this, this.input);
    };
    return PredictSingleAgeAndGenderWithFaceAlignmentTask;
}(PredictSingleAgeAndGenderTask));

//# sourceMappingURL=PredictAgeAndGenderTask.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js":
/*!************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js ***!
  \************************************************************************************/
/*! exports provided: PredictFaceExpressionsTaskBase, PredictAllFaceExpressionsTask, PredictSingleFaceExpressionsTask, PredictAllFaceExpressionsWithFaceAlignmentTask, PredictSingleFaceExpressionsWithFaceAlignmentTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictFaceExpressionsTaskBase", function() { return PredictFaceExpressionsTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllFaceExpressionsTask", function() { return PredictAllFaceExpressionsTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleFaceExpressionsTask", function() { return PredictSingleFaceExpressionsTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllFaceExpressionsWithFaceAlignmentTask", function() { return PredictAllFaceExpressionsWithFaceAlignmentTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleFaceExpressionsWithFaceAlignmentTask", function() { return PredictSingleFaceExpressionsWithFaceAlignmentTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithFaceExpressions */ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony import */ var _extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractFacesAndComputeResults */ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");







var PredictFaceExpressionsTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictFaceExpressionsTaskBase, _super);
    function PredictFaceExpressionsTaskBase(parentTask, input, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.extractedFaces = extractedFaces;
        return _this;
    }
    return PredictFaceExpressionsTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_2__["ComposableTask"]));

var PredictAllFaceExpressionsTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllFaceExpressionsTask, _super);
    function PredictAllFaceExpressionsTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllFaceExpressionsTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, faceExpressionsByFace;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _a.sent();
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_4__["extractAllFacesAndComputeResults"])(parentResults, this.input, function (faces) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, Promise.all(faces.map(function (face) { return _nets__WEBPACK_IMPORTED_MODULE_5__["nets"].faceExpressionNet.predictExpressions(face); }))];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); }, this.extractedFaces)];
                    case 2:
                        faceExpressionsByFace = _a.sent();
                        return [2 /*return*/, parentResults.map(function (parentResult, i) { return Object(_factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceExpressions"])(parentResult, faceExpressionsByFace[i]); })];
                }
            });
        });
    };
    PredictAllFaceExpressionsTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictAllAgeAndGenderTask"](this, this.input);
    };
    return PredictAllFaceExpressionsTask;
}(PredictFaceExpressionsTaskBase));

var PredictSingleFaceExpressionsTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleFaceExpressionsTask, _super);
    function PredictSingleFaceExpressionsTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleFaceExpressionsTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, faceExpressions;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _a.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_4__["extractSingleFaceAndComputeResult"])(parentResult, this.input, function (face) { return _nets__WEBPACK_IMPORTED_MODULE_5__["nets"].faceExpressionNet.predictExpressions(face); }, this.extractedFaces)];
                    case 2:
                        faceExpressions = _a.sent();
                        return [2 /*return*/, Object(_factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceExpressions"])(parentResult, faceExpressions)];
                }
            });
        });
    };
    PredictSingleFaceExpressionsTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictSingleAgeAndGenderTask"](this, this.input);
    };
    return PredictSingleFaceExpressionsTask;
}(PredictFaceExpressionsTaskBase));

var PredictAllFaceExpressionsWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllFaceExpressionsWithFaceAlignmentTask, _super);
    function PredictAllFaceExpressionsWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllFaceExpressionsWithFaceAlignmentTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictAllAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    PredictAllFaceExpressionsWithFaceAlignmentTask.prototype.withFaceDescriptors = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_3__["ComputeAllFaceDescriptorsTask"](this, this.input);
    };
    return PredictAllFaceExpressionsWithFaceAlignmentTask;
}(PredictAllFaceExpressionsTask));

var PredictSingleFaceExpressionsWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleFaceExpressionsWithFaceAlignmentTask, _super);
    function PredictSingleFaceExpressionsWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleFaceExpressionsWithFaceAlignmentTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictSingleAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    PredictSingleFaceExpressionsWithFaceAlignmentTask.prototype.withFaceDescriptor = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_3__["ComputeSingleFaceDescriptorTask"](this, this.input);
    };
    return PredictSingleFaceExpressionsWithFaceAlignmentTask;
}(PredictSingleFaceExpressionsTask));

//# sourceMappingURL=PredictFaceExpressionsTask.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/allFaces.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/allFaces.js ***!
  \******************************************************************/
/*! exports provided: allFacesSsdMobilenetv1, allFacesTinyYolov2, allFacesMtcnn, allFaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFacesSsdMobilenetv1", function() { return allFacesSsdMobilenetv1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFacesTinyYolov2", function() { return allFacesTinyYolov2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFacesMtcnn", function() { return allFacesMtcnn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFaces", function() { return allFaces; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mtcnn/MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony import */ var _ssdMobilenetv1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ssdMobilenetv1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");
/* harmony import */ var _detectFaces__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./detectFaces */ "./node_modules/face-api.js/build/es6/globalApi/detectFaces.js");





// export allFaces API for backward compatibility
function allFacesSsdMobilenetv1(input, minConfidence) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.warn('allFacesSsdMobilenetv1 is deprecated and will be removed soon, use the high level api instead');
                    return [4 /*yield*/, Object(_detectFaces__WEBPACK_IMPORTED_MODULE_4__["detectAllFaces"])(input, new _ssdMobilenetv1__WEBPACK_IMPORTED_MODULE_2__["SsdMobilenetv1Options"](minConfidence ? { minConfidence: minConfidence } : {}))
                            .withFaceLandmarks()
                            .withFaceDescriptors()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function allFacesTinyYolov2(input, forwardParams) {
    if (forwardParams === void 0) { forwardParams = {}; }
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.warn('allFacesTinyYolov2 is deprecated and will be removed soon, use the high level api instead');
                    return [4 /*yield*/, Object(_detectFaces__WEBPACK_IMPORTED_MODULE_4__["detectAllFaces"])(input, new _tinyYolov2__WEBPACK_IMPORTED_MODULE_3__["TinyYolov2Options"](forwardParams))
                            .withFaceLandmarks()
                            .withFaceDescriptors()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function allFacesMtcnn(input, forwardParams) {
    if (forwardParams === void 0) { forwardParams = {}; }
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.warn('allFacesMtcnn is deprecated and will be removed soon, use the high level api instead');
                    return [4 /*yield*/, Object(_detectFaces__WEBPACK_IMPORTED_MODULE_4__["detectAllFaces"])(input, new _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__["MtcnnOptions"](forwardParams))
                            .withFaceLandmarks()
                            .withFaceDescriptors()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
var allFaces = allFacesSsdMobilenetv1;
//# sourceMappingURL=allFaces.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/detectFaces.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/detectFaces.js ***!
  \*********************************************************************/
/*! exports provided: detectSingleFace, detectAllFaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectSingleFace", function() { return detectSingleFace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectAllFaces", function() { return detectAllFaces; });
/* harmony import */ var _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ssdMobilenetv1/SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");
/* harmony import */ var _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DetectFacesTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js");


function detectSingleFace(input, options) {
    if (options === void 0) { options = new _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_0__["SsdMobilenetv1Options"](); }
    return new _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_1__["DetectSingleFaceTask"](input, options);
}
function detectAllFaces(input, options) {
    if (options === void 0) { options = new _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_0__["SsdMobilenetv1Options"](); }
    return new _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_1__["DetectAllFacesTask"](input, options);
}
//# sourceMappingURL=detectFaces.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js ***!
  \***************************************************************************************/
/*! exports provided: extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractAllFacesAndComputeResults", function() { return extractAllFacesAndComputeResults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractSingleFaceAndComputeResult", function() { return extractSingleFaceAndComputeResult; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");




function extractAllFacesAndComputeResults(parentResults, input, computeResults, extractedFaces, getRectForAlignment) {
    if (getRectForAlignment === void 0) { getRectForAlignment = function (_a) {
        var alignedRect = _a.alignedRect;
        return alignedRect;
    }; }
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var faceBoxes, faces, _a, _b, results;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
            switch (_c.label) {
                case 0:
                    faceBoxes = parentResults.map(function (parentResult) {
                        return Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["isWithFaceLandmarks"])(parentResult)
                            ? getRectForAlignment(parentResult)
                            : parentResult.detection;
                    });
                    _a = extractedFaces;
                    if (_a) return [3 /*break*/, 5];
                    if (!(input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) return [3 /*break*/, 2];
                    return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaceTensors"])(input, faceBoxes)];
                case 1:
                    _b = _c.sent();
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaces"])(input, faceBoxes)];
                case 3:
                    _b = _c.sent();
                    _c.label = 4;
                case 4:
                    _a = (_b);
                    _c.label = 5;
                case 5:
                    faces = _a;
                    return [4 /*yield*/, computeResults(faces)];
                case 6:
                    results = _c.sent();
                    faces.forEach(function (f) { return f instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"] && f.dispose(); });
                    return [2 /*return*/, results];
            }
        });
    });
}
function extractSingleFaceAndComputeResult(parentResult, input, computeResult, extractedFaces, getRectForAlignment) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var _this = this;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            return [2 /*return*/, extractAllFacesAndComputeResults([parentResult], input, function (faces) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                    return [2 /*return*/, computeResult(faces[0])];
                }); }); }, extractedFaces, getRectForAlignment)];
        });
    });
}
//# sourceMappingURL=extractFacesAndComputeResults.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/index.js ***!
  \***************************************************************/
/*! exports provided: allFacesSsdMobilenetv1, allFacesTinyYolov2, allFacesMtcnn, allFaces, ComposableTask, ComputeFaceDescriptorsTaskBase, ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask, detectSingleFace, detectAllFaces, DetectFacesTaskBase, DetectAllFacesTask, DetectSingleFaceTask, DetectFaceLandmarksTaskBase, DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask, FaceMatcher, nets, ssdMobilenetv1, tinyFaceDetector, tinyYolov2, mtcnn, detectFaceLandmarks, detectFaceLandmarksTiny, computeFaceDescriptor, recognizeFaceExpressions, predictAgeAndGender, loadSsdMobilenetv1Model, loadTinyFaceDetectorModel, loadMtcnnModel, loadTinyYolov2Model, loadFaceLandmarkModel, loadFaceLandmarkTinyModel, loadFaceRecognitionModel, loadFaceExpressionModel, loadAgeGenderModel, loadFaceDetectionModel, locateFaces, detectLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _allFaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./allFaces */ "./node_modules/face-api.js/build/es6/globalApi/allFaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesSsdMobilenetv1", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFacesSsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesTinyYolov2", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFacesTinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesMtcnn", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFacesMtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFaces", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFaces"]; });

/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComposableTask", function() { return _ComposableTask__WEBPACK_IMPORTED_MODULE_1__["ComposableTask"]; });

/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeFaceDescriptorsTaskBase", function() { return _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__["ComputeFaceDescriptorsTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeAllFaceDescriptorsTask", function() { return _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__["ComputeAllFaceDescriptorsTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeSingleFaceDescriptorTask", function() { return _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__["ComputeSingleFaceDescriptorTask"]; });

/* harmony import */ var _detectFaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./detectFaces */ "./node_modules/face-api.js/build/es6/globalApi/detectFaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectSingleFace", function() { return _detectFaces__WEBPACK_IMPORTED_MODULE_3__["detectSingleFace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectAllFaces", function() { return _detectFaces__WEBPACK_IMPORTED_MODULE_3__["detectAllFaces"]; });

/* harmony import */ var _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DetectFacesTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFacesTaskBase", function() { return _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__["DetectFacesTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFacesTask", function() { return _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__["DetectAllFacesTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceTask", function() { return _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__["DetectSingleFaceTask"]; });

/* harmony import */ var _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DetectFaceLandmarksTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFaceLandmarksTaskBase", function() { return _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__["DetectFaceLandmarksTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFaceLandmarksTask", function() { return _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__["DetectAllFaceLandmarksTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceLandmarksTask", function() { return _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__["DetectSingleFaceLandmarksTask"]; });

/* harmony import */ var _FaceMatcher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FaceMatcher */ "./node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatcher", function() { return _FaceMatcher__WEBPACK_IMPORTED_MODULE_6__["FaceMatcher"]; });

/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nets", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["nets"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssdMobilenetv1", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["ssdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyFaceDetector", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["tinyFaceDetector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyYolov2", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["tinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mtcnn", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["mtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarks", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["detectFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarksTiny", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["detectFaceLandmarksTiny"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeFaceDescriptor", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["computeFaceDescriptor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recognizeFaceExpressions", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["recognizeFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "predictAgeAndGender", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["predictAgeAndGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadSsdMobilenetv1Model", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadSsdMobilenetv1Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyFaceDetectorModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadTinyFaceDetectorModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadMtcnnModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadMtcnnModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyYolov2Model", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadTinyYolov2Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceLandmarkModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkTinyModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceLandmarkTinyModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceRecognitionModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceRecognitionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceExpressionModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceExpressionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadAgeGenderModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadAgeGenderModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceDetectionModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceDetectionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "locateFaces", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["locateFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectLandmarks", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["detectLandmarks"]; });









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/nets.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/nets.js ***!
  \**************************************************************/
/*! exports provided: nets, ssdMobilenetv1, tinyFaceDetector, tinyYolov2, mtcnn, detectFaceLandmarks, detectFaceLandmarksTiny, computeFaceDescriptor, recognizeFaceExpressions, predictAgeAndGender, loadSsdMobilenetv1Model, loadTinyFaceDetectorModel, loadMtcnnModel, loadTinyYolov2Model, loadFaceLandmarkModel, loadFaceLandmarkTinyModel, loadFaceRecognitionModel, loadFaceExpressionModel, loadAgeGenderModel, loadFaceDetectionModel, locateFaces, detectLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nets", function() { return nets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssdMobilenetv1", function() { return ssdMobilenetv1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tinyFaceDetector", function() { return tinyFaceDetector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tinyYolov2", function() { return tinyYolov2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtcnn", function() { return mtcnn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarks", function() { return detectFaceLandmarks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarksTiny", function() { return detectFaceLandmarksTiny; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeFaceDescriptor", function() { return computeFaceDescriptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recognizeFaceExpressions", function() { return recognizeFaceExpressions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "predictAgeAndGender", function() { return predictAgeAndGender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadSsdMobilenetv1Model", function() { return loadSsdMobilenetv1Model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadTinyFaceDetectorModel", function() { return loadTinyFaceDetectorModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadMtcnnModel", function() { return loadMtcnnModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadTinyYolov2Model", function() { return loadTinyYolov2Model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkModel", function() { return loadFaceLandmarkModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkTinyModel", function() { return loadFaceLandmarkTinyModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceRecognitionModel", function() { return loadFaceRecognitionModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceExpressionModel", function() { return loadFaceExpressionModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAgeGenderModel", function() { return loadAgeGenderModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceDetectionModel", function() { return loadFaceDetectionModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locateFaces", function() { return locateFaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectLandmarks", function() { return detectLandmarks; });
/* harmony import */ var _ageGenderNet_AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ageGenderNet/AgeGenderNet */ "./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js");
/* harmony import */ var _faceExpressionNet_FaceExpressionNet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceExpressionNet/FaceExpressionNet */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js");
/* harmony import */ var _faceLandmarkNet_FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../faceLandmarkNet/FaceLandmark68Net */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js");
/* harmony import */ var _faceLandmarkNet_FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../faceLandmarkNet/FaceLandmark68TinyNet */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js");
/* harmony import */ var _faceRecognitionNet_FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../faceRecognitionNet/FaceRecognitionNet */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js");
/* harmony import */ var _mtcnn_Mtcnn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mtcnn/Mtcnn */ "./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js");
/* harmony import */ var _ssdMobilenetv1_SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ssdMobilenetv1/SsdMobilenetv1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js");
/* harmony import */ var _tinyFaceDetector_TinyFaceDetector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tinyFaceDetector/TinyFaceDetector */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");









var nets = {
    ssdMobilenetv1: new _ssdMobilenetv1_SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_6__["SsdMobilenetv1"](),
    tinyFaceDetector: new _tinyFaceDetector_TinyFaceDetector__WEBPACK_IMPORTED_MODULE_7__["TinyFaceDetector"](),
    tinyYolov2: new _tinyYolov2__WEBPACK_IMPORTED_MODULE_8__["TinyYolov2"](),
    mtcnn: new _mtcnn_Mtcnn__WEBPACK_IMPORTED_MODULE_5__["Mtcnn"](),
    faceLandmark68Net: new _faceLandmarkNet_FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68Net"](),
    faceLandmark68TinyNet: new _faceLandmarkNet_FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_3__["FaceLandmark68TinyNet"](),
    faceRecognitionNet: new _faceRecognitionNet_FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_4__["FaceRecognitionNet"](),
    faceExpressionNet: new _faceExpressionNet_FaceExpressionNet__WEBPACK_IMPORTED_MODULE_1__["FaceExpressionNet"](),
    ageGenderNet: new _ageGenderNet_AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__["AgeGenderNet"]()
};
/**
 * Attempts to detect all faces in an image using SSD Mobilenetv1 Network.
 *
 * @param input The input image.
 * @param options (optional, default: see SsdMobilenetv1Options constructor for default parameters).
 * @returns Bounding box of each face with score.
 */
var ssdMobilenetv1 = function (input, options) {
    return nets.ssdMobilenetv1.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image using the Tiny Face Detector.
 *
 * @param input The input image.
 * @param options (optional, default: see TinyFaceDetectorOptions constructor for default parameters).
 * @returns Bounding box of each face with score.
 */
var tinyFaceDetector = function (input, options) {
    return nets.tinyFaceDetector.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image using the Tiny Yolov2 Network.
 *
 * @param input The input image.
 * @param options (optional, default: see TinyYolov2Options constructor for default parameters).
 * @returns Bounding box of each face with score.
 */
var tinyYolov2 = function (input, options) {
    return nets.tinyYolov2.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image and the 5 point face landmarks
 * of each detected face using the MTCNN Network.
 *
 * @param input The input image.
 * @param options (optional, default: see MtcnnOptions constructor for default parameters).
 * @returns Bounding box of each face with score and 5 point face landmarks.
 */
var mtcnn = function (input, options) {
    return nets.mtcnn.forward(input, options);
};
/**
 * Detects the 68 point face landmark positions of the face shown in an image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns 68 point face landmarks or array thereof in case of batch input.
 */
var detectFaceLandmarks = function (input) {
    return nets.faceLandmark68Net.detectLandmarks(input);
};
/**
 * Detects the 68 point face landmark positions of the face shown in an image
 * using a tinier version of the 68 point face landmark model, which is slightly
 * faster at inference, but also slightly less accurate.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns 68 point face landmarks or array thereof in case of batch input.
 */
var detectFaceLandmarksTiny = function (input) {
    return nets.faceLandmark68TinyNet.detectLandmarks(input);
};
/**
 * Computes a 128 entry vector (face descriptor / face embeddings) from the face shown in an image,
 * which uniquely represents the features of that persons face. The computed face descriptor can
 * be used to measure the similarity between faces, by computing the euclidean distance of two
 * face descriptors.
 *
 * @param inputs The face image extracted from the aligned bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Face descriptor with 128 entries or array thereof in case of batch input.
 */
var computeFaceDescriptor = function (input) {
    return nets.faceRecognitionNet.computeFaceDescriptor(input);
};
/**
 * Recognizes the facial expressions from a face image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Facial expressions with corresponding probabilities or array thereof in case of batch input.
 */
var recognizeFaceExpressions = function (input) {
    return nets.faceExpressionNet.predictExpressions(input);
};
/**
 * Predicts age and gender from a face image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Predictions with age, gender and gender probability or array thereof in case of batch input.
 */
var predictAgeAndGender = function (input) {
    return nets.ageGenderNet.predictAgeAndGender(input);
};
var loadSsdMobilenetv1Model = function (url) { return nets.ssdMobilenetv1.load(url); };
var loadTinyFaceDetectorModel = function (url) { return nets.tinyFaceDetector.load(url); };
var loadMtcnnModel = function (url) { return nets.mtcnn.load(url); };
var loadTinyYolov2Model = function (url) { return nets.tinyYolov2.load(url); };
var loadFaceLandmarkModel = function (url) { return nets.faceLandmark68Net.load(url); };
var loadFaceLandmarkTinyModel = function (url) { return nets.faceLandmark68TinyNet.load(url); };
var loadFaceRecognitionModel = function (url) { return nets.faceRecognitionNet.load(url); };
var loadFaceExpressionModel = function (url) { return nets.faceExpressionNet.load(url); };
var loadAgeGenderModel = function (url) { return nets.ageGenderNet.load(url); };
// backward compatibility
var loadFaceDetectionModel = loadSsdMobilenetv1Model;
var locateFaces = ssdMobilenetv1;
var detectLandmarks = detectFaceLandmarks;
//# sourceMappingURL=nets.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/index.js ***!
  \*****************************************************/
/*! exports provided: draw, utils, tf, AgeGenderNet, Gender, BoundingBox, Box, Dimensions, FaceDetection, FaceLandmarks, FaceLandmarks5, FaceLandmarks68, FaceMatch, LabeledBox, LabeledFaceDescriptors, ObjectDetection, Point, PredictedBox, Rect, awaitMediaLoaded, bufferToImage, createCanvas, createCanvasFromMedia, extractFaces, extractFaceTensors, fetchImage, fetchJson, fetchNetWeights, fetchOrThrow, getContext2dOrThrow, getMediaDimensions, imageTensorToCanvas, imageToSquare, isMediaElement, isMediaLoaded, loadWeightMap, matchDimensions, NetInput, resolveInput, toNetInput, env, FaceExpressionNet, FACE_EXPRESSION_LABELS, FaceExpressions, FaceLandmark68Net, FaceLandmark68TinyNet, FaceLandmarkNet, FaceRecognitionNet, createFaceRecognitionNet, extendWithFaceDescriptor, isWithFaceDetection, extendWithFaceDetection, isWithFaceExpressions, extendWithFaceExpressions, isWithFaceLandmarks, extendWithFaceLandmarks, isWithAge, extendWithAge, isWithGender, extendWithGender, allFacesSsdMobilenetv1, allFacesTinyYolov2, allFacesMtcnn, allFaces, ComposableTask, ComputeFaceDescriptorsTaskBase, ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask, detectSingleFace, detectAllFaces, DetectFacesTaskBase, DetectAllFacesTask, DetectSingleFaceTask, DetectFaceLandmarksTaskBase, DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask, FaceMatcher, nets, ssdMobilenetv1, tinyFaceDetector, tinyYolov2, mtcnn, detectFaceLandmarks, detectFaceLandmarksTiny, computeFaceDescriptor, recognizeFaceExpressions, predictAgeAndGender, loadSsdMobilenetv1Model, loadTinyFaceDetectorModel, loadMtcnnModel, loadTinyYolov2Model, loadFaceLandmarkModel, loadFaceLandmarkTinyModel, loadFaceRecognitionModel, loadFaceExpressionModel, loadAgeGenderModel, loadFaceDetectionModel, locateFaces, detectLandmarks, Mtcnn, MtcnnOptions, createMtcnn, iou, minBbox, nonMaxSuppression, normalize, padToSquare, shuffleArray, sigmoid, inverseSigmoid, SsdMobilenetv1, SsdMobilenetv1Options, createSsdMobilenetv1, createFaceDetectionNet, FaceDetectionNet, TinyFaceDetector, TinyFaceDetectorOptions, createTinyFaceDetector, TinyYolov2SizeType, TinyYolov2Options, validateConfig, TinyYolov2, createTinyYolov2, euclideanDistance, NeuralNetwork, resizeResults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "tf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw */ "./node_modules/face-api.js/build/es6/draw/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return _draw__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _ageGenderNet_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ageGenderNet/index */ "./node_modules/face-api.js/build/es6/ageGenderNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AgeGenderNet", function() { return _ageGenderNet_index__WEBPACK_IMPORTED_MODULE_3__["AgeGenderNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gender", function() { return _ageGenderNet_index__WEBPACK_IMPORTED_MODULE_3__["Gender"]; });

/* harmony import */ var _classes_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/index */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["BoundingBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Box"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Dimensions", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Dimensions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceDetection", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks5", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks5"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks68", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks68"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatch", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceMatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledBox", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["LabeledBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledFaceDescriptors", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["LabeledFaceDescriptors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectDetection", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["ObjectDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Point"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PredictedBox", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["PredictedBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Rect"]; });

/* harmony import */ var _dom_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom/index */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "awaitMediaLoaded", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["awaitMediaLoaded"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToImage", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["bufferToImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["createCanvas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvasFromMedia", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["createCanvasFromMedia"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaces", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["extractFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaceTensors", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["extractFaceTensors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchImage", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchJson"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchNetWeights", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchNetWeights"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchOrThrow", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchOrThrow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContext2dOrThrow", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["getContext2dOrThrow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMediaDimensions", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["getMediaDimensions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageTensorToCanvas", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["imageTensorToCanvas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageToSquare", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["imageToSquare"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaElement", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["isMediaElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaLoaded", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["isMediaLoaded"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadWeightMap", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["loadWeightMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matchDimensions", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["matchDimensions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NetInput", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["NetInput"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveInput", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["resolveInput"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toNetInput", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["toNetInput"]; });

/* harmony import */ var _env_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./env/index */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "env", function() { return _env_index__WEBPACK_IMPORTED_MODULE_6__["env"]; });

/* harmony import */ var _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./faceExpressionNet/index */ "./node_modules/face-api.js/build/es6/faceExpressionNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressionNet", function() { return _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__["FaceExpressionNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FACE_EXPRESSION_LABELS", function() { return _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__["FACE_EXPRESSION_LABELS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressions", function() { return _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__["FaceExpressions"]; });

/* harmony import */ var _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./faceLandmarkNet/index */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68Net", function() { return _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__["FaceLandmark68Net"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68TinyNet", function() { return _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__["FaceLandmark68TinyNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarkNet", function() { return _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__["FaceLandmarkNet"]; });

/* harmony import */ var _faceRecognitionNet_index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./faceRecognitionNet/index */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceRecognitionNet", function() { return _faceRecognitionNet_index__WEBPACK_IMPORTED_MODULE_9__["FaceRecognitionNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFaceRecognitionNet", function() { return _faceRecognitionNet_index__WEBPACK_IMPORTED_MODULE_9__["createFaceRecognitionNet"]; });

/* harmony import */ var _factories_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./factories/index */ "./node_modules/face-api.js/build/es6/factories/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDescriptor", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceDescriptor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceDetection", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithFaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDetection", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceExpressions", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceExpressions", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceLandmarks", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceLandmarks", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithAge", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithAge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithAge", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithAge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithGender", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithGender", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithGender"]; });

/* harmony import */ var _globalApi_index__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./globalApi/index */ "./node_modules/face-api.js/build/es6/globalApi/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesSsdMobilenetv1", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFacesSsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesTinyYolov2", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFacesTinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesMtcnn", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFacesMtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFaces", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComposableTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComposableTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeFaceDescriptorsTaskBase", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComputeFaceDescriptorsTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeAllFaceDescriptorsTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComputeAllFaceDescriptorsTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeSingleFaceDescriptorTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComputeSingleFaceDescriptorTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectSingleFace", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectSingleFace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectAllFaces", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectAllFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFacesTaskBase", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectFacesTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFacesTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectAllFacesTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectSingleFaceTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFaceLandmarksTaskBase", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectFaceLandmarksTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFaceLandmarksTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectAllFaceLandmarksTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceLandmarksTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectSingleFaceLandmarksTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatcher", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["FaceMatcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nets", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["nets"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssdMobilenetv1", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ssdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyFaceDetector", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["tinyFaceDetector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyYolov2", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["tinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mtcnn", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["mtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarks", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarksTiny", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectFaceLandmarksTiny"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeFaceDescriptor", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["computeFaceDescriptor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recognizeFaceExpressions", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["recognizeFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "predictAgeAndGender", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["predictAgeAndGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadSsdMobilenetv1Model", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadSsdMobilenetv1Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyFaceDetectorModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadTinyFaceDetectorModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadMtcnnModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadMtcnnModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyYolov2Model", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadTinyYolov2Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceLandmarkModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkTinyModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceLandmarkTinyModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceRecognitionModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceRecognitionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceExpressionModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceExpressionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadAgeGenderModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadAgeGenderModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceDetectionModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceDetectionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "locateFaces", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["locateFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectLandmarks", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectLandmarks"]; });

/* harmony import */ var _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mtcnn/index */ "./node_modules/face-api.js/build/es6/mtcnn/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Mtcnn", function() { return _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__["Mtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MtcnnOptions", function() { return _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__["MtcnnOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createMtcnn", function() { return _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__["createMtcnn"]; });

/* harmony import */ var _ops_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ops/index */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iou", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["iou"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minBbox", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["minBbox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["nonMaxSuppression"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["normalize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padToSquare", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["padToSquare"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffleArray", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["shuffleArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["sigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inverseSigmoid", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["inverseSigmoid"]; });

/* harmony import */ var _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ssdMobilenetv1/index */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["SsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1Options", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["SsdMobilenetv1Options"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSsdMobilenetv1", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["createSsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFaceDetectionNet", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["createFaceDetectionNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceDetectionNet", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["FaceDetectionNet"]; });

/* harmony import */ var _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tinyFaceDetector/index */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetector", function() { return _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__["TinyFaceDetector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetectorOptions", function() { return _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__["TinyFaceDetectorOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTinyFaceDetector", function() { return _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__["createTinyFaceDetector"]; });

/* harmony import */ var _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tinyYolov2/index */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2SizeType", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2SizeType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Options", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2Options"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateConfig", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["validateConfig"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTinyYolov2", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["createTinyYolov2"]; });

/* harmony import */ var _euclideanDistance__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./euclideanDistance */ "./node_modules/face-api.js/build/es6/euclideanDistance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "euclideanDistance", function() { return _euclideanDistance__WEBPACK_IMPORTED_MODULE_17__["euclideanDistance"]; });

/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NeuralNetwork", function() { return _NeuralNetwork__WEBPACK_IMPORTED_MODULE_18__["NeuralNetwork"]; });

/* harmony import */ var _resizeResults__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./resizeResults */ "./node_modules/face-api.js/build/es6/resizeResults.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeResults", function() { return _resizeResults__WEBPACK_IMPORTED_MODULE_19__["resizeResults"]; });






















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js ***!
  \***********************************************************/
/*! exports provided: Mtcnn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mtcnn", function() { return Mtcnn; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _classes_FaceLandmarks5__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../classes/FaceLandmarks5 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _factories__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factories */ "./node_modules/face-api.js/build/es6/factories/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _bgrToRgbTensor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bgrToRgbTensor */ "./node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/mtcnn/config.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/mtcnn/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js");
/* harmony import */ var _getSizesForScale__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getSizesForScale */ "./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js");
/* harmony import */ var _MtcnnOptions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony import */ var _pyramidDown__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pyramidDown */ "./node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js");
/* harmony import */ var _stage1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./stage1 */ "./node_modules/face-api.js/build/es6/mtcnn/stage1.js");
/* harmony import */ var _stage2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./stage2 */ "./node_modules/face-api.js/build/es6/mtcnn/stage2.js");
/* harmony import */ var _stage3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./stage3 */ "./node_modules/face-api.js/build/es6/mtcnn/stage3.js");


















var Mtcnn = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(Mtcnn, _super);
    function Mtcnn() {
        return _super.call(this, 'Mtcnn') || this;
    }
    Mtcnn.prototype.load = function (weightsOrUrl) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                console.warn('mtcnn is deprecated and will be removed soon');
                return [2 /*return*/, _super.prototype.load.call(this, weightsOrUrl)];
            });
        });
    };
    Mtcnn.prototype.loadFromDisk = function (filePath) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                console.warn('mtcnn is deprecated and will be removed soon');
                return [2 /*return*/, _super.prototype.loadFromDisk.call(this, filePath)];
            });
        });
    };
    Mtcnn.prototype.forwardInput = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        params = this.params;
                        if (!params) {
                            throw new Error('Mtcnn - load model before inference');
                        }
                        inputCanvas = input.canvases[0];
                        if (!inputCanvas) {
                            throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');
                        }
                        stats = {};
                        tsTotal = Date.now();
                        imgTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                            return Object(_bgrToRgbTensor__WEBPACK_IMPORTED_MODULE_8__["bgrToRgbTensor"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["browser"].fromPixels(inputCanvas)).toFloat());
                        });
                        onReturn = function (results) {
                            // dispose tensors on return
                            imgTensor.dispose();
                            stats.total = Date.now() - tsTotal;
                            return results;
                        };
                        _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];
                        _b = new _MtcnnOptions__WEBPACK_IMPORTED_MODULE_13__["MtcnnOptions"](forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
                        scales = (scaleSteps || Object(_pyramidDown__WEBPACK_IMPORTED_MODULE_14__["pyramidDown"])(minFaceSize, scaleFactor, [height, width]))
                            .filter(function (scale) {
                            var sizes = Object(_getSizesForScale__WEBPACK_IMPORTED_MODULE_12__["getSizesForScale"])(scale, [height, width]);
                            return Math.min(sizes.width, sizes.height) > _config__WEBPACK_IMPORTED_MODULE_9__["CELL_SIZE"];
                        })
                            .slice(0, maxNumScales);
                        stats.scales = scales;
                        stats.pyramid = scales.map(function (scale) { return Object(_getSizesForScale__WEBPACK_IMPORTED_MODULE_12__["getSizesForScale"])(scale, [height, width]); });
                        ts = Date.now();
                        return [4 /*yield*/, Object(_stage1__WEBPACK_IMPORTED_MODULE_15__["stage1"])(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];
                    case 1:
                        out1 = _c.sent();
                        stats.total_stage1 = Date.now() - ts;
                        if (!out1.boxes.length) {
                            return [2 /*return*/, onReturn({ results: [], stats: stats })];
                        }
                        stats.stage2_numInputBoxes = out1.boxes.length;
                        // using the inputCanvas to extract and resize the image patches, since it is faster
                        // than doing this on the gpu
                        ts = Date.now();
                        return [4 /*yield*/, Object(_stage2__WEBPACK_IMPORTED_MODULE_16__["stage2"])(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];
                    case 2:
                        out2 = _c.sent();
                        stats.total_stage2 = Date.now() - ts;
                        if (!out2.boxes.length) {
                            return [2 /*return*/, onReturn({ results: [], stats: stats })];
                        }
                        stats.stage3_numInputBoxes = out2.boxes.length;
                        ts = Date.now();
                        return [4 /*yield*/, Object(_stage3__WEBPACK_IMPORTED_MODULE_17__["stage3"])(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];
                    case 3:
                        out3 = _c.sent();
                        stats.total_stage3 = Date.now() - ts;
                        results = out3.boxes.map(function (box, idx) { return Object(_factories__WEBPACK_IMPORTED_MODULE_6__["extendWithFaceLandmarks"])(Object(_factories__WEBPACK_IMPORTED_MODULE_6__["extendWithFaceDetection"])({}, new _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__["FaceDetection"](out3.scores[idx], new _classes__WEBPACK_IMPORTED_MODULE_2__["Rect"](box.left / width, box.top / height, box.width / width, box.height / height), {
                            height: height,
                            width: width
                        })), new _classes_FaceLandmarks5__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks5"](out3.points[idx].map(function (pt) { return pt.sub(new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](box.left, box.top)).div(new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](box.width, box.height)); }), { width: box.width, height: box.height })); });
                        return [2 /*return*/, onReturn({ results: results, stats: stats })];
                }
            });
        });
    };
    Mtcnn.prototype.forward = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(),
                            forwardParams])];
                    case 2: return [2 /*return*/, (_b.sent()).results];
                }
            });
        });
    };
    Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent(),
                            forwardParams])];
                }
            });
        });
    };
    Mtcnn.prototype.getDefaultModelName = function () {
        return 'mtcnn_model';
    };
    Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_11__["extractParamsFromWeigthMap"])(weightMap);
    };
    Mtcnn.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_10__["extractParams"])(weights);
    };
    return Mtcnn;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_7__["NeuralNetwork"]));

//# sourceMappingURL=Mtcnn.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js ***!
  \**************************************************************/
/*! exports provided: MtcnnBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MtcnnBox", function() { return MtcnnBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");


var MtcnnBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(MtcnnBox, _super);
    function MtcnnBox(left, top, right, bottom) {
        return _super.call(this, { left: left, top: top, right: right, bottom: bottom }, true) || this;
    }
    return MtcnnBox;
}(_classes__WEBPACK_IMPORTED_MODULE_1__["Box"]));

//# sourceMappingURL=MtcnnBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js ***!
  \******************************************************************/
/*! exports provided: MtcnnOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MtcnnOptions", function() { return MtcnnOptions; });
var MtcnnOptions = /** @class */ (function () {
    function MtcnnOptions(_a) {
        var _b = _a === void 0 ? {} : _a, minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
        this._name = 'MtcnnOptions';
        this._minFaceSize = minFaceSize || 20;
        this._scaleFactor = scaleFactor || 0.709;
        this._maxNumScales = maxNumScales || 10;
        this._scoreThresholds = scoreThresholds || [0.6, 0.7, 0.7];
        this._scaleSteps = scaleSteps;
        if (typeof this._minFaceSize !== 'number' || this._minFaceSize < 0) {
            throw new Error(this._name + " - expected minFaceSize to be a number > 0");
        }
        if (typeof this._scaleFactor !== 'number' || this._scaleFactor <= 0 || this._scaleFactor >= 1) {
            throw new Error(this._name + " - expected scaleFactor to be a number between 0 and 1");
        }
        if (typeof this._maxNumScales !== 'number' || this._maxNumScales < 0) {
            throw new Error(this._name + " - expected maxNumScales to be a number > 0");
        }
        if (!Array.isArray(this._scoreThresholds)
            || this._scoreThresholds.length !== 3
            || this._scoreThresholds.some(function (th) { return typeof th !== 'number'; })) {
            throw new Error(this._name + " - expected scoreThresholds to be an array of numbers of length 3");
        }
        if (this._scaleSteps
            && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some(function (th) { return typeof th !== 'number'; }))) {
            throw new Error(this._name + " - expected scaleSteps to be an array of numbers");
        }
    }
    Object.defineProperty(MtcnnOptions.prototype, "minFaceSize", {
        get: function () { return this._minFaceSize; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "scaleFactor", {
        get: function () { return this._scaleFactor; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "maxNumScales", {
        get: function () { return this._maxNumScales; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "scoreThresholds", {
        get: function () { return this._scoreThresholds; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "scaleSteps", {
        get: function () { return this._scaleSteps; },
        enumerable: true,
        configurable: true
    });
    return MtcnnOptions;
}());

//# sourceMappingURL=MtcnnOptions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/ONet.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/ONet.js ***!
  \**********************************************************/
/*! exports provided: ONet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONet", function() { return ONet; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _prelu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prelu */ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js");
/* harmony import */ var _sharedLayers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sharedLayers */ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js");





function ONet(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = Object(_sharedLayers__WEBPACK_IMPORTED_MODULE_4__["sharedLayer"])(x, params);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv4, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_3__["prelu"])(out, params.prelu4_alpha);
        var vectorized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](out, [out.shape[0], params.fc1.weights.shape[0]]);
        var fc1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(vectorized, params.fc1);
        var prelu5 = Object(_prelu__WEBPACK_IMPORTED_MODULE_3__["prelu"])(fc1, params.prelu5_alpha);
        var fc2_1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(prelu5, params.fc2_1);
        var max = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"](fc2_1, 1), 1);
        var prob = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](fc2_1, max), 1);
        var regions = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(prelu5, params.fc2_2);
        var points = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(prelu5, params.fc2_3);
        var scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](prob, 1)[1];
        return { scores: scores, regions: regions, points: points };
    });
}
//# sourceMappingURL=ONet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/PNet.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/PNet.js ***!
  \**********************************************************/
/*! exports provided: PNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PNet", function() { return PNet; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _sharedLayers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sharedLayers */ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js");



function PNet(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = Object(_sharedLayers__WEBPACK_IMPORTED_MODULE_2__["sharedLayer"])(x, params, true);
        var conv = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv4_1, 'valid');
        var max = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"](conv, 3), 3);
        var prob = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](conv, max), 3);
        var regions = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv4_2, 'valid');
        return { prob: prob, regions: regions };
    });
}
//# sourceMappingURL=PNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/RNet.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/RNet.js ***!
  \**********************************************************/
/*! exports provided: RNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RNet", function() { return RNet; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _prelu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prelu */ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js");
/* harmony import */ var _sharedLayers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sharedLayers */ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js");




function RNet(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var convOut = Object(_sharedLayers__WEBPACK_IMPORTED_MODULE_3__["sharedLayer"])(x, params);
        var vectorized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](convOut, [convOut.shape[0], params.fc1.weights.shape[0]]);
        var fc1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__["fullyConnectedLayer"])(vectorized, params.fc1);
        var prelu4 = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(fc1, params.prelu4_alpha);
        var fc2_1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__["fullyConnectedLayer"])(prelu4, params.fc2_1);
        var max = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"](fc2_1, 1), 1);
        var prob = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](fc2_1, max), 1);
        var regions = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__["fullyConnectedLayer"])(prelu4, params.fc2_2);
        var scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](prob, 1)[1];
        return { scores: scores, regions: regions };
    });
}
//# sourceMappingURL=RNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js ***!
  \********************************************************************/
/*! exports provided: bgrToRgbTensor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bgrToRgbTensor", function() { return bgrToRgbTensor; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function bgrToRgbTensor(tensor) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](tensor, 3).reverse(), 3); });
}
//# sourceMappingURL=bgrToRgbTensor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/config.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/config.js ***!
  \************************************************************/
/*! exports provided: CELL_STRIDE, CELL_SIZE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CELL_STRIDE", function() { return CELL_STRIDE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CELL_SIZE", function() { return CELL_SIZE; });
var CELL_STRIDE = 2;
var CELL_SIZE = 12;
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js":
/*!*************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js ***!
  \*************************************************************************/
/*! exports provided: extractImagePatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractImagePatches", function() { return extractImagePatches; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./normalize */ "./node_modules/face-api.js/build/es6/mtcnn/normalize.js");





function extractImagePatches(img, boxes, _a) {
    var width = _a.width, height = _a.height;
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var imgCtx, bitmaps, imagePatchesDatas;
        var _this = this;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    imgCtx = Object(_dom__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(img);
                    return [4 /*yield*/, Promise.all(boxes.map(function (box) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                            var _a, y, ey, x, ex, fromX, fromY, imgData;
                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                                _a = box.padAtBorders(img.height, img.width), y = _a.y, ey = _a.ey, x = _a.x, ex = _a.ex;
                                fromX = x - 1;
                                fromY = y - 1;
                                imgData = imgCtx.getImageData(fromX, fromY, (ex - fromX), (ey - fromY));
                                return [2 /*return*/, _env__WEBPACK_IMPORTED_MODULE_3__["env"].isNodejs() ? Object(_dom__WEBPACK_IMPORTED_MODULE_2__["createCanvasFromMedia"])(imgData) : createImageBitmap(imgData)];
                            });
                        }); }))];
                case 1:
                    bitmaps = _b.sent();
                    imagePatchesDatas = [];
                    bitmaps.forEach(function (bmp) {
                        var patch = Object(_dom__WEBPACK_IMPORTED_MODULE_2__["createCanvas"])({ width: width, height: height });
                        var patchCtx = Object(_dom__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(patch);
                        patchCtx.drawImage(bmp, 0, 0, width, height);
                        var data = patchCtx.getImageData(0, 0, width, height).data;
                        var currData = [];
                        // RGBA -> BGR
                        for (var i = 0; i < data.length; i += 4) {
                            currData.push(data[i + 2]);
                            currData.push(data[i + 1]);
                            currData.push(data[i]);
                        }
                        imagePatchesDatas.push(currData);
                    });
                    return [2 /*return*/, imagePatchesDatas.map(function (data) {
                            var t = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                                var imagePatchTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tensor4d"](data, [1, width, height, 3]), [0, 2, 1, 3]).toFloat();
                                return Object(_normalize__WEBPACK_IMPORTED_MODULE_4__["normalize"])(imagePatchTensor);
                            });
                            return t;
                        })];
            }
        });
    });
}
//# sourceMappingURL=extractImagePatches.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/extractParams.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/extractParams.js ***!
  \*******************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");



function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_2__["extractConvParamsFactory"])(extractWeights, paramMappings);
    var extractFCParams = Object(_common__WEBPACK_IMPORTED_MODULE_2__["extractFCParamsFactory"])(extractWeights, paramMappings);
    function extractPReluParams(size, paramPath) {
        var alpha = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tensor1d"](extractWeights(size));
        paramMappings.push({ paramPath: paramPath });
        return alpha;
    }
    function extractSharedParams(numFilters, mappedPrefix, isRnet) {
        if (isRnet === void 0) { isRnet = false; }
        var conv1 = extractConvParams(numFilters[0], numFilters[1], 3, mappedPrefix + "/conv1");
        var prelu1_alpha = extractPReluParams(numFilters[1], mappedPrefix + "/prelu1_alpha");
        var conv2 = extractConvParams(numFilters[1], numFilters[2], 3, mappedPrefix + "/conv2");
        var prelu2_alpha = extractPReluParams(numFilters[2], mappedPrefix + "/prelu2_alpha");
        var conv3 = extractConvParams(numFilters[2], numFilters[3], isRnet ? 2 : 3, mappedPrefix + "/conv3");
        var prelu3_alpha = extractPReluParams(numFilters[3], mappedPrefix + "/prelu3_alpha");
        return { conv1: conv1, prelu1_alpha: prelu1_alpha, conv2: conv2, prelu2_alpha: prelu2_alpha, conv3: conv3, prelu3_alpha: prelu3_alpha };
    }
    function extractPNetParams() {
        var sharedParams = extractSharedParams([3, 10, 16, 32], 'pnet');
        var conv4_1 = extractConvParams(32, 2, 1, 'pnet/conv4_1');
        var conv4_2 = extractConvParams(32, 4, 1, 'pnet/conv4_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4_1: conv4_1, conv4_2: conv4_2 });
    }
    function extractRNetParams() {
        var sharedParams = extractSharedParams([3, 28, 48, 64], 'rnet', true);
        var fc1 = extractFCParams(576, 128, 'rnet/fc1');
        var prelu4_alpha = extractPReluParams(128, 'rnet/prelu4_alpha');
        var fc2_1 = extractFCParams(128, 2, 'rnet/fc2_1');
        var fc2_2 = extractFCParams(128, 4, 'rnet/fc2_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { fc1: fc1, prelu4_alpha: prelu4_alpha, fc2_1: fc2_1, fc2_2: fc2_2 });
    }
    function extractONetParams() {
        var sharedParams = extractSharedParams([3, 32, 64, 64], 'onet');
        var conv4 = extractConvParams(64, 128, 2, 'onet/conv4');
        var prelu4_alpha = extractPReluParams(128, 'onet/prelu4_alpha');
        var fc1 = extractFCParams(1152, 256, 'onet/fc1');
        var prelu5_alpha = extractPReluParams(256, 'onet/prelu5_alpha');
        var fc2_1 = extractFCParams(256, 2, 'onet/fc2_1');
        var fc2_2 = extractFCParams(256, 4, 'onet/fc2_2');
        var fc2_3 = extractFCParams(256, 10, 'onet/fc2_3');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4: conv4, prelu4_alpha: prelu4_alpha, fc1: fc1, prelu5_alpha: prelu5_alpha, fc2_1: fc2_1, fc2_2: fc2_2, fc2_3: fc2_3 });
    }
    return {
        extractPNetParams: extractPNetParams,
        extractRNetParams: extractRNetParams,
        extractONetParams: extractONetParams
    };
}
function extractParams(weights) {
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_2__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractPNetParams = _b.extractPNetParams, extractRNetParams = _b.extractRNetParams, extractONetParams = _b.extractONetParams;
    var pnet = extractPNetParams();
    var rnet = extractRNetParams();
    var onet = extractONetParams();
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return { params: { pnet: pnet, rnet: rnet, onet: onet }, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js ***!
  \********************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");


function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractConvParams(prefix) {
        var filters = extractWeightEntry(prefix + "/weights", 4, prefix + "/filters");
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { filters: filters, bias: bias };
    }
    function extractFCParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { weights: weights, bias: bias };
    }
    function extractPReluParams(paramPath) {
        return extractWeightEntry(paramPath, 1);
    }
    function extractSharedParams(prefix) {
        var conv1 = extractConvParams(prefix + "/conv1");
        var prelu1_alpha = extractPReluParams(prefix + "/prelu1_alpha");
        var conv2 = extractConvParams(prefix + "/conv2");
        var prelu2_alpha = extractPReluParams(prefix + "/prelu2_alpha");
        var conv3 = extractConvParams(prefix + "/conv3");
        var prelu3_alpha = extractPReluParams(prefix + "/prelu3_alpha");
        return { conv1: conv1, prelu1_alpha: prelu1_alpha, conv2: conv2, prelu2_alpha: prelu2_alpha, conv3: conv3, prelu3_alpha: prelu3_alpha };
    }
    function extractPNetParams() {
        var sharedParams = extractSharedParams('pnet');
        var conv4_1 = extractConvParams('pnet/conv4_1');
        var conv4_2 = extractConvParams('pnet/conv4_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4_1: conv4_1, conv4_2: conv4_2 });
    }
    function extractRNetParams() {
        var sharedParams = extractSharedParams('rnet');
        var fc1 = extractFCParams('rnet/fc1');
        var prelu4_alpha = extractPReluParams('rnet/prelu4_alpha');
        var fc2_1 = extractFCParams('rnet/fc2_1');
        var fc2_2 = extractFCParams('rnet/fc2_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { fc1: fc1, prelu4_alpha: prelu4_alpha, fc2_1: fc2_1, fc2_2: fc2_2 });
    }
    function extractONetParams() {
        var sharedParams = extractSharedParams('onet');
        var conv4 = extractConvParams('onet/conv4');
        var prelu4_alpha = extractPReluParams('onet/prelu4_alpha');
        var fc1 = extractFCParams('onet/fc1');
        var prelu5_alpha = extractPReluParams('onet/prelu5_alpha');
        var fc2_1 = extractFCParams('onet/fc2_1');
        var fc2_2 = extractFCParams('onet/fc2_2');
        var fc2_3 = extractFCParams('onet/fc2_3');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4: conv4, prelu4_alpha: prelu4_alpha, fc1: fc1, prelu5_alpha: prelu5_alpha, fc2_1: fc2_1, fc2_2: fc2_2, fc2_3: fc2_3 });
    }
    return {
        extractPNetParams: extractPNetParams,
        extractRNetParams: extractRNetParams,
        extractONetParams: extractONetParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractPNetParams = _a.extractPNetParams, extractRNetParams = _a.extractRNetParams, extractONetParams = _a.extractONetParams;
    var pnet = extractPNetParams();
    var rnet = extractRNetParams();
    var onet = extractONetParams();
    Object(_common__WEBPACK_IMPORTED_MODULE_1__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: { pnet: pnet, rnet: rnet, onet: onet }, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js ***!
  \**********************************************************************/
/*! exports provided: getSizesForScale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizesForScale", function() { return getSizesForScale; });
function getSizesForScale(scale, _a) {
    var height = _a[0], width = _a[1];
    return {
        height: Math.floor(height * scale),
        width: Math.floor(width * scale)
    };
}
//# sourceMappingURL=getSizesForScale.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/index.js ***!
  \***********************************************************/
/*! exports provided: Mtcnn, MtcnnOptions, createMtcnn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMtcnn", function() { return createMtcnn; });
/* harmony import */ var _Mtcnn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mtcnn */ "./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Mtcnn", function() { return _Mtcnn__WEBPACK_IMPORTED_MODULE_0__["Mtcnn"]; });

/* harmony import */ var _MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MtcnnOptions", function() { return _MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__["MtcnnOptions"]; });




function createMtcnn(weights) {
    var net = new _Mtcnn__WEBPACK_IMPORTED_MODULE_0__["Mtcnn"]();
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/normalize.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/normalize.js ***!
  \***************************************************************/
/*! exports provided: normalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function normalize(x) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](x, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](127.5)), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](0.0078125)); });
}
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/prelu.js ***!
  \***********************************************************/
/*! exports provided: prelu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return prelu; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function prelu(x, alpha) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](x), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](alpha, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"](x)))));
    });
}
//# sourceMappingURL=prelu.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js ***!
  \*****************************************************************/
/*! exports provided: pyramidDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyramidDown", function() { return pyramidDown; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/mtcnn/config.js");

function pyramidDown(minFaceSize, scaleFactor, dims) {
    var height = dims[0], width = dims[1];
    var m = _config__WEBPACK_IMPORTED_MODULE_0__["CELL_SIZE"] / minFaceSize;
    var scales = [];
    var minLayer = Math.min(height, width) * m;
    var exp = 0;
    while (minLayer >= 12) {
        scales.push(m * Math.pow(scaleFactor, exp));
        minLayer = minLayer * scaleFactor;
        exp += 1;
    }
    return scales;
}
//# sourceMappingURL=pyramidDown.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js ***!
  \******************************************************************/
/*! exports provided: sharedLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sharedLayer", function() { return sharedLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _prelu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prelu */ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js");



function sharedLayer(x, params, isPnet) {
    if (isPnet === void 0) { isPnet = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(x, params.conv1, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(out, params.prelu1_alpha);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"](out, isPnet ? [2, 2] : [3, 3], [2, 2], 'same');
        out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv2, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(out, params.prelu2_alpha);
        out = isPnet ? out : _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"](out, [3, 3], [2, 2], 'valid');
        out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv3, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(out, params.prelu3_alpha);
        return out;
    });
}
//# sourceMappingURL=sharedLayers.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/stage1.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/stage1.js ***!
  \************************************************************/
/*! exports provided: stage1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stage1", function() { return stage1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/mtcnn/config.js");
/* harmony import */ var _getSizesForScale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getSizesForScale */ "./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js");
/* harmony import */ var _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MtcnnBox */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./normalize */ "./node_modules/face-api.js/build/es6/mtcnn/normalize.js");
/* harmony import */ var _PNet__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PNet */ "./node_modules/face-api.js/build/es6/mtcnn/PNet.js");








function rescaleAndNormalize(x, scale) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var _a = Object(_getSizesForScale__WEBPACK_IMPORTED_MODULE_4__["getSizesForScale"])(scale, x.shape.slice(1)), height = _a.height, width = _a.width;
        var resized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(x, [height, width]);
        var normalized = Object(_normalize__WEBPACK_IMPORTED_MODULE_6__["normalize"])(resized);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](normalized, [0, 2, 1, 3]);
    });
}
function extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {
    // TODO: fix this!, maybe better to use tf.gather here
    var indices = [];
    var scoresData = scoresTensor.arraySync();
    for (var y = 0; y < scoresTensor.shape[0]; y++) {
        for (var x = 0; x < scoresTensor.shape[1]; x++) {
            if (scoresData[y][x] >= scoreThreshold) {
                indices.push(new _classes__WEBPACK_IMPORTED_MODULE_1__["Point"](x, y));
            }
        }
    }
    var boundingBoxes = indices.map(function (idx) {
        var cell = new _classes__WEBPACK_IMPORTED_MODULE_1__["BoundingBox"](Math.round((idx.y * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + 1) / scale), Math.round((idx.x * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + 1) / scale), Math.round((idx.y * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + _config__WEBPACK_IMPORTED_MODULE_3__["CELL_SIZE"]) / scale), Math.round((idx.x * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + _config__WEBPACK_IMPORTED_MODULE_3__["CELL_SIZE"]) / scale));
        var score = scoresData[idx.y][idx.x];
        var regionsData = regionsTensor.arraySync();
        var region = new _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__["MtcnnBox"](regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);
        return {
            cell: cell,
            score: score,
            region: region
        };
    });
    return boundingBoxes;
}
function stage1(imgTensor, scales, scoreThreshold, params, stats) {
    stats.stage1 = [];
    var pnetOutputs = scales.map(function (scale) { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var statsForScale = { scale: scale };
        var resized = rescaleAndNormalize(imgTensor, scale);
        var ts = Date.now();
        var _a = Object(_PNet__WEBPACK_IMPORTED_MODULE_7__["PNet"])(resized, params), prob = _a.prob, regions = _a.regions;
        statsForScale.pnet = Date.now() - ts;
        var scoresTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](prob, 3)[1])[0];
        var regionsTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](regions)[0];
        return {
            scoresTensor: scoresTensor,
            regionsTensor: regionsTensor,
            scale: scale,
            statsForScale: statsForScale
        };
    }); });
    var boxesForScale = pnetOutputs.map(function (_a) {
        var scoresTensor = _a.scoresTensor, regionsTensor = _a.regionsTensor, scale = _a.scale, statsForScale = _a.statsForScale;
        var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);
        scoresTensor.dispose();
        regionsTensor.dispose();
        if (!boundingBoxes.length) {
            stats.stage1.push(statsForScale);
            return [];
        }
        var ts = Date.now();
        var indices = Object(_ops__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"])(boundingBoxes.map(function (bbox) { return bbox.cell; }), boundingBoxes.map(function (bbox) { return bbox.score; }), 0.5);
        statsForScale.nms = Date.now() - ts;
        statsForScale.numBoxes = indices.length;
        stats.stage1.push(statsForScale);
        return indices.map(function (boxIdx) { return boundingBoxes[boxIdx]; });
    });
    var allBoxes = boxesForScale.reduce(function (all, boxes) { return all.concat(boxes); }, []);
    var finalBoxes = [];
    var finalScores = [];
    if (allBoxes.length > 0) {
        var ts = Date.now();
        var indices = Object(_ops__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"])(allBoxes.map(function (bbox) { return bbox.cell; }), allBoxes.map(function (bbox) { return bbox.score; }), 0.7);
        stats.stage1_nms = Date.now() - ts;
        finalScores = indices.map(function (idx) { return allBoxes[idx].score; });
        finalBoxes = indices
            .map(function (idx) { return allBoxes[idx]; })
            .map(function (_a) {
            var cell = _a.cell, region = _a.region;
            return new _classes__WEBPACK_IMPORTED_MODULE_1__["BoundingBox"](cell.left + (region.left * cell.width), cell.top + (region.top * cell.height), cell.right + (region.right * cell.width), cell.bottom + (region.bottom * cell.height)).toSquare().round();
        });
    }
    return {
        boxes: finalBoxes,
        scores: finalScores
    };
}
//# sourceMappingURL=stage1.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/stage2.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/stage2.js ***!
  \************************************************************/
/*! exports provided: stage2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stage2", function() { return stage2; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _extractImagePatches__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractImagePatches */ "./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js");
/* harmony import */ var _MtcnnBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MtcnnBox */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js");
/* harmony import */ var _RNet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RNet */ "./node_modules/face-api.js/build/es6/mtcnn/RNet.js");






function stage2(img, inputBoxes, scoreThreshold, params, stats) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var ts, rnetInputs, rnetOuts, scoresTensor, scores, _a, _b, indices, filteredBoxes, filteredScores, finalBoxes, finalScores, indicesNms, regions_1;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
            switch (_c.label) {
                case 0:
                    ts = Date.now();
                    return [4 /*yield*/, Object(_extractImagePatches__WEBPACK_IMPORTED_MODULE_3__["extractImagePatches"])(img, inputBoxes, { width: 24, height: 24 })];
                case 1:
                    rnetInputs = _c.sent();
                    stats.stage2_extractImagePatches = Date.now() - ts;
                    ts = Date.now();
                    rnetOuts = rnetInputs.map(function (rnetInput) {
                        var out = Object(_RNet__WEBPACK_IMPORTED_MODULE_5__["RNet"])(rnetInput, params);
                        rnetInput.dispose();
                        return out;
                    });
                    stats.stage2_rnet = Date.now() - ts;
                    scoresTensor = rnetOuts.length > 1
                        ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"](rnetOuts.map(function (out) { return out.scores; }))
                        : rnetOuts[0].scores;
                    _b = (_a = Array).from;
                    return [4 /*yield*/, scoresTensor.data()];
                case 2:
                    scores = _b.apply(_a, [_c.sent()]);
                    scoresTensor.dispose();
                    indices = scores
                        .map(function (score, idx) { return ({ score: score, idx: idx }); })
                        .filter(function (c) { return c.score > scoreThreshold; })
                        .map(function (_a) {
                        var idx = _a.idx;
                        return idx;
                    });
                    filteredBoxes = indices.map(function (idx) { return inputBoxes[idx]; });
                    filteredScores = indices.map(function (idx) { return scores[idx]; });
                    finalBoxes = [];
                    finalScores = [];
                    if (filteredBoxes.length > 0) {
                        ts = Date.now();
                        indicesNms = Object(_ops__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"])(filteredBoxes, filteredScores, 0.7);
                        stats.stage2_nms = Date.now() - ts;
                        regions_1 = indicesNms.map(function (idx) {
                            var regionsData = rnetOuts[indices[idx]].regions.arraySync();
                            return new _MtcnnBox__WEBPACK_IMPORTED_MODULE_4__["MtcnnBox"](regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
                        });
                        finalScores = indicesNms.map(function (idx) { return filteredScores[idx]; });
                        finalBoxes = indicesNms.map(function (idx, i) { return filteredBoxes[idx].calibrate(regions_1[i]); });
                    }
                    rnetOuts.forEach(function (t) {
                        t.regions.dispose();
                        t.scores.dispose();
                    });
                    return [2 /*return*/, {
                            boxes: finalBoxes,
                            scores: finalScores
                        }];
            }
        });
    });
}
//# sourceMappingURL=stage2.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/stage3.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/stage3.js ***!
  \************************************************************/
/*! exports provided: stage3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stage3", function() { return stage3; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _extractImagePatches__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractImagePatches */ "./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js");
/* harmony import */ var _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MtcnnBox */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js");
/* harmony import */ var _ONet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ONet */ "./node_modules/face-api.js/build/es6/mtcnn/ONet.js");







function stage3(img, inputBoxes, scoreThreshold, params, stats) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var ts, onetInputs, onetOuts, scoresTensor, scores, _a, _b, indices, filteredRegions, filteredBoxes, filteredScores, finalBoxes, finalScores, points, indicesNms;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
            switch (_c.label) {
                case 0:
                    ts = Date.now();
                    return [4 /*yield*/, Object(_extractImagePatches__WEBPACK_IMPORTED_MODULE_4__["extractImagePatches"])(img, inputBoxes, { width: 48, height: 48 })];
                case 1:
                    onetInputs = _c.sent();
                    stats.stage3_extractImagePatches = Date.now() - ts;
                    ts = Date.now();
                    onetOuts = onetInputs.map(function (onetInput) {
                        var out = Object(_ONet__WEBPACK_IMPORTED_MODULE_6__["ONet"])(onetInput, params);
                        onetInput.dispose();
                        return out;
                    });
                    stats.stage3_onet = Date.now() - ts;
                    scoresTensor = onetOuts.length > 1
                        ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"](onetOuts.map(function (out) { return out.scores; }))
                        : onetOuts[0].scores;
                    _b = (_a = Array).from;
                    return [4 /*yield*/, scoresTensor.data()];
                case 2:
                    scores = _b.apply(_a, [_c.sent()]);
                    scoresTensor.dispose();
                    indices = scores
                        .map(function (score, idx) { return ({ score: score, idx: idx }); })
                        .filter(function (c) { return c.score > scoreThreshold; })
                        .map(function (_a) {
                        var idx = _a.idx;
                        return idx;
                    });
                    filteredRegions = indices.map(function (idx) {
                        var regionsData = onetOuts[idx].regions.arraySync();
                        return new _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__["MtcnnBox"](regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
                    });
                    filteredBoxes = indices
                        .map(function (idx, i) { return inputBoxes[idx].calibrate(filteredRegions[i]); });
                    filteredScores = indices.map(function (idx) { return scores[idx]; });
                    finalBoxes = [];
                    finalScores = [];
                    points = [];
                    if (filteredBoxes.length > 0) {
                        ts = Date.now();
                        indicesNms = Object(_ops__WEBPACK_IMPORTED_MODULE_3__["nonMaxSuppression"])(filteredBoxes, filteredScores, 0.7, false);
                        stats.stage3_nms = Date.now() - ts;
                        finalBoxes = indicesNms.map(function (idx) { return filteredBoxes[idx]; });
                        finalScores = indicesNms.map(function (idx) { return filteredScores[idx]; });
                        points = indicesNms.map(function (idx, i) {
                            return Array(5).fill(0).map(function (_, ptIdx) {
                                var pointsData = onetOuts[idx].points.arraySync();
                                return new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](((pointsData[0][ptIdx] * (finalBoxes[i].width + 1)) + finalBoxes[i].left), ((pointsData[0][ptIdx + 5] * (finalBoxes[i].height + 1)) + finalBoxes[i].top));
                            });
                        });
                    }
                    onetOuts.forEach(function (t) {
                        t.regions.dispose();
                        t.scores.dispose();
                        t.points.dispose();
                    });
                    return [2 /*return*/, {
                            boxes: finalBoxes,
                            scores: finalScores,
                            points: points
                        }];
            }
        });
    });
}
//# sourceMappingURL=stage3.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/index.js ***!
  \*********************************************************/
/*! exports provided: iou, minBbox, nonMaxSuppression, normalize, padToSquare, shuffleArray, sigmoid, inverseSigmoid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return sigmoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverseSigmoid", function() { return inverseSigmoid; });
/* harmony import */ var _iou__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iou */ "./node_modules/face-api.js/build/es6/ops/iou.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iou", function() { return _iou__WEBPACK_IMPORTED_MODULE_0__["iou"]; });

/* harmony import */ var _minBbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./minBbox */ "./node_modules/face-api.js/build/es6/ops/minBbox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minBbox", function() { return _minBbox__WEBPACK_IMPORTED_MODULE_1__["minBbox"]; });

/* harmony import */ var _nonMaxSuppression__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonMaxSuppression */ "./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return _nonMaxSuppression__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"]; });

/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./normalize */ "./node_modules/face-api.js/build/es6/ops/normalize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return _normalize__WEBPACK_IMPORTED_MODULE_3__["normalize"]; });

/* harmony import */ var _padToSquare__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./padToSquare */ "./node_modules/face-api.js/build/es6/ops/padToSquare.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padToSquare", function() { return _padToSquare__WEBPACK_IMPORTED_MODULE_4__["padToSquare"]; });

/* harmony import */ var _shuffleArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shuffleArray */ "./node_modules/face-api.js/build/es6/ops/shuffleArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffleArray", function() { return _shuffleArray__WEBPACK_IMPORTED_MODULE_5__["shuffleArray"]; });







function sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
}
function inverseSigmoid(x) {
    return Math.log(x / (1 - x));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/iou.js":
/*!*******************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/iou.js ***!
  \*******************************************************/
/*! exports provided: iou */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iou", function() { return iou; });
function iou(box1, box2, isIOU) {
    if (isIOU === void 0) { isIOU = true; }
    var width = Math.max(0.0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));
    var height = Math.max(0.0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));
    var interSection = width * height;
    return isIOU
        ? interSection / (box1.area + box2.area - interSection)
        : interSection / Math.min(box1.area, box2.area);
}
//# sourceMappingURL=iou.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/minBbox.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/minBbox.js ***!
  \***********************************************************/
/*! exports provided: minBbox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minBbox", function() { return minBbox; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");

function minBbox(pts) {
    var xs = pts.map(function (pt) { return pt.x; });
    var ys = pts.map(function (pt) { return pt.y; });
    var minX = xs.reduce(function (min, x) { return x < min ? x : min; }, Infinity);
    var minY = ys.reduce(function (min, y) { return y < min ? y : min; }, Infinity);
    var maxX = xs.reduce(function (max, x) { return max < x ? x : max; }, 0);
    var maxY = ys.reduce(function (max, y) { return max < y ? y : max; }, 0);
    return new _classes__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"](minX, minY, maxX, maxY);
}
//# sourceMappingURL=minBbox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js ***!
  \*********************************************************************/
/*! exports provided: nonMaxSuppression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return nonMaxSuppression; });
/* harmony import */ var _iou__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iou */ "./node_modules/face-api.js/build/es6/ops/iou.js");

function nonMaxSuppression(boxes, scores, iouThreshold, isIOU) {
    if (isIOU === void 0) { isIOU = true; }
    var indicesSortedByScore = scores
        .map(function (score, boxIndex) { return ({ score: score, boxIndex: boxIndex }); })
        .sort(function (c1, c2) { return c1.score - c2.score; })
        .map(function (c) { return c.boxIndex; });
    var pick = [];
    var _loop_1 = function () {
        var curr = indicesSortedByScore.pop();
        pick.push(curr);
        var indices = indicesSortedByScore;
        var outputs = [];
        for (var i = 0; i < indices.length; i++) {
            var idx = indices[i];
            var currBox = boxes[curr];
            var idxBox = boxes[idx];
            outputs.push(Object(_iou__WEBPACK_IMPORTED_MODULE_0__["iou"])(currBox, idxBox, isIOU));
        }
        indicesSortedByScore = indicesSortedByScore.filter(function (_, j) { return outputs[j] <= iouThreshold; });
    };
    while (indicesSortedByScore.length > 0) {
        _loop_1();
    }
    return pick;
}
//# sourceMappingURL=nonMaxSuppression.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/normalize.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/normalize.js ***!
  \*************************************************************/
/*! exports provided: normalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");


function normalize(x, meanRgb) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
        var r = meanRgb[0], g = meanRgb[1], b = meanRgb[2];
        var avg_r = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(x.shape.slice(0, 3), [1]), r);
        var avg_g = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(x.shape.slice(0, 3), [1]), g);
        var avg_b = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(x.shape.slice(0, 3), [1]), b);
        var avg_rgb = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([avg_r, avg_g, avg_b], 3);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["sub"](x, avg_rgb);
    });
}
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/padToSquare.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/padToSquare.js ***!
  \***************************************************************/
/*! exports provided: padToSquare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padToSquare", function() { return padToSquare; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

/**
 * Pads the smaller dimension of an image tensor with zeros, such that width === height.
 *
 * @param imgTensor The image tensor.
 * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
 * both sides of the minor dimension oof the image.
 * @returns The padded tensor with width === height.
 */
function padToSquare(imgTensor, isCenterImage) {
    if (isCenterImage === void 0) { isCenterImage = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];
        if (height === width) {
            return imgTensor;
        }
        var dimDiff = Math.abs(height - width);
        var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));
        var paddingAxis = height > width ? 2 : 1;
        var createPaddingTensor = function (paddingAmount) {
            var paddingTensorShape = imgTensor.shape.slice();
            paddingTensorShape[paddingAxis] = paddingAmount;
            return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"](paddingTensorShape, 0);
        };
        var paddingTensorAppend = createPaddingTensor(paddingAmount);
        var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];
        var paddingTensorPrepend = isCenterImage && remainingPaddingAmount
            ? createPaddingTensor(remainingPaddingAmount)
            : null;
        var tensorsToStack = [
            paddingTensorPrepend,
            imgTensor,
            paddingTensorAppend
        ]
            .filter(function (t) { return !!t; })
            .map(function (t) { return t.toFloat(); });
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"](tensorsToStack, paddingAxis);
    });
}
//# sourceMappingURL=padToSquare.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/shuffleArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/shuffleArray.js ***!
  \****************************************************************/
/*! exports provided: shuffleArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffleArray", function() { return shuffleArray; });
function shuffleArray(inputArray) {
    var array = inputArray.slice();
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var x = array[i];
        array[i] = array[j];
        array[j] = x;
    }
    return array;
}
//# sourceMappingURL=shuffleArray.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/resizeResults.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/resizeResults.js ***!
  \*************************************************************/
/*! exports provided: resizeResults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeResults", function() { return resizeResults; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");





function resizeResults(results, dimensions) {
    var _a = new _classes__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](dimensions.width, dimensions.height), width = _a.width, height = _a.height;
    if (width <= 0 || height <= 0) {
        throw new Error("resizeResults - invalid dimensions: " + JSON.stringify({ width: width, height: height }));
    }
    if (Array.isArray(results)) {
        return results.map(function (obj) { return resizeResults(obj, { width: width, height: height }); });
    }
    if (Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["isWithFaceLandmarks"])(results)) {
        var resizedDetection = results.detection.forSize(width, height);
        var resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height);
        return Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["extendWithFaceLandmarks"])(Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceDetection"])(results, resizedDetection), resizedLandmarks);
    }
    if (Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__["isWithFaceDetection"])(results)) {
        return Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceDetection"])(results, results.detection.forSize(width, height));
    }
    if (results instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__["FaceLandmarks"] || results instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]) {
        return results.forSize(width, height);
    }
    return results;
}
//# sourceMappingURL=resizeResults.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js ***!
  \*****************************************************************************/
/*! exports provided: SsdMobilenetv1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1", function() { return SsdMobilenetv1; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js");
/* harmony import */ var _mobileNetV1__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mobileNetV1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js");
/* harmony import */ var _nonMaxSuppression__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./nonMaxSuppression */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js");
/* harmony import */ var _outputLayer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./outputLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js");
/* harmony import */ var _predictionLayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./predictionLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js");
/* harmony import */ var _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");













var SsdMobilenetv1 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(SsdMobilenetv1, _super);
    function SsdMobilenetv1() {
        return _super.call(this, 'SsdMobilenetv1') || this;
    }
    SsdMobilenetv1.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('SsdMobilenetv1 - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(512, false).toFloat();
            var x = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["sub"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["mul"](batchTensor, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](0.007843137718737125)), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](1));
            var features = Object(_mobileNetV1__WEBPACK_IMPORTED_MODULE_8__["mobileNetV1"])(x, params.mobilenetv1);
            var _a = Object(_predictionLayer__WEBPACK_IMPORTED_MODULE_11__["predictionLayer"])(features.out, features.conv11, params.prediction_layer), boxPredictions = _a.boxPredictions, classPredictions = _a.classPredictions;
            return Object(_outputLayer__WEBPACK_IMPORTED_MODULE_10__["outputLayer"])(boxPredictions, classPredictions, params.output_layer);
        });
    };
    SsdMobilenetv1.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    SsdMobilenetv1.prototype.locateFaces = function (input, options) {
        if (options === void 0) { options = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _a = new _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_12__["SsdMobilenetv1Options"](options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1:
                        netInput = _e.sent();
                        _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;
                        boxes = _boxes[0];
                        scores = _scores[0];
                        for (i = 1; i < _boxes.length; i++) {
                            _boxes[i].dispose();
                            _scores[i].dispose();
                        }
                        _d = (_c = Array).from;
                        return [4 /*yield*/, scores.data()];
                    case 2:
                        scoresData = _d.apply(_c, [_e.sent()]);
                        iouThreshold = 0.5;
                        indices = Object(_nonMaxSuppression__WEBPACK_IMPORTED_MODULE_9__["nonMaxSuppression"])(boxes, scoresData, maxResults, iouThreshold, minConfidence);
                        reshapedDims = netInput.getReshapedInputDimensions(0);
                        inputSize = netInput.inputSize;
                        padX = inputSize / reshapedDims.width;
                        padY = inputSize / reshapedDims.height;
                        boxesData = boxes.arraySync();
                        results = indices
                            .map(function (idx) {
                            var _a = [
                                Math.max(0, boxesData[idx][0]),
                                Math.min(1.0, boxesData[idx][2])
                            ].map(function (val) { return val * padY; }), top = _a[0], bottom = _a[1];
                            var _b = [
                                Math.max(0, boxesData[idx][1]),
                                Math.min(1.0, boxesData[idx][3])
                            ].map(function (val) { return val * padX; }), left = _b[0], right = _b[1];
                            return new _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__["FaceDetection"](scoresData[idx], new _classes__WEBPACK_IMPORTED_MODULE_2__["Rect"](left, top, right - left, bottom - top), {
                                height: netInput.getInputHeight(0),
                                width: netInput.getInputWidth(0)
                            });
                        });
                        boxes.dispose();
                        scores.dispose();
                        return [2 /*return*/, results];
                }
            });
        });
    };
    SsdMobilenetv1.prototype.getDefaultModelName = function () {
        return 'ssd_mobilenetv1_model';
    };
    SsdMobilenetv1.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__["extractParamsFromWeigthMap"])(weightMap);
    };
    SsdMobilenetv1.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_6__["extractParams"])(weights);
    };
    return SsdMobilenetv1;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_5__["NeuralNetwork"]));

//# sourceMappingURL=SsdMobilenetv1.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js":
/*!************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js ***!
  \************************************************************************************/
/*! exports provided: SsdMobilenetv1Options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1Options", function() { return SsdMobilenetv1Options; });
var SsdMobilenetv1Options = /** @class */ (function () {
    function SsdMobilenetv1Options(_a) {
        var _b = _a === void 0 ? {} : _a, minConfidence = _b.minConfidence, maxResults = _b.maxResults;
        this._name = 'SsdMobilenetv1Options';
        this._minConfidence = minConfidence || 0.5;
        this._maxResults = maxResults || 100;
        if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) {
            throw new Error(this._name + " - expected minConfidence to be a number between 0 and 1");
        }
        if (typeof this._maxResults !== 'number') {
            throw new Error(this._name + " - expected maxResults to be a number");
        }
    }
    Object.defineProperty(SsdMobilenetv1Options.prototype, "minConfidence", {
        get: function () { return this._minConfidence; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SsdMobilenetv1Options.prototype, "maxResults", {
        get: function () { return this._maxResults; },
        enumerable: true,
        configurable: true
    });
    return SsdMobilenetv1Options;
}());

//# sourceMappingURL=SsdMobilenetv1Options.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js ***!
  \*********************************************************************************/
/*! exports provided: boxPredictionLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boxPredictionLayer", function() { return boxPredictionLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");


function boxPredictionLayer(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var batchSize = x.shape[0];
        var boxPredictionEncoding = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(x, params.box_encoding_predictor), [batchSize, -1, 1, 4]);
        var classPrediction = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(x, params.class_predictor), [batchSize, -1, 3]);
        return {
            boxPredictionEncoding: boxPredictionEncoding,
            classPrediction: classPrediction
        };
    });
}
//# sourceMappingURL=boxPredictionLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js ***!
  \****************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");


function extractorsFactory(extractWeights, paramMappings) {
    function extractDepthwiseConvParams(numChannels, mappedPrefix) {
        var filters = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1]);
        var batch_norm_scale = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        var batch_norm_offset = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        var batch_norm_mean = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        var batch_norm_variance = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/batch_norm_scale" }, { paramPath: mappedPrefix + "/batch_norm_offset" }, { paramPath: mappedPrefix + "/batch_norm_mean" }, { paramPath: mappedPrefix + "/batch_norm_variance" });
        return {
            filters: filters,
            batch_norm_scale: batch_norm_scale,
            batch_norm_offset: batch_norm_offset,
            batch_norm_mean: batch_norm_mean,
            batch_norm_variance: batch_norm_variance
        };
    }
    function extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, isPointwiseConv) {
        var filters = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/" + (isPointwiseConv ? 'batch_norm_offset' : 'bias') });
        return { filters: filters, bias: bias };
    }
    function extractPointwiseConvParams(channelsIn, channelsOut, filterSize, mappedPrefix) {
        var _a = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true), filters = _a.filters, bias = _a.bias;
        return {
            filters: filters,
            batch_norm_offset: bias
        };
    }
    function extractConvPairParams(channelsIn, channelsOut, mappedPrefix) {
        var depthwise_conv = extractDepthwiseConvParams(channelsIn, mappedPrefix + "/depthwise_conv");
        var pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/pointwise_conv");
        return { depthwise_conv: depthwise_conv, pointwise_conv: pointwise_conv };
    }
    function extractMobilenetV1Params() {
        var conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0');
        var conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1');
        var conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2');
        var conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3');
        var conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4');
        var conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5');
        var conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6');
        var conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7');
        var conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8');
        var conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9');
        var conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10');
        var conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11');
        var conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12');
        var conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13');
        return {
            conv_0: conv_0,
            conv_1: conv_1,
            conv_2: conv_2,
            conv_3: conv_3,
            conv_4: conv_4,
            conv_5: conv_5,
            conv_6: conv_6,
            conv_7: conv_7,
            conv_8: conv_8,
            conv_9: conv_9,
            conv_10: conv_10,
            conv_11: conv_11,
            conv_12: conv_12,
            conv_13: conv_13
        };
    }
    function extractPredictionLayerParams() {
        var conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0');
        var conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1');
        var conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2');
        var conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3');
        var conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4');
        var conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5');
        var conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6');
        var conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7');
        var box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor');
        var class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor');
        var box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor');
        var class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor');
        var box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor');
        var class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor');
        var box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor');
        var class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor');
        var box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor');
        var class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor');
        var box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor');
        var class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor');
        var box_predictor_0 = {
            box_encoding_predictor: box_encoding_0_predictor,
            class_predictor: class_predictor_0
        };
        var box_predictor_1 = {
            box_encoding_predictor: box_encoding_1_predictor,
            class_predictor: class_predictor_1
        };
        var box_predictor_2 = {
            box_encoding_predictor: box_encoding_2_predictor,
            class_predictor: class_predictor_2
        };
        var box_predictor_3 = {
            box_encoding_predictor: box_encoding_3_predictor,
            class_predictor: class_predictor_3
        };
        var box_predictor_4 = {
            box_encoding_predictor: box_encoding_4_predictor,
            class_predictor: class_predictor_4
        };
        var box_predictor_5 = {
            box_encoding_predictor: box_encoding_5_predictor,
            class_predictor: class_predictor_5
        };
        return {
            conv_0: conv_0,
            conv_1: conv_1,
            conv_2: conv_2,
            conv_3: conv_3,
            conv_4: conv_4,
            conv_5: conv_5,
            conv_6: conv_6,
            conv_7: conv_7,
            box_predictor_0: box_predictor_0,
            box_predictor_1: box_predictor_1,
            box_predictor_2: box_predictor_2,
            box_predictor_3: box_predictor_3,
            box_predictor_4: box_predictor_4,
            box_predictor_5: box_predictor_5
        };
    }
    return {
        extractMobilenetV1Params: extractMobilenetV1Params,
        extractPredictionLayerParams: extractPredictionLayerParams
    };
}
function extractParams(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var _b = extractorsFactory(extractWeights, paramMappings), extractMobilenetV1Params = _b.extractMobilenetV1Params, extractPredictionLayerParams = _b.extractPredictionLayerParams;
    var mobilenetv1 = extractMobilenetV1Params();
    var prediction_layer = extractPredictionLayerParams();
    var extra_dim = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor3d"](extractWeights(5118 * 4), [1, 5118, 4]);
    var output_layer = {
        extra_dim: extra_dim
    };
    paramMappings.push({ paramPath: 'output_layer/extra_dim' });
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        params: {
            mobilenetv1: mobilenetv1,
            prediction_layer: prediction_layer,
            output_layer: output_layer
        },
        paramMappings: paramMappings
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js ***!
  \*****************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractPointwiseConvParams(prefix, idx, mappedPrefix) {
        var filters = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/weights", 4, mappedPrefix + "/filters");
        var batch_norm_offset = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/convolution_bn_offset", 1, mappedPrefix + "/batch_norm_offset");
        return { filters: filters, batch_norm_offset: batch_norm_offset };
    }
    function extractConvPairParams(idx) {
        var mappedPrefix = "mobilenetv1/conv_" + idx;
        var prefixDepthwiseConv = "MobilenetV1/Conv2d_" + idx + "_depthwise";
        var mappedPrefixDepthwiseConv = mappedPrefix + "/depthwise_conv";
        var mappedPrefixPointwiseConv = mappedPrefix + "/pointwise_conv";
        var filters = extractWeightEntry(prefixDepthwiseConv + "/depthwise_weights", 4, mappedPrefixDepthwiseConv + "/filters");
        var batch_norm_scale = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/gamma", 1, mappedPrefixDepthwiseConv + "/batch_norm_scale");
        var batch_norm_offset = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/beta", 1, mappedPrefixDepthwiseConv + "/batch_norm_offset");
        var batch_norm_mean = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_mean", 1, mappedPrefixDepthwiseConv + "/batch_norm_mean");
        var batch_norm_variance = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_variance", 1, mappedPrefixDepthwiseConv + "/batch_norm_variance");
        return {
            depthwise_conv: {
                filters: filters,
                batch_norm_scale: batch_norm_scale,
                batch_norm_offset: batch_norm_offset,
                batch_norm_mean: batch_norm_mean,
                batch_norm_variance: batch_norm_variance
            },
            pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv)
        };
    }
    function extractMobilenetV1Params() {
        return {
            conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),
            conv_1: extractConvPairParams(1),
            conv_2: extractConvPairParams(2),
            conv_3: extractConvPairParams(3),
            conv_4: extractConvPairParams(4),
            conv_5: extractConvPairParams(5),
            conv_6: extractConvPairParams(6),
            conv_7: extractConvPairParams(7),
            conv_8: extractConvPairParams(8),
            conv_9: extractConvPairParams(9),
            conv_10: extractConvPairParams(10),
            conv_11: extractConvPairParams(11),
            conv_12: extractConvPairParams(12),
            conv_13: extractConvPairParams(13)
        };
    }
    function extractConvParams(prefix, mappedPrefix) {
        var filters = extractWeightEntry(prefix + "/weights", 4, mappedPrefix + "/filters");
        var bias = extractWeightEntry(prefix + "/biases", 1, mappedPrefix + "/bias");
        return { filters: filters, bias: bias };
    }
    function extractBoxPredictorParams(idx) {
        var box_encoding_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/BoxEncodingPredictor", "prediction_layer/box_predictor_" + idx + "/box_encoding_predictor");
        var class_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/ClassPredictor", "prediction_layer/box_predictor_" + idx + "/class_predictor");
        return { box_encoding_predictor: box_encoding_predictor, class_predictor: class_predictor };
    }
    function extractPredictionLayerParams() {
        return {
            conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),
            conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),
            conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),
            conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),
            conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),
            conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),
            conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),
            conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),
            box_predictor_0: extractBoxPredictorParams(0),
            box_predictor_1: extractBoxPredictorParams(1),
            box_predictor_2: extractBoxPredictorParams(2),
            box_predictor_3: extractBoxPredictorParams(3),
            box_predictor_4: extractBoxPredictorParams(4),
            box_predictor_5: extractBoxPredictorParams(5)
        };
    }
    return {
        extractMobilenetV1Params: extractMobilenetV1Params,
        extractPredictionLayerParams: extractPredictionLayerParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractMobilenetV1Params = _a.extractMobilenetV1Params, extractPredictionLayerParams = _a.extractPredictionLayerParams;
    var extra_dim = weightMap['Output/extra_dim'];
    paramMappings.push({ originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim' });
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor3D"])(extra_dim)) {
        throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " + extra_dim);
    }
    var params = {
        mobilenetv1: extractMobilenetV1Params(),
        prediction_layer: extractPredictionLayerParams(),
        output_layer: {
            extra_dim: extra_dim
        }
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js ***!
  \********************************************************************/
/*! exports provided: SsdMobilenetv1, SsdMobilenetv1Options, createSsdMobilenetv1, createFaceDetectionNet, FaceDetectionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSsdMobilenetv1", function() { return createSsdMobilenetv1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFaceDetectionNet", function() { return createFaceDetectionNet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceDetectionNet", function() { return FaceDetectionNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SsdMobilenetv1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1", function() { return _SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__["SsdMobilenetv1"]; });

/* harmony import */ var _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1Options", function() { return _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_2__["SsdMobilenetv1Options"]; });





function createSsdMobilenetv1(weights) {
    var net = new _SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__["SsdMobilenetv1"]();
    net.extractWeights(weights);
    return net;
}
function createFaceDetectionNet(weights) {
    return createSsdMobilenetv1(weights);
}
// alias for backward compatibily
var FaceDetectionNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceDetectionNet, _super);
    function FaceDetectionNet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FaceDetectionNet;
}(_SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__["SsdMobilenetv1"]));

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js ***!
  \**************************************************************************/
/*! exports provided: mobileNetV1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mobileNetV1", function() { return mobileNetV1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pointwiseConvLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js");


var epsilon = 0.0010000000474974513;
function depthwiseConvLayer(x, params, strides) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"](x, params.filters, strides, 'same');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"](out, params.batch_norm_mean, params.batch_norm_variance, params.batch_norm_offset, params.batch_norm_scale, epsilon);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"](out, 0, 6);
    });
}
function getStridesForLayerIdx(layerIdx) {
    return [2, 4, 6, 12].some(function (idx) { return idx === layerIdx; }) ? [2, 2] : [1, 1];
}
function mobileNetV1(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var conv11 = null;
        var out = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_1__["pointwiseConvLayer"])(x, params.conv_0, [2, 2]);
        var convPairParams = [
            params.conv_1,
            params.conv_2,
            params.conv_3,
            params.conv_4,
            params.conv_5,
            params.conv_6,
            params.conv_7,
            params.conv_8,
            params.conv_9,
            params.conv_10,
            params.conv_11,
            params.conv_12,
            params.conv_13
        ];
        convPairParams.forEach(function (param, i) {
            var layerIdx = i + 1;
            var depthwiseConvStrides = getStridesForLayerIdx(layerIdx);
            out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);
            out = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_1__["pointwiseConvLayer"])(out, param.pointwise_conv, [1, 1]);
            if (layerIdx === 11) {
                conv11 = out;
            }
        });
        if (conv11 === null) {
            throw new Error('mobileNetV1 - output of conv layer 11 is null');
        }
        return {
            out: out,
            conv11: conv11
        };
    });
}
//# sourceMappingURL=mobileNetV1.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js ***!
  \********************************************************************************/
/*! exports provided: nonMaxSuppression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return nonMaxSuppression; });
function nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    var numBoxes = boxes.shape[0];
    var outputSize = Math.min(maxOutputSize, numBoxes);
    var candidates = scores
        .map(function (score, boxIndex) { return ({ score: score, boxIndex: boxIndex }); })
        .filter(function (c) { return c.score > scoreThreshold; })
        .sort(function (c1, c2) { return c2.score - c1.score; });
    var suppressFunc = function (x) { return x <= iouThreshold ? 1 : 0; };
    var selected = [];
    candidates.forEach(function (c) {
        if (selected.length >= outputSize) {
            return;
        }
        var originalScore = c.score;
        for (var j = selected.length - 1; j >= 0; --j) {
            var iou = IOU(boxes, c.boxIndex, selected[j]);
            if (iou === 0.0) {
                continue;
            }
            c.score *= suppressFunc(iou);
            if (c.score <= scoreThreshold) {
                break;
            }
        }
        if (originalScore === c.score) {
            selected.push(c.boxIndex);
        }
    });
    return selected;
}
function IOU(boxes, i, j) {
    var boxesData = boxes.arraySync();
    var yminI = Math.min(boxesData[i][0], boxesData[i][2]);
    var xminI = Math.min(boxesData[i][1], boxesData[i][3]);
    var ymaxI = Math.max(boxesData[i][0], boxesData[i][2]);
    var xmaxI = Math.max(boxesData[i][1], boxesData[i][3]);
    var yminJ = Math.min(boxesData[j][0], boxesData[j][2]);
    var xminJ = Math.min(boxesData[j][1], boxesData[j][3]);
    var ymaxJ = Math.max(boxesData[j][0], boxesData[j][2]);
    var xmaxJ = Math.max(boxesData[j][1], boxesData[j][3]);
    var areaI = (ymaxI - yminI) * (xmaxI - xminI);
    var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) {
        return 0.0;
    }
    var intersectionYmin = Math.max(yminI, yminJ);
    var intersectionXmin = Math.max(xminI, xminJ);
    var intersectionYmax = Math.min(ymaxI, ymaxJ);
    var intersectionXmax = Math.min(xmaxI, xmaxJ);
    var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *
        Math.max(intersectionXmax - intersectionXmin, 0.0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
}
//# sourceMappingURL=nonMaxSuppression.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js ***!
  \**************************************************************************/
/*! exports provided: outputLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outputLayer", function() { return outputLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function getCenterCoordinatesAndSizesLayer(x) {
    var vec = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](x, [1, 0]));
    var sizes = [
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](vec[2], vec[0]),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](vec[3], vec[1])
    ];
    var centers = [
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](vec[0], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](sizes[0], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2))),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](vec[1], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](sizes[1], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2)))
    ];
    return {
        sizes: sizes,
        centers: centers
    };
}
function decodeBoxesLayer(x0, x1) {
    var _a = getCenterCoordinatesAndSizesLayer(x0), sizes = _a.sizes, centers = _a.centers;
    var vec = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](x1, [1, 0]));
    var div0_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[2], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](5))), sizes[0]), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2));
    var add0_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[0], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](10)), sizes[0]), centers[0]);
    var div1_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[3], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](5))), sizes[1]), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2));
    var add1_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[1], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](10)), sizes[1]), centers[1]);
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"]([
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](add0_out, div0_out),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](add1_out, div1_out),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](add0_out, div0_out),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](add1_out, div1_out)
    ]), [1, 0]);
}
function outputLayer(boxPredictions, classPredictions, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var batchSize = boxPredictions.shape[0];
        var boxes = decodeBoxesLayer(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"](params.extra_dim, [batchSize, 1, 1]), [-1, 4]), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](boxPredictions, [-1, 4]));
        boxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](boxes, [batchSize, (boxes.shape[0] / batchSize), 4]);
        var scoresAndClasses = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"](classPredictions, [0, 0, 1], [-1, -1, -1]));
        var scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"](scoresAndClasses, [0, 0, 0], [-1, -1, 1]);
        scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](scores, [batchSize, scores.shape[1]]);
        var boxesByBatch = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](boxes);
        var scoresByBatch = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](scores);
        return {
            boxes: boxesByBatch,
            scores: scoresByBatch
        };
    });
}
//# sourceMappingURL=outputLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js ***!
  \*********************************************************************************/
/*! exports provided: pointwiseConvLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointwiseConvLayer", function() { return pointwiseConvLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function pointwiseConvLayer(x, params, strides) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, params.filters, strides, 'same');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.batch_norm_offset);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"](out, 0, 6);
    });
}
//# sourceMappingURL=pointwiseConvLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js ***!
  \******************************************************************************/
/*! exports provided: predictionLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "predictionLayer", function() { return predictionLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boxPredictionLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js");
/* harmony import */ var _pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pointwiseConvLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js");



function predictionLayer(x, conv11, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var conv0 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(x, params.conv_0, [1, 1]);
        var conv1 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv0, params.conv_1, [2, 2]);
        var conv2 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv1, params.conv_2, [1, 1]);
        var conv3 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv2, params.conv_3, [2, 2]);
        var conv4 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv3, params.conv_4, [1, 1]);
        var conv5 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv4, params.conv_5, [2, 2]);
        var conv6 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv5, params.conv_6, [1, 1]);
        var conv7 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv6, params.conv_7, [2, 2]);
        var boxPrediction0 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv11, params.box_predictor_0);
        var boxPrediction1 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(x, params.box_predictor_1);
        var boxPrediction2 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv1, params.box_predictor_2);
        var boxPrediction3 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv3, params.box_predictor_3);
        var boxPrediction4 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv5, params.box_predictor_4);
        var boxPrediction5 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv7, params.box_predictor_5);
        var boxPredictions = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]([
            boxPrediction0.boxPredictionEncoding,
            boxPrediction1.boxPredictionEncoding,
            boxPrediction2.boxPredictionEncoding,
            boxPrediction3.boxPredictionEncoding,
            boxPrediction4.boxPredictionEncoding,
            boxPrediction5.boxPredictionEncoding
        ], 1);
        var classPredictions = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]([
            boxPrediction0.classPrediction,
            boxPrediction1.classPrediction,
            boxPrediction2.classPrediction,
            boxPrediction3.classPrediction,
            boxPrediction4.classPrediction,
            boxPrediction5.classPrediction
        ], 1);
        return {
            boxPredictions: boxPredictions,
            classPredictions: classPredictions
        };
    });
}
//# sourceMappingURL=predictionLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js ***!
  \*********************************************************************************/
/*! exports provided: TinyFaceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetector", function() { return TinyFaceDetector; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _tinyYolov2_TinyYolov2Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tinyYolov2/TinyYolov2Base */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js");
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./const */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/const.js");




var TinyFaceDetector = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyFaceDetector, _super);
    function TinyFaceDetector() {
        var _this = this;
        var config = {
            withSeparableConvs: true,
            iouThreshold: _const__WEBPACK_IMPORTED_MODULE_3__["IOU_THRESHOLD"],
            classes: ['face'],
            anchors: _const__WEBPACK_IMPORTED_MODULE_3__["BOX_ANCHORS"],
            meanRgb: _const__WEBPACK_IMPORTED_MODULE_3__["MEAN_RGB"],
            isFirstLayerConv2d: true,
            filterSizes: [3, 16, 32, 64, 128, 256, 512]
        };
        _this = _super.call(this, config) || this;
        return _this;
    }
    Object.defineProperty(TinyFaceDetector.prototype, "anchors", {
        get: function () {
            return this.config.anchors;
        },
        enumerable: true,
        configurable: true
    });
    TinyFaceDetector.prototype.locateFaces = function (input, forwardParams) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var objectDetections;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.detect(input, forwardParams)];
                    case 1:
                        objectDetections = _a.sent();
                        return [2 /*return*/, objectDetections.map(function (det) { return new _classes__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"](det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }); })];
                }
            });
        });
    };
    TinyFaceDetector.prototype.getDefaultModelName = function () {
        return 'tiny_face_detector_model';
    };
    TinyFaceDetector.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
    };
    return TinyFaceDetector;
}(_tinyYolov2_TinyYolov2Base__WEBPACK_IMPORTED_MODULE_2__["TinyYolov2Base"]));

//# sourceMappingURL=TinyFaceDetector.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js ***!
  \****************************************************************************************/
/*! exports provided: TinyFaceDetectorOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetectorOptions", function() { return TinyFaceDetectorOptions; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");


var TinyFaceDetectorOptions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyFaceDetectorOptions, _super);
    function TinyFaceDetectorOptions() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._name = 'TinyFaceDetectorOptions';
        return _this;
    }
    return TinyFaceDetectorOptions;
}(_tinyYolov2__WEBPACK_IMPORTED_MODULE_1__["TinyYolov2Options"]));

//# sourceMappingURL=TinyFaceDetectorOptions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/const.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/const.js ***!
  \**********************************************************************/
/*! exports provided: IOU_THRESHOLD, BOX_ANCHORS, MEAN_RGB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IOU_THRESHOLD", function() { return IOU_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOX_ANCHORS", function() { return BOX_ANCHORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEAN_RGB", function() { return MEAN_RGB; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");

var IOU_THRESHOLD = 0.4;
var BOX_ANCHORS = [
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](1.603231, 2.094468),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](6.041143, 7.080126),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](2.882459, 3.518061),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](4.266906, 5.178857),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](9.041765, 10.66308)
];
var MEAN_RGB = [117.001, 114.697, 97.404];
//# sourceMappingURL=const.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/index.js ***!
  \**********************************************************************/
/*! exports provided: TinyFaceDetector, TinyFaceDetectorOptions, createTinyFaceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTinyFaceDetector", function() { return createTinyFaceDetector; });
/* harmony import */ var _TinyFaceDetector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TinyFaceDetector */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetector", function() { return _TinyFaceDetector__WEBPACK_IMPORTED_MODULE_0__["TinyFaceDetector"]; });

/* harmony import */ var _TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TinyFaceDetectorOptions */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetectorOptions", function() { return _TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_1__["TinyFaceDetectorOptions"]; });




function createTinyFaceDetector(weights) {
    var net = new _TinyFaceDetector__WEBPACK_IMPORTED_MODULE_0__["TinyFaceDetector"]();
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js ***!
  \*********************************************************************/
/*! exports provided: TinyYolov2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2", function() { return TinyYolov2; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const */ "./node_modules/face-api.js/build/es6/tinyYolov2/const.js");
/* harmony import */ var _TinyYolov2Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TinyYolov2Base */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js");




var TinyYolov2 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyYolov2, _super);
    function TinyYolov2(withSeparableConvs) {
        if (withSeparableConvs === void 0) { withSeparableConvs = true; }
        var _this = this;
        var config = Object.assign({}, {
            withSeparableConvs: withSeparableConvs,
            iouThreshold: _const__WEBPACK_IMPORTED_MODULE_2__["IOU_THRESHOLD"],
            classes: ['face']
        }, withSeparableConvs
            ? {
                anchors: _const__WEBPACK_IMPORTED_MODULE_2__["BOX_ANCHORS_SEPARABLE"],
                meanRgb: _const__WEBPACK_IMPORTED_MODULE_2__["MEAN_RGB_SEPARABLE"]
            }
            : {
                anchors: _const__WEBPACK_IMPORTED_MODULE_2__["BOX_ANCHORS"],
                withClassScores: true
            });
        _this = _super.call(this, config) || this;
        return _this;
    }
    Object.defineProperty(TinyYolov2.prototype, "withSeparableConvs", {
        get: function () {
            return this.config.withSeparableConvs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2.prototype, "anchors", {
        get: function () {
            return this.config.anchors;
        },
        enumerable: true,
        configurable: true
    });
    TinyYolov2.prototype.locateFaces = function (input, forwardParams) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var objectDetections;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.detect(input, forwardParams)];
                    case 1:
                        objectDetections = _a.sent();
                        return [2 /*return*/, objectDetections.map(function (det) { return new _classes__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"](det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }); })];
                }
            });
        });
    };
    TinyYolov2.prototype.getDefaultModelName = function () {
        return this.withSeparableConvs ? _const__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_MODEL_NAME_SEPARABLE_CONV"] : _const__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_MODEL_NAME"];
    };
    TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
    };
    return TinyYolov2;
}(_TinyYolov2Base__WEBPACK_IMPORTED_MODULE_3__["TinyYolov2Base"]));

//# sourceMappingURL=TinyYolov2.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js":
/*!*************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js ***!
  \*************************************************************************/
/*! exports provided: TinyYolov2Base */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Base", function() { return TinyYolov2Base; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes_BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/BoundingBox */ "./node_modules/face-api.js/build/es6/classes/BoundingBox.js");
/* harmony import */ var _classes_ObjectDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/ObjectDetection */ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _ops_nonMaxSuppression__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ops/nonMaxSuppression */ "./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js");
/* harmony import */ var _ops_normalize__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../ops/normalize */ "./node_modules/face-api.js/build/es6/ops/normalize.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/tinyYolov2/config.js");
/* harmony import */ var _convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./convWithBatchNorm */ "./node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js");
/* harmony import */ var _depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./depthwiseSeparableConv */ "./node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js");
/* harmony import */ var _leaky__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./leaky */ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js");
/* harmony import */ var _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TinyYolov2Options */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js");

















var TinyYolov2Base = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyYolov2Base, _super);
    function TinyYolov2Base(config) {
        var _this = _super.call(this, 'TinyYolov2') || this;
        Object(_config__WEBPACK_IMPORTED_MODULE_10__["validateConfig"])(config);
        _this._config = config;
        return _this;
    }
    Object.defineProperty(TinyYolov2Base.prototype, "config", {
        get: function () {
            return this._config;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Base.prototype, "withClassScores", {
        get: function () {
            return this.config.withClassScores || this.config.classes.length > 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Base.prototype, "boxEncodingSize", {
        get: function () {
            return 5 + (this.withClassScores ? this.config.classes.length : 0);
        },
        enumerable: true,
        configurable: true
    });
    TinyYolov2Base.prototype.runTinyYolov2 = function (x, params) {
        var out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(x, params.conv0);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv1);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv2);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv3);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv4);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv5);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [1, 1], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv6);
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv7);
        return Object(_common__WEBPACK_IMPORTED_MODULE_4__["convLayer"])(out, params.conv8, 'valid', false);
    };
    TinyYolov2Base.prototype.runMobilenet = function (x, params) {
        var out = this.config.isFirstLayerConv2d
            ? Object(_leaky__WEBPACK_IMPORTED_MODULE_15__["leaky"])(Object(_common__WEBPACK_IMPORTED_MODULE_4__["convLayer"])(x, params.conv0, 'valid', false))
            : Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(x, params.conv0);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv1);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv2);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv3);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv4);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv5);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [1, 1], 'same');
        out = params.conv6 ? Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv6) : out;
        out = params.conv7 ? Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv7) : out;
        return Object(_common__WEBPACK_IMPORTED_MODULE_4__["convLayer"])(out, params.conv8, 'valid', false);
    };
    TinyYolov2Base.prototype.forwardInput = function (input, inputSize) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error('TinyYolov2 - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(inputSize, false).toFloat();
            batchTensor = _this.config.meanRgb
                ? Object(_ops_normalize__WEBPACK_IMPORTED_MODULE_9__["normalize"])(batchTensor, _this.config.meanRgb)
                : batchTensor;
            batchTensor = batchTensor.div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](256));
            return _this.config.withSeparableConvs
                ? _this.runMobilenet(batchTensor, params)
                : _this.runTinyYolov2(batchTensor, params);
        });
    };
    TinyYolov2Base.prototype.forward = function (input, inputSize) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(), inputSize])];
                    case 2: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    TinyYolov2Base.prototype.detect = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = new _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2Options"](forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1:
                        netInput = _b.sent();
                        return [4 /*yield*/, this.forwardInput(netInput, inputSize)];
                    case 2:
                        out = _b.sent();
                        out0 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out)[0].expandDims(); });
                        inputDimensions = {
                            width: netInput.getInputWidth(0),
                            height: netInput.getInputHeight(0)
                        };
                        return [4 /*yield*/, this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)];
                    case 3:
                        results = _b.sent();
                        out.dispose();
                        out0.dispose();
                        boxes = results.map(function (res) { return res.box; });
                        scores = results.map(function (res) { return res.score; });
                        classScores = results.map(function (res) { return res.classScore; });
                        classNames = results.map(function (res) { return _this.config.classes[res.label]; });
                        indices = Object(_ops_nonMaxSuppression__WEBPACK_IMPORTED_MODULE_8__["nonMaxSuppression"])(boxes.map(function (box) { return box.rescale(inputSize); }), scores, this.config.iouThreshold, true);
                        detections = indices.map(function (idx) {
                            return new _classes_ObjectDetection__WEBPACK_IMPORTED_MODULE_3__["ObjectDetection"](scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);
                        });
                        return [2 /*return*/, detections];
                }
            });
        });
    };
    TinyYolov2Base.prototype.getDefaultModelName = function () {
        return '';
    };
    TinyYolov2Base.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_14__["extractParamsFromWeigthMap"])(weightMap, this.config);
    };
    TinyYolov2Base.prototype.extractParams = function (weights) {
        var filterSizes = this.config.filterSizes || TinyYolov2Base.DEFAULT_FILTER_SIZES;
        var numFilters = filterSizes ? filterSizes.length : undefined;
        if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {
            throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found " + numFilters + " filterSizes in config");
        }
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_13__["extractParams"])(weights, this.config, this.boxEncodingSize, filterSizes);
    };
    TinyYolov2Base.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var width, height, inputSize, correctionFactorX, correctionFactorY, numCells, numBoxes, _a, boxesTensor, scoresTensor, classScoresTensor, results, scoresData, boxesData, row, col, anchor, score, ctX, ctY, width_1, height_1, x, y, pos, _b, classScore, label, _c;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        width = inputBlobDimensions.width, height = inputBlobDimensions.height;
                        inputSize = Math.max(width, height);
                        correctionFactorX = inputSize / width;
                        correctionFactorY = inputSize / height;
                        numCells = outputTensor.shape[1];
                        numBoxes = this.config.anchors.length;
                        _a = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                            var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);
                            var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);
                            var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);
                            var classScores = _this.withClassScores
                                ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["softmax"](reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3)
                                : _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](0);
                            return [boxes, scores, classScores];
                        }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];
                        results = [];
                        return [4 /*yield*/, scoresTensor.array()];
                    case 1:
                        scoresData = _d.sent();
                        return [4 /*yield*/, boxesTensor.array()];
                    case 2:
                        boxesData = _d.sent();
                        row = 0;
                        _d.label = 3;
                    case 3:
                        if (!(row < numCells)) return [3 /*break*/, 12];
                        col = 0;
                        _d.label = 4;
                    case 4:
                        if (!(col < numCells)) return [3 /*break*/, 11];
                        anchor = 0;
                        _d.label = 5;
                    case 5:
                        if (!(anchor < numBoxes)) return [3 /*break*/, 10];
                        score = Object(_ops__WEBPACK_IMPORTED_MODULE_7__["sigmoid"])(scoresData[row][col][anchor][0]);
                        if (!(!scoreThreshold || score > scoreThreshold)) return [3 /*break*/, 9];
                        ctX = ((col + Object(_ops__WEBPACK_IMPORTED_MODULE_7__["sigmoid"])(boxesData[row][col][anchor][0])) / numCells) * correctionFactorX;
                        ctY = ((row + Object(_ops__WEBPACK_IMPORTED_MODULE_7__["sigmoid"])(boxesData[row][col][anchor][1])) / numCells) * correctionFactorY;
                        width_1 = ((Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x) / numCells) * correctionFactorX;
                        height_1 = ((Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y) / numCells) * correctionFactorY;
                        x = (ctX - (width_1 / 2));
                        y = (ctY - (height_1 / 2));
                        pos = { row: row, col: col, anchor: anchor };
                        if (!this.withClassScores) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.extractPredictedClass(classScoresTensor, pos)];
                    case 6:
                        _c = _d.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        _c = { classScore: 1, label: 0 };
                        _d.label = 8;
                    case 8:
                        _b = _c, classScore = _b.classScore, label = _b.label;
                        results.push(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ box: new _classes_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["BoundingBox"](x, y, x + width_1, y + height_1), score: score, classScore: score * classScore, label: label }, pos));
                        _d.label = 9;
                    case 9:
                        anchor++;
                        return [3 /*break*/, 5];
                    case 10:
                        col++;
                        return [3 /*break*/, 4];
                    case 11:
                        row++;
                        return [3 /*break*/, 3];
                    case 12:
                        boxesTensor.dispose();
                        scoresTensor.dispose();
                        classScoresTensor.dispose();
                        return [2 /*return*/, results];
                }
            });
        });
    };
    TinyYolov2Base.prototype.extractPredictedClass = function (classesTensor, pos) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var row, col, anchor, classesData;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        row = pos.row, col = pos.col, anchor = pos.anchor;
                        return [4 /*yield*/, classesTensor.array()];
                    case 1:
                        classesData = _a.sent();
                        return [2 /*return*/, Array(this.config.classes.length).fill(0)
                                .map(function (_, i) { return classesData[row][col][anchor][i]; })
                                .map(function (classScore, label) { return ({
                                classScore: classScore,
                                label: label
                            }); })
                                .reduce(function (max, curr) { return max.classScore > curr.classScore ? max : curr; })];
                }
            });
        });
    };
    TinyYolov2Base.DEFAULT_FILTER_SIZES = [
        3, 16, 32, 64, 128, 256, 512, 1024, 1024
    ];
    return TinyYolov2Base;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_6__["NeuralNetwork"]));

//# sourceMappingURL=TinyYolov2Base.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js ***!
  \****************************************************************************/
/*! exports provided: TinyYolov2SizeType, TinyYolov2Options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2SizeType", function() { return TinyYolov2SizeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Options", function() { return TinyYolov2Options; });
var TinyYolov2SizeType;
(function (TinyYolov2SizeType) {
    TinyYolov2SizeType[TinyYolov2SizeType["XS"] = 224] = "XS";
    TinyYolov2SizeType[TinyYolov2SizeType["SM"] = 320] = "SM";
    TinyYolov2SizeType[TinyYolov2SizeType["MD"] = 416] = "MD";
    TinyYolov2SizeType[TinyYolov2SizeType["LG"] = 608] = "LG";
})(TinyYolov2SizeType || (TinyYolov2SizeType = {}));
var TinyYolov2Options = /** @class */ (function () {
    function TinyYolov2Options(_a) {
        var _b = _a === void 0 ? {} : _a, inputSize = _b.inputSize, scoreThreshold = _b.scoreThreshold;
        this._name = 'TinyYolov2Options';
        this._inputSize = inputSize || 416;
        this._scoreThreshold = scoreThreshold || 0.5;
        if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) {
            throw new Error(this._name + " - expected inputSize to be a number divisible by 32");
        }
        if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {
            throw new Error(this._name + " - expected scoreThreshold to be a number between 0 and 1");
        }
    }
    Object.defineProperty(TinyYolov2Options.prototype, "inputSize", {
        get: function () { return this._inputSize; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Options.prototype, "scoreThreshold", {
        get: function () { return this._scoreThreshold; },
        enumerable: true,
        configurable: true
    });
    return TinyYolov2Options;
}());

//# sourceMappingURL=TinyYolov2Options.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/config.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/config.js ***!
  \*****************************************************************/
/*! exports provided: validateConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateConfig", function() { return validateConfig; });
var isNumber = function (arg) { return typeof arg === 'number'; };
function validateConfig(config) {
    if (!config) {
        throw new Error("invalid config: " + config);
    }
    if (typeof config.withSeparableConvs !== 'boolean') {
        throw new Error("config.withSeparableConvs has to be a boolean, have: " + config.withSeparableConvs);
    }
    if (!isNumber(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1.0) {
        throw new Error("config.iouThreshold has to be a number between [0, 1], have: " + config.iouThreshold);
    }
    if (!Array.isArray(config.classes)
        || !config.classes.length
        || !config.classes.every(function (c) { return typeof c === 'string'; })) {
        throw new Error("config.classes has to be an array class names: string[], have: " + JSON.stringify(config.classes));
    }
    if (!Array.isArray(config.anchors)
        || !config.anchors.length
        || !config.anchors.map(function (a) { return a || {}; }).every(function (a) { return isNumber(a.x) && isNumber(a.y); })) {
        throw new Error("config.anchors has to be an array of { x: number, y: number }, have: " + JSON.stringify(config.anchors));
    }
    if (config.meanRgb && (!Array.isArray(config.meanRgb)
        || config.meanRgb.length !== 3
        || !config.meanRgb.every(isNumber))) {
        throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: " + JSON.stringify(config.meanRgb));
    }
}
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/const.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/const.js ***!
  \****************************************************************/
/*! exports provided: IOU_THRESHOLD, BOX_ANCHORS, BOX_ANCHORS_SEPARABLE, MEAN_RGB_SEPARABLE, DEFAULT_MODEL_NAME, DEFAULT_MODEL_NAME_SEPARABLE_CONV */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IOU_THRESHOLD", function() { return IOU_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOX_ANCHORS", function() { return BOX_ANCHORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOX_ANCHORS_SEPARABLE", function() { return BOX_ANCHORS_SEPARABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEAN_RGB_SEPARABLE", function() { return MEAN_RGB_SEPARABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MODEL_NAME", function() { return DEFAULT_MODEL_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MODEL_NAME_SEPARABLE_CONV", function() { return DEFAULT_MODEL_NAME_SEPARABLE_CONV; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");

var IOU_THRESHOLD = 0.4;
var BOX_ANCHORS = [
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](0.738768, 0.874946),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](2.42204, 2.65704),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](4.30971, 7.04493),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](10.246, 4.59428),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](12.6868, 11.8741)
];
var BOX_ANCHORS_SEPARABLE = [
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](1.603231, 2.094468),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](6.041143, 7.080126),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](2.882459, 3.518061),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](4.266906, 5.178857),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](9.041765, 10.66308)
];
var MEAN_RGB_SEPARABLE = [117.001, 114.697, 97.404];
var DEFAULT_MODEL_NAME = 'tiny_yolov2_model';
var DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model';
//# sourceMappingURL=const.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js ***!
  \****************************************************************************/
/*! exports provided: convWithBatchNorm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convWithBatchNorm", function() { return convWithBatchNorm; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _leaky__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leaky */ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js");


function convWithBatchNorm(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"](x, [[0, 0], [1, 1], [1, 1], [0, 0]]);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](out, params.conv.filters, [1, 1], 'valid');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](out, params.bn.sub);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](out, params.bn.truediv);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.conv.bias);
        return Object(_leaky__WEBPACK_IMPORTED_MODULE_1__["leaky"])(out);
    });
}
//# sourceMappingURL=convWithBatchNorm.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js ***!
  \*********************************************************************************/
/*! exports provided: depthwiseSeparableConv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseSeparableConv", function() { return depthwiseSeparableConv; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _leaky__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leaky */ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js");


function depthwiseSeparableConv(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"](x, [[0, 0], [1, 1], [1, 1], [0, 0]]);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"](out, params.depthwise_filter, params.pointwise_filter, [1, 1], 'valid');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.bias);
        return Object(_leaky__WEBPACK_IMPORTED_MODULE_1__["leaky"])(out);
    });
}
//# sourceMappingURL=depthwiseSeparableConv.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js ***!
  \************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/extractSeparableConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js");
/* harmony import */ var _common_extractWeightsFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/extractWeightsFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js");




function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractConvParamsFactory"])(extractWeights, paramMappings);
    function extractBatchNormParams(size, mappedPrefix) {
        var sub = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(size));
        var truediv = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(size));
        paramMappings.push({ paramPath: mappedPrefix + "/sub" }, { paramPath: mappedPrefix + "/truediv" });
        return { sub: sub, truediv: truediv };
    }
    function extractConvWithBatchNormParams(channelsIn, channelsOut, mappedPrefix) {
        var conv = extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv");
        var bn = extractBatchNormParams(channelsOut, mappedPrefix + "/bn");
        return { conv: conv, bn: bn };
    }
    var extractSeparableConvParams = Object(_common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_2__["extractSeparableConvParamsFactory"])(extractWeights, paramMappings);
    return {
        extractConvParams: extractConvParams,
        extractConvWithBatchNormParams: extractConvWithBatchNormParams,
        extractSeparableConvParams: extractSeparableConvParams
    };
}
function extractParams(weights, config, boxEncodingSize, filterSizes) {
    var _a = Object(_common_extractWeightsFactory__WEBPACK_IMPORTED_MODULE_3__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractConvWithBatchNormParams = _b.extractConvWithBatchNormParams, extractSeparableConvParams = _b.extractSeparableConvParams;
    var params;
    if (config.withSeparableConvs) {
        var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
        var conv0 = config.isFirstLayerConv2d
            ? extractConvParams(s0, s1, 3, 'conv0')
            : extractSeparableConvParams(s0, s1, 'conv0');
        var conv1 = extractSeparableConvParams(s1, s2, 'conv1');
        var conv2 = extractSeparableConvParams(s2, s3, 'conv2');
        var conv3 = extractSeparableConvParams(s3, s4, 'conv3');
        var conv4 = extractSeparableConvParams(s4, s5, 'conv4');
        var conv5 = extractSeparableConvParams(s5, s6, 'conv5');
        var conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined;
        var conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined;
        var conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8');
        params = { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3, conv4: conv4, conv5: conv5, conv6: conv6, conv7: conv7, conv8: conv8 };
    }
    else {
        var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
        var conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0');
        var conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1');
        var conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2');
        var conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3');
        var conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4');
        var conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5');
        var conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6');
        var conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7');
        var conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8');
        params = { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3, conv4: conv4, conv5: conv5, conv6: conv6, conv7: conv7, conv8: conv8 };
    }
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js ***!
  \*************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common_disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/disposeUnusedWeightTensors */ "./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js");
/* harmony import */ var _common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/extractSeparableConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js");
/* harmony import */ var _common_extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/extractWeightEntryFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js");



function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common_extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_2__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractBatchNormParams(prefix) {
        var sub = extractWeightEntry(prefix + "/sub", 1);
        var truediv = extractWeightEntry(prefix + "/truediv", 1);
        return { sub: sub, truediv: truediv };
    }
    function extractConvParams(prefix) {
        var filters = extractWeightEntry(prefix + "/filters", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { filters: filters, bias: bias };
    }
    function extractConvWithBatchNormParams(prefix) {
        var conv = extractConvParams(prefix + "/conv");
        var bn = extractBatchNormParams(prefix + "/bn");
        return { conv: conv, bn: bn };
    }
    var extractSeparableConvParams = Object(_common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadSeparableConvParamsFactory"])(extractWeightEntry);
    return {
        extractConvParams: extractConvParams,
        extractConvWithBatchNormParams: extractConvWithBatchNormParams,
        extractSeparableConvParams: extractSeparableConvParams
    };
}
function extractParamsFromWeigthMap(weightMap, config) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractConvParams = _a.extractConvParams, extractConvWithBatchNormParams = _a.extractConvWithBatchNormParams, extractSeparableConvParams = _a.extractSeparableConvParams;
    var params;
    if (config.withSeparableConvs) {
        var numFilters = (config.filterSizes && config.filterSizes.length || 9);
        params = {
            conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),
            conv1: extractSeparableConvParams('conv1'),
            conv2: extractSeparableConvParams('conv2'),
            conv3: extractSeparableConvParams('conv3'),
            conv4: extractSeparableConvParams('conv4'),
            conv5: extractSeparableConvParams('conv5'),
            conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,
            conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,
            conv8: extractConvParams('conv8')
        };
    }
    else {
        params = {
            conv0: extractConvWithBatchNormParams('conv0'),
            conv1: extractConvWithBatchNormParams('conv1'),
            conv2: extractConvWithBatchNormParams('conv2'),
            conv3: extractConvWithBatchNormParams('conv3'),
            conv4: extractConvWithBatchNormParams('conv4'),
            conv5: extractConvWithBatchNormParams('conv5'),
            conv6: extractConvWithBatchNormParams('conv6'),
            conv7: extractConvWithBatchNormParams('conv7'),
            conv8: extractConvParams('conv8')
        };
    }
    Object(_common_disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/index.js ***!
  \****************************************************************/
/*! exports provided: TinyYolov2SizeType, TinyYolov2Options, validateConfig, TinyYolov2, createTinyYolov2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTinyYolov2", function() { return createTinyYolov2; });
/* harmony import */ var _TinyYolov2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2", function() { return _TinyYolov2__WEBPACK_IMPORTED_MODULE_0__["TinyYolov2"]; });

/* harmony import */ var _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TinyYolov2Options */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2SizeType", function() { return _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_1__["TinyYolov2SizeType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Options", function() { return _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_1__["TinyYolov2Options"]; });

/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/tinyYolov2/config.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateConfig", function() { return _config__WEBPACK_IMPORTED_MODULE_2__["validateConfig"]; });





function createTinyYolov2(weights, withSeparableConvs) {
    if (withSeparableConvs === void 0) { withSeparableConvs = true; }
    var net = new _TinyYolov2__WEBPACK_IMPORTED_MODULE_0__["TinyYolov2"](withSeparableConvs);
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js ***!
  \****************************************************************/
/*! exports provided: leaky */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leaky", function() { return leaky; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function leaky(x) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var min = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](x, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](0.10000000149011612));
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](x, min)), min);
        //return tf.maximum(x, min)
    });
}
//# sourceMappingURL=leaky.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/utils/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/utils/index.js ***!
  \***********************************************************/
/*! exports provided: isTensor, isTensor1D, isTensor2D, isTensor3D, isTensor4D, isFloat, isEven, round, isDimensions, computeReshapedDimensions, getCenterPoint, range, isValidNumber, isValidProbablitiy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor", function() { return isTensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor1D", function() { return isTensor1D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor2D", function() { return isTensor2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor3D", function() { return isTensor3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor4D", function() { return isTensor4D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFloat", function() { return isFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEven", function() { return isEven; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDimensions", function() { return isDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeReshapedDimensions", function() { return computeReshapedDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenterPoint", function() { return getCenterPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidNumber", function() { return isValidNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidProbablitiy", function() { return isValidProbablitiy; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_Dimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");



function isTensor(tensor, dim) {
    return tensor instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"] && tensor.shape.length === dim;
}
function isTensor1D(tensor) {
    return isTensor(tensor, 1);
}
function isTensor2D(tensor) {
    return isTensor(tensor, 2);
}
function isTensor3D(tensor) {
    return isTensor(tensor, 3);
}
function isTensor4D(tensor) {
    return isTensor(tensor, 4);
}
function isFloat(num) {
    return num % 1 !== 0;
}
function isEven(num) {
    return num % 2 === 0;
}
function round(num, prec) {
    if (prec === void 0) { prec = 2; }
    var f = Math.pow(10, prec);
    return Math.floor(num * f) / f;
}
function isDimensions(obj) {
    return obj && obj.width && obj.height;
}
function computeReshapedDimensions(_a, inputSize) {
    var width = _a.width, height = _a.height;
    var scale = inputSize / Math.max(height, width);
    return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_2__["Dimensions"](Math.round(width * scale), Math.round(height * scale));
}
function getCenterPoint(pts) {
    return pts.reduce(function (sum, pt) { return sum.add(pt); }, new _classes__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0))
        .div(new _classes__WEBPACK_IMPORTED_MODULE_1__["Point"](pts.length, pts.length));
}
function range(num, start, step) {
    return Array(num).fill(0).map(function (_, i) { return start + (i * step); });
}
function isValidNumber(num) {
    return !!num && num !== Infinity && num !== -Infinity && !isNaN(num) || num === 0;
}
function isValidProbablitiy(num) {
    return isValidNumber(num) && 0 <= num && num <= 1.0;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/xception/TinyXception.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/xception/TinyXception.js ***!
  \*********************************************************************/
/*! exports provided: TinyXception */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyXception", function() { return TinyXception; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/xception/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js");









function conv(x, params, stride) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["conv2d"](x, params.filters, stride, 'same'), params.bias);
}
function reductionBlock(x, params, isActivateInput) {
    if (isActivateInput === void 0) { isActivateInput = true; }
    var out = isActivateInput ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](x) : x;
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(out, params.separable_conv0, [1, 1]);
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out), params.separable_conv1, [1, 1]);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [3, 3], [2, 2], 'same');
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](out, conv(x, params.expansion_conv, [2, 2]));
    return out;
}
function mainBlock(x, params) {
    var out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](x), params.separable_conv0, [1, 1]);
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out), params.separable_conv1, [1, 1]);
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out), params.separable_conv2, [1, 1]);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](out, x);
    return out;
}
var TinyXception = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyXception, _super);
    function TinyXception(numMainBlocks) {
        var _this = _super.call(this, 'TinyXception') || this;
        _this._numMainBlocks = numMainBlocks;
        return _this;
    }
    TinyXception.prototype.forwardInput = function (input) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error('TinyXception - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_5__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](256));
            var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](conv(normalized, params.entry_flow.conv_in, [2, 2]));
            out = reductionBlock(out, params.entry_flow.reduction_block_0, false);
            out = reductionBlock(out, params.entry_flow.reduction_block_1);
            Object(_utils__WEBPACK_IMPORTED_MODULE_6__["range"])(_this._numMainBlocks, 0, 1).forEach(function (idx) {
                out = mainBlock(out, params.middle_flow["main_block_" + idx]);
            });
            out = reductionBlock(out, params.exit_flow.reduction_block);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(out, params.exit_flow.separable_conv, [1, 1]));
            return out;
        });
    };
    TinyXception.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_3__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    TinyXception.prototype.getDefaultModelName = function () {
        return 'tiny_xception_model';
    };
    TinyXception.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_8__["extractParamsFromWeigthMap"])(weightMap, this._numMainBlocks);
    };
    TinyXception.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_7__["extractParams"])(weights, this._numMainBlocks);
    };
    return TinyXception;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__["NeuralNetwork"]));

//# sourceMappingURL=TinyXception.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/xception/extractParams.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/xception/extractParams.js ***!
  \**********************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractConvParamsFactory"])(extractWeights, paramMappings);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractSeparableConvParamsFactory"])(extractWeights, paramMappings);
    function extractReductionBlockParams(channelsIn, channelsOut, mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/separable_conv1");
        var expansion_conv = extractConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/expansion_conv");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, expansion_conv: expansion_conv };
    }
    function extractMainBlockParams(channels, mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv1");
        var separable_conv2 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv2");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, separable_conv2: separable_conv2 };
    }
    return {
        extractConvParams: extractConvParams,
        extractSeparableConvParams: extractSeparableConvParams,
        extractReductionBlockParams: extractReductionBlockParams,
        extractMainBlockParams: extractMainBlockParams
    };
}
function extractParams(weights, numMainBlocks) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractSeparableConvParams = _b.extractSeparableConvParams, extractReductionBlockParams = _b.extractReductionBlockParams, extractMainBlockParams = _b.extractMainBlockParams;
    var entry_flow_conv_in = extractConvParams(3, 32, 3, 'entry_flow/conv_in');
    var entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, 'entry_flow/reduction_block_0');
    var entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, 'entry_flow/reduction_block_1');
    var entry_flow = {
        conv_in: entry_flow_conv_in,
        reduction_block_0: entry_flow_reduction_block_0,
        reduction_block_1: entry_flow_reduction_block_1
    };
    var middle_flow = {};
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["range"])(numMainBlocks, 0, 1).forEach(function (idx) {
        middle_flow["main_block_" + idx] = extractMainBlockParams(128, "middle_flow/main_block_" + idx);
    });
    var exit_flow_reduction_block = extractReductionBlockParams(128, 256, 'exit_flow/reduction_block');
    var exit_flow_separable_conv = extractSeparableConvParams(256, 512, 'exit_flow/separable_conv');
    var exit_flow = {
        reduction_block: exit_flow_reduction_block,
        separable_conv: exit_flow_separable_conv
    };
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { entry_flow: entry_flow, middle_flow: middle_flow, exit_flow: exit_flow }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js ***!
  \***********************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/loadConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");



function loadParamsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    var extractConvParams = Object(_common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadConvParamsFactory"])(extractWeightEntry);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["loadSeparableConvParamsFactory"])(extractWeightEntry);
    function extractReductionBlockParams(mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
        var expansion_conv = extractConvParams(mappedPrefix + "/expansion_conv");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, expansion_conv: expansion_conv };
    }
    function extractMainBlockParams(mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
        var separable_conv2 = extractSeparableConvParams(mappedPrefix + "/separable_conv2");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, separable_conv2: separable_conv2 };
    }
    return {
        extractConvParams: extractConvParams,
        extractSeparableConvParams: extractSeparableConvParams,
        extractReductionBlockParams: extractReductionBlockParams,
        extractMainBlockParams: extractMainBlockParams
    };
}
function extractParamsFromWeigthMap(weightMap, numMainBlocks) {
    var paramMappings = [];
    var _a = loadParamsFactory(weightMap, paramMappings), extractConvParams = _a.extractConvParams, extractSeparableConvParams = _a.extractSeparableConvParams, extractReductionBlockParams = _a.extractReductionBlockParams, extractMainBlockParams = _a.extractMainBlockParams;
    var entry_flow_conv_in = extractConvParams('entry_flow/conv_in');
    var entry_flow_reduction_block_0 = extractReductionBlockParams('entry_flow/reduction_block_0');
    var entry_flow_reduction_block_1 = extractReductionBlockParams('entry_flow/reduction_block_1');
    var entry_flow = {
        conv_in: entry_flow_conv_in,
        reduction_block_0: entry_flow_reduction_block_0,
        reduction_block_1: entry_flow_reduction_block_1
    };
    var middle_flow = {};
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["range"])(numMainBlocks, 0, 1).forEach(function (idx) {
        middle_flow["main_block_" + idx] = extractMainBlockParams("middle_flow/main_block_" + idx);
    });
    var exit_flow_reduction_block = extractReductionBlockParams('exit_flow/reduction_block');
    var exit_flow_separable_conv = extractSeparableConvParams('exit_flow/separable_conv');
    var exit_flow = {
        reduction_block: exit_flow_reduction_block,
        separable_conv: exit_flow_separable_conv
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: { entry_flow: entry_flow, middle_flow: middle_flow, exit_flow: exit_flow }, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/histogram.js":
/*!**************************!*\
  !*** ./src/histogram.js ***!
  \**************************/
/*! exports provided: checkBright */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkBright", function() { return checkBright; });


function checkBright(id) {
  if (!id) return;
  var dark_threshold = 0.4;
  var light_threshold = 0.4;
  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');
  var img = document.getElementById(id);
  canvas.width = img.width;
  canvas.height = img.height;
  console.log(canvas.width, canvas.height);
  context.drawImage(img, 0, 0);
  var imgData = context.getImageData(0, 0, img.width, img.height).data;
  var chans = [[]],
      maxCount = 0,
      val = 0;
  var step = 1;
  step *= 4;

  for (var i = 0, n = imgData.length; i < n; i += step) {
    val = rgb2hsv(imgData[i], imgData[i + 1], imgData[i + 2]);
    val = [val[2]];

    for (var _y = 0, m = val.length; _y < m; _y++) {
      if (val[_y] in chans[_y]) {
        chans[_y][val[_y]]++;
      } else {
        chans[_y][val[_y]] = 1;
      }

      if (chans[_y][val[_y]] > maxCount) {
        maxCount = chans[_y][val[_y]];
      }
    }
  }

  if (maxCount === 0) {
    return;
  }

  var vals = chans[0];
  var x,
      y = 0;
  var light = 0,
      dark = 0,
      avr = 0;

  for (var _i = 0; _i <= 255; _i++) {
    if (!(_i in vals)) {
      continue;
    }

    y = Math.round(vals[_i] / maxCount * 480);
    x = Math.round(_i / 255 * 640);
    if (_i < 30) dark += y;
    if (_i > 210) light += y;
    avr += y;
  }

  console.log('dark= ', dark, ' ', dark / avr);
  console.log('light= ', light, ' ', light / avr);
  console.log('sum= ', avr);

  if (dark / avr > dark_threshold) {
    return 1;
  }

  if (light / avr > light_threshold) {
    return 2;
  } // This is gray


  function rgb2hsv(red, green, blue) {
    red /= 255;
    green /= 255;
    blue /= 255;
    var hue,
        sat,
        min = Math.min(red, green, blue),
        max = Math.max(red, green, blue),
        delta = max - min,
        value = max;

    if (delta === 0) {
      hue = sat = 0;
    } else {
      sat = delta / max;

      if (max === red) {
        hue = (green - blue) / delta;
      } else if (max === green) {
        hue = (blue - red) / delta + 2;
      } else if (max === blue) {
        hue = (red - green) / delta + 4;
      }

      hue /= 6;

      if (hue < 0) {
        hue += 1;
      }
    }

    return [Math.round(hue * 255), Math.round(sat * 255), Math.round(value * 255)];
  }
}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return checkPhoto; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _histogram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./histogram */ "./src/histogram.js");
/* harmony import */ var face_api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! face-api.js */ "./node_modules/face-api.js/build/es6/index.js");






function checkPhoto(id) {
  if (!id) return;

  _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
    var detection, brightResult, errors;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return face_api_js__WEBPACK_IMPORTED_MODULE_3__["nets"].tinyFaceDetector.loadFromUri('./models');

          case 2:
            _context.next = 4;
            return face_api_js__WEBPACK_IMPORTED_MODULE_3__["detectAllFaces"](id, new face_api_js__WEBPACK_IMPORTED_MODULE_3__["TinyFaceDetectorOptions"]());

          case 4:
            detection = _context.sent;
            brightResult = Object(_histogram__WEBPACK_IMPORTED_MODULE_2__["checkBright"])(id);
            errors = [];

            if (brightResult === 1) {
              console.warn("Темное изображение");
              errors.push(-1);
            }

            if (brightResult === 2) {
              console.warn("Светлое изображение");
              errors.push(-2);
            }

            if (!detection.length) {
              console.error("Лицо не обнаружено");
              errors.push(-3);
            } else {
              if (detection.length > 1) {
                console.error("Обнаружено несколько лиц");
                errors.push(-4);
              } else {
                console.info("Все ОК");
              }
            }

            return _context.abrupt("return", errors);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }))();
}

/***/ }),

/***/ 0:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGVja1Bob3RvL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC90Zi1jb3JlLmVzbS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9OZXVyYWxOZXR3b3JrLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2FnZUdlbmRlck5ldC9BZ2VHZW5kZXJOZXQuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvYWdlR2VuZGVyTmV0L2V4dHJhY3RQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvYWdlR2VuZGVyTmV0L2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2FnZUdlbmRlck5ldC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9hZ2VHZW5kZXJOZXQvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9Cb3VuZGluZ0JveC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL0JveC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL0RpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9GYWNlRGV0ZWN0aW9uLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvRmFjZUxhbmRtYXJrcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL0ZhY2VMYW5kbWFya3M1LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvRmFjZUxhbmRtYXJrczY4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvRmFjZU1hdGNoLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvTGFiZWxlZEJveC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL0xhYmVsZWRGYWNlRGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9PYmplY3REZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9Qb2ludC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL1ByZWRpY3RlZEJveC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL1JlY3QuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jb21tb24vY29udkxheWVyLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9kZXB0aHdpc2VTZXBhcmFibGVDb252LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9kaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jb21tb24vZXh0cmFjdENvbnZQYXJhbXNGYWN0b3J5LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9leHRyYWN0RkNQYXJhbXNGYWN0b3J5LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL2V4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL2V4dHJhY3RXZWlnaHRzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jb21tb24vZnVsbHlDb25uZWN0ZWRMYXllci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jb21tb24vZ2V0TW9kZWxVcmlzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jb21tb24vbG9hZENvbnZQYXJhbXNGYWN0b3J5LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi90eXBlcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vTmV0SW5wdXQuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2F3YWl0TWVkaWFMb2FkZWQuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2J1ZmZlclRvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2NyZWF0ZUNhbnZhcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vZXh0cmFjdEZhY2VUZW5zb3JzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9leHRyYWN0RmFjZXMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2ZldGNoSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2ZldGNoSnNvbi5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vZmV0Y2hOZXRXZWlnaHRzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9mZXRjaE9yVGhyb3cuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2dldENvbnRleHQyZE9yVGhyb3cuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2dldE1lZGlhRGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vaW1hZ2VUZW5zb3JUb0NhbnZhcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vaW1hZ2VUb1NxdWFyZS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2lzTWVkaWFFbGVtZW50LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9pc01lZGlhTG9hZGVkLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9sb2FkV2VpZ2h0TWFwLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9tYXRjaERpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL3Jlc29sdmVJbnB1dC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vdG9OZXRJbnB1dC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kcmF3L0RyYXdCb3guanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZHJhdy9EcmF3RmFjZUxhbmRtYXJrcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kcmF3L0RyYXdUZXh0RmllbGQuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZHJhdy9kcmF3Q29udG91ci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kcmF3L2RyYXdEZXRlY3Rpb25zLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RyYXcvZHJhd0ZhY2VFeHByZXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kcmF3L2luZGV4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2Vudi9jcmVhdGVCcm93c2VyRW52LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2Vudi9jcmVhdGVGaWxlU3lzdGVtLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2Vudi9jcmVhdGVOb2RlanNFbnYuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZW52L2luZGV4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2Vudi9pc0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZW52L2lzTm9kZWpzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2V1Y2xpZGVhbkRpc3RhbmNlLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VFeHByZXNzaW9uTmV0L0ZhY2VFeHByZXNzaW9uTmV0LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VFeHByZXNzaW9uTmV0L0ZhY2VFeHByZXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRXhwcmVzc2lvbk5ldC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9GYWNlRmVhdHVyZUV4dHJhY3Rvci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9UaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZUZlYXR1cmVFeHRyYWN0b3IvZGVuc2VCbG9jay5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9leHRyYWN0UGFyYW1zLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwVGlueS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9leHRyYWN0UGFyYW1zVGlueS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9leHRyYWN0b3JzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9sb2FkUGFyYW1zRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlTGFuZG1hcmtOZXQvRmFjZUxhbmRtYXJrNjhOZXQuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZUxhbmRtYXJrTmV0L0ZhY2VMYW5kbWFyazY4TmV0QmFzZS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlTGFuZG1hcmtOZXQvRmFjZUxhbmRtYXJrNjhUaW55TmV0LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VMYW5kbWFya05ldC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlUHJvY2Vzc29yL0ZhY2VQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVByb2Nlc3Nvci9leHRyYWN0UGFyYW1zLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VQcm9jZXNzb3IvZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVByb2Nlc3Nvci91dGlsLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VSZWNvZ25pdGlvbk5ldC9GYWNlUmVjb2duaXRpb25OZXQuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVJlY29nbml0aW9uTmV0L2NvbnZMYXllci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlUmVjb2duaXRpb25OZXQvZXh0cmFjdFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlUmVjb2duaXRpb25OZXQvZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVJlY29nbml0aW9uTmV0L2luZGV4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VSZWNvZ25pdGlvbk5ldC9yZXNpZHVhbExheWVyLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VSZWNvZ25pdGlvbk5ldC9zY2FsZUxheWVyLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY3Rvcmllcy9XaXRoQWdlLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY3Rvcmllcy9XaXRoRmFjZURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjdG9yaWVzL1dpdGhGYWNlRGV0ZWN0aW9uLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY3Rvcmllcy9XaXRoRmFjZUV4cHJlc3Npb25zLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY3Rvcmllcy9XaXRoRmFjZUxhbmRtYXJrcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWN0b3JpZXMvV2l0aEdlbmRlci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWN0b3JpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL0NvbXBvc2FibGVUYXNrLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2dsb2JhbEFwaS9Db21wdXRlRmFjZURlc2NyaXB0b3JzVGFza3MuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL0RldGVjdEZhY2VMYW5kbWFya3NUYXNrcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvRGV0ZWN0RmFjZXNUYXNrcy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvRmFjZU1hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL1ByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2dsb2JhbEFwaS9QcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFzay5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvYWxsRmFjZXMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL2RldGVjdEZhY2VzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2dsb2JhbEFwaS9leHRyYWN0RmFjZXNBbmRDb21wdXRlUmVzdWx0cy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL25ldHMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vTXRjbm4uanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vTXRjbm5Cb3guanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vTXRjbm5PcHRpb25zLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL09OZXQuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vUE5ldC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9STmV0LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL2JnclRvUmdiVGVuc29yLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9leHRyYWN0SW1hZ2VQYXRjaGVzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL2V4dHJhY3RQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vZ2V0U2l6ZXNGb3JTY2FsZS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vcHJlbHUuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vcHlyYW1pZERvd24uanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vc2hhcmVkTGF5ZXJzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL3N0YWdlMS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9zdGFnZTIuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vc3RhZ2UzLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L29wcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9vcHMvaW91LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L29wcy9taW5CYm94LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L29wcy9ub25NYXhTdXBwcmVzc2lvbi5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9vcHMvbm9ybWFsaXplLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L29wcy9wYWRUb1NxdWFyZS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9vcHMvc2h1ZmZsZUFycmF5LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3Jlc2l6ZVJlc3VsdHMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvU3NkTW9iaWxlbmV0djEuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvU3NkTW9iaWxlbmV0djFPcHRpb25zLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL2JveFByZWRpY3Rpb25MYXllci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9zc2RNb2JpbGVuZXR2MS9leHRyYWN0UGFyYW1zLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL2luZGV4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL21vYmlsZU5ldFYxLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL25vbk1heFN1cHByZXNzaW9uLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL291dHB1dExheWVyLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL3BvaW50d2lzZUNvbnZMYXllci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9zc2RNb2JpbGVuZXR2MS9wcmVkaWN0aW9uTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueUZhY2VEZXRlY3Rvci9UaW55RmFjZURldGVjdG9yLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlGYWNlRGV0ZWN0b3IvVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueUZhY2VEZXRlY3Rvci9jb25zdC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55RmFjZURldGVjdG9yL2luZGV4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvVGlueVlvbG92Mi5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55WW9sb3YyL1RpbnlZb2xvdjJCYXNlLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvVGlueVlvbG92Mk9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueVlvbG92Mi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueVlvbG92Mi9jb25zdC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55WW9sb3YyL2NvbnZXaXRoQmF0Y2hOb3JtLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvZGVwdGh3aXNlU2VwYXJhYmxlQ29udi5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55WW9sb3YyL2V4dHJhY3RQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueVlvbG92Mi9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55WW9sb3YyL2luZGV4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvbGVha3kuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYveGNlcHRpb24vVGlueVhjZXB0aW9uLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3hjZXB0aW9uL2V4dHJhY3RQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYveGNlcHRpb24vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9jaGVja1Bob3RvLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9zcmMvaGlzdG9ncmFtLmpzIiwid2VicGFjazovL2NoZWNrUGhvdG8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by9jcnlwdG8gKGlnbm9yZWQpIiwid2VicGFjazovL2NoZWNrUGhvdG8vbm9kZS1mZXRjaCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vY2hlY2tQaG90by91dGlsIChpZ25vcmVkKSJdLCJuYW1lcyI6WyJjaGVja0JyaWdodCIsImlkIiwiZGFya190aHJlc2hvbGQiLCJsaWdodF90aHJlc2hvbGQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImltZyIsImdldEVsZW1lbnRCeUlkIiwid2lkdGgiLCJoZWlnaHQiLCJjb25zb2xlIiwibG9nIiwiZHJhd0ltYWdlIiwiaW1nRGF0YSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJjaGFucyIsIm1heENvdW50IiwidmFsIiwic3RlcCIsImkiLCJuIiwibGVuZ3RoIiwicmdiMmhzdiIsInkiLCJtIiwidmFscyIsIngiLCJsaWdodCIsImRhcmsiLCJhdnIiLCJNYXRoIiwicm91bmQiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJodWUiLCJzYXQiLCJtaW4iLCJtYXgiLCJkZWx0YSIsInZhbHVlIiwiY2hlY2tQaG90byIsImZhY2VhcGkiLCJ0aW55RmFjZURldGVjdG9yIiwibG9hZEZyb21VcmkiLCJkZXRlY3Rpb24iLCJicmlnaHRSZXN1bHQiLCJlcnJvcnMiLCJ3YXJuIiwicHVzaCIsImVycm9yIiwiaW5mbyJdLCJtYXBwaW5ncyI6Ijs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQzs7Ozs7Ozs7Ozs7QUNwQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXFCOzs7Ozs7Ozs7Ozs7O0FDQTlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTRDO0FBQ2I7QUFDRTtBQUNOO0FBQ1U7QUFDTDtBQUNKO0FBQ0E7QUFDYztBQUNGO0FBQ0c7QUFDVDtBQUNBO0FBQ0o7QUFDRjtBQUNXO0FBQ0U7QUFDTjtBQUNDO0FBQ0o7QUFDQTtBQUNoQyxpQzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDekxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUE7QUFBQSxtQkFFMkJGLDBEQUFBLENBQXVCN0MsRUFBdkIsRUFBMkIsSUFBSTZDLG1FQUFKLEVBQTNCLENBRjNCOztBQUFBO0FBRVNHLHFCQUZUO0FBR1NDLHdCQUhULEdBR3dCbEQsOERBQVcsQ0FBQ0MsRUFBRCxDQUhuQztBQUlPa0Qsa0JBSlAsR0FJYyxFQUpkOztBQUtHLGdCQUFJRCxZQUFZLEtBQUcsQ0FBbkIsRUFBcUI7QUFDakJyQyxxQkFBTyxDQUFDdUMsSUFBUixDQUFhLG9CQUFiO0FBQ0FELG9CQUFNLENBQUNFLElBQVAsQ0FBWSxDQUFDLENBQWI7QUFDSDs7QUFDRCxnQkFBSUgsWUFBWSxLQUFHLENBQW5CLEVBQXFCO0FBQ2pCckMscUJBQU8sQ0FBQ3VDLElBQVIsQ0FBYSxxQkFBYjtBQUNBRCxvQkFBTSxDQUFDRSxJQUFQLENBQVksQ0FBQyxDQUFiO0FBQ0g7O0FBQ0QsZ0JBQUksQ0FBQ0osU0FBUyxDQUFDeEIsTUFBZixFQUF1QjtBQUNuQloscUJBQU8sQ0FBQ3lDLEtBQVIsQ0FBYyxvQkFBZDtBQUNBSCxvQkFBTSxDQUFDRSxJQUFQLENBQVksQ0FBQyxDQUFiO0FBRUgsYUFKRCxNQUlPO0FBQ0gsa0JBQUlKLFNBQVMsQ0FBQ3hCLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEJaLHVCQUFPLENBQUN5QyxLQUFSLENBQWMsMEJBQWQ7QUFDQUgsc0JBQU0sQ0FBQ0UsSUFBUCxDQUFZLENBQUMsQ0FBYjtBQUNILGVBSEQsTUFHTztBQUNIeEMsdUJBQU8sQ0FBQzBDLElBQVIsQ0FBYSxRQUFiO0FBQ0g7QUFDSjs7QUF4QkosNkNBeUJVSixNQXpCVjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFEO0FBNkJILEM7Ozs7Ozs7Ozs7O0FDcENELGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6Im1haW4uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciB0PWZ1bmN0aW9uKGUsbil7cmV0dXJuKHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSl9KShlLG4pfTtmdW5jdGlvbiBlKGUsbil7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX10KGUsbiksZS5wcm90b3R5cGU9bnVsbD09PW4/T2JqZWN0LmNyZWF0ZShuKTooci5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IHIpfWZ1bmN0aW9uIG4odCxlLG4scil7cmV0dXJuIG5ldyhufHwobj1Qcm9taXNlKSkoKGZ1bmN0aW9uKG8sYSl7ZnVuY3Rpb24gaSh0KXt0cnl7dShyLm5leHQodCkpfWNhdGNoKHQpe2EodCl9fWZ1bmN0aW9uIHModCl7dHJ5e3Uoci50aHJvdyh0KSl9Y2F0Y2godCl7YSh0KX19ZnVuY3Rpb24gdSh0KXt0LmRvbmU/byh0LnZhbHVlKTpuZXcgbigoZnVuY3Rpb24oZSl7ZSh0LnZhbHVlKX0pKS50aGVuKGkscyl9dSgocj1yLmFwcGx5KHQsZXx8W10pKS5uZXh0KCkpfSkpfWZ1bmN0aW9uIHIodCxlKXt2YXIgbixyLG8sYSxpPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJm9bMF0pdGhyb3cgb1sxXTtyZXR1cm4gb1sxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBhPXtuZXh0OnMoMCksdGhyb3c6cygxKSxyZXR1cm46cygyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoYVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxhO2Z1bmN0aW9uIHMoYSl7cmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybiBmdW5jdGlvbihhKXtpZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7aTspdHJ5e2lmKG49MSxyJiYobz0yJmFbMF0/ci5yZXR1cm46YVswXT9yLnRocm93fHwoKG89ci5yZXR1cm4pJiZvLmNhbGwociksMCk6ci5uZXh0KSYmIShvPW8uY2FsbChyLGFbMV0pKS5kb25lKXJldHVybiBvO3N3aXRjaChyPTAsbyYmKGE9WzImYVswXSxvLnZhbHVlXSksYVswXSl7Y2FzZSAwOmNhc2UgMTpvPWE7YnJlYWs7Y2FzZSA0OnJldHVybiBpLmxhYmVsKysse3ZhbHVlOmFbMV0sZG9uZTohMX07Y2FzZSA1OmkubGFiZWwrKyxyPWFbMV0sYT1bMF07Y29udGludWU7Y2FzZSA3OmE9aS5vcHMucG9wKCksaS50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShvPShvPWkudHJ5cykubGVuZ3RoPjAmJm9bby5sZW5ndGgtMV0pJiYoNj09PWFbMF18fDI9PT1hWzBdKSl7aT0wO2NvbnRpbnVlfWlmKDM9PT1hWzBdJiYoIW98fGFbMV0+b1swXSYmYVsxXTxvWzNdKSl7aS5sYWJlbD1hWzFdO2JyZWFrfWlmKDY9PT1hWzBdJiZpLmxhYmVsPG9bMV0pe2kubGFiZWw9b1sxXSxvPWE7YnJlYWt9aWYobyYmaS5sYWJlbDxvWzJdKXtpLmxhYmVsPW9bMl0saS5vcHMucHVzaChhKTticmVha31vWzJdJiZpLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWV9YT1lLmNhbGwodCxpKX1jYXRjaCh0KXthPVs2LHRdLHI9MH1maW5hbGx5e249bz0wfWlmKDUmYVswXSl0aHJvdyBhWzFdO3JldHVybnt2YWx1ZTphWzBdP2FbMV06dm9pZCAwLGRvbmU6ITB9fShbYSxzXSl9fX12YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5nbG9iYWw9dCx0aGlzLmZsYWdzPXt9LHRoaXMuZmxhZ1JlZ2lzdHJ5PXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9cmV0dXJuIHQucHJvdG90eXBlLnNldFBsYXRmb3JtPWZ1bmN0aW9uKHQsZSl7bnVsbCE9dGhpcy5wbGF0Zm9ybSYmY29uc29sZS53YXJuKFwiUGxhdGZvcm0gXCIrdGhpcy5wbGF0Zm9ybU5hbWUrXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuIE92ZXJ3cml0aW5nIHRoZSBwbGF0Zm9ybSB3aXRoIFwiK2UrXCIuXCIpLHRoaXMucGxhdGZvcm1OYW1lPXQsdGhpcy5wbGF0Zm9ybT1lfSx0LnByb3RvdHlwZS5yZWdpc3RlckZsYWc9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZmxhZ1JlZ2lzdHJ5W3RdPXtldmFsdWF0aW9uRm46ZSxzZXRIb29rOm59LG51bGwhPXRoaXMudXJsRmxhZ3NbdF0pe3ZhciByPXRoaXMudXJsRmxhZ3NbdF07Y29uc29sZS53YXJuKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiK3QrXCI6IFwiK3IrXCIuXCIpLHRoaXMuc2V0KHQscil9fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5mbGFncz90aGlzLmZsYWdzW3RdOih0aGlzLmZsYWdzW3RdPXRoaXMuZXZhbHVhdGVGbGFnKHQpLHRoaXMuZmxhZ3NbdF0pfSx0LnByb3RvdHlwZS5nZXROdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRCb29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0RmxhZ3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFnc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZmVhdHVyZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3N9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBmbGFnIFwiK3QrXCIgYXMgaXQgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXCIpO3RoaXMuZmxhZ3NbdF09ZSxudWxsIT10aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rJiZ0aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rKGUpfSx0LnByb3RvdHlwZS5ldmFsdWF0ZUZsYWc9ZnVuY3Rpb24odCl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV2YWx1YXRlIGZsYWcgJ1wiK3QrXCInOiBubyBldmFsdWF0aW9uIGZ1bmN0aW9uIGZvdW5kLlwiKTtyZXR1cm4gdGhpcy5mbGFnUmVnaXN0cnlbdF0uZXZhbHVhdGlvbkZuKCl9LHQucHJvdG90eXBlLnNldEZsYWdzPWZ1bmN0aW9uKHQpe3RoaXMuZmxhZ3M9T2JqZWN0LmFzc2lnbih7fSx0KX0sdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmZsYWdzPXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9LHQucHJvdG90eXBlLnBvcHVsYXRlVVJMRmxhZ3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKHZvaWQgMCE9PXRoaXMuZ2xvYmFsJiZ2b2lkIDAhPT10aGlzLmdsb2JhbC5sb2NhdGlvbiYmdm9pZCAwIT09dGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoKXt2YXIgZSxuLHI9KGU9dGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoLG49e30sZS5yZXBsYWNlKC9bPyZdKFtePT8mXSspKD86PShbXiZdKikpPy9nLChmdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTtyZXR1cm4gYShuLGVbMF0sZVsxXSksZS5qb2luKFwiPVwiKX0pKSxuKTtpZihcInRmanNmbGFnc1wiaW4gcilyLnRmanNmbGFncy5zcGxpdChcIixcIikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5zcGxpdChcIjpcIikscj1uWzBdLG89blsxXTt0LnVybEZsYWdzW3JdPWZ1bmN0aW9uKHQsZSl7aWYoXCJ0cnVlXCI9PT0oZT1lLnRvTG93ZXJDYXNlKCkpfHxcImZhbHNlXCI9PT1lKXJldHVyblwidHJ1ZVwiPT09ZTtpZihcIlwiKyArZT09PWUpcmV0dXJuK2U7dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHZhbHVlIGZsYWcgdmFsdWUgXCIrZStcIiBmb3IgZmxhZyBcIit0K1wiLlwiKX0ocixvKX0pKX19LHR9KCk7ZnVuY3Rpb24gYSh0LGUsbil7dFtkZWNvZGVVUklDb21wb25lbnQoZSldPWRlY29kZVVSSUNvbXBvbmVudChufHxcIlwiKX1mdW5jdGlvbiBpKCl7cmV0dXJuIHN9dmFyIHM9bnVsbDt2YXIgdT1uZXcgTWFwLGM9bmV3IE1hcDtmdW5jdGlvbiBsKHQsZSl7dmFyIG49Zyh0LGUpO3JldHVybiB1LmdldChuKX1mdW5jdGlvbiBoKHQpe3JldHVybiBjLmdldCh0KX1mdW5jdGlvbiBmKHQpe2Zvcih2YXIgZT11LmVudHJpZXMoKSxuPVtdOzspe3ZhciByPWUubmV4dCgpLG89ci5kb25lLGE9ci52YWx1ZTtpZihvKWJyZWFrO3ZhciBpPWFbMF0scz1hWzFdO2kuc3BsaXQoXCJfXCIpWzBdPT09dCYmbi5wdXNoKHMpfXJldHVybiBufWZ1bmN0aW9uIGQodCl7dmFyIGU9dC5rZXJuZWxOYW1lLG49dC5iYWNrZW5kTmFtZSxyPWcoZSxuKTtpZih1LmhhcyhyKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUga2VybmVsICdcIitlK1wiJyBmb3IgYmFja2VuZCAnXCIrbitcIicgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3Uuc2V0KHIsdCl9ZnVuY3Rpb24gcCh0KXt2YXIgZT10Lmtlcm5lbE5hbWU7Yy5oYXMoZSkmJmNvbnNvbGUud2FybihcIk92ZXJyaWRpbmcgdGhlIGdyYWRpZW50IGZvciAnXCIrZStcIidcIiksYy5zZXQoZSx0KX1mdW5jdGlvbiB2KHQsZSl7dmFyIG49Zyh0LGUpO2lmKCF1LmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUga2VybmVsICdcIit0K1wiJyBmb3IgYmFja2VuZCAnXCIrZStcIicgaXMgbm90IHJlZ2lzdGVyZWRcIik7dS5kZWxldGUobil9ZnVuY3Rpb24gbSh0KXtpZighYy5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGdyYWRpZW50ICdcIit0K1wiJyBmb3IgYmFja2VuZCBpcyBub3QgcmVnaXN0ZXJlZFwiKTtjLmRlbGV0ZSh0KX1mdW5jdGlvbiBnKHQsZSl7cmV0dXJuIGUrXCJfXCIrdH1mdW5jdGlvbiB5KHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxuPTAscj0wO2U+MDspcj1NYXRoLnJhbmRvbSgpKmV8MCxuPXRbLS1lXSx0W2VdPXRbcl0sdFtyXT1ufWZ1bmN0aW9uIHgodCxlLG4pe3JldHVybiBNYXRoLm1heCh0LE1hdGgubWluKGUsbikpfWZ1bmN0aW9uIGIodCl7cmV0dXJuIHQlMj09MD90OnQrMX1mdW5jdGlvbiB3KHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoO24rKyllKz10W25dO3JldHVybiBlfWZ1bmN0aW9uIEModCxlKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplKCkpfWZ1bmN0aW9uIEUodCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiXCIpLEMoUyh0LGUpLChmdW5jdGlvbigpe3JldHVybiBuK1wiIFNoYXBlcyBcIit0K1wiIGFuZCBcIitlK1wiIG11c3QgbWF0Y2hcIn0pKX1mdW5jdGlvbiBSKHQpe0MobnVsbCE9dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBpbnB1dCB0byB0aGUgdGVuc29yIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBub24tbnVsbCB2YWx1ZS5cIn0pKX1mdW5jdGlvbiBJKHQsZSxuKXtpZih2b2lkIDA9PT1lJiYoZT1bXSksdm9pZCAwPT09biYmKG49ITEpLG51bGw9PWUmJihlPVtdKSxBcnJheS5pc0FycmF5KHQpfHxWKHQpJiYhbilmb3IodmFyIHI9MDtyPHQubGVuZ3RoOysrcilJKHRbcl0sZSxuKTtlbHNlIGUucHVzaCh0KTtyZXR1cm4gZX1mdW5jdGlvbiBrKHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gMTtmb3IodmFyIGU9dFswXSxuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBTKHQsZSl7aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09dHx8bnVsbD09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKHRbbl0hPT1lW25dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEEodCl7cmV0dXJuIHQlMT09MH1mdW5jdGlvbiBEKHQpe2lmKG51bGwhPU1hdGgudGFuaClyZXR1cm4gTWF0aC50YW5oKHQpO2lmKHQ9PT0xLzApcmV0dXJuIDE7aWYodD09PS0xLzApcmV0dXJuLTE7dmFyIGU9TWF0aC5leHAoMip0KTtyZXR1cm4oZS0xKS8oZSsxKX1mdW5jdGlvbiBUKHQpe3ZhciBlPU1hdGguY2VpbChNYXRoLnNxcnQodCkpO3JldHVybltlLE1hdGguY2VpbCh0L2UpXX1mdW5jdGlvbiBOKHQsZSl7cmV0dXJuIGU8PXQubGVuZ3RoP3Q6dCtcIiBcIi5yZXBlYXQoZS10Lmxlbmd0aCl9ZnVuY3Rpb24gRih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPWZ1bmN0aW9uKHQpe3JldHVybiAwfSksbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbyl7dmFyIGE9MCxpPWZ1bmN0aW9uKCl7aWYodCgpKXIoKTtlbHNle2ErKzt2YXIgcz1lKGEpO251bGwhPW4mJmE+PW4/bygpOnNldFRpbWVvdXQoaSxzKX19O2koKX0pKX1mdW5jdGlvbiBfKHQsZSl7Zm9yKHZhciBuPTEscj0tMSxvPTA7bzx0Lmxlbmd0aDsrK28paWYodFtvXT49MCluKj10W29dO2Vsc2UgaWYoLTE9PT10W29dKXtpZigtMSE9PXIpdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG9ubHkgaGF2ZSAxIGltcGxpY2l0IHNpemUuIEZvdW5kIC0xIGF0IGRpbSBcIityK1wiIGFuZCBkaW0gXCIrbyk7cj1vfWVsc2UgaWYodFtvXTwwKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBub3QgYmUgPCAwLiBGb3VuZCBcIit0W29dK1wiIGF0IGRpbSBcIitvKTtpZigtMT09PXIpe2lmKGU+MCYmZSE9PW4pdGhyb3cgRXJyb3IoXCJTaXplKFwiK2UrXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIrdCk7cmV0dXJuIHR9aWYoMD09PW4pdGhyb3cgRXJyb3IoXCJDYW5ub3QgaW5mZXIgdGhlIG1pc3Npbmcgc2l6ZSBpbiBbXCIrdCtcIl0gd2hlbiB0aGVyZSBhcmUgMCBlbGVtZW50c1wiKTtpZihlJW4hPTApdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gR290IFwiK2UrXCIgLyBcIituKTt2YXIgYT10LnNsaWNlKCk7cmV0dXJuIGFbcl09ZS9uLGF9ZnVuY3Rpb24gTyh0LGUpe3ZhciBuPWUubGVuZ3RoO3JldHVybiBDKCh0PW51bGw9PXQ/ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV9KSk6W10uY29uY2F0KHQpKS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PS1uJiZ0PG59KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLVwiK24rXCIsIFwiK24rXCIpIGJ1dCBnb3QgYXhpcyBcIit0fSkpLEModC5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIEEodCl9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgXCIrdH0pKSx0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9uK3Q6dH0pKX1mdW5jdGlvbiBNKHQsZSl7Zm9yKHZhciBuPVtdLHI9W10sbz1udWxsIT1lJiZBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgsYT1udWxsPT1lfHxvP251bGw6TyhlLHQpLnNvcnQoKSxpPTAscz0wO3M8dC5sZW5ndGg7KytzKXtpZihudWxsIT1hKXtpZihhW2ldPT09cyYmMSE9PXRbc10pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3F1ZWV6ZSBheGlzIFwiK3MrXCIgc2luY2UgaXRzIGRpbSAnXCIrdFtzXStcIicgaXMgbm90IDFcIik7KG51bGw9PWFbaV18fGFbaV0+cykmJjE9PT10W3NdJiYobi5wdXNoKHRbc10pLHIucHVzaChzKSksYVtpXTw9cyYmaSsrfTEhPT10W3NdJiYobi5wdXNoKHRbc10pLHIucHVzaChzKSl9cmV0dXJue25ld1NoYXBlOm4sa2VwdERpbXM6cn19ZnVuY3Rpb24gQih0LGUpe3ZhciBuPW51bGw7aWYobnVsbD09dHx8XCJmbG9hdDMyXCI9PT10KW49bmV3IEZsb2F0MzJBcnJheShlKTtlbHNlIGlmKFwiaW50MzJcIj09PXQpbj1uZXcgSW50MzJBcnJheShlKTtlbHNle2lmKFwiYm9vbFwiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KTtuPW5ldyBVaW50OEFycmF5KGUpfXJldHVybiBufWZ1bmN0aW9uIFAodCxlKXt2YXIgbj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dCluPW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT10KW49bmV3IEludDMyQXJyYXkoZSk7ZWxzZSBpZihcImJvb2xcIj09PXQpbj1uZXcgVWludDhBcnJheShlKTtlbHNle2lmKFwic3RyaW5nXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpO249bmV3IEFycmF5KGUpfXJldHVybiBufWZ1bmN0aW9uIEwodCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtpZihpc05hTihyKXx8IWlzRmluaXRlKHIpKXRocm93IEVycm9yKFwiQSB0ZW5zb3Igb2YgdHlwZSBcIitlK1wiIGJlaW5nIHVwbG9hZGVkIGNvbnRhaW5zIFwiK3IrXCIuXCIpfX1mdW5jdGlvbiBXKHQpe3JldHVyblwiYm9vbFwiPT09dHx8XCJjb21wbGV4NjRcIj09PXR8fFwiZmxvYXQzMlwiPT09dHx8XCJpbnQzMlwiPT09dHx8XCJzdHJpbmdcIj09PXR9ZnVuY3Rpb24gVSh0LGUpe3JldHVyblwiY29tcGxleDY0XCIhPT1lJiYoKFwiZmxvYXQzMlwiIT09ZXx8XCJjb21wbGV4NjRcIj09PXQpJiYoKFwiaW50MzJcIiE9PWV8fFwiZmxvYXQzMlwiPT09dHx8XCJjb21wbGV4NjRcIj09PXQpJiYoXCJib29sXCIhPT1lfHxcImJvb2xcIiE9PXQpKSl9ZnVuY3Rpb24gVih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fWZ1bmN0aW9uIHoodCl7aWYoXCJmbG9hdDMyXCI9PT10fHxcImludDMyXCI9PT10KXJldHVybiA0O2lmKFwiY29tcGxleDY0XCI9PT10KXJldHVybiA4O2lmKFwiYm9vbFwiPT09dClyZXR1cm4gMTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiK3QpfWZ1bmN0aW9uIEcodCl7aWYobnVsbD09dClyZXR1cm4gMDt2YXIgZT0wO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlKz10Lmxlbmd0aH0pKSxlfWZ1bmN0aW9uIEgodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9ZnVuY3Rpb24gcSh0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9ZnVuY3Rpb24gSyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH1mdW5jdGlvbiBqKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP2oodFswXSk6dCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9cImZsb2F0MzJcIjp0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/XCJpbnQzMlwiOksodCk/XCJmbG9hdDMyXCI6SCh0KT9cInN0cmluZ1wiOnEodCk/XCJib29sXCI6XCJmbG9hdDMyXCJ9ZnVuY3Rpb24gWCh0KXtyZXR1cm4hISh0JiZ0LmNvbnN0cnVjdG9yJiZ0LmNhbGwmJnQuYXBwbHkpfWZ1bmN0aW9uIFkodCxlKXtmb3IodmFyIG49ZTtuPHQ7KytuKWlmKHQlbj09MClyZXR1cm4gbjtyZXR1cm4gdH1mdW5jdGlvbiAkKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU8MilyZXR1cm5bXTt2YXIgbj1uZXcgQXJyYXkoZS0xKTtuW2UtMl09dFtlLTFdO2Zvcih2YXIgcj1lLTM7cj49MDstLXIpbltyXT1uW3IrMV0qdFtyKzFdO3JldHVybiBufWZ1bmN0aW9uIFEodCxlLG4pe2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgc3RyaW5nW10gdG8gYSBUeXBlZEFycmF5XCIpO2lmKEFycmF5LmlzQXJyYXkodCkmJih0PUkodCkpLG4mJkwodCxlKSxmdW5jdGlvbih0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5JiZcImZsb2F0MzJcIj09PWV8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5JiZcImludDMyXCI9PT1lfHx0IGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJib29sXCI9PT1lfSh0LGUpKXJldHVybiB0O2lmKG51bGw9PWV8fFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCk7aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbmV3IEludDMyQXJyYXkodCk7aWYoXCJib29sXCI9PT1lKXtmb3IodmFyIHI9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLG89MDtvPHIubGVuZ3RoOysrbykwIT09TWF0aC5yb3VuZCh0W29dKSYmKHJbb109MSk7cmV0dXJuIHJ9dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrZSl9ZnVuY3Rpb24gSih0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZVswXTt2YXIgbj10LnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpO2lmKDA9PT1uKXJldHVybltdO2lmKG4hPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJbXCIrdCtcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIGlucHV0IHNpemUuXCIpO3JldHVybiBmdW5jdGlvbiB0KGUsbixyKXt2YXIgbz1uZXcgQXJyYXk7aWYoMT09PW4ubGVuZ3RoKWZvcih2YXIgYT1uWzBdLGk9MDtpPGE7aSsrKW9baV09cltlK2ldO2Vsc2V7YT1uWzBdO3ZhciBzPW4uc2xpY2UoMSksdT1zLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpO2ZvcihpPTA7aTxhO2krKylvW2ldPXQoZStpKnUscyxyKX1yZXR1cm4gb30oMCx0LGUpfWZ1bmN0aW9uIFoodCxlKXtmb3IodmFyIG49dHQodCxlKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT0xO3JldHVybiBufWZ1bmN0aW9uIHR0KHQsZSl7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0KTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheSh0KTtpZihcImJvb2xcIj09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KHQpO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfWZ1bmN0aW9uIGV0KCl7cmV0dXJuIGkoKS5wbGF0Zm9ybS5ub3coKX1mdW5jdGlvbiBudCh0KXt0LmZvckVhY2goKGZ1bmN0aW9uKGUpe0MoTnVtYmVyLmlzSW50ZWdlcihlKSYmZT49MCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRlbnNvciBtdXN0IGhhdmUgYSBzaGFwZSBjb21wcmlzZWQgb2YgcG9zaXRpdmUgaW50ZWdlcnMgYnV0IGdvdCBzaGFwZSBbXCIrdCtcIl0uXCJ9KSl9KSl9ZnVuY3Rpb24gcnQodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ1dGYtOFwiKSxlPWV8fFwidXRmLThcIixpKCkucGxhdGZvcm0uZW5jb2RlKHQsZSl9ZnVuY3Rpb24gb3QodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ1dGYtOFwiKSxlPWV8fFwidXRmLThcIixpKCkucGxhdGZvcm0uZGVjb2RlKHQsZSl9ZnVuY3Rpb24gYXQodCxlLG4pe2lmKDA9PT1lKXJldHVybiAwO2lmKDE9PT1lKXJldHVybiB0WzBdO2Zvcih2YXIgcj10W3QubGVuZ3RoLTFdLG89MDtvPHQubGVuZ3RoLTE7KytvKXIrPW5bb10qdFtvXTtyZXR1cm4gcn1mdW5jdGlvbiBpdCh0LGUsbil7aWYoMD09PWUpcmV0dXJuW107aWYoMT09PWUpcmV0dXJuW3RdO2Zvcih2YXIgcj1uZXcgQXJyYXkoZSksbz0wO288ci5sZW5ndGgtMTsrK28pcltvXT1NYXRoLmZsb29yKHQvbltvXSksdC09cltvXSpuW29dO3JldHVybiByW3IubGVuZ3RoLTFdPXQscn12YXIgc3Q9T2JqZWN0LmZyZWV6ZSh7c2h1ZmZsZTp5LGNsYW1wOngsbmVhcmVzdExhcmdlckV2ZW46YixzdW06dyxyYW5kVW5pZm9ybTpmdW5jdGlvbih0LGUpe3ZhciBuPU1hdGgucmFuZG9tKCk7cmV0dXJuIGUqbisoMS1uKSp0fSxkaXN0U3F1YXJlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89TnVtYmVyKHRbcl0pLU51bWJlcihlW3JdKTtuKz1vKm99cmV0dXJuIG59LGFzc2VydDpDLGFzc2VydFNoYXBlc01hdGNoOkUsYXNzZXJ0Tm9uTnVsbDpSLGZsYXR0ZW46SSxzaXplRnJvbVNoYXBlOmssaXNTY2FsYXJTaGFwZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQubGVuZ3RofSxhcnJheXNFcXVhbDpTLGlzSW50OkEsdGFuaDpELHNpemVUb1NxdWFyaXNoU2hhcGU6VCxjcmVhdGVTaHVmZmxlZEluZGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBVaW50MzJBcnJheSh0KSxuPTA7bjx0OysrbillW25dPW47cmV0dXJuIHkoZSksZX0scmlnaHRQYWQ6TixyZXBlYXRlZFRyeTpGLGluZmVyRnJvbUltcGxpY2l0U2hhcGU6XyxwYXJzZUF4aXNQYXJhbTpPLHNxdWVlemVTaGFwZTpNLGdldFR5cGVkQXJyYXlGcm9tRFR5cGU6QixnZXRBcnJheUZyb21EVHlwZTpQLGNoZWNrQ29udmVyc2lvbkZvckVycm9yczpMLGlzVmFsaWREdHlwZTpXLGhhc0VuY29kaW5nTG9zczpVLGlzVHlwZWRBcnJheTpWLGJ5dGVzUGVyRWxlbWVudDp6LGJ5dGVzRnJvbVN0cmluZ0FycmF5OkcsaXNTdHJpbmc6SCxpc0Jvb2xlYW46cSxpc051bWJlcjpLLGluZmVyRHR5cGU6aixpc0Z1bmN0aW9uOlgsbmVhcmVzdERpdmlzb3I6WSxjb21wdXRlU3RyaWRlczokLHRvVHlwZWRBcnJheTpRLHRvTmVzdGVkQXJyYXk6SixtYWtlT25lc1R5cGVkQXJyYXk6WixtYWtlWmVyb3NUeXBlZEFycmF5OnR0LG5vdzpldCxhc3NlcnROb25OZWdhdGl2ZUludGVnZXJEaW1lbnNpb25zOm50LGZldGNoOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGkoKS5wbGF0Zm9ybS5mZXRjaCh0LGUpfSxlbmNvZGVTdHJpbmc6cnQsZGVjb2RlU3RyaW5nOm90LGxvY1RvSW5kZXg6YXQsaW5kZXhUb0xvYzppdH0pLHV0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuYmFja2VuZFRpbWVyPXQsdGhpcy5sb2dnZXI9ZSxudWxsPT1lJiYodGhpcy5sb2dnZXI9bmV3IGN0KX1yZXR1cm4gdC5wcm90b3R5cGUucHJvZmlsZUtlcm5lbD1mdW5jdGlvbih0LGUsbil7dmFyIHIsbz10aGlzLGE9dGhpcy5iYWNrZW5kVGltZXIudGltZSgoZnVuY3Rpb24oKXtyPW4oKX0pKTtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbihuKXtuLmRhdGEoKS50aGVuKChmdW5jdGlvbihyKXshZnVuY3Rpb24odCxlLG4pe2lmKFwiZmxvYXQzMlwiIT09ZSlyZXR1cm4hMTtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89dFtyXTtpZihpc05hTihvKXx8IWlzRmluaXRlKG8pKXJldHVybiBjb25zb2xlLndhcm4oXCJGb3VuZCBcIitvK1wiIGluIHRoZSByZXN1bHQgb2YgJ1wiK24rXCInXCIpLCEwfX0ocixuLmR0eXBlLHQpLGEudGhlbigoZnVuY3Rpb24oYSl7dmFyIGk9XCJcIjtudWxsIT1hLmdldEV4dHJhUHJvZmlsZUluZm8mJihpPWEuZ2V0RXh0cmFQcm9maWxlSW5mbygpKSxvLmxvZ2dlci5sb2dLZXJuZWxQcm9maWxlKHQsbixyLGEua2VybmVsTXMsZSxpKX0pKX0pKX0pKSxyfSx0fSgpO3ZhciBjdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmxvZ0tlcm5lbFByb2ZpbGU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPVwibnVtYmVyXCI9PXR5cGVvZiByP04ocitcIm1zXCIsOSk6ci5lcnJvcixzPU4odCwyNSksdT1lLnJhbmssYz1lLnNpemUsbD1OKGUuc2hhcGUudG9TdHJpbmcoKSwxNCksaD1cIlwiO2Zvcih2YXIgZiBpbiBvKXt2YXIgZD1vW2ZdLnNoYXBlfHxlLnNoYXBlLHA9ZC5sZW5ndGg7aCs9ZitcIjogXCIrcCtcIkQgXCIrKHA+MD9kOlwiXCIpK1wiIFwifWNvbnNvbGUubG9nKFwiJWNcIitzK1wiXFx0JWNcIitpK1wiXFx0JWNcIit1K1wiRCBcIitsK1wiXFx0JWNcIitjK1wiXFx0JWNcIitoK1wiXFx0JWNcIithLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6cmVkXCIsXCJjb2xvcjpibHVlXCIsXCJjb2xvcjogb3JhbmdlXCIsXCJjb2xvcjogZ3JlZW5cIixcImNvbG9yOiBzdGVlbGJsdWVcIil9LHR9KCk7dmFyIGx0PTIwLGh0PTMsZnQ9NztmdW5jdGlvbiBkdCh0LGUsbixyKXt2YXIgbz0kKGUpLGE9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89ayhlKSxhPXJbci5sZW5ndGgtMV0saT1uZXcgQXJyYXkoYSkuZmlsbCgwKSxzPWUubGVuZ3RoLHU9XCJjb21wbGV4NjRcIj09PW4/bXQodCk6dDtpZihzPjEpZm9yKHZhciBjPTA7YzxvL2E7YysrKWZvcih2YXIgbD1jKmEsaD0wO2g8YTtoKyspaVtoXT1NYXRoLm1heChpW2hdLHB0KHVbbCtoXSwwLG4pLmxlbmd0aCk7cmV0dXJuIGl9KHQsZSxuLG8pLGk9ZS5sZW5ndGgscz1mdW5jdGlvbiB0KGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT0hMCk7dmFyIHM9XCJjb21wbGV4NjRcIj09PXI/MjoxLHU9blswXSxjPW4ubGVuZ3RoO2lmKDA9PT1jKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09cj9bcHQobXQoZSlbMF0sMCxyKV06XCJib29sXCI9PT1yP1t2dChlWzBdKV06W2VbMF0udG9TdHJpbmcoKV19aWYoMT09PWMpe2lmKHU+bHQpe3ZhciBsPWh0KnMsaD1BcnJheS5mcm9tKGUuc2xpY2UoMCxsKSksZj1BcnJheS5mcm9tKGUuc2xpY2UoKHUtaHQpKnMsdSpzKSk7cmV0dXJuXCJjb21wbGV4NjRcIj09PXImJihoPW10KGgpLGY9bXQoZikpLFtcIltcIitoLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcHQodCxhW2VdLHIpfSkpLmpvaW4oXCIsIFwiKStcIiwgLi4uLCBcIitmLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcHQodCxhW3UtaHQrZV0scil9KSkuam9pbihcIiwgXCIpK1wiXVwiXX1yZXR1cm5bXCJbXCIrKFwiY29tcGxleDY0XCI9PT1yP210KGUpOkFycmF5LmZyb20oZSkpLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcHQodCxhW2VdLHIpfSkpLmpvaW4oXCIsIFwiKStcIl1cIl19dmFyIGQ9bi5zbGljZSgxKSxwPW8uc2xpY2UoMSksdj1vWzBdKnMsbT1bXTtpZih1Pmx0KXtmb3IodmFyIGc9MDtnPGh0O2crKyl7dmFyIHk9KHg9Zyp2KSt2O20ucHVzaC5hcHBseShtLHQoZS5zbGljZSh4LHkpLGQscixwLGEsITEpKX1tLnB1c2goXCIuLi5cIik7Zm9yKGc9dS1odDtnPHU7ZysrKXt5PSh4PWcqdikrdjttLnB1c2guYXBwbHkobSx0KGUuc2xpY2UoeCx5KSxkLHIscCxhLGc9PT11LTEpKX19ZWxzZSBmb3IoZz0wO2c8dTtnKyspe3ZhciB4O3k9KHg9Zyp2KSt2O20ucHVzaC5hcHBseShtLHQoZS5zbGljZSh4LHkpLGQscixwLGEsZz09PXUtMSkpfXZhciBiPTI9PT1jP1wiLFwiOlwiXCI7bVswXT1cIltcIittWzBdK2I7Zm9yKGc9MTtnPG0ubGVuZ3RoLTE7ZysrKW1bZ109XCIgXCIrbVtnXStiO3ZhciB3PVwiLFxcblwiO2ZvcihnPTI7ZzxjO2crKyl3Kz1cIlxcblwiO3JldHVybiBtW20ubGVuZ3RoLTFdPVwiIFwiK21bbS5sZW5ndGgtMV0rXCJdXCIrKGk/XCJcIjp3KSxtfSh0LGUsbixvLGEpLHU9W1wiVGVuc29yXCJdO3JldHVybiByJiYodS5wdXNoKFwiICBkdHlwZTogXCIrbiksdS5wdXNoKFwiICByYW5rOiBcIitpKSx1LnB1c2goXCIgIHNoYXBlOiBbXCIrZStcIl1cIiksdS5wdXNoKFwiICB2YWx1ZXM6XCIpKSx1LnB1c2gocy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiICAgIFwiK3R9KSkuam9pbihcIlxcblwiKSksdS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIHB0KHQsZSxuKXtyZXR1cm4gTihBcnJheS5pc0FycmF5KHQpP3BhcnNlRmxvYXQodFswXS50b0ZpeGVkKGZ0KSkrXCIgKyBcIitwYXJzZUZsb2F0KHRbMV0udG9GaXhlZChmdCkpK1wialwiOkgodCk/XCInXCIrdCtcIidcIjpcImJvb2xcIj09PW4/dnQodCk6cGFyc2VGbG9hdCh0LnRvRml4ZWQoZnQpKS50b1N0cmluZygpLGUpfWZ1bmN0aW9uIHZ0KHQpe3JldHVybiAwPT09dD9cImZhbHNlXCI6XCJ0cnVlXCJ9ZnVuY3Rpb24gbXQodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rPTIpZS5wdXNoKFt0W25dLHRbbisxXV0pO3JldHVybiBlfXZhciBndD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3ZhciByPXRoaXM7aWYodGhpcy5kdHlwZT1lLHRoaXMuc2hhcGU9dC5zbGljZSgpLHRoaXMuc2l6ZT1rKHQpLG51bGwhPW4pe3ZhciBvPW4ubGVuZ3RoO0Mobz09PXRoaXMuc2l6ZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkxlbmd0aCBvZiB2YWx1ZXMgJ1wiK28rXCInIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIGluZmVycmVkIGJ5IHRoZSBzaGFwZSAnXCIrci5zaXplK1wiJy5cIn0pKX1pZihcImNvbXBsZXg2NFwiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJjb21wbGV4NjQgZHR5cGUgVGVuc29yQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGNyZWF0ZSBhIFRlbnNvckJ1ZmZlciBmb3IgdGhlIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cyBzZXBhcmF0ZWx5IGFuZCBjYWxsIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMudmFsdWVzPW58fFAoZSx0aGlzLnNpemUpLHRoaXMuc3RyaWRlcz0kKHQpfXJldHVybiB0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMsbj1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyluW3ItMV09YXJndW1lbnRzW3JdOzA9PT1uLmxlbmd0aCYmKG49WzBdKSxDKG4ubGVuZ3RoPT09dGhpcy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG51bWJlciBvZiBwcm92aWRlZCBjb29yZGluYXRlcyAoXCIrbi5sZW5ndGgrXCIpIG11c3QgbWF0Y2ggdGhlIHJhbmsgKFwiK2UucmFuaytcIilcIn0pKTt2YXIgbz10aGlzLmxvY1RvSW5kZXgobik7dGhpcy52YWx1ZXNbb109dH0sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdOzA9PT10Lmxlbmd0aCYmKHQ9WzBdKTtmb3IodmFyIG49MCxyPTAsbz10O3I8by5sZW5ndGg7cisrKXt2YXIgYT1vW3JdO2lmKGE8MHx8YT49dGhpcy5zaGFwZVtuXSl7dmFyIGk9XCJSZXF1ZXN0ZWQgb3V0IG9mIHJhbmdlIGVsZW1lbnQgYXQgXCIrdCtcIi4gICBCdWZmZXIgc2hhcGU9XCIrdGhpcy5zaGFwZTt0aHJvdyBuZXcgRXJyb3IoaSl9bisrfWZvcih2YXIgcz10W3QubGVuZ3RoLTFdLHU9MDt1PHQubGVuZ3RoLTE7Kyt1KXMrPXRoaXMuc3RyaWRlc1t1XSp0W3VdO3JldHVybiB0aGlzLnZhbHVlc1tzXX0sdC5wcm90b3R5cGUubG9jVG9JbmRleD1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5yYW5rKXJldHVybiAwO2lmKDE9PT10aGlzLnJhbmspcmV0dXJuIHRbMF07Zm9yKHZhciBlPXRbdC5sZW5ndGgtMV0sbj0wO248dC5sZW5ndGgtMTsrK24pZSs9dGhpcy5zdHJpZGVzW25dKnRbbl07cmV0dXJuIGV9LHQucHJvdG90eXBlLmluZGV4VG9Mb2M9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMucmFuaylyZXR1cm5bXTtpZigxPT09dGhpcy5yYW5rKXJldHVyblt0XTtmb3IodmFyIGU9bmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aC0xOysrbillW25dPU1hdGguZmxvb3IodC90aGlzLnN0cmlkZXNbbl0pLHQtPWVbbl0qdGhpcy5zdHJpZGVzW25dO3JldHVybiBlW2UubGVuZ3RoLTFdPXQsZX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUudG9UZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4geXQoKS5tYWtlVGVuc29yKHRoaXMudmFsdWVzLHRoaXMuc2hhcGUsdGhpcy5kdHlwZSl9LHR9KCkseXQ9bnVsbCx4dD1udWxsLGJ0PW51bGw7dmFyIHd0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyKXt0aGlzLmtlcHQ9ITEsdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITEsdGhpcy5zaGFwZT10LnNsaWNlKCksdGhpcy5kdHlwZT1lfHxcImZsb2F0MzJcIix0aGlzLnNpemU9ayh0KSx0aGlzLnN0cmlkZXM9JCh0KSx0aGlzLmRhdGFJZD1uLHRoaXMuaWQ9cix0aGlzLnJhbmtUeXBlPXRoaXMucmFuazw1P3RoaXMucmFuay50b1N0cmluZygpOlwiaGlnaGVyXCJ9cmV0dXJuIHQucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmFzMUQoKX0sdC5wcm90b3R5cGUuYXNTY2FsYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxDKDE9PT10aGlzLnNpemUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJyYXkgbXVzdCBoYXZlIG9ubHkgMSBlbGVtZW50LlwifSkpLHRoaXMucmVzaGFwZShbXSl9LHQucHJvdG90eXBlLmFzMUQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pfSx0LnByb3RvdHlwZS5hczJEPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGVdKX0sdC5wcm90b3R5cGUuYXMzRD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbl0pfSx0LnByb3RvdHlwZS5hczREPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlLG4scl0pfSx0LnByb3RvdHlwZS5hczVEPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbixyLG9dKX0sdC5wcm90b3R5cGUuYXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNhc3QodGhpcyx0KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSxbMix4dC5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHQpXX19KSl9KSl9LHQucHJvdG90eXBlLmJ1ZmZlclN5bmM9ZnVuY3Rpb24oKXtyZXR1cm4geHQuYnVmZmVyKHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0aGlzLmRhdGFTeW5jKCkpfSx0LnByb3RvdHlwZS5hcnJheT1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksWzIsSih0aGlzLnNoYXBlLHQpXX19KSl9KSl9LHQucHJvdG90eXBlLmFycmF5U3luYz1mdW5jdGlvbigpe3JldHVybiBKKHRoaXMuc2hhcGUsdGhpcy5kYXRhU3luYygpKX0sdC5wcm90b3R5cGUuZGF0YT1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdD15dCgpLnJlYWQodGhpcy5kYXRhSWQpLFwic3RyaW5nXCIhPT10aGlzLmR0eXBlP1szLDJdOls0LHRdO2Nhc2UgMTplPW4uc2VudCgpO3RyeXtyZXR1cm5bMixlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG90KHQpfSkpXX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIHRoZSBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOC4gVG8gZ2V0IHRoZSBvcmlnaW5hbCBieXRlcywgY2FsbCB0ZW5zb3IuYnl0ZXMoKS5cIil9bi5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMix0XX19KSl9KSl9LHQucHJvdG90eXBlLmRhdGFTeW5jPWZ1bmN0aW9uKCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgdD15dCgpLnJlYWRTeW5jKHRoaXMuZGF0YUlkKTtpZihcInN0cmluZ1wiPT09dGhpcy5kdHlwZSl0cnl7cmV0dXJuIHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gb3QodCl9KSl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSB0aGUgc3RyaW5nIGJ5dGVzIGludG8gdXRmLTguIFRvIGdldCB0aGUgb3JpZ2luYWwgYnl0ZXMsIGNhbGwgdGVuc29yLmJ5dGVzKCkuXCIpfXJldHVybiB0fSx0LnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFs0LHl0KCkucmVhZCh0aGlzLmRhdGFJZCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSxcInN0cmluZ1wiPT09dGhpcy5kdHlwZT9bMix0XTpbMixuZXcgVWludDhBcnJheSh0LmJ1ZmZlcildfX0pKX0pKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuaXNEaXNwb3NlZHx8KHl0KCkuZGlzcG9zZVRlbnNvcih0aGlzKSx0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlzRGlzcG9zZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNEaXNwb3NlZEludGVybmFsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNEaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaXMgZGlzcG9zZWQuXCIpfSx0LnByb3RvdHlwZS50b0Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiZmxvYXQzMlwiKX0sdC5wcm90b3R5cGUudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUudG9Cb29sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiYm9vbFwiKX0sdC5wcm90b3R5cGUucHJpbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx4dC5wcmludCh0aGlzLHQpfSx0LnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJlc2hhcGUodGhpcyx0KX0sdC5wcm90b3R5cGUucmVzaGFwZUFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZSh0LnNoYXBlKX0sdC5wcm90b3R5cGUuZXhwYW5kRGltcz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCkseHQuZXhwYW5kRGltcyh0aGlzLHQpfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49ITEpLHh0LmN1bXN1bSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuc3F1ZWV6ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcXVlZXplKHRoaXMsdCl9LHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY2xvbmUodGhpcyl9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQub25lSG90KHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLGR0KHRoaXMuZGF0YVN5bmMoKSx0aGlzLnNoYXBlLHRoaXMuZHR5cGUsdCl9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudGlsZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5nYXRoZXIodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5tYXRNdWw9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWF0TXVsKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS5kb3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZG90KHRoaXMsdCl9LHQucHJvdG90eXBlLm5vcm09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD1cImV1Y2xpZGVhblwiKSx2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5ub3JtKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNsaWNlKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yZXZlcnNlKHRoaXMsdCl9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbihlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGUgaW5zdGFuY2VvZiB0JiYoZT1bZV0pLHh0LmNvbmNhdChbdGhpc10uY29uY2F0KGUpLG4pfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwbGl0KHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3RhY2s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCkseHQuc3RhY2soW3RoaXMsdF0sZSl9LHQucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHh0LnVuc3RhY2sodGhpcyx0KX0sdC5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHh0LnBhZCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1uJiYobj0uMDAxKSxidChcInRmLmJhdGNoTm9ybWFsaXphdGlvbigpIGlzIGdvaW5nIGF3YXkuIFVzZSB0Zi5iYXRjaE5vcm0oKSBpbnN0ZWFkLCBhbmQgbm90ZSB0aGUgcG9zaXRpb25hbCBhcmd1bWVudCBjaGFuZ2Ugb2Ygc2NhbGUsIG9mZnNldCwgYW5kIHZhcmlhbmNlRXBzaWxvblwiKSx0aGlzLmJhdGNoTm9ybSh0LGUsbyxyLG4pfSx0LnByb3RvdHlwZS5iYXRjaE5vcm09ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09byYmKG89LjAwMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5iYXRjaE5vcm0odGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYWxsKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFueSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmxvZ1N1bUV4cD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dTdW1FeHAodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3VtKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wcm9kKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWVhbj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tZWFuKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1pbih0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tYXgodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXJnTWluKHRoaXMsdCl9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hcmdNYXgodGhpcyx0KX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jYXN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hZGQodGhpcyx0KX0sdC5wcm90b3R5cGUuYWRkU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFkZFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hdGFuMih0aGlzLHQpfSx0LnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3ViKHRoaXMsdCl9LHQucHJvdG90eXBlLnN1YlN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zdWJTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnBvdyh0aGlzLHQpfSx0LnByb3RvdHlwZS5wb3dTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucG93U3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tdWwodGhpcyx0KX0sdC5wcm90b3R5cGUubXVsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm11bFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5kaXY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZGl2KHRoaXMsdCl9LHQucHJvdG90eXBlLmRpdk5vTmFuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRpdk5vTmFuKHRoaXMsdCl9LHQucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmZsb29yRGl2KHRoaXMsdCl9LHQucHJvdG90eXBlLmRpdlN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5kaXZTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5taW5pbXVtKHRoaXMsdCl9LHQucHJvdG90eXBlLm1pbmltdW1TdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWluaW11bVN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1heGltdW0odGhpcyx0KX0sdC5wcm90b3R5cGUubWF4aW11bVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tYXhpbXVtU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tb2QodGhpcyx0KX0sdC5wcm90b3R5cGUubW9kU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1vZFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudHJhbnNwb3NlKHRoaXMsdCl9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm5vdEVxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLm5vdEVxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm5vdEVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubGVzcyh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lmxlc3NTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUuZXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lmxlc3NFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubGVzc0VxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ3JlYXRlcih0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmdyZWF0ZXJTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmdyZWF0ZXJFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ3JlYXRlckVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9naWNhbEFuZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9naWNhbE9yKHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dpY2FsTm90KHRoaXMpfSx0LnByb3RvdHlwZS5sb2dpY2FsWG9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ2ljYWxYb3IodGhpcyx0KX0sdC5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC53aGVyZSh0LHRoaXMsZSl9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm5lZyh0aGlzKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNlaWwodGhpcyl9LHQucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZmxvb3IodGhpcyl9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zaWduKHRoaXMpfSx0LnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmlzTmFOKHRoaXMpfSx0LnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmlzSW5mKHRoaXMpfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmlzRmluaXRlKHRoaXMpfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5leHAodGhpcyl9LHQucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXhwbTEodGhpcyl9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZyh0aGlzKX0sdC5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2cxcCh0aGlzKX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNxcnQodGhpcyl9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucnNxcnQodGhpcyl9LHQucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNxdWFyZSh0aGlzKX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJlY2lwcm9jYWwodGhpcyl9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFicyh0aGlzKX0sdC5wcm90b3R5cGUuY2xpcEJ5VmFsdWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jbGlwQnlWYWx1ZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5yZWx1Nj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJlbHU2KHRoaXMpfSx0LnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5lbHUodGhpcyl9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5sZWFreVJlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4yKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxlYWt5UmVsdSh0aGlzLHQpfSx0LnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wcmVsdSh0aGlzLHQpfSx0LnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2lnbW9pZCh0aGlzKX0sdC5wcm90b3R5cGUubG9nU2lnbW9pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ1NpZ21vaWQodGhpcyl9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc29mdHBsdXModGhpcyl9LHQucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lnplcm9zTGlrZSh0aGlzKX0sdC5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5vbmVzTGlrZSh0aGlzKX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2luKHRoaXMpfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb3ModGhpcyl9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnRhbih0aGlzKX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFzaW4odGhpcyl9LHQucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hY29zKHRoaXMpfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXRhbih0aGlzKX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNpbmgodGhpcyl9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb3NoKHRoaXMpfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudGFuaCh0aGlzKX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hc2luaCh0aGlzKX0sdC5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hY29zaCh0aGlzKX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hdGFuaCh0aGlzKX0sdC5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXJmKHRoaXMpfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJvdW5kKHRoaXMpfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN0ZXAodGhpcyx0KX0sdC5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc29mdG1heCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dTb2Z0bWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dTb2Z0bWF4KHRoaXMsdCl9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmltYWdlLnJlc2l6ZUJpbGluZWFyKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmltYWdlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLmNvbnYxZD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTldDXCIpLHZvaWQgMD09PW8mJihvPTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY29udjFkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5IV0NcIiksdm9pZCAwPT09byYmKG89WzEsMV0pLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2U9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb252MmRUcmFuc3Bvc2UodGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5IV0NcIiksdm9pZCAwPT09byYmKG89WzEsMV0pLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZGVwdGh3aXNlQ29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5zZXBhcmFibGVDb252MmQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1vJiYobz1bMSwxXSksdm9pZCAwPT09YSYmKGE9XCJOSFdDXCIpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2VwYXJhYmxlQ29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmF2Z1Bvb2wodGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tYXhQb29sKHRoaXMsdCxlLG4scil9LHQucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB2b2lkIDA9PT10JiYodD01KSx2b2lkIDA9PT1lJiYoZT0xKSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0uNSkseHQubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24odGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUucG9vbD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnBvb2wodGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS52YXJpYWJsZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHl0KCkubWFrZVZhcmlhYmxlKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC51bnNvcnRlZFNlZ21lbnRTdW0odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmJhdGNoVG9TcGFjZU5EKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGFjZVRvQmF0Y2hORCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MSksdm9pZCAwPT09ZSYmKGU9ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudG9wayh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz0wKSx2b2lkIDA9PT1hJiYoYT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1zJiYocz0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN0cmlkZWRTbGljZSh0aGlzLHQsZSxuLHIsbyxhLGkscyl9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRlcHRoVG9TcGFjZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwZWN0cmFsLmZmdCh0aGlzKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwZWN0cmFsLmlmZnQodGhpcyl9LHQucHJvdG90eXBlLnJmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGVjdHJhbC5yZmZ0KHRoaXMpfSx0LnByb3RvdHlwZS5pcmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwZWN0cmFsLmlyZmZ0KHRoaXMpfSx0fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3dCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiEhdCYmbnVsbCE9dC5kYXRhSWQmJm51bGwhPXQuc2hhcGUmJm51bGwhPXQuZHR5cGV9fSk7dmFyIEN0LEV0LFJ0LEl0LGt0LFN0PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIsbyl7dmFyIGE9dC5jYWxsKHRoaXMsZS5zaGFwZSxlLmR0eXBlLGUuZGF0YUlkLG8pfHx0aGlzO3JldHVybiBhLnRyYWluYWJsZT1uLGEubmFtZT1yLGF9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hc3NpZ249ZnVuY3Rpb24odCl7aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiZHR5cGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrdC5kdHlwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLmR0eXBlK1wiKSBtdXN0IG1hdGNoXCIpO2lmKCFTKHQuc2hhcGUsdGhpcy5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrdC5zaGFwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLnNoYXBlK1wiKSBtdXN0IG1hdGNoXCIpO3l0KCkuZGlzcG9zZVRlbnNvcih0aGlzKSx0aGlzLmRhdGFJZD10LmRhdGFJZCx5dCgpLmluY1JlZih0aGlzLG51bGwpfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7eXQoKS5kaXNwb3NlVmFyaWFibGUodGhpcyksdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITB9LG59KHd0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoU3QsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0JiZudWxsIT10LmFzc2lnbiYmdC5hc3NpZ24gaW5zdGFuY2VvZiBGdW5jdGlvbn19KSxmdW5jdGlvbih0KXt0LlIwPVwiUjBcIix0LlIxPVwiUjFcIix0LlIyPVwiUjJcIix0LlIzPVwiUjNcIix0LlI0PVwiUjRcIix0LlI1PVwiUjVcIix0LlI2PVwiUjZcIn0oQ3R8fChDdD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiaW50MzJcIix0LmJvb2w9XCJpbnQzMlwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KEV0fHwoRXQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImludDMyXCIsdC5ib29sPVwiYm9vbFwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KFJ0fHwoUnQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImZsb2F0MzJcIix0LmJvb2w9XCJmbG9hdDMyXCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oSXR8fChJdD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImNvbXBsZXg2NFwiLHQuaW50MzI9XCJjb21wbGV4NjRcIix0LmJvb2w9XCJjb21wbGV4NjRcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShrdHx8KGt0PXt9KSk7dmFyIEF0PXtmbG9hdDMyOkl0LGludDMyOkV0LGJvb2w6UnQsY29tcGxleDY0Omt0fTtmdW5jdGlvbiBEdCh0LGUpe2lmKFwic3RyaW5nXCI9PT10fHxcInN0cmluZ1wiPT09ZSl7aWYoXCJzdHJpbmdcIj09PXQmJlwic3RyaW5nXCI9PT1lKXJldHVyblwic3RyaW5nXCI7dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCB1cGNhc3QgXCIrdCtcIiB3aXRoIFwiK2UpfXJldHVybiBBdFt0XVtlXX1mdW5jdGlvbiBUdCh0KXtyZXR1cm4gRHQodCxcImludDMyXCIpfWZ1bmN0aW9uIE50KHQsZSl7aWYodC5kdHlwZT09PWUuZHR5cGUpcmV0dXJuW3QsZV07dmFyIG49RHQodC5kdHlwZSxlLmR0eXBlKTtyZXR1cm5bdC5jYXN0KG4pLGUuY2FzdChuKV19ZnVuY3Rpb24gRnQodCxlKXtDKHQuZHR5cGU9PT1lLmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlcyBvZiB0aGUgZmlyc3QoXCIrdC5kdHlwZStcIikgYW5kIHNlY29uZChcIitlLmR0eXBlK1wiKSBpbnB1dCBtdXN0IG1hdGNoXCJ9KSl9ZnVuY3Rpb24gX3QodCl7dmFyIGU9W107cmV0dXJuIGZ1bmN0aW9uIHQoZSxuLHIpe2lmKG51bGw9PWUpcmV0dXJuO2lmKGUgaW5zdGFuY2VvZiB3dClyZXR1cm4gdm9pZCBuLnB1c2goZSk7aWYobz1lLCFBcnJheS5pc0FycmF5KG8pJiZcIm9iamVjdFwiIT10eXBlb2YgbylyZXR1cm47dmFyIG87dmFyIGE9ZTtmb3IodmFyIGkgaW4gYSl7dmFyIHM9YVtpXTtyLmhhcyhzKXx8KHIuYWRkKHMpLHQocyxuLHIpKX19KHQsZSxuZXcgU2V0KSxlfXZhciBPdCxNdD1PYmplY3QuZnJlZXplKHttYWtlVHlwZXNNYXRjaDpOdCxhc3NlcnRUeXBlc01hdGNoOkZ0LGlzVGVuc29ySW5MaXN0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT10LmlkfSkpfSxnZXRUZW5zb3JzSW5Db250YWluZXI6X3R9KSxCdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXM9e30sdGhpcy5uZXh0VGFwZU5vZGVJZD0wLHRoaXMubnVtQnl0ZXM9MCx0aGlzLm51bVRlbnNvcnM9MCx0aGlzLm51bVN0cmluZ1RlbnNvcnM9MCx0aGlzLm51bURhdGFCdWZmZXJzPTAsdGhpcy5ncmFkaWVudERlcHRoPTAsdGhpcy5rZXJuZWxEZXB0aD0wLHRoaXMuc2NvcGVTdGFjaz1bXSx0aGlzLm51bURhdGFNb3Zlc1N0YWNrPVtdLHRoaXMubmV4dFNjb3BlSWQ9MCx0aGlzLnRlbnNvckluZm89bmV3IFdlYWtNYXAsdGhpcy5wcm9maWxpbmc9ITEsdGhpcy5hY3RpdmVQcm9maWxlPXtuZXdCeXRlczowLG5ld1RlbnNvcnM6MCxwZWFrQnl0ZXM6MCxrZXJuZWxzOltdLHJlc3VsdDpudWxsfX1yZXR1cm4gdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMpdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3RdLmRpc3Bvc2UoKX0sdH0oKSxQdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5FTlY9dCx0aGlzLnJlZ2lzdHJ5PXt9LHRoaXMucmVnaXN0cnlGYWN0b3J5PXt9LHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQ9MCx0aGlzLnN0YXRlPW5ldyBCdH1yZXR1cm4gdC5wcm90b3R5cGUucmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYobnVsbCE9dGhpcy5wZW5kaW5nQmFja2VuZEluaXQpcmV0dXJuWzIsdGhpcy5wZW5kaW5nQmFja2VuZEluaXQudGhlbigoZnVuY3Rpb24oKXt9KSldO2lmKG51bGwhPXRoaXMuYmFja2VuZEluc3RhbmNlKXJldHVyblsyXTt0PXRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKSxlPTAsci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gZTx0Lmxlbmd0aD8obj10W2VdLFs0LHRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQobikuc3VjY2Vzc10pOlszLDVdO2Nhc2UgMjpyZXR1cm4gci5zZW50KCk/WzQsdGhpcy5zZXRCYWNrZW5kKG4pXTpbMyw0XTtjYXNlIDM6cmV0dXJuIHIuc2VudCgpLFsyXTtjYXNlIDQ6cmV0dXJuIGUrKyxbMywxXTtjYXNlIDU6dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX19KSl9KSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJhY2tlbmRcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5wZW5kaW5nQmFja2VuZEluaXQpdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCAnXCIrdGhpcy5iYWNrZW5kTmFtZStcIicgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXplZC4gTWFrZSBzdXJlIHRvIGF3YWl0IHRmLnJlYWR5KCkgb3IgYXdhaXQgdGYuc2V0QmFja2VuZCgpIGJlZm9yZSBjYWxsaW5nIG90aGVyIG1ldGhvZHNcIik7aWYobnVsbD09dGhpcy5iYWNrZW5kSW5zdGFuY2Upe3ZhciB0PXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdCgpLGU9dC5uYW1lO2lmKHQuYXN5bmNJbml0KXRocm93IG5ldyBFcnJvcihcIlRoZSBoaWdoZXN0IHByaW9yaXR5IGJhY2tlbmQgJ1wiK2UrXCInIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB0byBhd2FpdCB0Zi5yZWFkeSgpIG9yIGF3YWl0IHRmLnNldEJhY2tlbmQoKSBiZWZvcmUgY2FsbGluZyBvdGhlciBtZXRob2RzXCIpO3RoaXMuc2V0QmFja2VuZChlKX1yZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2V9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYmFja2VuZE5hbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KX0sdC5wcm90b3R5cGUuZmluZEJhY2tlbmQ9ZnVuY3Rpb24odCl7aWYoISh0IGluIHRoaXMucmVnaXN0cnkpKXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeUZhY3RvcnkpKXJldHVybiBudWxsO2lmKHRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQodCkuYXN5bmNJbml0KXJldHVybiBudWxsfXJldHVybiB0aGlzLnJlZ2lzdHJ5W3RdfSx0LnByb3RvdHlwZS5maW5kQmFja2VuZEZhY3Rvcnk9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5yZWdpc3RyeUZhY3Rvcnk/dGhpcy5yZWdpc3RyeUZhY3RvcnlbdF0uZmFjdG9yeTpudWxsfSx0LnByb3RvdHlwZS5yZWdpc3RlckJhY2tlbmQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0xKSx0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5Pyhjb25zb2xlLndhcm4odCtcIiBiYWNrZW5kIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQuIFJldXNpbmcgZXhpc3RpbmcgYmFja2VuZCBmYWN0b3J5LlwiKSwhMSk6KHRoaXMucmVnaXN0cnlGYWN0b3J5W3RdPXtmYWN0b3J5OmUscHJpb3JpdHk6bn0sITApfSx0LnByb3RvdHlwZS5zZXRCYWNrZW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG87cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihudWxsPT10aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kIG5hbWUgJ1wiK3QrXCInIG5vdCBmb3VuZCBpbiByZWdpc3RyeVwiKTtyZXR1cm4gdGhpcy5iYWNrZW5kTmFtZT10LG51bGwhPXRoaXMucmVnaXN0cnlbdF0/WzMsNF06KHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwsZT10aGlzLmluaXRpYWxpemVCYWNrZW5kKHQpLG49ZS5zdWNjZXNzLGUuYXN5bmNJbml0P1s0LG5dOlszLDJdKTtjYXNlIDE6cmV0dXJuIG89ci5zZW50KCksWzMsM107Y2FzZSAyOm89bixyLmxhYmVsPTM7Y2FzZSAzOmlmKCFvKXJldHVyblsyLCExXTtyLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiB0aGlzLmJhY2tlbmRJbnN0YW5jZT10aGlzLnJlZ2lzdHJ5W3RdLHRoaXMuc2V0dXBSZWdpc3RlcmVkS2VybmVscygpLHRoaXMucHJvZmlsZXI9bmV3IHV0KHRoaXMuYmFja2VuZEluc3RhbmNlKSxbMiwhMF19fSkpfSkpfSx0LnByb3RvdHlwZS5zZXR1cFJlZ2lzdGVyZWRLZXJuZWxzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztmKHRoaXMuYmFja2VuZE5hbWUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe251bGwhPWUuc2V0dXBGdW5jJiZlLnNldHVwRnVuYyh0LmJhY2tlbmRJbnN0YW5jZSl9KSl9LHQucHJvdG90eXBlLmRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2YodCkuZm9yRWFjaCgoZnVuY3Rpb24obil7bnVsbCE9bi5kaXNwb3NlRnVuYyYmbi5kaXNwb3NlRnVuYyhlLnJlZ2lzdHJ5W3RdKX0pKX0sdC5wcm90b3R5cGUuaW5pdGlhbGl6ZUJhY2tlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMucmVnaXN0cnlGYWN0b3J5W3RdO2lmKG51bGw9PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgYmFja2VuZCBcIit0K1wiLCBubyByZWdpc3RyYXRpb24gZm91bmQuXCIpO3RyeXt2YXIgcj1uLmZhY3RvcnkoKTtpZihQcm9taXNlLnJlc29sdmUocik9PT1yKXt2YXIgbz0rK3RoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQsYT1yLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybiEobzxlLnBlbmRpbmdCYWNrZW5kSW5pdElkKSYmKGUucmVnaXN0cnlbdF09bixlLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLCEwKX0pKS5jYXRjaCgoZnVuY3Rpb24obil7cmV0dXJuIShvPGUucGVuZGluZ0JhY2tlbmRJbml0SWQpJiYoZS5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCxjb25zb2xlLndhcm4oXCJJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kIFwiK3QrXCIgZmFpbGVkXCIpLGNvbnNvbGUud2FybihuLnN0YWNrfHxuLm1lc3NhZ2UpLCExKX0pKTtyZXR1cm4gdGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9YSx7c3VjY2VzczphLGFzeW5jSW5pdDohMH19cmV0dXJuIHRoaXMucmVnaXN0cnlbdF09cix7c3VjY2VzczohMCxhc3luY0luaXQ6ITF9fWNhdGNoKGUpe3JldHVybiBjb25zb2xlLndhcm4oXCJJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kIFwiK3QrXCIgZmFpbGVkXCIpLGNvbnNvbGUud2FybihlLnN0YWNrfHxlLm1lc3NhZ2UpLHtzdWNjZXNzOiExLGFzeW5jSW5pdDohMX19fSx0LnByb3RvdHlwZS5yZW1vdmVCYWNrZW5kPWZ1bmN0aW9uKHQpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkpdGhyb3cgbmV3IEVycm9yKHQrXCIgYmFja2VuZCBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7dGhpcy5iYWNrZW5kTmFtZT09PXQmJm51bGwhPXRoaXMucGVuZGluZ0JhY2tlbmRJbml0JiZ0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkKyssdCBpbiB0aGlzLnJlZ2lzdHJ5JiYodGhpcy5kaXNwb3NlUmVnaXN0ZXJlZEtlcm5lbHModCksdGhpcy5yZWdpc3RyeVt0XS5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbdF0pLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XSx0aGlzLmJhY2tlbmROYW1lPT09dCYmKHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsdGhpcy5iYWNrZW5kTmFtZT1udWxsLHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwpfSx0LnByb3RvdHlwZS5nZXRTb3J0ZWRCYWNrZW5kcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoMD09PU9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS5cIik7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5zb3J0KChmdW5jdGlvbihlLG4pe3JldHVybiB0LnJlZ2lzdHJ5RmFjdG9yeVtuXS5wcmlvcml0eS10LnJlZ2lzdHJ5RmFjdG9yeVtlXS5wcmlvcml0eX0pKX0sdC5wcm90b3R5cGUuaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdD1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdldFNvcnRlZEJhY2tlbmRzKCksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdLHI9dGhpcy5pbml0aWFsaXplQmFja2VuZChuKSxvPXIuc3VjY2VzcyxhPXIuYXN5bmNJbml0O2lmKGF8fG8pcmV0dXJue25hbWU6bixhc3luY0luaXQ6YX19dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX0sdC5wcm90b3R5cGUubW92ZURhdGE9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGUpLHI9bi5iYWNrZW5kLG89dGhpcy5yZWFkU3luYyhlKTtyLmRpc3Bvc2VEYXRhKGUpLG4uYmFja2VuZD10LHQubW92ZShlLG8sbi5zaGFwZSxuLmR0eXBlKSx0aGlzLnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFja1t0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLmxlbmd0aC0xXSsrfSx0LnByb3RvdHlwZS50aWR5PWZ1bmN0aW9uKHQsZSl7dmFyIG4scj10aGlzLG89bnVsbDtpZihudWxsPT1lKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgZnVuY3Rpb24gdG8gdGlkeSgpXCIpO2U9dH1lbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0JiYhKHQgaW5zdGFuY2VvZiBTdHJpbmcpKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aWR5KCkgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSAybmQgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBmdW5jdGlvblwiKTtvPXR9cmV0dXJuIHRoaXMuc2NvcGVkUnVuKChmdW5jdGlvbigpe3JldHVybiByLnN0YXJ0U2NvcGUobyl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gci5lbmRTY29wZShuKX0pLChmdW5jdGlvbigpe3JldHVybihuPWUoKSlpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksbn0pKX0sdC5wcm90b3R5cGUuc2NvcGVkUnVuPWZ1bmN0aW9uKHQsZSxuKXt0KCk7dHJ5e3ZhciByPW4oKTtyZXR1cm4gZSgpLHJ9Y2F0Y2godCl7dGhyb3cgZSgpLHR9fSx0LnByb3RvdHlwZS5uZXh0VGVuc29ySWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZXh0VGVuc29ySWQrK30sdC5wcm90b3R5cGUubmV4dFZhcmlhYmxlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZXh0VmFyaWFibGVJZCsrfSx0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm1ha2VUZW5zb3JGcm9tRGF0YUlkKHQuZGF0YUlkLHQuc2hhcGUsdC5kdHlwZSksbj17eDp0fTtyZXR1cm4gdGhpcy5hZGRUYXBlTm9kZSh0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLm5hbWUsbixbZV0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQudG9GbG9hdCgpfX19KSxbXSksZX0sdC5wcm90b3R5cGUucnVuS2VybmVsPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMucnVuS2VybmVsRnVuYyhudWxsLGUsbnVsbCx0LG4scixvKX0sdC5wcm90b3R5cGUuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLkVOVi5nZXRCb29sKFwiSVNfVEVTVFwiKX0sdC5wcm90b3R5cGUuY2hlY2tLZXJuZWxGb3JNZW1MZWFrPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLmJhY2tlbmQubnVtRGF0YUlkcygpLG89MDtuLmZvckVhY2goKGZ1bmN0aW9uKHQpe28rPVwiY29tcGxleDY0XCI9PT10LmR0eXBlPzM6MX0pKTt2YXIgYT10aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrW3RoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2subGVuZ3RoLTFdLGk9ci1lLW8tYTtpZihpPjApdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCAnXCIrdGhpcy5iYWNrZW5kTmFtZStcIicgaGFzIGFuIGludGVybmFsIG1lbW9yeSBsZWFrIChcIitpK1wiIGRhdGEgaWRzKSBhZnRlciBydW5uaW5nICdcIit0K1wiJ1wiKX0sdC5wcm90b3R5cGUucnVuS2VybmVsRnVuYz1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2YXIgcyx1PXRoaXM7dm9pZCAwPT09YSYmKGE9W10pLHZvaWQgMD09PWkmJihpPVtdKTt2YXIgYz1bXSxoPXRoaXMuaXNUYXBlT24oKTtudWxsPT1yJiYocj1udWxsIT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlP3RoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZTpcIlwiKTt2YXIgZixkPWZ1bmN0aW9uKHQpe2gmJihjPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdS5rZWVwKHUuY2xvbmUodCkpfSkpKX0scD10aGlzLnN0YXRlLm51bUJ5dGVzLHY9dGhpcy5zdGF0ZS5udW1UZW5zb3JzO3RoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpJiZ0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLnB1c2goMCk7dmFyIG0sZz1sKHIsdGhpcy5iYWNrZW5kTmFtZSk7cmV0dXJuIGY9bnVsbCE9Zz9mdW5jdGlvbigpe3ZhciB0PXUuYmFja2VuZC5udW1EYXRhSWRzKCk7bT1nLmtlcm5lbEZ1bmMoe2lucHV0czplLGF0dHJzOm8sYmFja2VuZDp1LmJhY2tlbmR9KTt2YXIgbj1BcnJheS5pc0FycmF5KG0pP206W21dO3Uuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpJiZ1LmNoZWNrS2VybmVsRm9yTWVtTGVhayhyLHQsbik7dmFyIHM9bi5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0YUlkLG49dC5zaGFwZSxyPXQuZHR5cGU7cmV0dXJuIHUubWFrZVRlbnNvckZyb21EYXRhSWQoZSxuLHIpfSkpLGM9cy5maWx0ZXIoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGlbZV19KSk7cmV0dXJuIGQoKGF8fFtdKS5zbGljZSgpLmNvbmNhdChjKSksc306ZnVuY3Rpb24oKXt2YXIgZT11LmJhY2tlbmQubnVtRGF0YUlkcygpO209dS50aWR5KChmdW5jdGlvbigpe3JldHVybiB0KHUuYmFja2VuZCxkKX0pKTt2YXIgbj1BcnJheS5pc0FycmF5KG0pP206W21dO3JldHVybiB1LnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdS5jaGVja0tlcm5lbEZvck1lbUxlYWsocixlLG4pLG59LHRoaXMuc2NvcGVkUnVuKChmdW5jdGlvbigpe3JldHVybiB1LnN0YXRlLmtlcm5lbERlcHRoKyt9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdS5zdGF0ZS5rZXJuZWxEZXB0aC0tfSksKGZ1bmN0aW9uKCl7cz11LkVOVi5nZXRCb29sKFwiREVCVUdcIik/dS5wcm9maWxlci5wcm9maWxlS2VybmVsKHIsZSwoZnVuY3Rpb24oKXtyZXR1cm4gZigpfSkpOmYoKX0pKSxoJiZ0aGlzLmFkZFRhcGVOb2RlKHIsZSxzLG4sYyksdGhpcy5zdGF0ZS5wcm9maWxpbmcmJnRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLnB1c2goe25hbWU6cixieXRlc0FkZGVkOnRoaXMuc3RhdGUubnVtQnl0ZXMtcCx0b3RhbEJ5dGVzU25hcHNob3Q6dGhpcy5zdGF0ZS5udW1CeXRlcyx0ZW5zb3JzQWRkZWQ6dGhpcy5zdGF0ZS5udW1UZW5zb3JzLXYsdG90YWxUZW5zb3JzU25hcHNob3Q6dGhpcy5zdGF0ZS5udW1UZW5zb3JzLGlucHV0U2hhcGVzOk9iamVjdC5rZXlzKGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0uc2hhcGV9KSksb3V0cHV0U2hhcGVzOnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKX0pLEFycmF5LmlzQXJyYXkobSk/czpzWzBdfSx0LnByb3RvdHlwZS5tYWtlVGVuc29yPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwiVmFsdWVzIHBhc3NlZCB0byBlbmdpbmUubWFrZVRlbnNvcigpIGFyZSBudWxsXCIpO249bnx8XCJmbG9hdDMyXCIscj1yfHx0aGlzLmJhY2tlbmQ7dmFyIG89dDtcInN0cmluZ1wiPT09biYmSCh0WzBdKSYmKG89dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBydCh0KX0pKSk7dmFyIGE9ci53cml0ZShvLGUsbiksaT1uZXcgd3QoZSxuLGEsdGhpcy5uZXh0VGVuc29ySWQoKSk7aWYodGhpcy5pbmNSZWYoaSxyKSxcInN0cmluZ1wiPT09bil7dmFyIHM9dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldChhKSx1PUcobyk7dGhpcy5zdGF0ZS5udW1CeXRlcys9dS1zLmJ5dGVzLHMuYnl0ZXM9dX1yZXR1cm4gaX0sdC5wcm90b3R5cGUubWFrZVRlbnNvckZyb21EYXRhSWQ9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IHd0KGUsbj1ufHxcImZsb2F0MzJcIix0LHRoaXMubmV4dFRlbnNvcklkKCkpO3JldHVybiB0aGlzLmluY1JlZihvLHIpLG99LHQucHJvdG90eXBlLm1ha2VWYXJpYWJsZT1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0hMCksbj1ufHx0aGlzLm5leHRWYXJpYWJsZUlkKCkudG9TdHJpbmcoKSxudWxsIT1yJiZyIT09dC5kdHlwZSYmKHQ9dC5hc1R5cGUocikpO3ZhciBvPW5ldyBTdCh0LGUsbix0aGlzLm5leHRUZW5zb3JJZCgpKTtpZihudWxsIT10aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbby5uYW1lXSl0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSB3aXRoIG5hbWUgXCIrby5uYW1lK1wiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7cmV0dXJuIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1tvLm5hbWVdPW8sdGhpcy5pbmNSZWYobyx0aGlzLmJhY2tlbmQpLG99LHQucHJvdG90eXBlLmluY1JlZj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuc3RhdGUudGVuc29ySW5mby5oYXModC5kYXRhSWQpP3RoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpLnJlZkNvdW50OjA7aWYodGhpcy5zdGF0ZS5udW1UZW5zb3JzKyssXCJzdHJpbmdcIj09PXQuZHR5cGUmJnRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycysrLDA9PT1uKXt0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzKys7dmFyIHI9MDtcImNvbXBsZXg2NFwiIT09dC5kdHlwZSYmXCJzdHJpbmdcIiE9PXQuZHR5cGUmJihyPXQuc2l6ZSp6KHQuZHR5cGUpKSx0aGlzLnN0YXRlLnRlbnNvckluZm8uc2V0KHQuZGF0YUlkLHtiYWNrZW5kOmV8fHRoaXMuYmFja2VuZCxkdHlwZTp0LmR0eXBlLHNoYXBlOnQuc2hhcGUsYnl0ZXM6cixyZWZDb3VudDowfSksdGhpcy5zdGF0ZS5udW1CeXRlcys9cn10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudCsrLHQgaW5zdGFuY2VvZiBTdHx8dGhpcy50cmFjayh0KX0sdC5wcm90b3R5cGUuZGlzcG9zZVRlbnNvcj1mdW5jdGlvbih0KXtpZih0aGlzLnN0YXRlLnRlbnNvckluZm8uaGFzKHQuZGF0YUlkKSl7dGhpcy5zdGF0ZS5udW1UZW5zb3JzLS0sXCJzdHJpbmdcIj09PXQuZHR5cGUmJnRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycy0tO3ZhciBlPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpO2UucmVmQ291bnQ8PTE/KFwiY29tcGxleDY0XCIhPT10LmR0eXBlJiYodGhpcy5zdGF0ZS5udW1CeXRlcy09ZS5ieXRlcyksdGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycy0tLGUuYmFja2VuZC5kaXNwb3NlRGF0YSh0LmRhdGFJZCksdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmRlbGV0ZSh0LmRhdGFJZCkpOnRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpLnJlZkNvdW50LS19fSx0LnByb3RvdHlwZS5kaXNwb3NlVmFyaWFibGVzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlcyl7dmFyIGU9dGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3RdO3RoaXMuZGlzcG9zZVZhcmlhYmxlKGUpfX0sdC5wcm90b3R5cGUuZGlzcG9zZVZhcmlhYmxlPWZ1bmN0aW9uKHQpe3RoaXMuZGlzcG9zZVRlbnNvcih0KSxudWxsIT10aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdC5uYW1lXSYmZGVsZXRlIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0Lm5hbWVdfSx0LnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJhY2tlbmQubWVtb3J5KCk7cmV0dXJuIHQubnVtVGVuc29ycz10aGlzLnN0YXRlLm51bVRlbnNvcnMsdC5udW1EYXRhQnVmZmVycz10aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzLHQubnVtQnl0ZXM9dGhpcy5zdGF0ZS5udW1CeXRlcyx0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnM+MCYmKHQudW5yZWxpYWJsZT0hMCxudWxsPT10LnJlYXNvbnMmJih0LnJlYXNvbnM9W10pLHQucmVhc29ucy5wdXNoKFwiTWVtb3J5IHVzYWdlIGJ5IHN0cmluZyB0ZW5zb3JzIGlzIGFwcHJveGltYXRlICgyIGJ5dGVzIHBlciBjaGFyYWN0ZXIpXCIpKSx0fSx0LnByb3RvdHlwZS5wcm9maWxlPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnN0YXRlLnByb2ZpbGluZz0hMCxlPXRoaXMuc3RhdGUubnVtQnl0ZXMsbj10aGlzLnN0YXRlLm51bVRlbnNvcnMsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHM9W10sdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLnJlc3VsdD10KCksdGhpcy5zdGF0ZS5wcm9maWxpbmc9ITEsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLnBlYWtCeXRlcz1NYXRoLm1heC5hcHBseShNYXRoLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudG90YWxCeXRlc1NuYXBzaG90fSkpKSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUubmV3Qnl0ZXM9dGhpcy5zdGF0ZS5udW1CeXRlcy1lLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5uZXdUZW5zb3JzPXRoaXMuc3RhdGUubnVtVGVuc29ycy1uLFsyLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZV19KSl9KSl9LHQucHJvdG90eXBlLmlzVGFwZU9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aD4wJiYwPT09dGhpcy5zdGF0ZS5rZXJuZWxEZXB0aH0sdC5wcm90b3R5cGUuYWRkVGFwZU5vZGU9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10aGlzLGk9e2lkOnRoaXMuc3RhdGUubmV4dFRhcGVOb2RlSWQrKyxrZXJuZWxOYW1lOnQsaW5wdXRzOmUsb3V0cHV0czpuLHNhdmVkOm99LHM9aCh0KTtudWxsIT1zJiYocj1zLmdyYWRGdW5jKSxudWxsIT1yJiYoaS5ncmFkaWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdD10Lm1hcCgoZnVuY3Rpb24odCxlKXtpZihudWxsPT10KXt2YXIgcj1uW2VdLG89dHQoci5zaXplLHIuZHR5cGUpO3JldHVybiBhLm1ha2VUZW5zb3IobyxyLnNoYXBlLHIuZHR5cGUpfXJldHVybiB0fSkpLHIodC5sZW5ndGg+MT90OnRbMF0sbyl9KSx0aGlzLnN0YXRlLmFjdGl2ZVRhcGUucHVzaChpKX0sdC5wcm90b3R5cGUua2VlcD1mdW5jdGlvbih0KXtyZXR1cm4gdC5rZXB0PSEwLHR9LHQucHJvdG90eXBlLnN0YXJ0VGFwZT1mdW5jdGlvbigpezA9PT10aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgmJih0aGlzLnN0YXRlLmFjdGl2ZVRhcGU9W10pLHRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aCsrfSx0LnByb3RvdHlwZS5lbmRUYXBlPWZ1bmN0aW9uKCl7dGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoLS19LHQucHJvdG90eXBlLnN0YXJ0U2NvcGU9ZnVuY3Rpb24odCl7dmFyIGU9e3RyYWNrOltdLG5hbWU6XCJ1bm5hbWVkIHNjb3BlXCIsaWQ6dGhpcy5zdGF0ZS5uZXh0U2NvcGVJZCsrfTt0JiYoZS5uYW1lPXQpLHRoaXMuc3RhdGUuc2NvcGVTdGFjay5wdXNoKGUpLHRoaXMuc3RhdGUuYWN0aXZlU2NvcGU9ZX0sdC5wcm90b3R5cGUuZW5kU2NvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMsbj1fdCh0KSxyPW5ldyBTZXQobi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkfSkpKSxvPTA7bzx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLmxlbmd0aDtvKyspe3ZhciBhPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2tbb107YS5rZXB0fHxyLmhhcyhhLmlkKXx8YS5kaXNwb3NlKCl9dmFyIGk9dGhpcy5zdGF0ZS5zY29wZVN0YWNrLnBvcCgpO3RoaXMuc3RhdGUuYWN0aXZlU2NvcGU9MD09PXRoaXMuc3RhdGUuc2NvcGVTdGFjay5sZW5ndGg/bnVsbDp0aGlzLnN0YXRlLnNjb3BlU3RhY2tbdGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aC0xXSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Qua2VwdHx8dC5zY29wZUlkIT09aS5pZHx8ZS50cmFjayh0KX0pKX0sdC5wcm90b3R5cGUuZ3JhZGllbnRzPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXM7aWYodm9pZCAwPT09ciYmKHI9ITEpLEMoZS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cImdyYWRpZW50cygpIHJlY2VpdmVkIGFuIGVtcHR5IGxpc3Qgb2YgeHMuXCJ9KSksbnVsbCE9biYmXCJmbG9hdDMyXCIhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcImR5IG11c3QgaGF2ZSAnZmxvYXQzMicgZHR5cGUsIGJ1dCBoYXMgJ1wiK24uZHR5cGUrXCInXCIpO3ZhciBhPXRoaXMuc2NvcGVkUnVuKChmdW5jdGlvbigpe3JldHVybiBvLnN0YXJ0VGFwZSgpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5kVGFwZSgpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIG8udGlkeShcImZvcndhcmRcIix0KX0pKTtDKGEgaW5zdGFuY2VvZiB3dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSByZXN1bHQgeSByZXR1cm5lZCBieSBmKCkgbXVzdCBiZSBhIHRlbnNvci5cIn0pKTt2YXIgaT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPXt9LG89e30sYT0wO2E8ZS5sZW5ndGg7YSsrKXJbZVthXS5pZF09ITA7Zm9yKGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIGk9KHA9dFthXSkuaW5wdXRzO2Zvcih2YXIgcyBpbiBpKXtmb3IodmFyIHU9aVtzXSxjPSExLGw9MDtsPGUubGVuZ3RoO2wrKylpZihyW3UuaWRdKXtwLm91dHB1dHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHJbdC5pZF09ITB9KSksYz0hMCxvW3AuaWRdPSEwO2JyZWFrfWlmKGMpYnJlYWt9fXZhciBoPXt9O2hbbi5pZF09ITA7dmFyIGY9e307Zm9yKGE9dC5sZW5ndGgtMTthPj0wO2EtLSlmb3IoaT0ocD10W2FdKS5pbnB1dHMsbD0wO2w8cC5vdXRwdXRzLmxlbmd0aDtsKyspaWYoaFtwLm91dHB1dHNbbF0uaWRdKXtmb3IodmFyIHMgaW4gaSloW2lbc10uaWRdPSEwLGZbcC5pZF09ITA7YnJlYWt9dmFyIGQ9W107Zm9yKGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIHA7aWYob1socD10W2FdKS5pZF0mJmZbcC5pZF0pe3ZhciB2PXt9O2Zvcih2YXIgcyBpbiBwLmlucHV0cyl7dmFyIG09cC5pbnB1dHNbc107clttLmlkXSYmKHZbc109bSl9dmFyIGc9T2JqZWN0LmFzc2lnbih7fSxwKTtnLmlucHV0cz12LGcub3V0cHV0cz1wLm91dHB1dHMsZC5wdXNoKGcpfX1yZXR1cm4gZH0odGhpcy5zdGF0ZS5hY3RpdmVUYXBlLGUsYSk7aWYoIXImJjA9PT1pLmxlbmd0aCYmZS5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0IHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKTtyZXR1cm4gdGhpcy50aWR5KFwiYmFja3dhcmRcIiwoZnVuY3Rpb24oKXt2YXIgdCxyLHM9e307c1thLmlkXT1udWxsPT1uPyh0PWEuc2hhcGUscj1aKGsodCksXCJmbG9hdDMyXCIpLEx0Lm1ha2VUZW5zb3Iocix0LFwiZmxvYXQzMlwiKSk6bixmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPWZ1bmN0aW9uKHIpe3ZhciBvPWVbcl0sYT1bXTtpZihvLm91dHB1dHMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49dFtlLmlkXTtudWxsIT1uP2EucHVzaChuKTphLnB1c2gobnVsbCl9KSksbnVsbD09by5ncmFkaWVudCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudDogZ3JhZGllbnQgZnVuY3Rpb24gbm90IGZvdW5kIGZvciBcIitvLmtlcm5lbE5hbWUrXCIuXCIpO3ZhciBpPW8uZ3JhZGllbnQoYSkscz1mdW5jdGlvbihlKXtpZighKGUgaW4gaSkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJhY2twcm9wIHRocm91Z2ggaW5wdXQgXCIrZStcIi4gQXZhaWxhYmxlIGdyYWRpZW50cyBmb3VuZDogXCIrT2JqZWN0LmtleXMoaSkrXCIuXCIpO3ZhciByPW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGlbZV0oKX0pKTtpZihcImZsb2F0MzJcIiE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wIFwiK28ua2VybmVsTmFtZStcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0IFwiK2UrXCIgbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnXCIrci5kdHlwZStcIidcIik7dmFyIGE9by5pbnB1dHNbZV07aWYoIVMoci5zaGFwZSxhLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIrby5rZXJuZWxOYW1lK1wiLiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgJ1wiK2UrXCInIGhhcyBzaGFwZSAnXCIrci5zaGFwZStcIicsIHdoaWNoIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgJ1wiK2Euc2hhcGUrXCInXCIpO2lmKG51bGw9PXRbYS5pZF0pdFthLmlkXT1yO2Vsc2V7dmFyIHM9dFthLmlkXTt0W2EuaWRdPXMuYWRkKHIpLHMuZGlzcG9zZSgpfX07Zm9yKHZhciB1IGluIG8uaW5wdXRzKXModSl9LG89ZS5sZW5ndGgtMTtvPj0wO28tLSlyKG8pfShzLGksKGZ1bmN0aW9uKHQpe3JldHVybiBvLnRpZHkodCl9KSk7dmFyIHU9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBzW3QuaWRdfSkpO3JldHVybiAwPT09by5zdGF0ZS5ncmFkaWVudERlcHRoJiYoby5zdGF0ZS5hY3RpdmVUYXBlLmZvckVhY2goKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dC5zYXZlZDtlPG4ubGVuZ3RoO2UrKyl7bltlXS5kaXNwb3NlKCl9fSkpLG8uc3RhdGUuYWN0aXZlVGFwZT1udWxsKSx7dmFsdWU6YSxncmFkczp1fX0pKX0sdC5wcm90b3R5cGUuY3VzdG9tR3JhZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb24uXCJ9KSksZnVuY3Rpb24oKXtmb3IodmFyIG4scj1bXSxvPTA7bzxhcmd1bWVudHMubGVuZ3RoO28rKylyW29dPWFyZ3VtZW50c1tvXTtDKHIuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygd3R9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSh4MSwgeDIsLi4uKSBtdXN0IGFsbCBiZSB0ZW5zb3JzXCJ9KSk7dmFyIGE9e307cmV0dXJuIHIuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXthW2VdPXR9KSksZS5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihlLG8pe3JldHVybiBDKChuPXQuYXBwbHkodm9pZCAwLHIuY29uY2F0KFtvXSkpKS52YWx1ZSBpbnN0YW5jZW9mIHd0LChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmoudmFsdWVgIGlzIGEgdGVuc29yXCJ9KSksQyhYKG4uZ3JhZEZ1bmMpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24uXCJ9KSksbi52YWx1ZX0pLGEsKGZ1bmN0aW9uKHQsZSl7dmFyIG89bi5ncmFkRnVuYyh0LGUpLGE9QXJyYXkuaXNBcnJheShvKT9vOltvXTtDKGEubGVuZ3RoPT09ci5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNhbWUgbnVtYmVyIG9mIHRlbnNvcnMgYXMgaW5wdXRzIHBhc3NlZCB0byBmKC4uLikuXCJ9KSksQyhhLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0fSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiBvbmx5IHRlbnNvcnMuXCJ9KSk7dmFyIGk9e307cmV0dXJuIGEuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtpW2VdPWZ1bmN0aW9uKCl7cmV0dXJuIHR9fSkpLGl9KSl9fSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWRTeW5jKHQpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQucmVhZCh0KX0sdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPWV0KCksWzQsdGhpcy5iYWNrZW5kLnRpbWUodCldO2Nhc2UgMTpyZXR1cm4obj1yLnNlbnQoKSkud2FsbE1zPWV0KCktZSxbMixuXX19KSl9KSl9LHQucHJvdG90eXBlLnRyYWNrPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlJiYodC5zY29wZUlkPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUuaWQsdGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5wdXNoKHQpKSx0fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWdpc3RlcmVkVmFyaWFibGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZCsrLHRoaXMuc3RhdGUuZGlzcG9zZSgpLHRoaXMuRU5WLnJlc2V0KCksdGhpcy5zdGF0ZT1uZXcgQnQsdGhpcy5yZWdpc3RyeSl0aGlzLmRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyh0KSx0aGlzLnJlZ2lzdHJ5W3RdLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5yZWdpc3RyeVt0XTt0aGlzLmJhY2tlbmROYW1lPW51bGwsdGhpcy5iYWNrZW5kSW5zdGFuY2U9bnVsbCx0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsfSx0Lm5leHRUZW5zb3JJZD0wLHQubmV4dFZhcmlhYmxlSWQ9MCx0fSgpO3ZhciBMdD1mdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKCl7aWYobnVsbD09T3Qpe3ZhciB0PXZvaWQgMDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXQ9d2luZG93O2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCl0PWdsb2JhbDtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzKXQ9cHJvY2VzcztlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdFwiKTt0PXNlbGZ9T3Q9dH1yZXR1cm4gT3R9KCk7aWYobnVsbD09dC5fdGZlbmdpbmUpe3ZhciBlPW5ldyBvKHQpO3QuX3RmZW5naW5lPW5ldyBQdChlKX1yZXR1cm4gZnVuY3Rpb24odCl7cz10fSh0Ll90ZmVuZ2luZS5FTlYpLHl0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuX3RmZW5naW5lfSx0Ll90ZmVuZ2luZX0oKTtmdW5jdGlvbiBXdCgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJm51bGwhPXdpbmRvdy5kb2N1bWVudHx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlfXZhciBVdD1pKCk7VXQucmVnaXN0ZXJGbGFnKFwiREVCVUdcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMX0pLChmdW5jdGlvbih0KXt0JiZjb25zb2xlLndhcm4oXCJEZWJ1Z2dpbmcgbW9kZSBpcyBPTi4gVGhlIG91dHB1dCBvZiBldmVyeSBtYXRoIGNhbGwgd2lsbCBiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuXCIpfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIklTX0JST1dTRVJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gV3QoKX0pKSxVdC5yZWdpc3RlckZsYWcoXCJJU19OT0RFXCIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnZvaWQgMCE9PXByb2Nlc3MudmVyc2lvbnMmJnZvaWQgMCE9PXByb2Nlc3MudmVyc2lvbnMubm9kZX0pKSxVdC5yZWdpc3RlckZsYWcoXCJJU19DSFJPTUVcIiwoZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZudWxsIT1uYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJi9DaHJvbWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9Hb29nbGUgSW5jLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIlBST0RcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMX0pKSxVdC5yZWdpc3RlckZsYWcoXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFV0LmdldEJvb2woXCJERUJVR1wiKX0pKSxVdC5yZWdpc3RlckZsYWcoXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITB9KSksVXQucmVnaXN0ZXJGbGFnKFwiSVNfVEVTVFwiLChmdW5jdGlvbigpe3JldHVybiExfSkpO3ZhciBWdCx6dCxHdCxIdD17fSxxdD17YWxwaGE6ITEsYW50aWFsaWFzOiExLHByZW11bHRpcGxpZWRBbHBoYTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsZGVwdGg6ITEsc3RlbmNpbDohMSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiEwfTtmdW5jdGlvbiBLdCh0LGUpe0h0W3RdPWV9ZnVuY3Rpb24ganQodCl7dCBpbiBIdHx8KEh0W3RdPWZ1bmN0aW9uKHQpe2lmKDEhPT10JiYyIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC5cIik7dmFyIGU9ZnVuY3Rpb24odCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIE9mZnNjcmVlbkNhbnZhcyYmMj09PXQpcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMzAwLDE1MCk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50KXJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBjYW52YXMgaW4gdGhpcyBjb250ZXh0XCIpfSh0KTtpZihlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsKGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSxkZWxldGUgSHRbdF19KSwhMSksMT09PXQpcmV0dXJuIGUuZ2V0Q29udGV4dChcIndlYmdsXCIscXQpfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixxdCk7cmV0dXJuIGUuZ2V0Q29udGV4dChcIndlYmdsMlwiLHF0KX0odCkpO3ZhciBlPUh0W3RdO3JldHVybiBlLmlzQ29udGV4dExvc3QoKT8oZGVsZXRlIEh0W3RdLGp0KHQpKTooZS5kaXNhYmxlKGUuREVQVEhfVEVTVCksZS5kaXNhYmxlKGUuU1RFTkNJTF9URVNUKSxlLmRpc2FibGUoZS5CTEVORCksZS5kaXNhYmxlKGUuRElUSEVSKSxlLmRpc2FibGUoZS5QT0xZR09OX09GRlNFVF9GSUxMKSxlLmRpc2FibGUoZS5TQU1QTEVfQ09WRVJBR0UpLGUuZW5hYmxlKGUuU0NJU1NPUl9URVNUKSxlLmVuYWJsZShlLkNVTExfRkFDRSksZS5jdWxsRmFjZShlLkJBQ0spLEh0W3RdKX1mdW5jdGlvbiBYdCh0LGUpe3JldHVybltlLHRdfWZ1bmN0aW9uIFl0KHQpe3ZhciBlPWsodCk7cmV0dXJuIFQoTWF0aC5jZWlsKGUvNCkpfWZ1bmN0aW9uICR0KHQsZSl7cmV0dXJuW01hdGgubWF4KDEsTWF0aC5jZWlsKGUvMikpLE1hdGgubWF4KDEsTWF0aC5jZWlsKHQvMikpXX1mdW5jdGlvbiBRdCh0LGUpe3ZhciBuLHIsbyxhLHMsdSxjLGwsaCxmPXQ7cmV0dXJuIDI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8obj1mLlIzMkYscj1mLlIxNkYsbz1mLlJHQkExNkYsYT1mLlJHQkEzMkYscz1mLlJFRCx1PTQsYz0xLGw9Zi5IQUxGX0ZMT0FULGg9Zi5GTE9BVCk6KG49dC5SR0JBLHI9dC5SR0JBLG89dC5SR0JBLGE9Zi5SR0JBLHM9dC5SR0JBLHU9NCxjPTQsbD1udWxsIT1lP2UuSEFMRl9GTE9BVF9PRVM6bnVsbCxoPXQuRkxPQVQpLHtpbnRlcm5hbEZvcm1hdEZsb2F0Om4saW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQ6cixpbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdDpvLGludGVybmFsRm9ybWF0UGFja2VkRmxvYXQ6YSx0ZXh0dXJlRm9ybWF0RmxvYXQ6cyxkb3dubG9hZFRleHR1cmVGb3JtYXQ6dC5SR0JBLGRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHM6dSxkZWZhdWx0TnVtQ2hhbm5lbHM6Yyx0ZXh0dXJlVHlwZUhhbGZGbG9hdDpsLHRleHR1cmVUeXBlRmxvYXQ6aH19ZnVuY3Rpb24gSnQodCxlLG4pe3ZhciByPW4oKTtyZXR1cm4gZSYmZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFcnJvcigpO2lmKGUhPT10Lk5PX0VSUk9SKXRocm93IG5ldyBFcnJvcihcIldlYkdMIEVycm9yOiBcIituZSh0LGUpKX0odCkscn0hZnVuY3Rpb24odCl7dFt0LkRFTlNFPTBdPVwiREVOU0VcIix0W3QuU0hBUkVEX0JBVENIPTFdPVwiU0hBUkVEX0JBVENIXCJ9KFZ0fHwoVnQ9e30pKSxmdW5jdGlvbih0KXt0W3QuUkVOREVSPTBdPVwiUkVOREVSXCIsdFt0LlVQTE9BRD0xXT1cIlVQTE9BRFwiLHRbdC5QSVhFTFM9Ml09XCJQSVhFTFNcIix0W3QuRE9XTkxPQUQ9M109XCJET1dOTE9BRFwifSh6dHx8KHp0PXt9KSksZnVuY3Rpb24odCl7dFt0LlVOUEFDS0VEX0ZMT0FUMTY9MF09XCJVTlBBQ0tFRF9GTE9BVDE2XCIsdFt0LlVOUEFDS0VEX0ZMT0FUMzI9MV09XCJVTlBBQ0tFRF9GTE9BVDMyXCIsdFt0LlBBQ0tFRF80WDFfVU5TSUdORURfQllURT0yXT1cIlBBQ0tFRF80WDFfVU5TSUdORURfQllURVwiLHRbdC5QQUNLRURfMlgyX0ZMT0FUMzI9M109XCJQQUNLRURfMlgyX0ZMT0FUMzJcIix0W3QuUEFDS0VEXzJYMl9GTE9BVDE2PTRdPVwiUEFDS0VEXzJYMl9GTE9BVDE2XCJ9KEd0fHwoR3Q9e30pKTt2YXIgWnQ9NS45NmUtOCx0ZT02NTUwNDtmdW5jdGlvbiBlZSh0KXtyZXR1cm4hIShpKCkuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIil8fDA9PT10fHxadDxNYXRoLmFicyh0KSYmTWF0aC5hYnModCk8dGUpfWZ1bmN0aW9uIG5lKHQsZSl7c3dpdGNoKGUpe2Nhc2UgdC5OT19FUlJPUjpyZXR1cm5cIk5PX0VSUk9SXCI7Y2FzZSB0LklOVkFMSURfRU5VTTpyZXR1cm5cIklOVkFMSURfRU5VTVwiO2Nhc2UgdC5JTlZBTElEX1ZBTFVFOnJldHVyblwiSU5WQUxJRF9WQUxVRVwiO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpyZXR1cm5cIklOVkFMSURfT1BFUkFUSU9OXCI7Y2FzZSB0LklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIjtjYXNlIHQuT1VUX09GX01FTU9SWTpyZXR1cm5cIk9VVF9PRl9NRU1PUllcIjtjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOnJldHVyblwiQ09OVEVYVF9MT1NUX1dFQkdMXCI7ZGVmYXVsdDpyZXR1cm5cIlVua25vd24gZXJyb3IgY29kZSBcIitlfX1mdW5jdGlvbiByZSh0LGUsbil7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5nZXRFeHRlbnNpb24obil9KSwnRXh0ZW5zaW9uIFwiJytuKydcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKX1mdW5jdGlvbiBvZSh0LGUsbil7dmFyIHI9a2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVNoYWRlcih0LlZFUlRFWF9TSEFERVIpfSksXCJVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci5cIik7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnNoYWRlclNvdXJjZShyLG4pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jb21waWxlU2hhZGVyKHIpfSkpLCExPT09dC5nZXRTaGFkZXJQYXJhbWV0ZXIocix0LkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFNoYWRlckluZm9Mb2cocikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuXCIpO3JldHVybiByfWZ1bmN0aW9uIGFlKHQsZSxuKXt2YXIgcj1rZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlU2hhZGVyKHQuRlJBR01FTlRfU0hBREVSKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBmcmFnbWVudCBXZWJHTFNoYWRlci5cIik7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnNoYWRlclNvdXJjZShyLG4pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jb21waWxlU2hhZGVyKHIpfSkpLCExPT09dC5nZXRTaGFkZXJQYXJhbWV0ZXIocix0LkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBmdW5jdGlvbih0LGUpe3ZhciBuPXVlLmV4ZWMoZSk7aWYobnVsbD09bilyZXR1cm4gY29uc29sZS5sb2coXCJDb3VsZG4ndCBwYXJzZSBsaW5lIG51bWJlciBpbiBlcnJvcjogXCIrZSksdm9pZCBjb25zb2xlLmxvZyh0KTtmb3IodmFyIHI9K25bMV0sbz10LnNwbGl0KFwiXFxuXCIpLGE9by5sZW5ndGgudG9TdHJpbmcoKS5sZW5ndGgrMixpPW8ubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBOKChlKzEpLnRvU3RyaW5nKCksYSkrdH0pKSxzPTAsdT0wO3U8aS5sZW5ndGg7dSsrKXM9TWF0aC5tYXgoaVt1XS5sZW5ndGgscyk7dmFyIGM9aS5zbGljZSgwLHItMSksbD1pLnNsaWNlKHItMSxyKSxoPWkuc2xpY2Uocik7Y29uc29sZS5sb2coYy5qb2luKFwiXFxuXCIpKSxjb25zb2xlLmxvZyhlLnNwbGl0KFwiXFxuXCIpWzBdKSxjb25zb2xlLmxvZyhcIiVjIFwiK04obFswXSxzKSxcImJvcmRlcjoxcHggc29saWQgcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiNlM2QyZDI7IGNvbG9yOiNhNjE3MTdcIiksY29uc29sZS5sb2coaC5qb2luKFwiXFxuXCIpKX0obix0LmdldFNoYWRlckluZm9Mb2cocikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci5cIik7cmV0dXJuIHJ9dmFyIGllLHNlLHVlPS9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO2Z1bmN0aW9uIGNlKHQsZSl7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVQcm9ncmFtKCl9KSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xQcm9ncmFtLlwiKX1mdW5jdGlvbiBsZSh0LGUsbil7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmxpbmtQcm9ncmFtKG4pfSkpLCExPT09dC5nZXRQcm9ncmFtUGFyYW1ldGVyKG4sdC5MSU5LX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2codC5nZXRQcm9ncmFtSW5mb0xvZyhuKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLlwiKX1mdW5jdGlvbiBoZSh0LGUsbil7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnZhbGlkYXRlUHJvZ3JhbShuKX0pKSwhMT09PXQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihuLHQuVkFMSURBVEVfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFByb2dyYW1JbmZvTG9nKG4pKSxuZXcgRXJyb3IoXCJTaGFkZXIgcHJvZ3JhbSB2YWxpZGF0aW9uIGZhaWxlZC5cIil9ZnVuY3Rpb24gZmUodCxlLG4pe3ZhciByPWtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVCdWZmZXIoKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5BUlJBWV9CVUZGRVIsbix0LlNUQVRJQ19EUkFXKX0pKSxyfWZ1bmN0aW9uIGRlKHQsZSxuKXt2YXIgcj1rZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlQnVmZmVyKCl9KSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXJcIik7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixuLHQuU1RBVElDX0RSQVcpfSkpLHJ9ZnVuY3Rpb24gcGUodCxlKXtyZXR1cm4ga2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVRleHR1cmUoKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuXCIpfWZ1bmN0aW9uIHZlKHQsZSl7dmFyIG49aSgpLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIik7aWYodDw9MHx8ZTw9MCl7dmFyIHI9XCJbXCIrdCtcInhcIitlK1wiXVwiO3Rocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgXCIrcitcIiBpcyBpbnZhbGlkLlwiKX1pZih0Pm58fGU+bil7cj1cIltcIit0K1wieFwiK2UrXCJdXCI7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIityK1wiIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSBcIisoXCJbXCIrbitcInhcIituK1wiXVwiKStcIi5cIil9fWZ1bmN0aW9uIG1lKHQsZSl7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVGcmFtZWJ1ZmZlcigpfSksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuXCIpfWZ1bmN0aW9uIGdlKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9dC5nZXRBdHRyaWJMb2NhdGlvbihuLHIpO3JldHVybi0xIT09dSYmKEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG8pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHUsYSx0LkZMT0FULCExLGkscyl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHUpfSkpLCEwKX1mdW5jdGlvbiB5ZSh0LGUsbixyKXtTZSh0LHIpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArcil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKX0pKX1mdW5jdGlvbiB4ZSh0LGUsbixyKXtyZXR1cm4ga2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmdldFVuaWZvcm1Mb2NhdGlvbihuLHIpfSksJ3VuaWZvcm0gXCInK3IrJ1wiIG5vdCBwcmVzZW50IGluIHByb2dyYW0uJyl9ZnVuY3Rpb24gYmUodCxlLG4pe3JldHVybiB0LmdldFVuaWZvcm1Mb2NhdGlvbihlLG4pfWZ1bmN0aW9uIHdlKHQsZSxuLHIsbyxhKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHllKHQsZSxyLGEpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC51bmlmb3JtMWkobyxhKX0pKX1mdW5jdGlvbiBDZSh0LGUsbixyKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsbiwwKX0pKX1mdW5jdGlvbiBFZSh0LGUsbil7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELG51bGwsMCl9KSl9ZnVuY3Rpb24gUmUodCl7dmFyIGU9dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpO2lmKGUhPT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6IFwiK0llKHQsZSkpfWZ1bmN0aW9uIEllKHQsZSl7c3dpdGNoKGUpe2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIjtjYXNlIHQuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiO2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIjtjYXNlIHQuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiO2RlZmF1bHQ6cmV0dXJuXCJ1bmtub3duIGVycm9yIFwiK2V9fWZ1bmN0aW9uIGtlKHQsZSxuLHIpe3ZhciBvPUp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpO2lmKG51bGw9PW8pdGhyb3cgbmV3IEVycm9yKHIpO3JldHVybiBvfWZ1bmN0aW9uIFNlKHQsZSl7dmFyIG49dC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUy0xLHI9ZSt0LlRFWFRVUkUwO2lmKHI8dC5URVhUVVJFMHx8cj5uKXRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gXCIrKFwiW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIrbitcIl1cIikrXCIuXCIpfWZ1bmN0aW9uIEFlKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTIpLGsodC5zbGljZSgwLHQubGVuZ3RoLWUpKX1mdW5jdGlvbiBEZSh0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX1mdW5jdGlvbiBUZSh0KXt2YXIgZT1bMSwxLDFdO3JldHVybiAwPT09dC5sZW5ndGh8fDE9PT10Lmxlbmd0aCYmMT09PXRbMF18fChlPVtBZSh0KV0uY29uY2F0KERlKHQpKSksZX1mdW5jdGlvbiBOZSh0LGUpe3ZhciBuO3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZihlJiYocio9MiwxPT09KHQ9dC5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4+PXQubGVuZ3RoLTI/Yih0W25dKTp0W25dfSkpKS5sZW5ndGgmJih0PVsyLHRbMF1dKSksMiE9PXQubGVuZ3RoKXt2YXIgbz1NKHQpO3Q9by5uZXdTaGFwZX12YXIgYT1rKHQpO2lmKHQubGVuZ3RoPD0xJiZhPD1yKXJldHVyblsxLGFdO2lmKDI9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXTw9cilyZXR1cm4gdDtpZigzPT09dC5sZW5ndGgmJnRbMF0qdFsxXTw9ciYmdFsyXTw9cilyZXR1cm5bdFswXSp0WzFdLHRbMl1dO2lmKDM9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXSp0WzJdPD1yKXJldHVyblt0WzBdLHRbMV0qdFsyXV07aWYoND09PXQubGVuZ3RoJiZ0WzBdKnRbMV0qdFsyXTw9ciYmdFszXTw9cilyZXR1cm5bdFswXSp0WzFdKnRbMl0sdFszXV07aWYoND09PXQubGVuZ3RoJiZ0WzBdPD1yJiZ0WzFdKnRbMl0qdFszXTw9cilyZXR1cm5bdFswXSx0WzFdKnRbMl0qdFszXV07aWYoZSl7dmFyIHM9QWUodCksdT0yLGM9MjtyZXR1cm4gdC5sZW5ndGgmJih1PShuPURlKHQpKVswXSxjPW5bMV0pLFQoYT1zKih1LzIpKihjLzIpKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiAyKnR9KSl9cmV0dXJuIFQoYSl9ZnVuY3Rpb24gRmUodCl7cmV0dXJuIHQlMj09MH1mdW5jdGlvbiBfZSh0LGUpe2lmKFModD10LnNsaWNlKC0yKSxlPWUuc2xpY2UoLTIpKSlyZXR1cm4hMDtpZighdC5sZW5ndGh8fCFlLmxlbmd0aClyZXR1cm4hMDtpZigwPT09dFswXXx8MD09PXRbMV18fDA9PT1lWzBdfHwwPT09ZVsxXSlyZXR1cm4hMDtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXt2YXIgbj10LnNsaWNlKC0xKVswXSxyPWUuc2xpY2UoLTEpWzBdO2lmKG49PT1yKXJldHVybiEwO2lmKEZlKG4pJiZGZShyKSYmKDE9PT10WzBdfHwxPT09ZVswXSkpcmV0dXJuITB9cmV0dXJuIHRbMV09PT1lWzFdJiZGZSh0WzBdKSYmRmUoZVswXSl9ZnVuY3Rpb24gT2UodCl7aWYobnVsbD09aWUpe3ZhciBlPWp0KHQpO2llPWUuZ2V0UGFyYW1ldGVyKGUuTUFYX1RFWFRVUkVfU0laRSl9cmV0dXJuIGllfWZ1bmN0aW9uIE1lKHQpe2lmKG51bGw9PXNlKXt2YXIgZT1qdCh0KTtzZT1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKX1yZXR1cm4gTWF0aC5taW4oMTYsc2UpfWZ1bmN0aW9uIEJlKHQpe2lmKDA9PT10KXJldHVybiAwO3ZhciBlPWp0KHQpO3JldHVybiBQZShlLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSYmMj09PXQ/MjpQZShlLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XCIpPzE6MH1mdW5jdGlvbiBQZSh0LGUpe3JldHVybiBudWxsIT10LmdldEV4dGVuc2lvbihlKX1mdW5jdGlvbiBMZSh0KXt0cnl7aWYobnVsbCE9anQodCkpcmV0dXJuITB9Y2F0Y2godCl7cmV0dXJuITF9cmV0dXJuITF9ZnVuY3Rpb24gV2UodCl7aWYoMD09PXQpcmV0dXJuITE7dmFyIGU9anQodCk7aWYoMT09PXQpe2lmKCFQZShlLFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITF9ZWxzZSBpZighUGUoZSxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITE7cmV0dXJuIFZlKGUpfWZ1bmN0aW9uIFVlKHQpe2lmKDA9PT10KXJldHVybiExO3ZhciBlPWp0KHQpO2lmKDEhPT10KXtpZihQZShlLFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4gVmUoZSk7aWYoUGUoZSxcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSl7dmFyIG49ZS5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIik7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49UXQodCxlKSxyPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELHIpO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0SGFsZkZsb2F0LDEsMSwwLG4udGV4dHVyZUZvcm1hdEZsb2F0LG4udGV4dHVyZVR5cGVIYWxmRmxvYXQsbnVsbCk7dmFyIG89dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbyksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELHIsMCk7dmFyIGE9dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpPT09dC5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKSx0LmRlbGV0ZVRleHR1cmUociksdC5kZWxldGVGcmFtZWJ1ZmZlcihvKSxhfShlLG4pfXJldHVybiExfXJldHVybiEhUGUoZSxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpJiYoISFQZShlLFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpJiZWZShlKSl9ZnVuY3Rpb24gVmUodCl7dmFyIGU9UXQodCksbj10LmNyZWF0ZVRleHR1cmUoKTt0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKTt0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsZS5pbnRlcm5hbEZvcm1hdEZsb2F0LDEsMSwwLGUudGV4dHVyZUZvcm1hdEZsb2F0LGUudGV4dHVyZVR5cGVGbG9hdCxudWxsKTt2YXIgcj10LmNyZWF0ZUZyYW1lYnVmZmVyKCk7dC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixyKSx0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsbiwwKTt2YXIgbz10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShuKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKHIpLG99ZnVuY3Rpb24gemUodCl7cmV0dXJuIDI9PT10JiZudWxsIT1qdCh0KS5mZW5jZVN5bmN9dmFyIEdlPU9iamVjdC5mcmVlemUoe2NhbGxBbmRDaGVjazpKdCxjYW5CZVJlcHJlc2VudGVkOmVlLGdldFdlYkdMRXJyb3JNZXNzYWdlOm5lLGdldEV4dGVuc2lvbk9yVGhyb3c6cmUsY3JlYXRlVmVydGV4U2hhZGVyOm9lLGNyZWF0ZUZyYWdtZW50U2hhZGVyOmFlLGNyZWF0ZVByb2dyYW06Y2UsbGlua1Byb2dyYW06bGUsdmFsaWRhdGVQcm9ncmFtOmhlLGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcjpmZSxjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcjpkZSxnZXROdW1DaGFubmVsczpmdW5jdGlvbigpe3JldHVybiAyPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/MTo0fSxjcmVhdGVUZXh0dXJlOnBlLHZhbGlkYXRlVGV4dHVyZVNpemU6dmUsY3JlYXRlRnJhbWVidWZmZXI6bWUsYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTpnZSxiaW5kVGV4dHVyZVVuaXQ6eWUsdW5iaW5kVGV4dHVyZVVuaXQ6ZnVuY3Rpb24odCxlLG4pe1NlKHQsbiksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmFjdGl2ZVRleHR1cmUodC5URVhUVVJFMCtuKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSkpfSxnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdzp4ZSxnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uOmJlLGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI6d2UsYmluZENhbnZhc1RvRnJhbWVidWZmZXI6ZnVuY3Rpb24odCxlKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnZpZXdwb3J0KDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5zY2lzc29yKDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpfSkpfSxiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjpDZSx1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI6RWUsdmFsaWRhdGVGcmFtZWJ1ZmZlcjpSZSxnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTpJZSxnZXRCYXRjaERpbTpBZSxnZXRSb3dzQ29sczpEZSxnZXRTaGFwZUFzM0Q6VGUsZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZTpOZSxpc1Jlc2hhcGVGcmVlOl9lLGdldFdlYkdMTWF4VGV4dHVyZVNpemU6T2UscmVzZXRNYXhUZXh0dXJlU2l6ZTpmdW5jdGlvbigpe2llPW51bGx9LHJlc2V0TWF4VGV4dHVyZXNJblNoYWRlcjpmdW5jdGlvbigpe3NlPW51bGx9LGdldE1heFRleHR1cmVzSW5TaGFkZXI6TWUsZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uOkJlLGhhc0V4dGVuc2lvbjpQZSxpc1dlYkdMVmVyc2lvbkVuYWJsZWQ6TGUsaXNDYXBhYmxlT2ZSZW5kZXJpbmdUb0Zsb2F0VGV4dHVyZTpXZSxpc0Rvd25sb2FkRmxvYXRUZXh0dXJlRW5hYmxlZDpVZSxpc1dlYkdMRmVuY2VFbmFibGVkOnplfSksSGU9aSgpO2Z1bmN0aW9uIHFlKCl7aSgpLnNldChcIlBST0RcIiwhMCl9ZnVuY3Rpb24gS2UoKXtpKCkuc2V0KFwiREVCVUdcIiwhMCl9ZnVuY3Rpb24gamUoKXtpKCkuc2V0KFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiLCExKSxjb25zb2xlLndhcm4oXCJUZW5zb3JGbG93LmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzIGhhdmUgYmVlbiBkaXNhYmxlZC5cIil9ZnVuY3Rpb24gWGUodCl7aSgpLmdldEJvb2woXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIpJiZjb25zb2xlLndhcm4odCtcIiBZb3UgY2FuIGRpc2FibGUgZGVwcmVjYXRpb24gd2FybmluZ3Mgd2l0aCB0Zi5kaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5ncygpLlwiKX1mdW5jdGlvbiBZZSgpe0x0LmRpc3Bvc2VWYXJpYWJsZXMoKX1mdW5jdGlvbiAkZSgpe3JldHVybiBMdH1mdW5jdGlvbiBRZSgpe3JldHVybiBMdC5tZW1vcnkoKX1mdW5jdGlvbiBKZSh0KXtyZXR1cm4gTHQucHJvZmlsZSh0KX1mdW5jdGlvbiBaZSh0LGUpe3JldHVybiBMdC50aWR5KHQsZSl9ZnVuY3Rpb24gdG4odCl7X3QodCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGlzcG9zZSgpfSkpfWZ1bmN0aW9uIGVuKHQpe3JldHVybiBMdC5rZWVwKHQpfWZ1bmN0aW9uIG5uKHQpe3JldHVybiBMdC50aW1lKHQpfWZ1bmN0aW9uIHJuKHQpe3JldHVybiBMdC5zZXRCYWNrZW5kKHQpfWZ1bmN0aW9uIG9uKCl7cmV0dXJuIEx0LnJlYWR5KCl9ZnVuY3Rpb24gYW4oKXtyZXR1cm4gTHQuYmFja2VuZE5hbWV9ZnVuY3Rpb24gc24odCl7THQucmVtb3ZlQmFja2VuZCh0KX1mdW5jdGlvbiB1bih0KXtyZXR1cm4gTHQuZmluZEJhY2tlbmQodCl9ZnVuY3Rpb24gY24odCl7cmV0dXJuIEx0LmZpbmRCYWNrZW5kRmFjdG9yeSh0KX1mdW5jdGlvbiBsbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTEpLEx0LnJlZ2lzdGVyQmFja2VuZCh0LGUsbil9ZnVuY3Rpb24gaG4oKXtyZXR1cm4gTHQuYmFja2VuZH1mdW5jdGlvbiBmbih0LGUpe2koKS5zZXRQbGF0Zm9ybSh0LGUpfWZ1bmN0aW9uIGRuKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO2koKS5nZXRCb29sKFwiSVNfVEVTVFwiKXx8Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsdCl9ZnVuY3Rpb24gcG4odCxlKXt2YXIgbj10O2lmKFYodCkpcmV0dXJuXCJzdHJpbmdcIj09PWU/W106W3QubGVuZ3RoXTtpZighQXJyYXkuaXNBcnJheSh0KSlyZXR1cm5bXTtmb3IodmFyIHI9W107QXJyYXkuaXNBcnJheShuKXx8VihuKSYmXCJzdHJpbmdcIiE9PWU7KXIucHVzaChuLmxlbmd0aCksbj1uWzBdO3JldHVybiBBcnJheS5pc0FycmF5KHQpJiZpKCkuZ2V0Qm9vbChcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIikmJmZ1bmN0aW9uIHQoZSxuLHIpe2lmKHI9cnx8W10sIUFycmF5LmlzQXJyYXkoZSkmJiFWKGUpKXJldHVybiB2b2lkIEMoMD09PW4ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIGlzIGEgcHJpbWl0aXZlLCBidXQgc2hvdWxkIGJlIGFuIGFycmF5L1R5cGVkQXJyYXkgb2YgXCIrblswXStcIiBlbGVtZW50c1wifSkpO0Mobi5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVsZW1lbnQgYXJyW1wiK3Iuam9pbihcIl1bXCIpK1wiXSBzaG91bGQgYmUgYSBwcmltaXRpdmUsIGJ1dCBpcyBhbiBhcnJheSBvZiBcIitlLmxlbmd0aCtcIiBlbGVtZW50c1wifSkpLEMoZS5sZW5ndGg9PT1uWzBdLChmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIHNob3VsZCBoYXZlIFwiK25bMF0rXCIgZWxlbWVudHMsIGJ1dCBoYXMgXCIrZS5sZW5ndGgrXCIgZWxlbWVudHNcIn0pKTtmb3IodmFyIG89bi5zbGljZSgxKSxhPTA7YTxlLmxlbmd0aDsrK2EpdChlW2FdLG8sci5jb25jYXQoYSkpfSh0LHIsW10pLHJ9ZnVuY3Rpb24gdm4odCxlLG4scil7aWYobnVsbCE9dCYmKFwibnVtZXJpY1wiIT09dCYmdCE9PWV8fFwibnVtZXJpY1wiPT09dCYmXCJzdHJpbmdcIj09PWUpKXRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50ICdcIituK1wiJyBwYXNzZWQgdG8gJ1wiK3IrXCInIG11c3QgYmUgXCIrdCtcIiB0ZW5zb3IsIGJ1dCBnb3QgXCIrZStcIiB0ZW5zb3JcIil9ZnVuY3Rpb24gbW4odCxlLG4scil7aWYodm9pZCAwPT09ciYmKHI9XCJudW1lcmljXCIpLHQgaW5zdGFuY2VvZiB3dClyZXR1cm4gdm4ocix0LmR0eXBlLGUsbiksdDt2YXIgbz1qKHQpO2lmKFwic3RyaW5nXCIhPT1vJiZbXCJib29sXCIsXCJpbnQzMlwiLFwiZmxvYXQzMlwiXS5pbmRleE9mKHIpPj0wJiYobz1yKSx2bihyLG8sZSxuKSxudWxsPT10fHwhVih0KSYmIUFycmF5LmlzQXJyYXkodCkmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiZcImJvb2xlYW5cIiE9dHlwZW9mIHQmJlwic3RyaW5nXCIhPXR5cGVvZiB0KXt2YXIgYT1udWxsPT10P1wibnVsbFwiOnQuY29uc3RydWN0b3IubmFtZTt0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAnXCIrZStcIicgcGFzc2VkIHRvICdcIituK1wiJyBtdXN0IGJlIGEgVGVuc29yIG9yIFRlbnNvckxpa2UsIGJ1dCBnb3QgJ1wiK2ErXCInXCIpfXZhciBzPXBuKHQsbyk7Vih0KXx8QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKTt2YXIgdT1cInN0cmluZ1wiIT09bz9RKHQsbyxpKCkuZ2V0Qm9vbChcIkRFQlVHXCIpKTpJKHQsW10sITApO3JldHVybiBMdC5tYWtlVGVuc29yKHUscyxvKX1mdW5jdGlvbiBnbih0LGUsbixyKXtpZih2b2lkIDA9PT1yJiYocj1cIm51bWVyaWNcIiksIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgXCIrZStcIiBwYXNzZWQgdG8gXCIrbitcIiBtdXN0IGJlIGEgYFRlbnNvcltdYCBvciBgVGVuc29yTGlrZVtdYFwiKTtyZXR1cm4gdC5tYXAoKGZ1bmN0aW9uKHQscil7cmV0dXJuIG1uKHQsZStcIltcIityK1wiXVwiLG4pfSkscil9ZnVuY3Rpb24geW4odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoOysrbilpZih0W3QubGVuZ3RoLW4tMV0hPT1lLTEtbilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB4bih0LGUsbil7Zm9yKHZhciByPXQubGVuZ3RoK2UubGVuZ3RoLG89W10sYT0wLGk9MCxzPTA7czxyO3MrKyktMT09PW4uaW5kZXhPZihzKT9vLnB1c2godFthKytdKTpvLnB1c2goZVtpKytdKTtyZXR1cm4gb31mdW5jdGlvbiBibih0LGUpe2Zvcih2YXIgbj1bXSxyPXQubGVuZ3RoLG89MDtvPHI7bysrKS0xPT09ZS5pbmRleE9mKG8pJiZuLnB1c2godFtvXSk7cmV0dXJuW24sZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfSkpXX1mdW5jdGlvbiB3bih0LGUpe3JldHVybiB4bih0LGUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gMX0pKSxlKX1mdW5jdGlvbiBDbih0LGUsbil7Qyh5bihlLG4pLChmdW5jdGlvbigpe3JldHVybiB0K1wiIHN1cHBvcnRzIG9ubHkgaW5uZXItbW9zdCBheGVzIGZvciBub3cuIEdvdCBheGVzIFwiK2UrXCIgYW5kIHJhbmstXCIrbitcIiBpbnB1dC5cIn0pKX1mdW5jdGlvbiBFbih0LGUpe2lmKHluKHQsZSkpcmV0dXJuIG51bGw7Zm9yKHZhciBuPVtdLHI9MDtyPGU7KytyKS0xPT09dC5pbmRleE9mKHIpJiZuLnB1c2gocik7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIG4ucHVzaCh0KX0pKSxufWZ1bmN0aW9uIFJuKHQpe3JldHVybiB0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5bZSx0XX0pKS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0WzFdLWVbMV19KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKX1mdW5jdGlvbiBJbih0LGUpe2Zvcih2YXIgbj1bXSxyPWUtdDtyPGU7KytyKW4ucHVzaChyKTtyZXR1cm4gbn1mdW5jdGlvbiBrbih0LGUpe3ZhciBuPXRbMF0ubGVuZ3RoO3QuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtDKHQubGVuZ3RoPT09biwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiByYW5rIG9mIHRlbnNvcnNbXCIrZStcIl0gbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgcmFuayBvZiB0aGUgcmVzdCAoXCIrbitcIilcIn0pKX0pKSxDKGU+PTAmJmU8biwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiBheGlzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCBcIisobi0xKStcIi5cIn0pKTt2YXIgcj10WzBdO3QuZm9yRWFjaCgoZnVuY3Rpb24odCxvKXtmb3IodmFyIGE9MDthPG47YSsrKUMoYT09PWV8fHRbYV09PT1yW2FdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29uY2F0XCIrbitcIkQ6IFNoYXBlIG9mIHRlbnNvcnNbXCIrbytcIl0gKFwiK3QrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgcmVzdCAoXCIrcitcIikgYWxvbmcgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhpcyBcIitvK1wiLlwifSkpfSkpfWZ1bmN0aW9uIFNuKHQsZSl7Zm9yKHZhciBuPXRbMF0uc2xpY2UoKSxyPTE7cjx0Lmxlbmd0aDtyKyspbltlXSs9dFtyXVtlXTtyZXR1cm4gbn1mdW5jdGlvbiBBbih0KXt2YXIgZT1PYmplY3Qua2V5cyh0KTtpZigxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5IChvcGVyYXRpb24gbmFtZSkgbWFwcGluZyB0byBhIGZ1bmN0aW9uLiBHb3QgYW4gb2JqZWN0IHdpdGggXCIrZS5sZW5ndGgrXCIga2V5cy5cIik7dmFyIG49ZVswXSxyPXRbbl07bi5lbmRzV2l0aChcIl9cIikmJihuPW4uc3Vic3RyaW5nKDAsbi5sZW5ndGgtMSkpO3ZhciBvPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO0x0LnN0YXJ0U2NvcGUobik7dHJ5e3ZhciBvPXIuYXBwbHkodm9pZCAwLHQpO3JldHVybiBvIGluc3RhbmNlb2YgUHJvbWlzZSYmY29uc29sZS5lcnJvcihcIkNhbm5vdCByZXR1cm4gYSBQcm9taXNlIGluc2lkZSBvZiB0aWR5LlwiKSxMdC5lbmRTY29wZShvKSxvfWNhdGNoKHQpe3Rocm93IEx0LmVuZFNjb3BlKG51bGwpLHR9fTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sXCJuYW1lXCIse3ZhbHVlOm4sY29uZmlndXJhYmxlOiEwfSksb31IZS5yZWdpc3RlckZsYWcoXCJIQVNfV0VCR0xcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT4wfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1ZFUlNJT05cIiwoZnVuY3Rpb24oKXtyZXR1cm4gTGUoMik/MjpMZSgxKT8xOjB9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiLChmdW5jdGlvbigpe3JldHVybiAyPT09SGUuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9DUFVfRk9SV0FSRFwiLChmdW5jdGlvbigpe3JldHVybiEwfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiLChmdW5jdGlvbigpe3JldHVybiExfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIkhBU19XRUJHTFwiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19DTElQXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiLChmdW5jdGlvbigpe3JldHVybiExfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19SRURVQ0VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9DT05WX0lNMkNPTFwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE9lKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTWUoSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIiwoZnVuY3Rpb24oKXt2YXIgdD1IZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpO3JldHVybiAwPT09dD8wOkJlKHQpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wJiYodD1uYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEsISgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdCh0KXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdCh0LnN1YnN0cigwLDQpKSkpO3ZhciB0fSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0NBUEFCTEVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gV2UoSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiLChmdW5jdGlvbigpe3JldHVybiFIZS5nZXRCb29sKFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIpJiZIZS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRVwiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFVlKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHplKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/NDowfSkpLGJ0PVhlO3ZhciBEbj1Bbih7Y29tcGxleF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwicmVhbFwiLFwiY29tcGxleFwiKSxyPW1uKGUsXCJpbWFnXCIsXCJjb21wbGV4XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcInJlYWwgYW5kIGltYWcgc2hhcGVzLCBcIituLnNoYXBlK1wiIGFuZCBcIityLnNoYXBlK1wiLCBtdXN0IG1hdGNoIGluIGNhbGwgdG8gdGYuY29tcGxleCgpLlwiKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21wbGV4KG4scil9KSx7JHJlYWw6biwkaW1hZzpyfSl9fSksVG49QW4oe3JlYWxfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJpbnB1dFwiLFwicmVhbFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhbChlKX0pLHskaW5wdXQ6ZX0pfX0pLE5uPUFuKHtpbWFnXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwiaW5wdXRcIixcImltYWdcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmltYWcoZSl9KSx7JGlucHV0OmV9KX19KTtmdW5jdGlvbiBGbih0LGUsbil7cmV0dXJuIF9uKHQsZSxwbih0LG4pLG4pfWZ1bmN0aW9uIF9uKHQsZSxuLHIpe2lmKG51bGw9PXImJihyPWoodCkpLFwiY29tcGxleDY0XCI9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgYSBjb21wbGV4NjQgdGVuc29yIGRpcmVjdGx5LiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO2lmKCFWKHQpJiYhQXJyYXkuaXNBcnJheSh0KSYmXCJudW1iZXJcIiE9dHlwZW9mIHQmJlwiYm9vbGVhblwiIT10eXBlb2YgdCYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIHBhc3NlZCB0byB0ZW5zb3IodmFsdWVzKSBtdXN0IGJlIGEgbnVtYmVyL2Jvb2xlYW4vc3RyaW5nIG9yIGFuIGFycmF5IG9mIG51bWJlcnMvYm9vbGVhbnMvc3RyaW5ncywgb3IgYSBUeXBlZEFycmF5XCIpO2lmKG51bGwhPWUpe250KGUpO3ZhciBvPWsoZSksYT1rKG4pO0Mobz09PWEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXNlZCBvbiB0aGUgcHJvdmlkZWQgc2hhcGUsIFtcIitlK1wiXSwgdGhlIHRlbnNvciBzaG91bGQgaGF2ZSBcIitvK1wiIHZhbHVlcyBidXQgaGFzIFwiK2F9KSk7Zm9yKHZhciBzPTA7czxuLmxlbmd0aDsrK3Mpe3ZhciB1PW5bc10sYz1zIT09bi5sZW5ndGgtMXx8dSE9PWsoZS5zbGljZShzKSk7QyhuW3NdPT09ZVtzXXx8IWMsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBjcmVhdGluZyBhIG5ldyBUZW5zb3IuIEluZmVycmVkIHNoYXBlIChcIituK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgKFwiK2UrXCIpLiBcIn0pKX19cmV0dXJuIFYodCl8fEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksZT1lfHxuLHQ9XCJzdHJpbmdcIiE9PXI/USh0LHIsaSgpLmdldEJvb2woXCJERUJVR1wiKSk6SSh0LFtdLCEwKSxMdC5tYWtlVGVuc29yKHQsZSxyKX1mdW5jdGlvbiBPbih0LGUpe2lmKChWKHQpJiZcInN0cmluZ1wiIT09ZXx8QXJyYXkuaXNBcnJheSh0KSkmJlwiY29tcGxleDY0XCIhPT1lKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGNyZWF0aW5nIGEgbmV3IFNjYWxhcjogdmFsdWUgbXVzdCBiZSBhIHByaW1pdGl2ZSAobnVtYmVyfGJvb2xlYW58c3RyaW5nKVwiKTtpZihcInN0cmluZ1wiPT09ZSYmVih0KSYmISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBtYWtpbmcgYSBzY2FsYXIgZnJvbSBlbmNvZGVkIHN0cmluZywgdGhlIHZhbHVlIG11c3QgYmUgYFVpbnQ4QXJyYXlgLlwiKTtyZXR1cm4gX24odCxbXSxbXSxlKX1mdW5jdGlvbiBNbih0LGUpe1IodCk7dmFyIG49cG4odCxlKTtpZigxIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIF9uKHQsbnVsbCxuLGUpfWZ1bmN0aW9uIEJuKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdHdvIG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZigyIT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gX24odCxlLHIsbil9ZnVuY3Rpb24gUG4odCxlLG4pe2lmKFIodCksbnVsbCE9ZSYmMyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSB0aHJlZSBudW1iZXJzXCIpO3ZhciByPXBuKHQsbik7aWYoMyE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIF9uKHQsZSxyLG4pfWZ1bmN0aW9uIExuKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjQhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZm91ciBudW1iZXJzXCIpO3ZhciByPXBuKHQsbik7aWYoNCE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gX24odCxlLHIsbil9ZnVuY3Rpb24gV24odCxlLG4pe2lmKFIodCksbnVsbCE9ZSYmNSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmaXZlIG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZig1IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIF9uKHQsZSxyLG4pfWZ1bmN0aW9uIFVuKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjYhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgc2l4IG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZig2IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gX24odCxlPWV8fHIscixuKX1mdW5jdGlvbiBWbih0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITApLEx0Lm1ha2VWYXJpYWJsZSh0LGUsbixyKX1mdW5jdGlvbiB6bih0LGUpe2lmKHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxcImNvbXBsZXg2NFwiPT09ZSl7dmFyIG49em4odCxcImZsb2F0MzJcIikscj1Hbih0LFwiZmxvYXQzMlwiKTtyZXR1cm4gRG4obixyKX12YXIgbz1aKGsodCksZSk7cmV0dXJuIEx0Lm1ha2VUZW5zb3Iobyx0LGUpfWZ1bmN0aW9uIEduKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLFwiY29tcGxleDY0XCI9PT1lKXt2YXIgbj1Hbih0LFwiZmxvYXQzMlwiKSxyPUduKHQsXCJmbG9hdDMyXCIpO3JldHVybiBEbihuLHIpfXZhciBvPXR0KGsodCksZSk7cmV0dXJuIEx0Lm1ha2VUZW5zb3Iobyx0LGUpfWZ1bmN0aW9uIEhuKHQsZSxuKXtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24ocil7cmV0dXJuIHIuZmlsbCh0LGUsbil9KSx7fSl9ZnVuY3Rpb24gcW4odCxlLG4pe2lmKG48PTApdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiB2YWx1ZXMgc2hvdWxkIGJlIHBvc2l0aXZlLlwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24ocil7cmV0dXJuIHIubGluc3BhY2UodCxlLG4pfSkse30pfWZ1bmN0aW9uIEtuKHQsZSxuLHIpe2lmKHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBhIHN0ZXAgb2YgemVyb1wiKTtpZih0PT09ZXx8dDxlJiZuPDB8fGU8dCYmbj4xKXJldHVybiBHbihbMF0scik7dmFyIG89dHQoTWF0aC5hYnMoTWF0aC5jZWlsKChlLXQpL24pKSxyKTtlPHQmJjE9PT1uJiYobj0tMSksb1swXT10O2Zvcih2YXIgYT0xO2E8by5sZW5ndGg7YSsrKW9bYV09b1thLTFdK247cmV0dXJuIE1uKG8scil9dmFyIGpuPUFuKHtvbmVzTGlrZV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcIm9uZXNMaWtlXCIpO2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXt2YXIgbj1qbihUbihlKSkscj1YbihObihlKSk7cmV0dXJuIERuKG4scil9cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9uZXNMaWtlKGUpfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLFhuPUFuKHt6ZXJvc0xpa2VfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJ6ZXJvc0xpa2VcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lnplcm9zTGlrZShlKX0pLHskeDplfSwoZnVuY3Rpb24odCxlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KTt2YXIgWW49QW4oe2NvbmNhdF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKSxDKHQubGVuZ3RoPj0xLChmdW5jdGlvbigpe3JldHVyblwiUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIGNvbmNhdFwifSkpO3ZhciBuPWduKHQsXCJ0ZW5zb3JzXCIsXCJjb25jYXRcIik7XCJjb21wbGV4NjRcIj09PW5bMF0uZHR5cGUmJm4uZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoXCJjb21wbGV4NjRcIiE9PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbmNhdGVuYXRlIGNvbXBsZXg2NCB0ZW5zb3JzIHdpdGggYSB0ZW5zb3JcXG4gICAgICAgICAgd2l0aCBkdHlwZSBcIit0LmR0eXBlK1wiLiBcIil9KSksZT1PKGUsblswXS5zaGFwZSlbMF07dmFyIHI9U24obi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLGUpO2lmKDA9PT1rKHIpKXJldHVybiBGbihbXSxyKTtpZigxPT09KG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNpemU+MH0pKSkubGVuZ3RoKXJldHVybiBuWzBdO3ZhciBvPW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKTtrbihvLGUpO3ZhciBhPW4saT17YXhpczplfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29uY2F0KG4sZSl9KSxhLChmdW5jdGlvbih0KXt2YXIgbj1vLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbZV19KSk7cmV0dXJuIHRyKHQsbixlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX0pKX0pLFwiQ29uY2F0XCIsaSl9fSksJG49QW4oe2NvbmNhdDFkXzpmdW5jdGlvbih0KXtyZXR1cm4gWW4odCwwKX19KSxRbj1Bbih7Y29uY2F0MmRfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFluKHQsZSl9fSksSm49QW4oe2NvbmNhdDNkXzpmdW5jdGlvbih0LGUpe3JldHVybiBZbih0LGUpfX0pLFpuPUFuKHtjb25jYXQ0ZF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gWW4odCxlKX19KSx0cj1Bbih7c3BsaXRfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0wKTt2YXIgcixvPW1uKHQsXCJ4XCIsXCJzcGxpdFwiKTtyZXR1cm4gbj1PKG4sby5zaGFwZSlbMF0sXCJudW1iZXJcIj09dHlwZW9mIGU/KEMoby5zaGFwZVtuXSVlPT0wLChmdW5jdGlvbigpe3JldHVyblwiTnVtYmVyIG9mIHNwbGl0cyBtdXN0IGV2ZW5seSBkaXZpZGUgdGhlIGF4aXMuXCJ9KSkscj1uZXcgQXJyYXkoZSkuZmlsbChvLnNoYXBlW25dL2UpKTooQyhvLnNoYXBlW25dPT09ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBzdW0gb2Ygc2l6ZXMgbXVzdCBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgYXhpcyBkaW1lbnNpb24uXCJ9KSkscj1lKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdChvLHIsbil9KSx7JHg6b30sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBZbih0LG4pfX19KSl9fSk7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZjtmdW5jdGlvbiBlcih0LGUpe3JldHVybiB0KGU9e2V4cG9ydHM6e319LGUuZXhwb3J0cyksZS5leHBvcnRzfXZhciBucj1lcigoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlLG49dGhpcyxyPShlPTQwMjI4NzExOTcsZnVuY3Rpb24odCl7dD10LnRvU3RyaW5nKCk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPS4wMjUxOTYwMzI4MjQxNjkzOCooZSs9dC5jaGFyQ29kZUF0KG4pKTtyLT1lPXI+Pj4wLGU9KHIqPWUpPj4+MCxlKz00Mjk0OTY3Mjk2KihyLT1lKX1yZXR1cm4gMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCooZT4+PjApfSk7bi5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9MjA5MTYzOSpuLnMwKzIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqbi5jO3JldHVybiBuLnMwPW4uczEsbi5zMT1uLnMyLG4uczI9dC0obi5jPTB8dCl9LG4uYz0xLG4uczA9cihcIiBcIiksbi5zMT1yKFwiIFwiKSxuLnMyPXIoXCIgXCIpLG4uczAtPXIodCksbi5zMDwwJiYobi5zMCs9MSksbi5zMS09cih0KSxuLnMxPDAmJihuLnMxKz0xKSxuLnMyLT1yKHQpLG4uczI8MCYmKG4uczIrPTEpLHI9bnVsbH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUuYz10LmMsZS5zMD10LnMwLGUuczE9dC5zMSxlLnMyPXQuczIsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9bi5uZXh0O3JldHVybiBpLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5NjcyOTYqbi5uZXh0KCl8MH0saS5kb3VibGU9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpKzExMTAyMjMwMjQ2MjUxNTY1ZS0zMiooMjA5NzE1MippKCl8MCl9LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMuYWxlYT1hfSgwLHQsITEpfSkpLHJyPWVyKChmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcyxuPVwiXCI7ZS54PTAsZS55PTAsZS56PTAsZS53PTAsZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS54XmUueDw8MTE7cmV0dXJuIGUueD1lLnksZS55PWUueixlLno9ZS53LGUud149ZS53Pj4+MTledF50Pj4+OH0sdD09PSgwfHQpP2UueD10Om4rPXQ7Zm9yKHZhciByPTA7cjxuLmxlbmd0aCs2NDtyKyspZS54Xj0wfG4uY2hhckNvZGVBdChyKSxlLm5leHQoKX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUueD10LngsZS55PXQueSxlLno9dC56LGUudz10LncsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLnhvcjEyOD1hfSgwLHQsITEpfSkpLG9yPWVyKChmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcyxuPVwiXCI7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS54XmUueD4+PjI7cmV0dXJuIGUueD1lLnksZS55PWUueixlLno9ZS53LGUudz1lLnYsKGUuZD1lLmQrMzYyNDM3fDApKyhlLnY9ZS52XmUudjw8NF50XnQ8PDEpfDB9LGUueD0wLGUueT0wLGUuej0wLGUudz0wLGUudj0wLHQ9PT0oMHx0KT9lLng9dDpuKz10O2Zvcih2YXIgcj0wO3I8bi5sZW5ndGgrNjQ7cisrKWUueF49MHxuLmNoYXJDb2RlQXQocikscj09bi5sZW5ndGgmJihlLmQ9ZS54PDwxMF5lLng+Pj40KSxlLm5leHQoKX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUueD10LngsZS55PXQueSxlLno9dC56LGUudz10LncsZS52PXQudixlLmQ9dC5kLGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy54b3J3b3c9YX0oMCx0LCExKX0pKSxhcj1lcigoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXM7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQsbixyPWUueCxvPWUuaTtyZXR1cm4gdD1yW29dLG49KHRePXQ+Pj43KV50PDwyNCxuXj0odD1yW28rMSY3XSledD4+PjEwLG5ePSh0PXJbbyszJjddKV50Pj4+MyxuXj0odD1yW28rNCY3XSledDw8Nyx0PXJbbys3JjddLG5ePSh0Xj10PDwxMyledDw8OSxyW29dPW4sZS5pPW8rMSY3LG59LGZ1bmN0aW9uKHQsZSl7dmFyIG4scj1bXTtpZihlPT09KDB8ZSkpclswXT1lO2Vsc2UgZm9yKGU9XCJcIitlLG49MDtuPGUubGVuZ3RoOysrbilyWzcmbl09cls3Jm5dPDwxNV5lLmNoYXJDb2RlQXQobikrcltuKzEmN108PDEzO2Zvcig7ci5sZW5ndGg8ODspci5wdXNoKDApO2ZvcihuPTA7bjw4JiYwPT09cltuXTsrK24pO2Zvcig4PT1uP3JbN109LTE6cltuXSx0Lng9cix0Lmk9MCxuPTI1NjtuPjA7LS1uKXQubmV4dCgpfShlLHQpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS54PXQueC5zbGljZSgpLGUuaT10LmksZX1mdW5jdGlvbiBhKHQsZSl7bnVsbD09dCYmKHQ9K25ldyBEYXRlKTt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoYS54JiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLnhvcnNoaWZ0Nz1hfSgwLHQsITEpfSkpLGlyPWVyKChmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcztlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdCxuLHI9ZS53LG89ZS5YLGE9ZS5pO3JldHVybiBlLnc9cj1yKzE2NDA1MzE1Mjd8MCxuPW9bYSszNCYxMjddLHQ9b1thPWErMSYxMjddLG5ePW48PDEzLHRePXQ8PDE3LG5ePW4+Pj4xNSx0Xj10Pj4+MTIsbj1vW2FdPW5edCxlLmk9YSxuKyhyXnI+Pj4xNil8MH0sZnVuY3Rpb24odCxlKXt2YXIgbixyLG8sYSxpLHM9W10sdT0xMjg7Zm9yKGU9PT0oMHxlKT8ocj1lLGU9bnVsbCk6KGUrPVwiXFwwXCIscj0wLHU9TWF0aC5tYXgodSxlLmxlbmd0aCkpLG89MCxhPS0zMjthPHU7KythKWUmJihyXj1lLmNoYXJDb2RlQXQoKGErMzIpJWUubGVuZ3RoKSksMD09PWEmJihpPXIpLHJePXI8PDEwLHJePXI+Pj4xNSxyXj1yPDw0LHJePXI+Pj4xMyxhPj0wJiYoaT1pKzE2NDA1MzE1Mjd8MCxvPTA9PShuPXNbMTI3JmFdXj1yK2kpP28rMTowKTtmb3Iobz49MTI4JiYoc1sxMjcmKGUmJmUubGVuZ3RofHwwKV09LTEpLG89MTI3LGE9NTEyO2E+MDstLWEpcj1zW28rMzQmMTI3XSxuPXNbbz1vKzEmMTI3XSxyXj1yPDwxMyxuXj1uPDwxNyxyXj1yPj4+MTUsbl49bj4+PjEyLHNbb109cl5uO3Qudz1pLHQuWD1zLHQuaT1vfShlLHQpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS5pPXQuaSxlLnc9dC53LGUuWD10Llguc2xpY2UoKSxlfWZ1bmN0aW9uIGEodCxlKXtudWxsPT10JiYodD0rbmV3IERhdGUpO3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihhLlgmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMueG9yNDA5Nj1hfSgwLHQsITEpfSkpLHNyPWVyKChmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcyxuPVwiXCI7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS5iLG49ZS5jLHI9ZS5kLG89ZS5hO3JldHVybiB0PXQ8PDI1XnQ+Pj43Xm4sbj1uLXJ8MCxyPXI8PDI0XnI+Pj44Xm8sbz1vLXR8MCxlLmI9dD10PDwyMF50Pj4+MTJebixlLmM9bj1uLXJ8MCxlLmQ9cjw8MTZebj4+PjE2Xm8sZS5hPW8tdHwwfSxlLmE9MCxlLmI9MCxlLmM9LTE2NDA1MzE1MjcsZS5kPTEzNjcxMzA1NTEsdD09PU1hdGguZmxvb3IodCk/KGUuYT10LzQyOTQ5NjcyOTZ8MCxlLmI9MHx0KTpuKz10O2Zvcih2YXIgcj0wO3I8bi5sZW5ndGgrMjA7cisrKWUuYl49MHxuLmNoYXJDb2RlQXQociksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLmE9dC5hLGUuYj10LmIsZS5jPXQuYyxlLmQ9dC5kLGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy50eWNoZWk9YX0oMCx0LCExKX0pKSx1cj1lcigoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUsbil7dmFyIHIsbz10aGlzLGE9MjU2LGk9NixzPVwicmFuZG9tXCIsdT1uLnBvdyhhLGkpLGM9bi5wb3coMiw1MiksbD0yKmMsaD1hLTE7ZnVuY3Rpb24gZih0LGgsZil7dmFyIGc9W10seT12KGZ1bmN0aW9uIHQoZSxuKXt2YXIgcixvPVtdLGE9dHlwZW9mIGU7aWYobiYmXCJvYmplY3RcIj09YSlmb3IociBpbiBlKXRyeXtvLnB1c2godChlW3JdLG4tMSkpfWNhdGNoKHQpe31yZXR1cm4gby5sZW5ndGg/bzpcInN0cmluZ1wiPT1hP2U6ZStcIlxcMFwifSgoaD0xPT1oP3tlbnRyb3B5OiEwfTpofHx7fSkuZW50cm9weT9bdCxtKGUpXTpudWxsPT10P2Z1bmN0aW9uKCl7dHJ5e3ZhciB0O3JldHVybiByJiYodD1yLnJhbmRvbUJ5dGVzKT90PXQoYSk6KHQ9bmV3IFVpbnQ4QXJyYXkoYSksKG8uY3J5cHRvfHxvLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXModCkpLG0odCl9Y2F0Y2godCl7dmFyIG49by5uYXZpZ2F0b3IsaT1uJiZuLnBsdWdpbnM7cmV0dXJuWytuZXcgRGF0ZSxvLGksby5zY3JlZW4sbShlKV19fSgpOnQsMyksZykseD1uZXcgZChnKSxiPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXguZyhpKSxlPXUsbj0wO3Q8YzspdD0odCtuKSphLGUqPWEsbj14LmcoMSk7Zm9yKDt0Pj1sOyl0Lz0yLGUvPTIsbj4+Pj0xO3JldHVybih0K24pL2V9O3JldHVybiBiLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDB8eC5nKDQpfSxiLnF1aWNrPWZ1bmN0aW9uKCl7cmV0dXJuIHguZyg0KS80Mjk0OTY3Mjk2fSxiLmRvdWJsZT1iLHYobSh4LlMpLGUpLChoLnBhc3N8fGZ8fGZ1bmN0aW9uKHQsZSxyLG8pe3JldHVybiBvJiYoby5TJiZwKG8seCksdC5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBwKHgse30pfSkscj8obltzXT10LGUpOnR9KShiLHksXCJnbG9iYWxcImluIGg/aC5nbG9iYWw6dGhpcz09bixoLnN0YXRlKX1mdW5jdGlvbiBkKHQpe3ZhciBlLG49dC5sZW5ndGgscj10aGlzLG89MCxpPXIuaT1yLmo9MCxzPXIuUz1bXTtmb3Iobnx8KHQ9W24rK10pO288YTspc1tvXT1vKys7Zm9yKG89MDtvPGE7bysrKXNbb109c1tpPWgmaSt0W28lbl0rKGU9c1tvXSldLHNbaV09ZTsoci5nPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPTAsbz1yLmksaT1yLmoscz1yLlM7dC0tOyllPXNbbz1oJm8rMV0sbj1uKmErc1toJihzW29dPXNbaT1oJmkrZV0pKyhzW2ldPWUpXTtyZXR1cm4gci5pPW8sci5qPWksbn0pKGEpfWZ1bmN0aW9uIHAodCxlKXtyZXR1cm4gZS5pPXQuaSxlLmo9dC5qLGUuUz10LlMuc2xpY2UoKSxlfWZ1bmN0aW9uIHYodCxlKXtmb3IodmFyIG4scj10K1wiXCIsbz0wO288ci5sZW5ndGg7KWVbaCZvXT1oJihuXj0xOSplW2gmb10pK3IuY2hhckNvZGVBdChvKyspO3JldHVybiBtKGUpfWZ1bmN0aW9uIG0odCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCx0KX1pZihuW1wic2VlZFwiK3NdPWYsdihuLnJhbmRvbSgpLGUpLHQuZXhwb3J0cyl7dC5leHBvcnRzPWY7dHJ5e3I9cmVxdWlyZShcImNyeXB0b1wiKX1jYXRjaCh0KXt9fX0oW10sTWF0aCl9KSk7dXIuYWxlYT1ucix1ci54b3IxMjg9cnIsdXIueG9yd293PW9yLHVyLnhvcnNoaWZ0Nz1hcix1ci54b3I0MDk2PWlyLHVyLnR5Y2hlaT1zcjt2YXIgY3I9dXIuYWxlYSxscj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scixvKXt0aGlzLm1lYW49dCx0aGlzLnN0ZERldj1lLHRoaXMuZHR5cGU9bix0aGlzLm5leHRWYWw9TmFOLHRoaXMudHJ1bmNhdGVkPXIsdGhpcy50cnVuY2F0ZWQmJih0aGlzLnVwcGVyPXRoaXMubWVhbisyKnRoaXMuc3RkRGV2LHRoaXMubG93ZXI9dGhpcy5tZWFuLTIqdGhpcy5zdGREZXYpO3ZhciBhPW98fE1hdGgucmFuZG9tKCk7dGhpcy5yYW5kb209Y3IoYS50b1N0cmluZygpKX1yZXR1cm4gdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7aWYoIWlzTmFOKHRoaXMubmV4dFZhbCkpe3ZhciB0PXRoaXMubmV4dFZhbDtyZXR1cm4gdGhpcy5uZXh0VmFsPU5hTix0fWZvcih2YXIgZSxuLHI9ITE7IXI7KXt2YXIgbz12b2lkIDAsYT12b2lkIDAsaT12b2lkIDA7ZG97aT0obz0yKnRoaXMucmFuZG9tKCktMSkqbysoYT0yKnRoaXMucmFuZG9tKCktMSkqYX13aGlsZShpPj0xfHwwPT09aSk7dmFyIHM9TWF0aC5zcXJ0KC0yKk1hdGgubG9nKGkpL2kpO2U9dGhpcy5tZWFuK3RoaXMuc3RkRGV2Km8qcyxuPXRoaXMubWVhbit0aGlzLnN0ZERldiphKnMsdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQoZSl8fChyPSEwKX1yZXR1cm4gdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQobil8fCh0aGlzLm5leHRWYWw9dGhpcy5jb252ZXJ0VmFsdWUobikpLHRoaXMuY29udmVydFZhbHVlKGUpfSx0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMuZHR5cGV8fFwiZmxvYXQzMlwiPT09dGhpcy5kdHlwZT90Ok1hdGgucm91bmQodCl9LHQucHJvdG90eXBlLmlzVmFsaWRUcnVuY2F0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8PXRoaXMudXBwZXImJnQ+PXRoaXMubG93ZXJ9LHR9KCksaHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIpe3RoaXMuYWxwaGE9dCx0aGlzLmJldGE9MS9lLHRoaXMuZHR5cGU9bjt2YXIgbz1yfHxNYXRoLnJhbmRvbSgpO3RoaXMucmFuZHU9Y3Ioby50b1N0cmluZygpKSx0aGlzLnJhbmRuPW5ldyBscigwLDEsbiwhMSx0aGlzLnJhbmR1KCkpLHRoaXMuZD10PDE/dCsyLzM6dC0xLzMsdGhpcy5jPTEvTWF0aC5zcXJ0KDkqdGhpcy5kKX1yZXR1cm4gdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0LGUsbixyLG8sYTs7KXtkb3tyPXRoaXMucmFuZG4ubmV4dFZhbHVlKCksYT0xK3RoaXMuYypyfXdoaWxlKGE8PTApO2lmKGEqPWEqYSxlPTEtLjMzMSoodD1yKnIpKnQsbj0uNSp0K3RoaXMuZCooMS1hK01hdGgubG9nKGEpKSwobz10aGlzLnJhbmR1KCkpPGV8fE1hdGgubG9nKG8pPG4pYnJlYWt9cmV0dXJuIGE9MS90aGlzLmJldGEqdGhpcy5kKmEsdGhpcy5hbHBoYTwxJiYoYSo9TWF0aC5wb3codGhpcy5yYW5kdSgpLDEvdGhpcy5hbHBoYSkpLHRoaXMuY29udmVydFZhbHVlKGEpfSx0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuXCJmbG9hdDMyXCI9PT10aGlzLmR0eXBlP3Q6TWF0aC5yb3VuZCh0KX0sdH0oKSxmcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scil7dmFyIG89dGhpcztpZih2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0xKSx0aGlzLmNhblJldHVybkZsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PW8uZHR5cGV8fFwiZmxvYXQzMlwiPT09by5kdHlwZX0sdGhpcy5taW49dCx0aGlzLnJhbmdlPWUtdCx0aGlzLmR0eXBlPW4sbnVsbD09ciYmKHI9TWF0aC5yYW5kb20oKSksXCJudW1iZXJcIj09dHlwZW9mIHImJihyPXIudG9TdHJpbmcoKSksIXRoaXMuY2FuUmV0dXJuRmxvYXQoKSYmdGhpcy5yYW5nZTw9MSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFwiK3QrXCIgLSBcIitlK1wiIDw9IDEgYW5kIGR0eXBlIGlzIG5vdCBmbG9hdFwiKTt0aGlzLnJhbmRvbT1jcihyKX1yZXR1cm4gdC5wcm90b3R5cGUuY29udmVydFZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNhblJldHVybkZsb2F0KCk/dDpNYXRoLnJvdW5kKHQpfSx0LnByb3RvdHlwZS5uZXh0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUodGhpcy5taW4rdGhpcy5yYW5nZSp0aGlzLnJhbmRvbSgpKX0sdH0oKTtmdW5jdGlvbiBkcih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxlPWV8fFwiZmxvYXQzMlwiLG50KHQpLG5ldyBndCh0LGUsbil9ZnVuY3Rpb24gcHIodCxlKXt2b2lkIDA9PT1lJiYoZT0hMSksY29uc29sZS5sb2codC50b1N0cmluZyhlKSl9dmFyIHZyPUFuKHtiYXRjaFRvU3BhY2VORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJiYXRjaFRvU3BhY2VORFwiKSxvPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSk7cmV0dXJuIEMoci5yYW5rPj0xK2UubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgcmFuayBpcyBcIityLnJhbmsrXCIgYnV0IHNob3VsZCBiZSA+IHRoYW4gYmxvY2tTaGFwZS5sZW5ndGggXCIrZS5sZW5ndGh9KSksQyhuLmxlbmd0aD09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiY3JvcHMubGVuZ3RoIGlzIFwiK24ubGVuZ3RoK1wiIGJ1dCBzaG91bGQgYmUgZXF1YWwgdG8gYmxvY2tTaGFwZS5sZW5ndGggIFwiK2UubGVuZ3RofSkpLEMoci5zaGFwZVswXSVvPT0wLChmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgdGVuc29yIGJhdGNoIGlzIFwiK3Iuc2hhcGVbMF0rXCIgYnV0IGlzIG5vdCBkaXZpc2libGUgYnkgdGhlIHByb2R1Y3Qgb2YgdGhlIGVsZW1lbnRzIG9mIGJsb2NrU2hhcGUgXCIrZS5qb2luKFwiICogXCIpK1wiID09PSBcIitvfSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmJhdGNoVG9TcGFjZU5EKHIsZSxuKX0pLHskeDpyfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuc3BhY2VUb0JhdGNoTkQoZSxuKX19fSkpfX0pLG1yPUFuKHticm9hZGNhc3RUb186ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYnJvYWRjYXN0VG9cIixcInhcIikscj1uLnNoYXBlO2lmKGUuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuISh0PjApfHx0JTEhPTB9KSkpdGhyb3cgbmV3IEVycm9yKFwiYnJvYWRjYXN0VG8oKTogSW52YWxpZCBicm9hZGNhc3Qgc2hhcGUgW1wiK2UrXCJdLlwiKTtpZihlLmxlbmd0aDxuLnJhbmspdGhyb3cgbmV3IEVycm9yKFwiYnJvYWRjYXN0VG8oKTogc2hhcGUubGVuZ3RoPVwiK2UubGVuZ3RoK1wiIDwgaW5wdXQucmFuaz1cIituLnJhbmsrXCIuXCIpO2lmKGUubGVuZ3RoPm4ucmFuayl7Zm9yKHZhciBvPW4uc2hhcGUuc2xpY2UoKTtvLmxlbmd0aDxlLmxlbmd0aDspby51bnNoaWZ0KDEpO249bi5yZXNoYXBlKG8pfWZvcih2YXIgYT1BcnJheS5mcm9tKGUpLGk9ZS5sZW5ndGgtMTtpPj0wO2ktLSlpZihuLnNoYXBlW2ldPT09ZVtpXSlhW2ldPTE7ZWxzZSBpZigxIT09bi5zaGFwZVtpXSl0aHJvdyBuZXcgRXJyb3IoXCJicm9hZGNhc3RUbygpOiBbXCIrcitcIl0gY2Fubm90IGJlIGJyb2FkY2FzdCB0byBbXCIrZStcIl0uXCIpO3ZhciBzPWEubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiB0PjE/ZTotMX0pKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0Pj0wfSkpO3JldHVybiAwPT09cy5sZW5ndGg/bi5jbG9uZSgpOkx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRpbGUobixhKX0pLHtpbnB1dDpufSwoZnVuY3Rpb24odCl7cmV0dXJue2lucHV0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuc3VtKHMsITApfX19KSl9fSksZ3I9QW4oe2Nhc3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcImNhc3RcIik7aWYoIVcoZSkpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNhc3QgdG8gdW5rbm93biBkdHlwZSBcIitlKTtpZihcInN0cmluZ1wiPT09ZSYmXCJzdHJpbmdcIiE9PW4uZHR5cGV8fFwic3RyaW5nXCIhPT1lJiZcInN0cmluZ1wiPT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHN0cmluZ3MgY2FuIGJlIGNhc3RlZCB0byBzdHJpbmdzXCIpO3ZhciByPXtkdHlwZTplfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2FzdChuLGUpfSkse3g6bn0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuY2xvbmUoKX19fSksXCJDYXN0XCIscil9fSkseXI9QW4oe2Nsb25lXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiY2xvbmVcIixudWxsKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQoZS5kYXRhSWQsZS5zaGFwZSxlLmR0eXBlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQudG9GbG9hdCgpfX19KSl9fSkseHI9QW4oe2N1bXN1bV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKTt2YXIgbz1tbih0LFwieFwiLFwiY3Vtc3VtXCIpLGE9RW4oW2V8PTBdLG8ucmFuayksaT1vO251bGwhPWEmJihpPW8udHJhbnNwb3NlKGEpKTt2YXIgcz1JbigxLG8ucmFuaylbMF0sdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jdW1zdW0oaSxzLG4scil9KSx7cGVybXV0ZWRYOml9LChmdW5jdGlvbih0KXtyZXR1cm57cGVybXV0ZWRYOmZ1bmN0aW9uKCl7cmV0dXJuIHQuY3Vtc3VtKGUsbiwhcil9fX0pKTtyZXR1cm4gbnVsbCE9YSYmKHU9dS50cmFuc3Bvc2UoYSkpLHV9fSksYnI9QW4oe2RlcHRoVG9TcGFjZV86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiTkhXQ1wiKTt2YXIgcj1tbih0LFwieFwiLFwiZGVwdGhUb1NwYWNlXCIpLG89XCJOSFdDXCI9PT1uP3Iuc2hhcGVbMV06ci5zaGFwZVsyXSxhPVwiTkhXQ1wiPT09bj9yLnNoYXBlWzJdOnIuc2hhcGVbM10saT1cIk5IV0NcIj09PW4/ci5zaGFwZVszXTpyLnNoYXBlWzFdO3JldHVybiBDKG8qZT49MCwoZnVuY3Rpb24oKXtyZXR1cm5cIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXFxuICAgICAgXCIrbytcIiBhbmQgXCIrZStcIiAgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXFxuICAgICAgXCIrci5zaGFwZX0pKSxDKGEqZT49MCwoZnVuY3Rpb24oKXtyZXR1cm5cIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXFxuICAgICAgXCIrYStcIiBhbmQgXCIrZStcIiBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGVcXG4gICAgICAgICAgXCIrci5zaGFwZX0pKSxDKGklKGUqZSk9PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJEaW1lbnNpb24gc2l6ZSBtdXN0IGJlIGV2ZW5seSBkaXZpc2libGUgYnkgXCIrZSplK1wiIGJ1dCBpcyBcIitpK1wiIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZSBcIityLnNoYXBlfSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRoVG9TcGFjZShyLGUsbil9KSx7JHg6cn0pfX0pLHdyPUFuKHtleHBhbmREaW1zXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPW1uKHQsXCJ4XCIsXCJleHBhbmREaW1zXCIsbnVsbCk7QyhlPD1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCJ9KSk7dmFyIHI9bi5zaGFwZS5zbGljZSgpO3JldHVybiBlPDAmJihDKC0obi5yYW5rKzEpPD1lLChmdW5jdGlvbigpe3JldHVyblwiQXhpcyBtdXN0IGJlIGluIHRoZSBpbnRlcnZhbCBbXCIrLShuLnJhbmsrMSkrXCIsIFwiK24ucmFuaytcIl1cIn0pKSxlPW4ucmFuaytlKzEpLHIuc3BsaWNlKGUsMCwxKSxPcihuLHIpfX0pLENyPUFuKHtleWVfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSxudWxsPT1lJiYoZT10KTtmb3IodmFyIG89ZHIoW3QsZV0sciksYT10PD1lP3Q6ZSxpPTA7aTxhOysraSlvLnNldCgxLGksaSk7dmFyIHM9by50b1RlbnNvcigpLmFzMkQodCxlKTtpZihudWxsPT1uKXJldHVybiBzO2lmKDE9PT1uLmxlbmd0aClyZXR1cm4gTHIod3IocywwKSxbblswXSwxLDFdKTtpZigyPT09bi5sZW5ndGgpcmV0dXJuIExyKHdyKHdyKHMsMCksMCksW25bMF0sblsxXSwxLDFdKTtpZigzPT09bi5sZW5ndGgpcmV0dXJuIExyKHdyKHdyKHdyKHMsMCksMCksMCksW25bMF0sblsxXSxuWzJdLDEsMV0pO3Rocm93IG5ldyBFcnJvcihcImV5ZSgpIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IDFEIGFuZCAyRCBiYXRjaFNoYXBlcywgYnV0IHJlY2VpdmVkIFwiK24ubGVuZ3RoK1wiRC5cIil9fSksRXI9QW4oe211bHRpbm9taWFsXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89bW4odCxcImxvZ2l0c1wiLFwibXVsdGlub21pYWxcIiksYT1vLnNpemUsaT1vLnJhbms7aWYoYTwyKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG11bHRpbm9taWFsOiB5b3UgbmVlZCBhdCBsZWFzdCAyIG91dGNvbWVzLCBidXQgZ290IFwiK2ErXCIuXCIpO2lmKGk+Mil0aHJvdyBuZXcgRXJyb3IoXCJSYW5rIG9mIHByb2JhYmlsaXRpZXMgbXVzdCBiZSAxIG9yIDIsIGJ1dCBpcyBcIitpKTtuPW58fE1hdGgucmFuZG9tKCk7dmFyIHM9MT09PWk/by5hczJEKDEsLTEpOm8sdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5tdWx0aW5vbWlhbChzLHIsZSxuKX0pLHtsb2dpdHMyRDpzfSk7cmV0dXJuIDE9PT1pP3UuYXMxRCgpOnV9fSksUnI9QW4oe29uZUhvdF86ZnVuY3Rpb24odCxlLG4scil7aWYodm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9MCksZTwyKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG9uZUhvdDogZGVwdGggbXVzdCBiZSA+PTIsIGJ1dCBpdCBpcyBcIitlKTt2YXIgbz1tbih0LFwiaW5kaWNlc1wiLFwib25lSG90XCIsXCJpbnQzMlwiKSxhPW8uc2hhcGUuY29uY2F0KFtlXSk7cmV0dXJuIG89by5mbGF0dGVuKCksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQub25lSG90KG8sZSxuLHIpfSkseyRpbmRpY2VzOm99LChmdW5jdGlvbih0KXtyZXR1cm57JGluZGljZXM6ZnVuY3Rpb24oKXtyZXR1cm4gR24oby5zaGFwZSxcImZsb2F0MzJcIil9fX0pKS5yZXNoYXBlKGEpfX0pLElyPUFuKHtwYWRfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0wKTt2YXIgcj1tbih0LFwieFwiLFwicGFkXCIpO2lmKDA9PT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwicGFkKHNjYWxhcikgaXMgbm90IGRlZmluZWQuIFBhc3Mgbm9uLXNjYWxhciB0byBwYWRcIik7dmFyIG89e3BhZGRpbmdzOmUsY29uc3RhbnRWYWx1ZTpufTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucGFkKHIsZSxuKX0pLHt4OnJ9LChmdW5jdGlvbih0KXt2YXIgbj1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5zbGljZShuLHIuc2hhcGUpfX19KSxcIlBhZFYyXCIsbyl9fSksa3I9QW4oe3BhZDFkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLEMoMj09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIuXCJ9KSksSXIodCxbZV0sbil9fSksU3I9QW4oe3BhZDJkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLEMoMj09PWUubGVuZ3RoJiYyPT09ZVswXS5sZW5ndGgmJjI9PT1lWzFdLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSksSXIodCxlLG4pfX0pLEFyPUFuKHtwYWQzZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxDKDM9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgmJjI9PT1lWzJdLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSksSXIodCxlLG4pfX0pLERyPUFuKHtwYWQ0ZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxDKDQ9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgmJjI9PT1lWzJdLmxlbmd0aCYmMj09PWVbM10ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIn0pKSxJcih0LGUsbil9fSksVHI9QW4oe3JhbmRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1rKHQpLG89bnVsbDtpZihudWxsPT1ufHxcImZsb2F0MzJcIj09PW4pbz1uZXcgRmxvYXQzMkFycmF5KHIpO2Vsc2UgaWYoXCJpbnQzMlwiPT09bilvPW5ldyBJbnQzMkFycmF5KHIpO2Vsc2V7aWYoXCJib29sXCIhPT1uKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK24pO289bmV3IFVpbnQ4QXJyYXkocil9Zm9yKHZhciBhPTA7YTxyO2ErKylvW2FdPWUoKTtyZXR1cm4gTHQubWFrZVRlbnNvcihvLHQsbil9fSksTnI9QW4oe3JhbmRvbU5vcm1hbF86ZnVuY3Rpb24odCxlLG4scixvKXtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSxudWxsIT1yJiZcImJvb2xcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiK3IpO2Zvcih2YXIgYT1uZXcgbHIoZSxuLHIsITEsbyksaT1kcih0LHIpLHM9MDtzPGkudmFsdWVzLmxlbmd0aDtzKyspaS52YWx1ZXNbc109YS5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfX0pLEZyPUFuKHtyYW5kb21HYW1tYV86ZnVuY3Rpb24odCxlLG4scixvKXtpZih2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksbnVsbD09biYmKG49MSksbnVsbD09ciYmKHI9XCJmbG9hdDMyXCIpLFwiZmxvYXQzMlwiIT09ciYmXCJpbnQzMlwiIT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXCIrcik7Zm9yKHZhciBhPW5ldyBocihlLG4scixvKSxpPWRyKHQscikscz0wO3M8aS52YWx1ZXMubGVuZ3RoO3MrKylpLnZhbHVlc1tzXT1hLm5leHRWYWx1ZSgpO3JldHVybiBpLnRvVGVuc29yKCl9fSksX3I9QW4oe3JhbmRvbVVuaWZvcm1fOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpO2Zvcih2YXIgYT1kcih0LHIpLGk9bmV3IGZyKGUsbixudWxsLG8pLHM9MDtzPGEudmFsdWVzLmxlbmd0aDtzKyspYS52YWx1ZXNbc109aS5uZXh0VmFsdWUoKTtyZXR1cm4gYS50b1RlbnNvcigpfX0pLE9yPUFuKHtyZXNoYXBlXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJyZXNoYXBlXCIsbnVsbCk7ZT1fKGUsbi5zaXplKSxDKG4uc2l6ZT09PWsoZSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJuZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLlwifSkpO3ZhciByPXtzaGFwZTplfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzaGFwZShuLGUpfSkse3g6bn0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQucmVzaGFwZShuLnNoYXBlKX19fSksXCJSZXNoYXBlXCIscil9fSksTXI9QW4oe3NwYWNlVG9CYXRjaE5EXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcInNwYWNlVG9CYXRjaE5EXCIpO3JldHVybiBDKHIucmFuaz49MStlLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHJhbmsgXCIrci5yYW5rK1wiIHNob3VsZCBiZSA+IHRoYW4gW2Jsb2NrU2hhcGVdIFwiK2UubGVuZ3RofSkpLEMobi5sZW5ndGg9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cInBhZGRpbmdzLnNoYXBlWzBdIFwiK24ubGVuZ3RoK1wiIG11c3QgYmUgZXF1YWwgdG8gW2Jsb2NrU2hhcGVdIFwiK2UubGVuZ3RofSkpLEMoci5zaGFwZS5yZWR1Y2UoKGZ1bmN0aW9uKHQscixvKXtyZXR1cm4gbz4wJiZvPD1lLmxlbmd0aD90JiYocituW28tMV1bMF0rbltvLTFdWzFdKSVlW28tMV09PTA6dH0pLCEwKSwoZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHNwYXRpYWwgZGltZW5zaW9ucyBcIityLnNoYXBlLnNsaWNlKDEpK1wiIHdpdGggcGFkZGluZ3MgXCIrbi50b1N0cmluZygpK1wiIG11c3QgYmUgZGl2aXNpYmxlIGJ5IGJsb2NrU2hhcGVzIFwiK2UudG9TdHJpbmcoKX0pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGFjZVRvQmF0Y2hORChyLGUsbil9KSx7JHg6cn0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmJhdGNoVG9TcGFjZU5EKGUsbil9fX0pKX19KSxCcj1Bbih7c3F1ZWV6ZV86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwic3F1ZWV6ZVwiKTtyZXR1cm4gT3IobixNKG4uc2hhcGUsZSkubmV3U2hhcGUpfX0pLFByPUFuKHtzdGFja186ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1nbih0LFwidGVuc29yc1wiLFwic3RhY2tcIik7aWYoQyhuLmxlbmd0aD49MSwoZnVuY3Rpb24oKXtyZXR1cm5cIlBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byB0Zi5zdGFja1wifSkpLDE9PT1uLmxlbmd0aClyZXR1cm4gblswXS5leHBhbmREaW1zKGUpO3ZhciByPW5bMF0ucmFuayxvPW5bMF0uc2hhcGUsYT1uWzBdLmR0eXBlO0MoZTw9ciwoZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgbXVzdCBiZSA8PSByYW5rIG9mIHRoZSB0ZW5zb3JcIn0pKSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe0Uobyx0LnNoYXBlLFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBzaGFwZXNcIil9KSksbi5mb3JFYWNoKChmdW5jdGlvbih0KXtDKGE9PT10LmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBkdHlwZXNcIn0pKX0pKTt2YXIgaT1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXhwYW5kRGltcyhlKX0pKTtyZXR1cm4gWW4oaSxlKX19KSxMcj1Bbih7dGlsZV86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwidGlsZVwiLG51bGwpO0Mobi5yYW5rPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIrbi5yYW5rK1wiIG11c3QgbWF0Y2ggbGVuZ3RoIG9mIHJlcHMgXCIrZStcIi5cIn0pKTt2YXIgcj1bbl0sbz17cmVwczplfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxyKXt2YXIgbz10LnRpbGUobixlKTtyZXR1cm4gcihbbl0pLG99KSx7eDpufSwoZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7dmFyIG49WG4ocik7aWYoMT09PXIucmFuaylmb3IodmFyIG89MDtvPGVbMF07KytvKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdXSxbci5zaGFwZVswXV0pKTtlbHNlIGlmKDI9PT1yLnJhbmspZm9yKG89MDtvPGVbMF07KytvKWZvcih2YXIgYT0wO2E8ZVsxXTsrK2Epbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdXSkpO2Vsc2UgaWYoMz09PXIucmFuaylmb3Iobz0wO288ZVswXTsrK28pZm9yKGE9MDthPGVbMV07KythKWZvcih2YXIgaT0wO2k8ZVsyXTsrK2kpbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdLGkqci5zaGFwZVsyXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdXSkpO2Vsc2V7aWYoNCE9PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgdGlsZSBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JzIHlldC5cIik7Zm9yKG89MDtvPGVbMF07KytvKWZvcihhPTA7YTxlWzFdOysrYSlmb3IoaT0wO2k8ZVsyXTsrK2kpZm9yKHZhciBzPTA7czxlWzNdOysrcyluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXSxhKnIuc2hhcGVbMV0saSpyLnNoYXBlWzJdLHMqci5zaGFwZVszXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdLHIuc2hhcGVbM11dKSl9cmV0dXJuIG59fX0pLFwiVGlsZVwiLG8scil9fSksV3I9QW4oe3RydW5jYXRlZE5vcm1hbF86ZnVuY3Rpb24odCxlLG4scixvKXtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSxudWxsIT1yJiZcImJvb2xcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiK3IpO2Zvcih2YXIgYT1uZXcgbHIoZSxuLHIsITAsbyksaT1kcih0LHIpLHM9MDtzPGkudmFsdWVzLmxlbmd0aDtzKyspaS52YWx1ZXNbc109YS5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfX0pLFVyPUFuKHt1bnN0YWNrXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLGU9ZXx8MDt2YXIgbj1tbih0LFwieFwiLFwidW5zdGFja1wiKTtDKGU+PS1uLnNoYXBlLmxlbmd0aCYmZTxuLnNoYXBlLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgPSBcIitlK1wiIGlzIG5vdCBpbiBbLVwiK24uc2hhcGUubGVuZ3RoK1wiLCBcIituLnNoYXBlLmxlbmd0aCtcIilcIn0pKSxlPDAmJihlKz1uLnNoYXBlLmxlbmd0aCk7dmFyIHI9e2F4aXM6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnVuc3RhY2sobixlKX0pLHt4Om59LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBQcih0LGUpfX19KSxcIlVucGFja1wiLHIpfX0pLFZyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLG8sYSxpLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49bW4odCxcInhcIixcInNldGRpZmYxZFwiKSxvPW1uKGUsXCJ5XCIsXCJzZXRkaWZmMWRcIiksQyhuLmR0eXBlPT09by5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cInggYW5kIHkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZHR5cGUsIGJ1dCBnb3QgeCAoXCIrbi5kdHlwZStcIikgYW5kIHkgKFwiK28uZHR5cGUrXCIpLlwifSkpLEMoMT09PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInggc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB4IChcIituLnNoYXBlK1wiKS5cIn0pKSxDKDE9PT1vLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJ5IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeSAoXCIrby5zaGFwZStcIikuXCJ9KSksWzQsbi5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gYT1yLnNlbnQoKSxbNCxvLmRhdGEoKV07Y2FzZSAyOmZvcihpPXIuc2VudCgpLHM9bmV3IFNldChpKSx1PTAsaD0wO2g8YS5sZW5ndGg7aCsrKXMuaGFzKGFbaF0pfHx1Kys7Zm9yKGM9bmV3IGd0KFt1XSxuLmR0eXBlKSxsPW5ldyBndChbdV0sXCJpbnQzMlwiKSxoPTAsZj0wO2g8YS5sZW5ndGg7aCsrKXMuaGFzKGFbaF0pfHwoYy52YWx1ZXNbZl09YVtoXSxsLnZhbHVlc1tmXT1oLGYrKyk7cmV0dXJuWzIsW2MudG9UZW5zb3IoKSxsLnRvVGVuc29yKCldXX19KSl9KSl9O2Z1bmN0aW9uIHpyKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSEwKTt2YXIgbz1bXTtpZihyKShvPW8uY29uY2F0KGUuc2xpY2UoMCkpKS5wdXNoKHRbMF0vbiksbz1vLmNvbmNhdCh0LnNsaWNlKDEpKTtlbHNle289by5jb25jYXQodFswXSk7Zm9yKHZhciBhPWUubGVuZ3RoLGk9MDtpPGE7KytpKW89by5jb25jYXQoW3RbaSsxXS9lW2ldLGVbaV1dKTtvPW8uY29uY2F0KHQuc2xpY2UoYSsxKSl9cmV0dXJuIG99ZnVuY3Rpb24gR3IodCxlLG4pe3ZvaWQgMD09PW4mJihuPSEwKTt2YXIgcj1bXTtpZihuKXtyLnB1c2goZSk7Zm9yKHZhciBvPWUrMTtvPHQ7KytvKW88PTIqZT8oci5wdXNoKG8pLHIucHVzaChvLShlKzEpKSk6ci5wdXNoKG8pfWVsc2V7dmFyIGE9W10saT1bXTtmb3Iobz0xO288dDsrK28pbz49MiplKzF8fG8lMj09MT9pLnB1c2gobyk6YS5wdXNoKG8pO3IucHVzaC5hcHBseShyLGEpLHIucHVzaCgwKSxyLnB1c2guYXBwbHkocixpKX1yZXR1cm4gcn1mdW5jdGlvbiBIcih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMCk7dmFyIG89W107cj9vLnB1c2godFswXS9uKTpvLnB1c2godFswXSpuKTtmb3IodmFyIGE9MTthPHQubGVuZ3RoOysrYSlhPD1lLmxlbmd0aD9yP28ucHVzaChlW2EtMV0qdFthXSk6by5wdXNoKHRbYV0vZVthLTFdKTpvLnB1c2godFthXSk7cmV0dXJuIG99ZnVuY3Rpb24gcXIodCxlKXtmb3IodmFyIG49WzBdLHI9MDtyPGU7KytyKW4ucHVzaCh0W3JdWzBdKTtyZXR1cm4gbn1mdW5jdGlvbiBLcih0LGUsbil7Zm9yKHZhciByPXQuc2xpY2UoMCwxKSxvPTA7bzxuOysrbylyLnB1c2godFtvKzFdLWVbb11bMF0tZVtvXVsxXSk7cmV0dXJuIHJ9ZnVuY3Rpb24ganIodCxlKXtpZih0LnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrdC5yYW5rK1wiLlwiKTtpZihlLnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIitlLnJhbmsrXCIuXCIpO2lmKFwiaW50MzJcIiE9PWUuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzIFwiK2UuZHR5cGUrXCIuXCIpO2lmKGUuc2hhcGVbZS5yYW5rLTFdPnQucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpbm5lcm1vc3QgZGltZW5zaW9uIGxlbmd0aCBtdXN0IGJlIDw9IHRlbnNvciByYW5rOyBzYXc6IFwiK2Uuc2hhcGVbZS5yYW5rLTFdK1wiIHZzLiBcIit0LnJhbmspO2lmKDA9PT10LnNpemUpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIG1vcmUgdGhhbiAwIGVudHJpZXMsIGJ1dCBpbnB1dCBpcyBlbXB0eS4gSW5wdXQgc2hhcGU6IFwiK3Quc2hhcGUrXCIuXCIpO2Zvcih2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPTEsYT0wO2E8bi5sZW5ndGgtMTsrK2Epbyo9blthXTt2YXIgaT10LnNoYXBlLHM9bi5zbGljZSgpO3MucG9wKCk7dmFyIHU9MTtmb3IoYT1yO2E8dC5yYW5rOysrYSl1Kj1pW2FdLHMucHVzaChpW2FdKTt2YXIgYz0kKHQuc2hhcGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQvdX0pKS5jb25jYXQoWzFdKS5zbGljZSgwLHIpO3JldHVybltzLG8sdSxjXX12YXIgWHI9T2JqZWN0LmZyZWV6ZSh7cHJlcGFyZUFuZFZhbGlkYXRlOmpyfSksWXI9MzA7ZnVuY3Rpb24gJHIodCl7cmV0dXJuIHQ8PVlyP3Q6WSh0LE1hdGguZmxvb3IoTWF0aC5zcXJ0KHQpKSl9ZnVuY3Rpb24gUXIodCxlLG4pe3ZhciByPWUucmFuaz4xP2Uuc2hhcGVbZS5yYW5rLTFdOjEsbz1lLnJhbms+MT9lLnJhbmstMToxLGE9XCJNdXN0IGhhdmUgdXBkYXRlcy5zaGFwZSA9IGluZGljZXMuc2hhcGVbOmJhdGNoRGltXSArIHNoYXBlW3NsaWNlRGltOl0sIGdvdCB1cGRhdGVzLnNoYXBlOiBcIituLnNoYXBlK1wiLCBpbmRpY2VzLnNoYXBlOiBcIitlLnNoYXBlK1wiLCBzaGFwZTogXCIrdCtcIiwgc2xpY2VEaW06IFwiK3IrXCIsIGFuZCBiYXRjaERpbTogXCIrbytcIi5cIjtpZihuLnJhbms8byl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGUucmFuayA8IFwiK28rXCIuIFwiKTtpZih0Lmxlbmd0aDxyKyhuLnJhbmstbykpdGhyb3cgbmV3IEVycm9yKGErXCIgT3V0cHV0IHNoYXBlIGxlbmd0aCA8IFwiKyhyKyhuLnJhbmstbykpKTtpZihuLnJhbmshPT1vK3QubGVuZ3RoLXIpdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlLnJhbmsgIT0gXCIrKG8rdC5sZW5ndGgtcikpO2Zvcih2YXIgaT0wO2k8bzsrK2kpaWYobi5zaGFwZVtpXSE9PWUuc2hhcGVbaV0pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlcy5zaGFwZVtcIitpK1wiXSAoXCIrbi5zaGFwZVtpXStcIikgIT0gaW5kaWNlcy5zaGFwZVtcIitpK1wiXSAoXCIrZS5zaGFwZVtpXStcIikuXCIpO2ZvcihpPTA7aTxuLnJhbmstbzsrK2kpaWYobi5zaGFwZVtpK29dIT09dFtpK3JdKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZXMuc2hhcGVbXCIrKGkrbykrXCJdIChcIituLnNoYXBlW2krb10rXCIpICE9IHNoYXBlW1wiKyhpK28pK1wiXSAoXCIrdFtpK29dK1wiKVwiKX1mdW5jdGlvbiBKcih0LGUsbil7aWYoZS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuc2NhdHRlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK2UucmFuaytcIi5cIik7aWYodC5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuc2NhdHRlck5EKCkgZXhwZWN0cyB0aGUgdXBkYXRlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK3QucmFuaytcIi5cIik7aWYoXCJpbnQzMlwiIT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZHR5cGUgb2YgJ2luZGljZXMnIHNob3VsZCBiZSBpbnQzMiwgYnV0IGdvdCBkdHlwZTogXCIrZS5kdHlwZSk7aWYobi5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgcmFuayBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMSwgYnV0IGdvdCBzaGFwZTogXCIrbik7aWYoMD09PW4ubGVuZ3RoKXtpZigwPT09ZS5zaXplKXRocm93IG5ldyBFcnJvcihcIkluZGljZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIGluZGljZXMgc2hhcGU6IFwiK2Uuc2hhcGUpO2lmKDA9PT10LnNpemUpdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRlcyBzcGVjaWZpZWQgZm9yIGVtcHR5IG91dHB1dC4gdXBkYXRlcyBzaGFwZTogXCIrdC5zaGFwZSl9UXIobixlLHQpfWZ1bmN0aW9uIFpyKHQsZSxuKXtmb3IodmFyIHI9ZS5zaGFwZS5sZW5ndGgsbz1yPjE/ZS5zaGFwZVtyLTFdOjEsYT1uLmxlbmd0aCxpPTEscz1vO3M8YTsrK3MpaSo9bltzXTt2YXIgdT1vPDE/MTpvO3JldHVybntzbGljZVJhbms6byxudW1VcGRhdGVzOmsoZS5zaGFwZSkvdSxzbGljZVNpemU6aSxzdHJpZGVzOiQobi5zbGljZSgwLG8pKS5jb25jYXQoWzFdKSxvdXRwdXRTaXplOmsobil9fXZhciB0bz1PYmplY3QuZnJlZXplKHt2YWxpZGF0ZVVwZGF0ZVNoYXBlOlFyLHZhbGlkYXRlSW5wdXQ6SnIsY2FsY3VsYXRlU2hhcGVzOlpyfSk7ZnVuY3Rpb24gZW8odCxlLG4pe0ModC5yYW5rPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzbGljZVwiK3QucmFuaytcIkQ6IExlbmd0aCBvZiBiZWdpbiBcIitlK1wiIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIit0LnJhbmsrXCIpLlwifSkpLEModC5yYW5rPT09bi5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzbGljZVwiK3QucmFuaytcIkQ6IExlbmd0aCBvZiBzaXplIFwiK24rXCIgbXVzdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiK3QucmFuaytcIikuXCJ9KSk7Zm9yKHZhciByPWZ1bmN0aW9uKHIpe0MoZVtyXStuW3JdPD10LnNoYXBlW3JdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBiZWdpbltcIityK1wiXSArIHNpemVbXCIrcitcIl0gKFwiKyhlW3JdK25bcl0pK1wiKSB3b3VsZCBvdmVyZmxvdyBpbnB1dC5zaGFwZVtcIityK1wiXSAoXCIrdC5zaGFwZVtyXStcIilcIn0pKX0sbz0wO288dC5yYW5rOysrbylyKG8pfWZ1bmN0aW9uIG5vKHQpe2Zvcih2YXIgZT1bXSxuPTA7dD4wOykxJnQmJmUucHVzaChuKSx0Lz0yLG4rKztyZXR1cm4gZX1mdW5jdGlvbiBybyh0LGUsbil7Zm9yKHZhciByPVtdLG89MDtvPHQubGVuZ3RoO28rKylyW29dPU1hdGguY2VpbCgoZVtvXS10W29dKS9uW29dKTtyZXR1cm4gcn1mdW5jdGlvbiBvbyh0LGUsbixyLG8pe3ZhciBhPWVbb10saT1uW29dfHwxOyh0JjE8PG98fG51bGw9PWEpJiYoYT1pPjA/TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI6TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO3ZhciBzPXJbb107cmV0dXJuIGE8MCYmKGErPXMpLGE9eCgwLGEscy0xKX1mdW5jdGlvbiBhbyh0LGUsbixyLG8pe3ZhciBhPWVbb10saT1uW29dfHwxOyh0JjE8PG98fG51bGw9PWEpJiYoYT1pPjA/TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI6TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO3ZhciBzPXJbb107cmV0dXJuIGE8MCYmKGErPXMpLGE9aT4wP3goMCxhLHMpOngoLTEsYSxzLTEpfWZ1bmN0aW9uIGlvKHQsZSxuKXtmb3IodmFyIHI9bi5sZW5ndGgsbz0wO288bi5sZW5ndGg7bysrKWlmKG5bb10+MSl7cj1vO2JyZWFrfWZvcihvPXIrMTtvPG4ubGVuZ3RoO28rKylpZihlW29dPjB8fG5bb10hPT10W29dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHNvKHQsZSl7Zm9yKHZhciBuPXQubGVuZ3RoPjA/dFt0Lmxlbmd0aC0xXToxLHI9MDtyPHQubGVuZ3RoLTE7cisrKW4rPXRbcl0qZVtyXTtyZXR1cm4gbn12YXIgdW89T2JqZWN0LmZyZWV6ZSh7YXNzZXJ0UGFyYW1zVmFsaWQ6ZW8sbWFza1RvQXhlczpubyxjb21wdXRlT3V0U2hhcGU6cm8sc3RhcnRGb3JBeGlzOm9vLHN0b3BGb3JBeGlzOmFvLGlzU2xpY2VDb250aW5vdXM6aW8sY29tcHV0ZUZsYXRPZmZzZXQ6c299KTtmdW5jdGlvbiBjbyh0KXtyZXR1cm4gQyhYKHQpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIGdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSksZnVuY3Rpb24oZSxuKXt2YXIgcj1tbihlLFwieFwiLFwidGYuZ3JhZFwiLG51bGwpLG89bnVsbCE9bj9tbihuLFwiZHlcIixcInRmLmdyYWRcIik6bnVsbDtyZXR1cm4gTHQudGlkeSgoZnVuY3Rpb24oKXt2YXIgZT1MdC5ncmFkaWVudHMoKGZ1bmN0aW9uKCl7cmV0dXJuIHQocil9KSxbcl0sbyksbj1lLnZhbHVlLGE9ZS5ncmFkcztyZXR1cm4gbnVsbCE9byYmRShuLnNoYXBlLG8uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWQoZikoeCwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoeClcIiksbW8oYSksYVswXX0pKX19ZnVuY3Rpb24gbG8odCl7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiBncmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pKSxmdW5jdGlvbihlLG4pe0MoQXJyYXkuaXNBcnJheShlKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmdzIHBhc3NlZCBpbiBncmFkcyhmKShhcmdzKSBtdXN0IGJlIGFuIGFycmF5IG9mIGBUZW5zb3JgcyBvciBgVGVuc29yTGlrZWBzXCJ9KSk7dmFyIHI9Z24oZSxcImFyZ3NcIixcInRmLmdyYWRzXCIsbnVsbCksbz1udWxsIT1uP21uKG4sXCJkeVwiLFwidGYuZ3JhZHNcIik6bnVsbDtyZXR1cm4gTHQudGlkeSgoZnVuY3Rpb24oKXt2YXIgZT1MdC5ncmFkaWVudHMoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkodm9pZCAwLHIpfSkscixvKSxuPWUudmFsdWUsYT1lLmdyYWRzO3JldHVybiBudWxsIT1vJiZFKG4uc2hhcGUsby5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxtbyhhKSxhfSkpfX1mdW5jdGlvbiBobyh0KXtyZXR1cm4gQyhYKHQpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pKSxmdW5jdGlvbihlLG4pe0MoZSBpbnN0YW5jZW9mIHd0LChmdW5jdGlvbigpe3JldHVyblwiVGhlIHggcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSh4KSBtdXN0IGJlIGEgdGVuc29yXCJ9KSksQyhudWxsPT1ufHxuIGluc3RhbmNlb2Ygd3QsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSh4LCBkeSkgbXVzdCBiZSBhIHRlbnNvclwifSkpO3ZhciByPUx0LmdyYWRpZW50cygoZnVuY3Rpb24oKXtyZXR1cm4gdChlKX0pLFtlXSxuKSxvPXIuZ3JhZHMsYT1yLnZhbHVlO3JldHVybiBtbyhvKSx7Z3JhZDpvWzBdLHZhbHVlOmF9fX1mdW5jdGlvbiBmbyh0KXtyZXR1cm4gQyhYKHQpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSksZnVuY3Rpb24oZSxuKXtDKEFycmF5LmlzQXJyYXkoZSkmJmUuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygd3R9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzKSBtdXN0IGJlIGFycmF5IG9mIHRlbnNvcnNcIn0pKSxDKG51bGw9PW58fG4gaW5zdGFuY2VvZiB3dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzLCBkeSkgbXVzdCBiZSBhIHRlbnNvclwifSkpO3ZhciByPUx0LmdyYWRpZW50cygoZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseSh2b2lkIDAsZSl9KSxlLG4pO3JldHVybiBudWxsIT1uJiZFKHIudmFsdWUuc2hhcGUsbi5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pXCIpLG1vKHIuZ3JhZHMpLHJ9fWZ1bmN0aW9uIHBvKHQsZSl7QyhYKHQpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSksQyhudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpJiZlLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFN0fSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIHZhckxpc3QgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZiwgdmFyTGlzdCkgbXVzdCBiZSBhbiBhcnJheSBvZiB2YXJpYWJsZXNcIn0pKTt2YXIgbj1udWxsIT1lO2lmKCFuKWZvcih2YXIgciBpbiBlPVtdLEx0LnJlZ2lzdGVyZWRWYXJpYWJsZXMpZS5wdXNoKEx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbcl0pO3ZhciBvPW4/ZS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiF0LnRyYWluYWJsZX0pKTpudWxsLGE9ZS5sZW5ndGg7QygoZT1lLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJhaW5hYmxlfSkpKS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cInZhcmlhYmxlR3JhZHMoKSBleHBlY3RzIGF0IGxlYXN0IG9uZSBvZiB0aGUgaW5wdXQgdmFyaWFibGVzIHRvIGJlIHRyYWluYWJsZSwgYnV0IG5vbmUgb2YgdGhlIFwiK2ErXCIgdmFyaWFibGVzIGlzIHRyYWluYWJsZS5cIn0pKTt2YXIgaT1MdC5ncmFkaWVudHModCxlLG51bGwsITApLHM9aS52YWx1ZSx1PWkuZ3JhZHM7Qyh1LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSkpLChmdW5jdGlvbigpe3JldHVyblwiQ2Fubm90IGZpbmQgYSBjb25uZWN0aW9uIGJldHdlZW4gYW55IHZhcmlhYmxlIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSBsb3NzIGZ1bmN0aW9uIHk9Zih4KS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3BlcmF0aW9ucyB0aGF0IHVzZSB2YXJpYWJsZXMgYXJlIGluc2lkZSB0aGUgZnVuY3Rpb24gZiBwYXNzZWQgdG8gbWluaW1pemUoKS5cIn0pKSxDKDA9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IHJldHVybiBhIHNjYWxhciwgYnV0IGl0IHJldHVybmVkIGEgcmFuay1cIitzLnJhbmsrXCIgdGVuc29yXCJ9KSk7dmFyIGM9e307cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtudWxsIT11W2VdJiYoY1t0Lm5hbWVdPXVbZV0pfSkpLG51bGwhPW8mJm8uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGNbdC5uYW1lXT1udWxsfSkpLHt2YWx1ZTpzLGdyYWRzOmN9fWZ1bmN0aW9uIHZvKHQpe3JldHVybiBMdC5jdXN0b21HcmFkKHQpfWZ1bmN0aW9uIG1vKHQpe2lmKHQuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dH0pKS5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0XFxuICAgIHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKX12YXIgZ289QW4oe3NvZnRtYXhfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9LTEpO3ZhciBuPW1uKHQsXCJsb2dpdHNcIixcInNvZnRtYXhcIixcImZsb2F0MzJcIik7aWYoLTE9PT1lJiYoZT1uLnJhbmstMSksZSE9PW4ucmFuay0xKXRocm93IEVycm9yKFwiU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTG9naXRzIHdhcyByYW5rIFwiK24ucmFuaytcIiBhbmQgZGltIHdhcyBcIitlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxyKXt2YXIgbz10LnNvZnRtYXgobixlKTtyZXR1cm4gcihbb10pLG99KSx7bG9naXRzOm59LChmdW5jdGlvbih0LG4pe3ZhciByPW5bMF0sbz10Lm11bChyKTtyZXR1cm57bG9naXRzOmZ1bmN0aW9uKCl7cmV0dXJuIG8uc3ViKG8uc3VtKFtlXSwhMCkubXVsKHIpKX19fSksXCJTb2Z0bWF4XCIse2RpbTplfSxbXSxbITBdKX19KSx5bz1Bbih7bG9nU29mdG1heF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0tMSk7dmFyIG49bW4odCxcImxvZ2l0c1wiLFwibG9nU29mdG1heFwiKTtpZigtMT09PWUmJihlPW4ucmFuay0xKSxlIT09bi5yYW5rLTEpdGhyb3cgRXJyb3IoXCJMb2cgU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTG9naXRzIHdhcyByYW5rIFwiK24ucmFuaytcIiBhbmQgYXhpcyB3YXMgXCIrZSk7cmV0dXJuIHZvKChmdW5jdGlvbih0LG4pe3ZhciByPXQubWF4KGUsITApLG89dC5zdWIociksYT1vLnRvRmxvYXQoKS5zdWIoby5leHAoKS5zdW0oZSwhMCkubG9nKCkpO24oW2FdKTtyZXR1cm57dmFsdWU6YSxncmFkRnVuYzpmdW5jdGlvbih0LG4pe3ZhciByPW5bMF0uZXhwKCk7cmV0dXJuIHQuc3ViKHQuc3VtKGUsITApLm11bChyKSl9fX0pKShuKX19KSx4bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLmJhY2tlbmQ9dCx0aGlzLmRhdGFNb3Zlcj1lLHRoaXMuZGF0YT1uZXcgV2Vha01hcCx0aGlzLmRhdGFJZHNDb3VudD0wfXJldHVybiB0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5oYXModCl8fHRoaXMuZGF0YU1vdmVyLm1vdmVEYXRhKHRoaXMuYmFja2VuZCx0KSx0aGlzLmRhdGEuZ2V0KHQpfSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXt0aGlzLmRhdGFJZHNDb3VudCsrLHRoaXMuZGF0YS5zZXQodCxlKX0sdC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuaGFzKHQpfSx0LnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YUlkc0NvdW50LS0sdGhpcy5kYXRhLmRlbGV0ZSh0KX0sdC5wcm90b3R5cGUubnVtRGF0YUlkcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGFJZHNDb3VudH0sdH0oKSxibz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwidGltZVwiKX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyZWFkXCIpfSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyZWFkU3luY1wiKX0sdC5wcm90b3R5cGUubnVtRGF0YUlkcz1mdW5jdGlvbigpe3JldHVybiB3byhcIm51bURhdGFJZHNcIil9LHQucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImRpc3Bvc2VEYXRhXCIpfSx0LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwid3JpdGVcIil9LHQucHJvdG90eXBlLm1vdmU9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwibW92ZVwiKX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJuIHdvKFwibWVtb3J5XCIpfSx0LnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiB3byhcImZsb2F0UHJlY2lzaW9uXCIpfSx0LnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyPT09dGhpcy5mbG9hdFByZWNpc2lvbigpPzFlLTc6MWUtNH0sdC5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwiYmF0Y2hNYXRNdWxcIil9LHQucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCl7dC5hLHQuYix0LnRyYW5zcG9zZUEsdC50cmFuc3Bvc2VCLHQuYmlhcyx0LmFjdGl2YXRpb24sdC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO3JldHVybiB3byhcImZ1c2VkQmF0Y2hNYXRNdWxcIil9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJzbGljZVwiKX0sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcInN0cmlkZWRTbGljZVwiKX0sdC5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInVuc3RhY2tcIil9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJyZXZlcnNlXCIpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJjb25jYXRcIil9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJuZWdcIil9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImFkZFwiKX0sdC5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhZGROXCIpfSx0LnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInN1YnRyYWN0XCIpfSx0LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm11bHRpcGx5XCIpfSx0LnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwicmVhbERpdmlkZVwiKX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJmbG9vckRpdlwiKX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwic3VtXCIpfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwicHJvZFwiKX0sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIil9LHQucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImFyZ01pblwiKX0sdC5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYXJnTWF4XCIpfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImVxdWFsXCIpfSx0LnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm5vdEVxdWFsXCIpfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibGVzc1wiKX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibGVzc0VxdWFsXCIpfSx0LnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiZ3JlYXRlclwiKX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiZ3JlYXRlckVxdWFsXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImxvZ2ljYWxOb3RcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJsb2dpY2FsQW5kXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJsb2dpY2FsT3JcIil9LHQucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcIndoZXJlXCIpfSx0LnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInNlbGVjdFwiKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwidG9wa1wiKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibWluXCIpfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibWluaW11bVwiKX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibW9kXCIpfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtYXhcIil9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtYXhpbXVtXCIpfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhbGxcIil9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImFueVwiKX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJzcXVhcmVkRGlmZmVyZW5jZVwiKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJjZWlsXCIpfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJmbG9vclwiKX0sdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicm91bmRcIil9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic2lnblwiKX0sdC5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiaXNOYU5cIil9LHQucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImlzSW5mXCIpfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJpc0Zpbml0ZVwiKX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwicG93XCIpfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZXhwXCIpfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJleHBtMVwiKX0sdC5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInNvZnRtYXhcIil9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJsb2dcIil9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImxvZzFwXCIpfSx0LnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNxcnRcIil9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJzcXJ0XCIpfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic3F1YXJlXCIpfSx0LnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJlY2lwcm9jYWxcIil9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicmVsdVwiKX0sdC5wcm90b3R5cGUucmVsdTY9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicmVsdTZcIil9LHQucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwicHJlbHVcIil9LHQucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJlbHVcIil9LHQucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImVsdURlclwiKX0sdC5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzZWx1XCIpfSx0LnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiaW50XCIpfSx0LnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJjbGlwXCIpfSx0LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYWJzXCIpfSx0LnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImNvbXBsZXhBYnNcIil9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic2lnbW9pZFwiKX0sdC5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic29mdHBsdXNcIil9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzaW5cIil9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJjb3NcIil9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJ0YW5cIil9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYXNpblwiKX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhY29zXCIpfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImF0YW5cIil9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYXRhbjJcIil9LHQucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic2luaFwiKX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJjb3NoXCIpfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInRhbmhcIil9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImFzaW5oXCIpfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhY29zaFwiKX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYXRhbmhcIil9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJlcmZcIil9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJzdGVwXCIpfSx0LnByb3RvdHlwZS5mdXNlZENvbnYyZD1mdW5jdGlvbih0KXt0LmlucHV0LHQuZmlsdGVyLHQuY29udkluZm8sdC5iaWFzLHQuYWN0aXZhdGlvbix0LnByZWx1QWN0aXZhdGlvbldlaWdodHM7cmV0dXJuIHdvKFwiZnVzZWRDb252MmRcIil9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiY29udjJkXCIpfSx0LnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiY29udjJkRGVySW5wdXRcIil9LHQucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiY29udjJkRGVyRmlsdGVyXCIpfSx0LnByb3RvdHlwZS5mdXNlZERlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0KXt0LmlucHV0LHQuZmlsdGVyLHQuY29udkluZm8sdC5iaWFzLHQuYWN0aXZhdGlvbix0LnByZWx1QWN0aXZhdGlvbldlaWdodHM7cmV0dXJuIHdvKFwiZnVzZWREZXB0aHdpc2VDb252MkRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiZGVwdGh3aXNlQ29udjJEXCIpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiZGVwdGh3aXNlQ29udjJERGVySW5wdXRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyXCIpfSx0LnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImNvbnYzZFwiKX0sdC5wcm90b3R5cGUuY29udjNkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImNvbnYzZERlcklucHV0XCIpfSx0LnByb3RvdHlwZS5jb252M2REZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImNvbnYzZERlckZpbHRlclwiKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm1heFBvb2xcIil9LHQucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJtYXhQb29sQmFja3Byb3BcIil9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhdmdQb29sXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImF2Z1Bvb2xCYWNrcHJvcFwiKX0sdC5wcm90b3R5cGUuYXZnUG9vbDNkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYXZnUG9vbDNkXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiYXZnUG9vbDNkQmFja3Byb3BcIil9LHQucHJvdG90eXBlLm1heFBvb2wzZD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm1heFBvb2wzZFwiKX0sdC5wcm90b3R5cGUubWF4UG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwibWF4UG9vbDNkQmFja3Byb3BcIil9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJyZXNoYXBlXCIpfSx0LnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiY2FzdFwiKX0sdC5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInRpbGVcIil9LHQucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwicGFkXCIpfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJ0cmFuc3Bvc2VcIil9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiZ2F0aGVyXCIpfSx0LnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImdhdGhlck5EXCIpfSx0LnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInNjYXR0ZXJORFwiKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImJhdGNoVG9TcGFjZU5EXCIpfSx0LnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwic3BhY2VUb0JhdGNoTkRcIil9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcInJlc2l6ZUJpbGluZWFyXCIpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJyZXNpemVCaWxpbmVhckJhY2twcm9wXCIpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwicmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3BcIil9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHdvKFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHdvKFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RFwiKX0sdC5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXtyZXR1cm4gd28oXCJMUk5HcmFkXCIpfSx0LnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJtdWx0aW5vbWlhbFwiKX0sdC5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcIm9uZUhvdFwiKX0sdC5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcImN1bXN1bVwiKX0sdC5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gd28oXCJub25NYXhTdXBwcmVzc2lvblwiKX0sdC5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImZmdFwiKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJpZmZ0XCIpfSx0LnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiY29tcGxleFwiKX0sdC5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyZWFsXCIpfSx0LnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImltYWdcIil9LHQucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB3byhcImNyb3BBbmRSZXNpemVcIil9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiZGVwdGhUb1NwYWNlXCIpfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwic3BsaXRcIil9LHQucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwic3BhcnNlVG9EZW5zZVwiKX0sdC5wcm90b3R5cGUuZGlhZz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJkaWFnXCIpfSx0LnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJmaWxsXCIpfSx0LnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJvbmVzTGlrZVwiKX0sdC5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInplcm9zTGlrZVwiKX0sdC5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImxpbnNwYWNlXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIHdvKFwiZGlzcG9zZVwiKX0sdH0oKTtmdW5jdGlvbiB3byh0KXt0aHJvdyBuZXcgRXJyb3IoXCInXCIrdCtcIicgbm90IHlldCBpbXBsZW1lbnRlZCBvciBub3QgZm91bmQgaW4gdGhlIHJlZ2lzdHJ5LiBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgdGhlIGtlcm5lbD9cIil9ZnVuY3Rpb24gQ28odCxlKXtmb3IodmFyIG49dC5sZW5ndGgscj1bXSxvPTA7bzxuO28rKyl7dmFyIGE9bi0xLW8saT10W2FdfHwxOyhlW2UubGVuZ3RoLTEtb118fDEpPjEmJjE9PT1pJiZyLnVuc2hpZnQoYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gRW8odCxlKXtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbz10W3QubGVuZ3RoLXItMV0sYT1lLmxlbmd0aC1yLTEsaT1lW2FdOyhudWxsPT1vfHwxPT09byYmaT4xKSYmbi51bnNoaWZ0KGEpfXJldHVybiBufWZ1bmN0aW9uIFJvKHQsZSl7Zm9yKHZhciBuPVtdLHI9TWF0aC5tYXgodC5sZW5ndGgsZS5sZW5ndGgpLG89MDtvPHI7bysrKXt2YXIgYT10W3QubGVuZ3RoLW8tMV07bnVsbD09YSYmKGE9MSk7dmFyIGk9ZVtlLmxlbmd0aC1vLTFdO2lmKG51bGw9PWkmJihpPTEpLDE9PT1hKW4udW5zaGlmdChpKTtlbHNlIGlmKDE9PT1pKW4udW5zaGlmdChhKTtlbHNle2lmKGEhPT1pKXRocm93IEVycm9yKFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIit0K1wiIGFuZCBcIitlK1wiLlwiKTtuLnVuc2hpZnQoYSl9fXJldHVybiBufWZ1bmN0aW9uIElvKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPVwiY2hhbm5lbHNMYXN0XCIpO3ZhciBzLHU9VG8oZSksYz11WzBdLGw9dVsxXTtpZihcImNoYW5uZWxzTGFzdFwiPT09aSlzPVtjLGwsdFszXSx0WzNdXTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIraSk7cz1bYyxsLHRbMV0sdFsxXV19cmV0dXJuIFNvKHQscyxuLHIsbyxhLCExLGkpfWZ1bmN0aW9uIGtvKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPVwiTkRIV0NcIik7dmFyIHMsdSxjPU5vKGUpLGw9Y1swXSxoPWNbMV0sZj1jWzJdO2lmKFwiTkRIV0NcIj09PWkpdT1cImNoYW5uZWxzTGFzdFwiLHM9W2wsaCxmLHRbNF0sdFs0XV07ZWxzZXtpZihcIk5DREhXXCIhPT1pKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitpKTt1PVwiY2hhbm5lbHNGaXJzdFwiLHM9W2wsaCxmLHRbMV0sdFsxXV19cmV0dXJuIEFvKHQscyxuLHIsbywhMSx1LGEpfWZ1bmN0aW9uIFNvKHQsZSxuLHIsbyxhLGkscyl7dm9pZCAwPT09aSYmKGk9ITEpLHZvaWQgMD09PXMmJihzPVwiY2hhbm5lbHNMYXN0XCIpO3ZhciB1PVstMSwtMSwtMSwtMV0sYz11WzBdLGw9dVsxXSxoPXVbMl0sZj11WzNdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1zKWM9dFswXSxsPXRbMV0saD10WzJdLGY9dFszXTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIrcyk7Yz10WzBdLGY9dFsxXSxsPXRbMl0saD10WzNdfXZhciBkLHA9ZVswXSx2PWVbMV0sbT1lWzNdLGc9VG8obikseT1nWzBdLHg9Z1sxXSxiPVRvKHIpLHc9YlswXSxFPWJbMV0sUj1GbyhwLHcpLEk9Rm8odixFKSxrPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyl7dmFyIHUsYyxsO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXt1PXt0b3A6dCxib3R0b206dCxsZWZ0OnQscmlnaHQ6dCx0eXBlOjA9PT10P1wiVkFMSURcIjpcIk5VTUJFUlwifTt2YXIgaD1mdW5jdGlvbih0LGUsbixyLG8pe251bGw9PXImJihyPURvKHQsZSxuKSk7dmFyIGE9dFswXSxpPXRbMV0scz1fbygoYS1lKzIqcikvbisxLG8pO0MoQShzKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBvdXRwdXQgIyBvZiByb3dzIChcIitzK1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCJ9KSk7dmFyIHU9X28oKGktZSsyKnIpL24rMSxvKTtyZXR1cm4gQyhBKHUpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKFwiK3UrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pKSxbcyx1XX0oW2Usbl0sYSxyLHQscyk7Yz1oWzBdLGw9aFsxXX1lbHNlIGlmKFwic2FtZVwiPT09dCl7Yz1NYXRoLmNlaWwoZS9yKSxsPU1hdGguY2VpbChuL28pO3ZhciBmPU1hdGgubWF4KDAsKGMtMSkqcithLWUpLGQ9TWF0aC5tYXgoMCwobC0xKSpvK2ktbikscD1NYXRoLmZsb29yKGYvMiksdj1mLXAsbT1NYXRoLmZsb29yKGQvMik7dT17dG9wOnAsYm90dG9tOnYsbGVmdDptLHJpZ2h0OmQtbSx0eXBlOlwiU0FNRVwifX1lbHNle2lmKFwidmFsaWRcIiE9PXQpdGhyb3cgRXJyb3IoXCJVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiBcIit0KTt1PXt0b3A6MCxib3R0b206MCxsZWZ0OjAscmlnaHQ6MCx0eXBlOlwiVkFMSURcIn0sYz1NYXRoLmNlaWwoKGUtYSsxKS9yKSxsPU1hdGguY2VpbCgobi1pKzEpL28pfXJldHVybntwYWRJbmZvOnUsb3V0SGVpZ2h0OmMsb3V0V2lkdGg6bH19KG8sbCxoLHkseCxSLEksYSksUz1rLnBhZEluZm8sRD1rLm91dEhlaWdodCxUPWsub3V0V2lkdGgsTj1pP20qZjptO3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09cz9kPVtjLE4sRCxUXTpcImNoYW5uZWxzTGFzdFwiPT09cyYmKGQ9W2MsRCxULE5dKSx7YmF0Y2hTaXplOmMsZGF0YUZvcm1hdDpzLGluSGVpZ2h0OmwsaW5XaWR0aDpoLGluQ2hhbm5lbHM6ZixvdXRIZWlnaHQ6RCxvdXRXaWR0aDpULG91dENoYW5uZWxzOk4scGFkSW5mbzpTLHN0cmlkZUhlaWdodDp5LHN0cmlkZVdpZHRoOngsZmlsdGVySGVpZ2h0OnAsZmlsdGVyV2lkdGg6dixlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6UixlZmZlY3RpdmVGaWx0ZXJXaWR0aDpJLGRpbGF0aW9uSGVpZ2h0OncsZGlsYXRpb25XaWR0aDpFLGluU2hhcGU6dCxvdXRTaGFwZTpkLGZpbHRlclNoYXBlOmV9fWZ1bmN0aW9uIEFvKHQsZSxuLHIsbyxhLGkscyl7dm9pZCAwPT09YSYmKGE9ITEpLHZvaWQgMD09PWkmJihpPVwiY2hhbm5lbHNMYXN0XCIpO3ZhciB1PVstMSwtMSwtMSwtMSwtMV0sYz11WzBdLGw9dVsxXSxoPXVbMl0sZj11WzNdLGQ9dVs0XTtpZihcImNoYW5uZWxzTGFzdFwiPT09aSljPXRbMF0sbD10WzFdLGg9dFsyXSxmPXRbM10sZD10WzRdO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1pKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitpKTtjPXRbMF0sZD10WzFdLGw9dFsyXSxoPXRbM10sZj10WzRdfXZhciBwLHY9ZVswXSxtPWVbMV0sZz1lWzJdLHk9ZVs0XSx4PU5vKG4pLGI9eFswXSx3PXhbMV0sRT14WzJdLFI9Tm8ociksST1SWzBdLGs9UlsxXSxTPVJbMl0sRD1Gbyh2LEkpLFQ9Rm8obSxrKSxOPUZvKGcsUyksRj1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSxjLGwpe3ZhciBoLGYsZCxwO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtoPXt0b3A6dCxib3R0b206dCxsZWZ0OnQscmlnaHQ6dCxmcm9udDp0LGJhY2s6dCx0eXBlOjA9PT10P1wiVkFMSURcIjpcIk5VTUJFUlwifTt2YXIgdj1mdW5jdGlvbih0LGUsbixyLG8sYSl7bnVsbD09byYmKG89RG8odCxlLHIpKTt2YXIgaT10WzBdLHM9dFsxXSx1PXRbMl0sYz1fbygoaS1lKzIqbykvcisxLGEpO0MoQShjKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBvdXRwdXQgIyBvZiBkZXB0aHMgKFwiK2MrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pKTt2YXIgbD1fbygocy1lKzIqbykvcisxLGEpO0MoQShsKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBvdXRwdXQgIyBvZiByb3dzIChcIitsK1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCJ9KSk7dmFyIGg9X28oKHUtZSsyKm8pL3IrMSxhKTtyZXR1cm4gQyhBKGgpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKFwiK2grXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pKSxbYyxsLGgsbl19KFtlLG4sciwxXSxzLDEsbyx0LGwpO2Y9dlswXSxkPXZbMV0scD12WzJdfWVsc2UgaWYoXCJzYW1lXCI9PT10KXtmPU1hdGguY2VpbChlL28pLGQ9TWF0aC5jZWlsKG4vYSkscD1NYXRoLmNlaWwoci9pKTt2YXIgbT0oZi0xKSpvK3MtZSxnPShkLTEpKmErdS1uLHk9KHAtMSkqaStjLXIseD1NYXRoLmZsb29yKG0vMiksYj1tLXgsdz1NYXRoLmZsb29yKGcvMiksRT1nLXcsUj1NYXRoLmZsb29yKHkvMik7aD17dG9wOncsYm90dG9tOkUsbGVmdDpSLHJpZ2h0OnktUixmcm9udDp4LGJhY2s6Yix0eXBlOlwiU0FNRVwifX1lbHNle2lmKFwidmFsaWRcIiE9PXQpdGhyb3cgRXJyb3IoXCJVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiBcIit0KTtoPXt0b3A6MCxib3R0b206MCxsZWZ0OjAscmlnaHQ6MCxmcm9udDowLGJhY2s6MCx0eXBlOlwiVkFMSURcIn0sZj1NYXRoLmNlaWwoKGUtcysxKS9vKSxkPU1hdGguY2VpbCgobi11KzEpL2EpLHA9TWF0aC5jZWlsKChyLWMrMSkvaSl9cmV0dXJue3BhZEluZm86aCxvdXREZXB0aDpmLG91dEhlaWdodDpkLG91dFdpZHRoOnB9fShvLGwsaCxmLGIsdyxFLEQsVCxOLHMpLF89Ri5wYWRJbmZvLE89Ri5vdXREZXB0aCxNPUYub3V0SGVpZ2h0LEI9Ri5vdXRXaWR0aCxQPWE/eSpkOnk7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT1pP3A9W2MsUCxPLE0sQl06XCJjaGFubmVsc0xhc3RcIj09PWkmJihwPVtjLE8sTSxCLFBdKSx7YmF0Y2hTaXplOmMsZGF0YUZvcm1hdDppLGluRGVwdGg6bCxpbkhlaWdodDpoLGluV2lkdGg6ZixpbkNoYW5uZWxzOmQsb3V0RGVwdGg6TyxvdXRIZWlnaHQ6TSxvdXRXaWR0aDpCLG91dENoYW5uZWxzOlAscGFkSW5mbzpfLHN0cmlkZURlcHRoOmIsc3RyaWRlSGVpZ2h0Oncsc3RyaWRlV2lkdGg6RSxmaWx0ZXJEZXB0aDp2LGZpbHRlckhlaWdodDptLGZpbHRlcldpZHRoOmcsZWZmZWN0aXZlRmlsdGVyRGVwdGg6RCxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6VCxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpOLGRpbGF0aW9uRGVwdGg6SSxkaWxhdGlvbkhlaWdodDprLGRpbGF0aW9uV2lkdGg6UyxpblNoYXBlOnQsb3V0U2hhcGU6cCxmaWx0ZXJTaGFwZTplfX1mdW5jdGlvbiBEbyh0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0xKTt2YXIgbz1GbyhlLHIpO3JldHVybiBNYXRoLmZsb29yKCh0WzBdKihuLTEpLW4rbykvMil9ZnVuY3Rpb24gVG8odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdCx0XToyPT09dC5sZW5ndGg/W3RbMF0sdFsxXSwxXTp0fWZ1bmN0aW9uIE5vKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P1t0LHQsdF06dH1mdW5jdGlvbiBGbyh0LGUpe3JldHVybiBlPD0xP3Q6dCsodC0xKSooZS0xKX1mdW5jdGlvbiBfbyh0LGUpe2lmKCFlKXJldHVybiB0O3N3aXRjaChlKXtjYXNlXCJyb3VuZFwiOnJldHVybiBNYXRoLnJvdW5kKHQpO2Nhc2VcImNlaWxcIjpyZXR1cm4gTWF0aC5jZWlsKHQpO2Nhc2VcImZsb29yXCI6cmV0dXJuIE1hdGguZmxvb3IodCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJvdW5kaW5nTW9kZSBcIitlKX19ZnVuY3Rpb24gT28odCl7dmFyIGU9VG8odCksbj1lWzBdLHI9ZVsxXSxvPWVbMl07cmV0dXJuIDE9PT1uJiYxPT09ciYmMT09PW99ZnVuY3Rpb24gTW8odCxlKXtyZXR1cm4gT28odCl8fE9vKGUpfWZ1bmN0aW9uIEJvKHQpe2lmKFwiTkhXQ1wiPT09dClyZXR1cm5cImNoYW5uZWxzTGFzdFwiO2lmKFwiTkNIV1wiPT09dClyZXR1cm5cImNoYW5uZWxzRmlyc3RcIjt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIrdCl9ZnVuY3Rpb24gUG8odCxlLG4pe2lmKFwiY29tcGxleDY0XCI9PT1lKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSlyZXR1cm4gdC5jbG9uZSgpO3ZhciByPUduKHQuc2hhcGUpLG89dC50b0Zsb2F0KCksYT1uLmNvbXBsZXgobyxyKTtyZXR1cm4gci5kaXNwb3NlKCksby5kaXNwb3NlKCksYX1pZighVSh0LmR0eXBlLGUpKXJldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZCh0LmRhdGFJZCx0LnNoYXBlLGUpO2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXt2YXIgaT1uLnJlYWwodCk7YT1pLmNhc3QoZSk7cmV0dXJuIGkuZGlzcG9zZSgpLGF9aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbi5pbnQodCk7aWYoXCJib29sXCI9PT1lKXt2YXIgcz1PbigwLHQuZHR5cGUpO2E9bi5ub3RFcXVhbCh0LHMpO3JldHVybiBzLmRpc3Bvc2UoKSxhfXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIENhc3Q6IGZhaWxlZCB0byBjYXN0IFwiK3QuZHR5cGUrXCIgdG8gXCIrZSl9ZnVuY3Rpb24gTG8odCxlKXtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQodC5kYXRhSWQsZSx0LmR0eXBlKX1mdW5jdGlvbiBXbyh0LGUsbil7dmFyIHI9KGUtdCkvKG4tMSksbz10dChuLFwiZmxvYXQzMlwiKTtvWzBdPXQ7Zm9yKHZhciBhPTE7YTxvLmxlbmd0aDthKyspb1thXT1vW2EtMV0rcjtyZXR1cm4gTW4obyxcImZsb2F0MzJcIil9dmFyIFVvPU9iamVjdC5mcmVlemUoe2Nhc3RUZW5zb3I6UG8scmVzaGFwZVRlbnNvcjpMbyxsaW5zcGFjZUltcGw6V28sdXBjYXN0VHlwZTpEdCxheGVzQXJlSW5uZXJNb3N0RGltczp5bixjb21iaW5lTG9jYXRpb25zOnhuLGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXM6Ym4sZXhwYW5kU2hhcGVUb0tlZXBEaW06d24sYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXM6Q24sZ2V0QXhlc1Blcm11dGF0aW9uOkVuLGdldFVuZG9BeGVzUGVybXV0YXRpb246Um4sZ2V0SW5uZXJNb3N0QXhlczpJbixnZXRCcm9hZGNhc3REaW1zOkNvLGdldFJlZHVjdGlvbkF4ZXM6RW8sYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGU6Um8sYXNzZXJ0UGFyYW1zQ29uc2lzdGVudDprbixjb21wdXRlT3V0U2hhcGU6U24sY29tcHV0ZVBvb2wyREluZm86SW8sY29tcHV0ZVBvb2wzREluZm86a28sY29tcHV0ZUNvbnYyREluZm86U28sY29tcHV0ZUNvbnYzREluZm86QW8sY29tcHV0ZURlZmF1bHRQYWQ6RG8sdHVwbGVWYWx1ZXNBcmVPbmU6T28sZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lOk1vLGNvbnZlcnRDb252MkREYXRhRm9ybWF0OkJvLFBBUkFMTEVMSVpFX1RIUkVTSE9MRDpZcixjb21wdXRlT3B0aW1hbFdpbmRvd1NpemU6JHJ9KTtmdW5jdGlvbiBWbyh0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHJlYWwgYW5kIGltYWcgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGhzLiByZWFsOlwiK3QubGVuZ3RoK1wiLCBpbWFnOiBcIitlLmxlbmd0aCtcIi5cIik7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkoMip0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cis9MiluW3JdPXRbci8yXSxuW3IrMV09ZVtyLzJdO3JldHVybiBufWZ1bmN0aW9uIHpvKHQsZSl7cmV0dXJue3JlYWw6dFsyKmVdLGltYWc6dFsyKmUrMV19fWZ1bmN0aW9uIEdvKHQsZSxuLHIpe3RbMipyXT1lLHRbMipyKzFdPW59ZnVuY3Rpb24gSG8odCxlLG4pe3ZhciByPShuPzI6LTIpKk1hdGguUEkqKHQvZSk7cmV0dXJue3JlYWw6TWF0aC5jb3MociksaW1hZzpNYXRoLnNpbihyKX19ZnVuY3Rpb24gcW8odCxlLG4pe3ZhciByPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZhciByPTAsbz10Lmxlbmd0aCxhPTAsaT0hMTtmb3IoO3I8bzspe3ZhciBzPW4oZSx0W2E9cisoby1yPj4+MSldKTtzPjA/cj1hKzE6KG89YSxpPSFzKX1yZXR1cm4gaT9yOi1yLTF9KHQsZSxufHxLbyl9KHQsZSxuKSxvPXI8MD8tKHIrMSk6cjt0LnNwbGljZShvLDAsZSl9ZnVuY3Rpb24gS28odCxlKXtyZXR1cm4gdD5lPzE6dDxlPy0xOjB9ZnVuY3Rpb24gam8odCxlLG4scixvKXtyZXR1cm4gWW8odCxlLG4scixvLDApLnNlbGVjdGVkSW5kaWNlc31mdW5jdGlvbiBYbyh0LGUsbixyLG8sYSl7dmFyIGk9WW8odCxlLG4scixvLGEsITApO3JldHVybiBpLm51bVZhbGlkT3V0cHV0cy5kaXNwb3NlKCkse3NlbGVjdGVkSW5kaWNlczppLnNlbGVjdGVkSW5kaWNlcyxzZWxlY3RlZFNjb3JlczppLnNlbGVjdGVkU2NvcmVzfX1mdW5jdGlvbiBZbyh0LGUsbixyLG8sYSxpLHMpe3ZvaWQgMD09PWkmJihpPSExKSx2b2lkIDA9PT1zJiYocz0hMSk7Zm9yKHZhciB1PUFycmF5LmZyb20oZSkubWFwKChmdW5jdGlvbih0LGUpe3JldHVybntzY29yZTp0LGJveEluZGV4OmUsc3VwcHJlc3NCZWdpbkluZGV4OjB9fSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2NvcmU+b30pKS5zb3J0KEpvKSxjPWE+MD8tLjUvYTowLGw9W10saD1bXTtsLmxlbmd0aDxuJiZ1Lmxlbmd0aD4wOyl7dmFyIGY9dS5wb3AoKSxkPWYuc2NvcmUscD1mLmJveEluZGV4LHY9Zi5zdXBwcmVzc0JlZ2luSW5kZXg7aWYoZDxvKWJyZWFrO2Zvcih2YXIgbT0hMSxnPWwubGVuZ3RoLTE7Zz49djstLWcpe3ZhciB5PSRvKHQscCxsW2ddKTtpZih5Pj1yKXttPSEwO2JyZWFrfWlmKGYuc2NvcmU9Zi5zY29yZSpRbyhyLGMseSksZi5zY29yZTw9bylicmVha31mLnN1cHByZXNzQmVnaW5JbmRleD1sLmxlbmd0aCxtfHwoZi5zY29yZT09PWQ/KGwucHVzaChwKSxoLnB1c2goZi5zY29yZSkpOmYuc2NvcmU+byYmcW8odSxmLEpvKSl9dmFyIHg9bC5sZW5ndGg7cmV0dXJuIHMmJihsLmZpbGwoMCx4KSxoLmZpbGwoMCx4KSkse3NlbGVjdGVkSW5kaWNlczpNbihsLFwiaW50MzJcIiksc2VsZWN0ZWRTY29yZXM6TW4oaCxcImZsb2F0MzJcIiksbnVtVmFsaWRPdXRwdXRzOk9uKHgsXCJpbnQzMlwiKX19ZnVuY3Rpb24gJG8odCxlLG4pe3ZhciByPXQuc3ViYXJyYXkoNCplLDQqZSs0KSxvPXQuc3ViYXJyYXkoNCpuLDQqbis0KSxhPU1hdGgubWluKHJbMF0sclsyXSksaT1NYXRoLm1pbihyWzFdLHJbM10pLHM9TWF0aC5tYXgoclswXSxyWzJdKSx1PU1hdGgubWF4KHJbMV0sclszXSksYz1NYXRoLm1pbihvWzBdLG9bMl0pLGw9TWF0aC5taW4ob1sxXSxvWzNdKSxoPU1hdGgubWF4KG9bMF0sb1syXSksZj1NYXRoLm1heChvWzFdLG9bM10pLGQ9KHMtYSkqKHUtaSkscD0oaC1jKSooZi1sKTtpZihkPD0wfHxwPD0wKXJldHVybiAwO3ZhciB2PU1hdGgubWF4KGEsYyksbT1NYXRoLm1heChpLGwpLGc9TWF0aC5taW4ocyxoKSx5PU1hdGgubWluKHUsZikseD1NYXRoLm1heChnLXYsMCkqTWF0aC5tYXgoeS1tLDApO3JldHVybiB4LyhkK3AteCl9ZnVuY3Rpb24gUW8odCxlLG4pe3ZhciByPU1hdGguZXhwKGUqbipuKTtyZXR1cm4gbjw9dD9yOjB9ZnVuY3Rpb24gSm8odCxlKXtyZXR1cm4gdC5zY29yZS1lLnNjb3JlfHx0LnNjb3JlPT09ZS5zY29yZSYmZS5ib3hJbmRleC10LmJveEluZGV4fWZ1bmN0aW9uIFpvKHQsZSxuKXt2YXIgcj1uZXcgQXJyYXkodC5yYW5rKS5maWxsKDApLG89dC5zaGFwZS5zbGljZSgpO3JldHVybiBlLm1hcCgoZnVuY3Rpb24oZSl7b1tuXT1lO3ZhciBhPXQuc2xpY2UocixvKTtyZXR1cm4gcltuXSs9ZSxhfSkpfWZ1bmN0aW9uIHRhKHQsZSl7Zm9yKHZhciBuPW5ldyBBcnJheSh0LnJhbmspLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXQuc2hhcGVbcl0qZVtyXTt2YXIgbz1kcihuLHQuZHR5cGUpO2ZvcihyPTA7cjxvLnZhbHVlcy5sZW5ndGg7KytyKXtmb3IodmFyIGE9by5pbmRleFRvTG9jKHIpLGk9bmV3IEFycmF5KHQucmFuaykscz0wO3M8aS5sZW5ndGg7cysrKWlbc109YVtzXSV0LnNoYXBlW3NdO3ZhciB1PXQubG9jVG9JbmRleChpKTtvLnZhbHVlc1tyXT10LnZhbHVlc1t1XX1yZXR1cm4gby50b1RlbnNvcigpfWZ1bmN0aW9uIGVhKHQsZSxuLHIsbyl7Zm9yKHZhciBhPWVbZS5sZW5ndGgtMV0saT1bdC5sZW5ndGgvYSxhXSxzPWlbMF0sdT1pWzFdLGM9QihuLHMqciksbD1CKFwiaW50MzJcIixzKnIpLGg9MDtoPHM7aCsrKXtmb3IodmFyIGY9aCp1LGQ9dC5zdWJhcnJheShmLGYrdSkscD1bXSx2PTA7djxkLmxlbmd0aDt2KyspcC5wdXNoKHt2YWx1ZTpkW3ZdLGluZGV4OnZ9KTtwLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUudmFsdWUtdC52YWx1ZX0pKTt2YXIgbT1oKnIsZz1jLnN1YmFycmF5KG0sbStyKSx5PWwuc3ViYXJyYXkobSxtK3IpO2Zvcih2PTA7djxyO3YrKylnW3ZdPXBbdl0udmFsdWUseVt2XT1wW3ZdLmluZGV4fXZhciB4PWUuc2xpY2UoKTtyZXR1cm4geFt4Lmxlbmd0aC0xXT1yLFtGbihjLHgsbiksRm4obCx4LFwiaW50MzJcIildfWZ1bmN0aW9uIG5hKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyllW3JdJiZuLnB1c2gocik7dmFyIG89ZHIodCxcImludDMyXCIpLGE9ZHIoW24ubGVuZ3RoLHQubGVuZ3RoXSxcImludDMyXCIpO2ZvcihyPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW8uaW5kZXhUb0xvYyhuW3JdKSxzPXIqdC5sZW5ndGg7YS52YWx1ZXMuc2V0KGkscyl9cmV0dXJuIGEudG9UZW5zb3IoKX12YXIgcmE9ZnVuY3Rpb24odCxlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnZhcmlhYmxlTmFtZXM9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pKTt2YXIgbj1bXTt0aGlzLnZhcmlhYmxlTmFtZXMuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5wdXNoKFwiZmxvYXQgdlwiK3QrXCIgPSBnZXRcIit0K1wiQXRPdXRDb29yZHMoKTtcIil9KSk7dmFyIHI9dGhpcy52YXJpYWJsZU5hbWVzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJ2XCIrdH0pKS5qb2luKFwiICsgXCIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIituLmpvaW4oXCJcXG4gICAgICAgIFwiKStcIlxcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gXCIrcitcIjtcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LG9hPWZ1bmN0aW9uKHQsZSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy52YXJpYWJsZU5hbWVzPWUubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KSk7dmFyIG49W107dGhpcy52YXJpYWJsZU5hbWVzLmZvckVhY2goKGZ1bmN0aW9uKHQpe24ucHVzaChcInZlYzQgdlwiK3QrXCIgPSBnZXRcIit0K1wiQXRPdXRDb29yZHMoKTtcIil9KSk7dmFyIHI9dGhpcy52YXJpYWJsZU5hbWVzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJ2XCIrdH0pKS5qb2luKFwiICsgXCIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIituLmpvaW4oXCJcXG4gICAgICAgIFwiKStcIlxcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSBcIityK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sYWE9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO3ZhciByPXQud2luZG93U2l6ZSxvPXQuYmF0Y2hTaXplLGE9dC5pblNpemUsaT1NYXRoLmNlaWwoYS9yKTtufHx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJlc3RJbmRpY2VzQVwiKSx0aGlzLm91dHB1dFNoYXBlPVtvLGldO3ZhciBzPVwibWF4XCI9PT1lP1wiPlwiOlwiPFwiLHU9bj9cImluT2Zmc2V0ICsgaTtcIjpcInJvdW5kKGdldEJlc3RJbmRpY2VzQShiYXRjaCwgaW5PZmZzZXQgKyBpKSk7XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiK3IrXCI7XFxuXFxuICAgICAgICBpbnQgYmVzdEluZGV4ID0gaW5PZmZzZXQ7XFxuICAgICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXRBKGJhdGNoLCBiZXN0SW5kZXgpO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIityK1wiOyBpKyspIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gXCIrdStcIjtcXG4gICAgICAgICAgZmxvYXQgY2FuZGlkYXRlID0gZ2V0QShiYXRjaCwgaW5JZHgpO1xcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlIFwiK3MrXCIgYmVzdFZhbHVlKSB7XFxuICAgICAgICAgICAgYmVzdFZhbHVlID0gY2FuZGlkYXRlO1xcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGluSWR4O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoYmVzdEluZGV4KSk7XFxuICAgICAgfVxcbiAgICBcIn07ZnVuY3Rpb24gaWEodCxlKXtyZXR1cm5bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAsZSkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gdCtcIi5cIitlfSkpfWZ1bmN0aW9uIHNhKHQsZSl7cmV0dXJuIDE9PT1lP1t0XTppYSh0LGUpfWZ1bmN0aW9uIHVhKCl7dmFyIHQsZSxuLHIsbyxhLHMsdSxjLGw7cmV0dXJuIDI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8odD1cIiN2ZXJzaW9uIDMwMCBlc1wiLGU9XCJpblwiLG49XCJvdXRcIixyPVwiaW5cIixvPVwidGV4dHVyZVwiLGE9XCJvdXRwdXRDb2xvclwiLHM9XCJvdXQgdmVjNCBvdXRwdXRDb2xvcjtcIix1PVwiXFxuICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gKHZhbCA+IDAuMCB8fCB2YWwgPCAwLjApID8gZmFsc2UgOiB2YWwgIT0gMC4wO1xcbiAgICAgIH1cXG5cXG4gICAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBidmVjNChpc25hbl9jdXN0b20odmFsLngpLFxcbiAgICAgICAgICBpc25hbl9jdXN0b20odmFsLnkpLCBpc25hbl9jdXN0b20odmFsLnopLCBpc25hbl9jdXN0b20odmFsLncpKTtcXG4gICAgICB9XFxuXFxuICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxcbiAgICBcIixjPVwiXCIsbD1cIlxcbiAgICAgICNkZWZpbmUgcm91bmQodmFsdWUpIG5ld1JvdW5kKHZhbHVlKVxcbiAgICAgIGludCBuZXdSb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpdmVjNCBuZXdSb3VuZCh2ZWM0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzQoZmxvb3IodmFsdWUgKyB2ZWM0KDAuNSkpKTtcXG4gICAgICB9XFxuICAgIFwiKToodD1cIlwiLGU9XCJhdHRyaWJ1dGVcIixuPVwidmFyeWluZ1wiLHI9XCJ2YXJ5aW5nXCIsbz1cInRleHR1cmUyRFwiLGE9XCJnbF9GcmFnQ29sb3JcIixzPVwiXCIsdT1cIlxcbiAgICAgICNkZWZpbmUgaXNuYW4odmFsdWUpIGlzbmFuX2N1c3RvbSh2YWx1ZSlcXG4gICAgICBib29sIGlzbmFuX2N1c3RvbShmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiAodmFsID4gMC4gfHwgdmFsIDwgMS4gfHwgdmFsID09IDAuKSA/IGZhbHNlIDogdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgYnZlYzQgaXNuYW5fY3VzdG9tKHZlYzQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gYnZlYzQoaXNuYW4odmFsLngpLCBpc25hbih2YWwueSksIGlzbmFuKHZhbC56KSwgaXNuYW4odmFsLncpKTtcXG4gICAgICB9XFxuICAgIFwiLGM9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IElORklOSVRZO1xcblxcbiAgICAgIGJvb2wgaXNpbmYoZmxvYXQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gYWJzKHZhbCkgPT0gSU5GSU5JVFk7XFxuICAgICAgfVxcbiAgICAgIGJ2ZWM0IGlzaW5mKHZlYzQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gZXF1YWwoYWJzKHZhbCksIHZlYzQoSU5GSU5JVFkpKTtcXG4gICAgICB9XFxuICAgIFwiLGw9XCJcXG4gICAgICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaXZlYzQgcm91bmQodmVjNCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XFxuICAgICAgfVxcbiAgICBcIikse3ZlcnNpb246dCxhdHRyaWJ1dGU6ZSx2YXJ5aW5nVnM6bix2YXJ5aW5nRnM6cix0ZXh0dXJlMkQ6byxvdXRwdXQ6YSxkZWZpbmVPdXRwdXQ6cyxkZWZpbmVTcGVjaWFsTmFOOnUsZGVmaW5lU3BlY2lhbEluZjpjLGRlZmluZVJvdW5kOmx9fWZ1bmN0aW9uIGNhKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cImluZGV4XCIpO3ZhciByPSQoZSk7cmV0dXJuIHIubWFwKChmdW5jdGlvbihlLG8pe3JldHVyblwiaW50IFwiK3Rbb10rXCIgPSBcIituK1wiIC8gXCIrZStcIjsgXCIrKG89PT1yLmxlbmd0aC0xP1wiaW50IFwiK3RbbysxXStcIiA9IFwiK24rXCIgLSBcIit0W29dK1wiICogXCIrZTpcImluZGV4IC09IFwiK3Rbb10rXCIgKiBcIitlKStcIjtcIn0pKS5qb2luKFwiXCIpfWZ1bmN0aW9uIGxhKHQpe3ZhciBlPSQodCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC50b1N0cmluZygpfSkpO3JldHVyblwiXFxuICBpbnQgZ2V0RmxhdEluZGV4KGl2ZWMzIGNvb3Jkcykge1xcbiAgICByZXR1cm4gY29vcmRzLnggKiBcIitlWzBdK1wiICsgY29vcmRzLnkgKiBcIitlWzFdK1wiICsgY29vcmRzLno7XFxuICB9XFxuXCJ9dmFyIGhhPVwiXFxuICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgY29uc3QgZmxvYXQgRkxPQVRfTUlOID0gMS4xNzU0OTQzNWUtMzg7XFxuXFxuICBsb3dwIHZlYzQgZW5jb2RlX2Zsb2F0KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgaWYgKGlzbmFuKHYpKSB7XFxuICAgICAgcmV0dXJuIHZlYzQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcXG4gICAgfVxcblxcbiAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcXG5cXG4gICAgaWYoYXYgPCBGTE9BVF9NSU4pIHtcXG4gICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xcbiAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XFxuICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xcbiAgICB9XFxuXFxuICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XFxuICAgIGhpZ2hwIGZsb2F0IG0gPSBleHAyKGZyYWN0KGxvZzIoYXYpKSkgLSAxLjA7XFxuXFxuICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICBtIC09IGNbMl0gLyAxMjguMDtcXG4gICAgY1sxXSA9IGZsb29yKDMyNzY4LjAgKiBtKTtcXG4gICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xcblxcbiAgICBoaWdocCBmbG9hdCBlYmlhcyA9IGUgKyAxMjcuMDtcXG4gICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgZWJpYXMgLT0gY1szXSAqIDIuMDtcXG4gICAgY1syXSArPSBmbG9vcihlYmlhcykgKiAxMjguMDtcXG5cXG4gICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgIHJldHVybiBjIC8gMjU1LjA7XFxuICB9XFxuXCI7ZnVuY3Rpb24gZmEodCxlLG4scil7dmFyIG89W107dC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1rKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7dC5zaGFwZUluZm8uaXNVbmlmb3JtP28ucHVzaChcInVuaWZvcm0gZmxvYXQgXCIrdC5uYW1lKyhlPjE/XCJbXCIrZStcIl1cIjpcIlwiKStcIjtcIik6KG8ucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIFwiK3QubmFtZStcIjtcIiksby5wdXNoKFwidW5pZm9ybSBpbnQgb2Zmc2V0XCIrdC5uYW1lK1wiO1wiKSl9KSk7dmFyIGEsaSxzPW8uam9pbihcIlxcblwiKSx1PXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1cIlwiO3IrPW4/cGEodCk6ZGEodCk7dmFyIG89dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGE9ZS5sb2dpY2FsU2hhcGU7by5sZW5ndGg8PWEubGVuZ3RoJiYocis9bj9mdW5jdGlvbih0LGUpe3ZhciBuLHI9dC5uYW1lLG89ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStyLnNsaWNlKDEpLGE9XCJnZXRcIitvK1wiQXRPdXRDb29yZHNcIixpPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgscz1lLmxvZ2ljYWxTaGFwZS5sZW5ndGgsdT1Dbyh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpLGM9d2EocyksbD1zLWksaD1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdO249MD09PWk/XCJcIjpzPDImJnUubGVuZ3RoPj0xP1wiY29vcmRzID0gMDtcIjp1Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJjb29yZHMuXCIraFt0K2xdK1wiID0gMDtcIn0pKS5qb2luKFwiXFxuXCIpO3ZhciBmPVwiXCI7Zj1zPDImJmk+MD9cImNvb3Jkc1wiOnQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb29yZHMuXCIraFtlK2xdfSkpLmpvaW4oXCIsIFwiKTt2YXIgZD1cInJldHVybiBvdXRwdXRWYWx1ZTtcIixwPTE9PT1rKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSksdj0xPT09ayhlLmxvZ2ljYWxTaGFwZSk7aWYoMSE9PWl8fHB8fHYpe2lmKHAmJiF2KWQ9MT09PXM/XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLngsIDAuLCAwLik7XFxuICAgICAgXCI6XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgIFwiO2Vsc2UgaWYodS5sZW5ndGgpe3ZhciBtPWktMixnPWktMTt1LmluZGV4T2YobSk+LTEmJnUuaW5kZXhPZihnKT4tMT9kPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XCI6dS5pbmRleE9mKG0pPi0xP2Q9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55LCBvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55KTtcIjp1LmluZGV4T2YoZyk+LTEmJihkPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnp6KTtcIil9fWVsc2UgZD1cIlxcbiAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgIFwiO3JldHVyblwiXFxuICAgIHZlYzQgXCIrYStcIigpIHtcXG4gICAgICBcIitjK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiK24rXCJcXG4gICAgICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0XCIrbytcIihcIitmK1wiKTtcXG4gICAgICBcIitkK1wiXFxuICAgIH1cXG4gIFwifSh0LGUpOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5uYW1lLHI9bi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89XCJnZXRcIityK1wiQXRPdXRDb29yZHNcIixhPWUudGV4U2hhcGUsaT10LnNoYXBlSW5mby50ZXhTaGFwZSxzPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgsdT1lLmxvZ2ljYWxTaGFwZS5sZW5ndGg7aWYoIXQuc2hhcGVJbmZvLmlzVW5pZm9ybSYmcz09PXUmJm51bGw9PXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQmJlMoaSxhKSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK28rXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCByZXN1bHRVVik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgYyxsPXdhKHUpLGg9Q28odC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGUubG9naWNhbFNoYXBlKSxmPXUtcyxkPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07Yz0wPT09cz9cIlwiOnU8MiYmaC5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmgubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cImNvb3Jkcy5cIitkW3QrZl0rXCIgPSAwO1wifSkpLmpvaW4oXCJcXG5cIik7dmFyIHA9XCJcIjtwPXU8MiYmcz4wP1wiY29vcmRzXCI6dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvb3Jkcy5cIitkW2UrZl19KSkuam9pbihcIiwgXCIpO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK28rXCIoKSB7XFxuICAgICAgXCIrbCtcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIitjK1wiXFxuICAgICAgcmV0dXJuIGdldFwiK3IrXCIoXCIrcCtcIik7XFxuICAgIH1cXG4gIFwifSh0LGUpKTtyZXR1cm4gcn0odCxlLHIpfSkpLmpvaW4oXCJcXG5cIiksYz1lLnRleFNoYXBlLGw9dWEoKSxoPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgICAgcmV0dXJuIFwiK3QudGV4dHVyZTJEK1wiKHRleHR1cmVTYW1wbGVyLCB1dikucjtcXG4gICAgfVxcbiAgXCJ9KGwpLGY9ZnVuY3Rpb24odCl7cmV0dXJuIHQudmVyc2lvbitcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgIFwiK3QudmFyeWluZ0ZzK1wiIHZlYzIgcmVzdWx0VVY7XFxuICAgIFwiK3QuZGVmaW5lT3V0cHV0K1wiXFxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XFxuXFxuICAgIHN0cnVjdCBpdmVjNVxcbiAgICB7XFxuICAgICAgaW50IHg7XFxuICAgICAgaW50IHk7XFxuICAgICAgaW50IHo7XFxuICAgICAgaW50IHc7XFxuICAgICAgaW50IHU7XFxuICAgIH07XFxuXFxuICAgIHN0cnVjdCBpdmVjNlxcbiAgICB7XFxuICAgICAgaW50IHg7XFxuICAgICAgaW50IHk7XFxuICAgICAgaW50IHo7XFxuICAgICAgaW50IHc7XFxuICAgICAgaW50IHU7XFxuICAgICAgaW50IHY7XFxuICAgIH07XFxuXFxuICAgIHVuaWZvcm0gZmxvYXQgTkFOO1xcbiAgICBcIit0LmRlZmluZVNwZWNpYWxOYU4rXCJcXG4gICAgXCIrdC5kZWZpbmVTcGVjaWFsSW5mK1wiXFxuICAgIFwiK3QuZGVmaW5lUm91bmQrXCJcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBpbnQgaWRpdihpbnQgYSwgaW50IGIsIGZsb2F0IHNpZ24pIHtcXG4gICAgICBpbnQgcmVzID0gYSAvIGI7XFxuICAgICAgaW50IG1vZCA9IGltb2QoYSwgYik7XFxuICAgICAgaWYgKHNpZ24gPCAwLiAmJiBtb2QgIT0gMCkge1xcbiAgICAgICAgcmVzIC09IDE7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXM7XFxuICAgIH1cXG5cXG4gICAgLy9CYXNlZCBvbiB0aGUgd29yayBvZiBEYXZlIEhvc2tpbnNcXG4gICAgLy9odHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNGRqU1JXXFxuICAgICNkZWZpbmUgSEFTSFNDQUxFMSA0NDMuODk3NVxcbiAgICBmbG9hdCByYW5kb20oZmxvYXQgc2VlZCl7XFxuICAgICAgdmVjMiBwID0gcmVzdWx0VVYgKiBzZWVkO1xcbiAgICAgIHZlYzMgcDMgID0gZnJhY3QodmVjMyhwLnh5eCkgKiBIQVNIU0NBTEUxKTtcXG4gICAgICBwMyArPSBkb3QocDMsIHAzLnl6eCArIDE5LjE5KTtcXG4gICAgICByZXR1cm4gZnJhY3QoKHAzLnggKyBwMy55KSAqIHAzLnopO1xcbiAgICB9XFxuXFxuICAgIFwiK3ZhK1wiXFxuICAgIFwiK21hK1wiXFxuICAgIFwiK2dhK1wiXFxuICBcIn0obCk7cmV0dXJuIGUuaXNQYWNrZWQ/KGE9ZnVuY3Rpb24odCxlKXtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuICBcIjtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49W01hdGguY2VpbChlWzBdLzIpLE1hdGguY2VpbChlWzFdLzIpXTtpZigxPT09blswXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi54ICogXCIrblsxXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT1uWzFdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnkgKiBcIituWzBdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIHJldHVybiAyICogKHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueSk7XFxuICAgIH1cXG4gIFwifSgwLGUpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildO2lmKFModCxlKSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciByPU1hdGguY2VpbCh0WzFdLzIpO3JldHVyblwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcblxcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIityK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK3IrXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgMzpyZXR1cm4gbj10LHI9ZSxvPVtNYXRoLmNlaWwoclswXS8yKSxNYXRoLmNlaWwoclsxXS8yKV0sYT1NYXRoLmNlaWwoblsyXS8yKSxpPWEqTWF0aC5jZWlsKG5bMV0vMiksXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitvWzBdK1wiLCBcIitvWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK29bMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIGludCBiID0gaW5kZXggLyBcIitpK1wiO1xcbiAgICAgIGluZGV4IC09IGIgKiBcIitpK1wiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK2ErXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrYStcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgfVxcbiAgXCI7ZGVmYXVsdDpyZXR1cm4gZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W01hdGguY2VpbChlWzBdLzIpLE1hdGguY2VpbChlWzFdLzIpXSxyPU1hdGguY2VpbCh0W3QubGVuZ3RoLTFdLzIpLG89cipNYXRoLmNlaWwodFt0Lmxlbmd0aC0yXS8yKSxhPW8saT1cIlwiLHM9XCJiLCByLCBjXCIsdT0yO3U8dC5sZW5ndGgtMTt1KyspYSo9dFt0Lmxlbmd0aC11LTFdLGk9XCJcXG4gICAgICBpbnQgYlwiK3UrXCIgPSBpbmRleCAvIFwiK2ErXCI7XFxuICAgICAgaW5kZXggLT0gYlwiK3UrXCIgKiBcIithK1wiO1xcbiAgICBcIitpLHM9XCJiXCIrdStcIiwgXCIrcztyZXR1cm5cIlxcbiAgICBpdmVjXCIrdC5sZW5ndGgrXCIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK2krXCJcXG5cXG4gICAgICBpbnQgYiA9IGluZGV4IC8gXCIrbytcIjtcXG4gICAgICBpbmRleCAtPSBiICogXCIrbytcIjtcXG5cXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIityK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK3IrXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlY1wiK3QubGVuZ3RoK1wiKFwiK3MrXCIpO1xcbiAgICB9XFxuICBcIn0odCxlKX12YXIgbixyLG8sYSxpfShlLmxvZ2ljYWxTaGFwZSxjKSxpPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgXCIrdC5vdXRwdXQrXCIgPSB2YWw7XFxuICAgIH1cXG4gIFwifShsKSk6KGE9ZnVuY3Rpb24odCxlKXtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuICBcIjtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoMT09PWVbMF0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi54ICogXCIrZVsxXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT1lWzFdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqIFwiK2VbMF0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgfVxcbiAgXCJ9KDAsZSk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0LGUpe2lmKFModCxlKSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PXRbMV0pcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PXRbMF0pcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIit0WzFdK1wiO1xcbiAgICAgIGludCBjID0gaW5kZXggLSByICogXCIrdFsxXStcIjtcXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgMzpyZXR1cm4gbj1lLHI9Y2EoW1wiclwiLFwiY1wiLFwiZFwiXSx0KSxcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIrcitcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCI7Y2FzZSA0OnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPWNhKFtcInJcIixcImNcIixcImRcIixcImQyXCJdLHQpO3JldHVyblwiXFxuICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIituK1wiXFxuICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSA1OnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPWNhKFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiXSx0KTtyZXR1cm5cIlxcbiAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrZVswXStcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiK2VbMV0rXCIpKTtcXG5cXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIrbitcIlxcblxcbiAgICAgIGl2ZWM1IG91dFNoYXBlID0gaXZlYzUociwgYywgZCwgZDIsIGQzKTtcXG4gICAgICByZXR1cm4gb3V0U2hhcGU7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgNjpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1jYShbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIixcImQ0XCJdLHQpO3JldHVyblwiXFxuICAgIGl2ZWM2IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIituK1wiXFxuXFxuICAgICAgaXZlYzYgcmVzdWx0ID0gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IodC5sZW5ndGgrXCItRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9dmFyIG4scn0oZS5sb2dpY2FsU2hhcGUsYyksaT1mdW5jdGlvbih0KXtyZXR1cm5cIlxcbiAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICBcIit0Lm91dHB1dCtcIiA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgfVxcbiAgXCJ9KGwpKSxyJiYoZis9eWEpLFtmLGgsaSxzLGEsdSxuXS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIGRhKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSk7aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiZmxvYXQgXCIrbitcIigpIHtyZXR1cm4gXCIrZStcIjt9XCI7dmFyIHI9dC5zaGFwZUluZm8udGV4U2hhcGUsbz1yWzBdLGE9clsxXTtpZigxPT09byYmMT09PWEpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBpPXQuc2hhcGVJbmZvLnRleFNoYXBlLHM9aVswXSx1PWlbMV0sYz14YShlKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIituK1wiKCkge1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3MrXCIsIFwiK3UrXCIsIFwiK2MrXCIpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSk7aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIFwiK2JhKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgcj10LnNoYXBlSW5mby50ZXhTaGFwZSxvPXJbMF0sYT1yWzFdO2lmKDE9PT1hJiYxPT09bylyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGk9eGEoZSk7aWYoMT09PWEpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXggKyBcIitpK1wiKSArIDAuNSkgLyBcIitvK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PW8pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4ICsgXCIraStcIikgKyAwLjUpIC8gXCIrYStcIi4wLCAwLjUpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitvK1wiLCBcIithK1wiLCBpbmRleCArIFwiK2krXCIpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz10LnNoYXBlSW5mby50ZXhTaGFwZTtpZihudWxsIT1vJiZTKGUsbykpe3ZhciBhPW9bMF0saT1vWzFdO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIitpK1wiLjAsIFwiK2ErXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn12YXIgcz1NKGUpLHU9cy5uZXdTaGFwZSxjPXMua2VwdERpbXMsbD11O2lmKGwubGVuZ3RoPGUubGVuZ3RoKXt2YXIgaD1DYSh0LGwpO3JldHVyblwiXFxuICAgICAgXCIrZGEoaCkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VhKFtcInJvd1wiLFwiY29sXCJdLGMpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK2VbMV0rXCIsIDEpKSk7XFxuICAgICAgICBcIitiYSh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGY9b1swXSxkPW9bMV0scD14YShuKTtpZigxPT09ZClyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBcIitwK1wiKSwgdmVjMyhcIitlWzFdK1wiLCAxLCAxKSk7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gXCIrZitcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwiO2lmKDE9PT1mKXJldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIFwiK3ArXCIpLCB2ZWMzKFwiK2VbMV0rXCIsIDEsIDEpKTtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gXCIrZCtcIi4wLCAwLjUpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7cmV0dXJuXCJcXG4gIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgIGludCBpbmRleCA9IHJvdyAqIFwiK2VbMV0rXCIgKyBjb2wgKyBcIitwK1wiO1xcbiAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitmK1wiLCBcIitkK1wiLCBpbmRleCk7XFxuICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gIH1cXG5cIn0odCk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPWVbMV0qZVsyXSxhPWVbMl0saT1NKGUpLHM9aS5uZXdTaGFwZSx1PWkua2VwdERpbXMsYz1zO2lmKGMubGVuZ3RoPGUubGVuZ3RoKXt2YXIgbD1DYSh0LGMpO3JldHVyblwiXFxuICAgICAgICBcIitkYShsKStcIlxcbiAgICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRWEoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCJdLHUpK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoXCIrbytcIiwgXCIrYStcIiwgMSkpKTtcXG4gICAgICAgIFwiK2JhKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgaD10LnNoYXBlSW5mby50ZXhTaGFwZSxmPWhbMF0sZD1oWzFdLHA9dC5zaGFwZUluZm8uZmxhdE9mZnNldDtpZihkPT09byYmbnVsbD09cClyZXR1cm5cIlxcbiAgICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XFxuICAgICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjMihjb2wsIGRlcHRoKSwgdmVjMihcIithK1wiLCAxKSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZCtcIi4wLCBcIitmK1wiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgICB9XFxuICAgICAgXCI7aWYoZD09PWEmJm51bGw9PXApcmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK2VbMV0rXCIsIDEpKTtcXG4gICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgpO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK2QrXCIuMCwgXCIrZitcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwiO3ZhciB2PXhhKG4pO3JldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK28rXCIgKyBjb2wgKiBcIithK1wiICsgZGVwdGggKyBcIit2K1wiO1xcbiAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrZitcIiwgXCIrZCtcIiwgaW5kZXgpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gIFwifSh0KTtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVszXSxhPWVbMl0qbyxpPWVbMV0qYSxzPU0oZSksdT1zLm5ld1NoYXBlLGM9cy5rZXB0RGltcztpZih1Lmxlbmd0aDxlLmxlbmd0aCl7dmFyIGw9Q2EodCx1KTtyZXR1cm5cIlxcbiAgICAgIFwiK2RhKGwpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VhKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCJdLGMpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0KFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIsIDEpKSk7XFxuICAgICAgICBcIitiYSh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGg9dC5zaGFwZUluZm8uZmxhdE9mZnNldCxmPXQuc2hhcGVJbmZvLnRleFNoYXBlLGQ9ZlswXSxwPWZbMV07aWYocD09PWkmJm51bGw9PWgpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XFxuICAgICAgICBmbG9hdCB0ZXhDID1cXG4gICAgICAgICAgICBkb3QodmVjMyhjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICAgICAgICB2ZWMzKFwiK2ErXCIsIFwiK28rXCIsIDEpKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3ArXCIuMCwgXCIrZCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKHA9PT1vJiZudWxsPT1oKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKFwiK2VbMV0qZVsyXStcIiwgXCIrZVsyXStcIiwgMSkpO1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoMik7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiK3ArXCIuMCwgXCIrZCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciB2PXhhKG4pO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK2krXCIgKyBjb2wgKiBcIithK1wiICtcXG4gICAgICAgICAgZGVwdGggKiBcIitvK1wiICsgZGVwdGgyO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK2QrXCIsIFwiK3ArXCIsIGluZGV4ICsgXCIrditcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSA1OnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPWVbNF0sYT1lWzNdKm8saT1lWzJdKmEscz1lWzFdKmksdT1NKGUpLGM9dS5uZXdTaGFwZSxsPXUua2VwdERpbXM7aWYoYy5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBoPUNhKHQsYyk7cmV0dXJuXCJcXG4gICAgICBcIitkYShoKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFYShbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCJdLGwpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBmbG9hdCBpbmRleCA9IGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrcytcIiwgXCIraStcIiwgXCIrYStcIiwgXCIrbytcIikpICtcXG4gICAgICAgICAgZGVwdGgzO1xcbiAgICAgICAgXCIrYmEodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBmPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQsZD10LnNoYXBlSW5mby50ZXhTaGFwZSxwPWRbMF0sdj1kWzFdO2lmKHY9PT1zJiZudWxsPT1mKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWM0KGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmVjNChcIitpK1wiLCBcIithK1wiLCBcIitvK1wiLCAxKSk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIit2K1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZih2PT09byYmbnVsbD09ZilyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitlWzFdKmVbMl0qZVszXStcIixcXG4gICAgICAgICAgICAgICBcIitlWzJdKmVbM10rXCIsIFwiK2VbM10rXCIsIDEpKTtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGgzO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIit2K1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgbT14YShuKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitzK1wiICsgY29sICogXCIraStcIiArIGRlcHRoICogXCIrYStcIiArXFxuICAgICAgICAgIGRlcHRoMiAqIFwiK28rXCIgKyBkZXB0aDMgKyBcIittK1wiO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3ArXCIsIFwiK3YrXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDY6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89TShlKSxhPW8ubmV3U2hhcGUsaT1vLmtlcHREaW1zO2lmKGEubGVuZ3RoPGUubGVuZ3RoKXt2YXIgcz1DYSh0LGEpO3JldHVyblwiXFxuICAgICAgXCIrZGEocykrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VhKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSxpKStcIik7XFxuICAgICAgfVxcbiAgICBcIn12YXIgdT1lWzVdLGM9ZVs0XSp1LGw9ZVszXSpjLGg9ZVsyXSpsLGY9ZVsxXSpoO2lmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrZitcIiwgXCIraCtcIiwgXCIrbCtcIiwgXCIrYytcIikpICtcXG4gICAgICAgICAgZG90KFxcbiAgICAgICAgICAgIHZlYzIoZGVwdGgzLCBkZXB0aDQpLFxcbiAgICAgICAgICAgIHZlYzIoXCIrdStcIiwgMSkpKTtcXG4gICAgICAgIFwiK2JhKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgZD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0LHA9dC5zaGFwZUluZm8udGV4U2hhcGUsdj1wWzBdLG09cFsxXTtpZihtPT09ZiYmbnVsbD09ZClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzQoY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpLFxcbiAgICAgICAgICB2ZWM0KFwiK2grXCIsIFwiK2wrXCIsIFwiK2MrXCIsIFwiK3UrXCIpKSArXFxuICAgICAgICAgICAgICAgZmxvYXQoZGVwdGg0KTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK20rXCIuMCwgXCIrditcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKG09PT11JiZudWxsPT1kKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK2VbMV0qZVsyXSplWzNdKmVbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVsyXSplWzNdKmVbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbNF0rXCIpKSArIGZsb2F0KGRlcHRoMyk7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoNDtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIrbStcIi4wLCBcIit2K1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGc9eGEobik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitmK1wiICsgY29sICogXCIraCtcIiArIGRlcHRoICogXCIrbCtcIiArXFxuICAgICAgICAgIGRlcHRoMiAqIFwiK2MrXCIgKyBkZXB0aDMgKiBcIit1K1wiICsgZGVwdGg0ICsgXCIrZytcIjtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIit2K1wiLCBcIittK1wiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoZS5sZW5ndGgrXCItRCBpbnB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX19ZnVuY3Rpb24gcGEodCl7dmFyIGUsbixyO3N3aXRjaCh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSkscj11YSgpLFwiXFxuICAgIHZlYzQgXCIrbitcIigpIHtcXG4gICAgICByZXR1cm4gXCIrci50ZXh0dXJlMkQrXCIoXCIrZStcIiwgaGFsZkNSKTtcXG4gICAgfVxcbiAgXCI7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxyPXQuc2hhcGVJbmZvLnRleFNoYXBlLG89W01hdGguY2VpbChyWzBdLzIpLE1hdGguY2VpbChyWzFdLzIpXSxhPXVhKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAgIFwiK29bMF0rXCIsIFwiK29bMV0rXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gXCIrYS50ZXh0dXJlMkQrXCIoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlLGE9b1swXSxpPW9bMV0scz11YSgpO2lmKG51bGwhPW8mJlMoZSxvKSlyZXR1cm5cIlxcbiAgICAgIHZlYzQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIraStcIi4wLCBcIithK1wiLjApO1xcblxcbiAgICAgICAgcmV0dXJuIFwiK3MudGV4dHVyZTJEK1wiKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciB1PVtNYXRoLmNlaWwob1swXS8yKSxNYXRoLmNlaWwob1sxXS8yKV0sYz1NYXRoLmNlaWwoZVsxXS8yKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRChcIitjK1wiLCBcIit1WzBdK1wiLCBcIit1WzFdK1wiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuIFwiK3MudGV4dHVyZTJEK1wiKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz10LnNoYXBlSW5mby50ZXhTaGFwZSxhPVtNYXRoLmNlaWwob1swXS8yKSxNYXRoLmNlaWwob1sxXS8yKV07aWYoMT09PWVbMF0pe3ZhciBpPWUuc2xpY2UoMSkscz1DYSh0LGkpO3JldHVyblwiXFxuICAgICAgICBcIitwYShzKStcIlxcbiAgICAgICAgdmVjNCBcIityK1wiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgIHJldHVybiBcIityK1wiKFwiK0VhKFtcImJcIixcInJvd1wiLFwiY29sXCJdLFsxLDJdKStcIik7XFxuICAgICAgICB9XFxuICAgICAgXCJ9dmFyIHU9YVswXSxjPWFbMV0sbD1NYXRoLmNlaWwoZVsyXS8yKSxoPWwqTWF0aC5jZWlsKGVbMV0vMiksZj11YSgpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrcitcIihpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20zRChcXG4gICAgICAgIFwiK3UrXCIsIFwiK2MrXCIsIFwiK2grXCIsIFwiK2wrXCIsIGIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gXCIrZi50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7ZGVmYXVsdDpyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPWUubGVuZ3RoLHI9dC5uYW1lLG89XCJnZXRcIityLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksYT10LnNoYXBlSW5mby50ZXhTaGFwZSxpPVtNYXRoLmNlaWwoYVswXS8yKSxNYXRoLmNlaWwoYVsxXS8yKV0scz1pWzBdLHU9aVsxXSxjPU1hdGguY2VpbChlW24tMV0vMiksbD1jKk1hdGguY2VpbChlW24tMl0vMiksaD1cImludCBiLCBpbnQgcm93LCBpbnQgY29sXCIsZj1cImIgKiBcIitsK1wiICsgKHJvdyAvIDIpICogXCIrYytcIiArIChjb2wgLyAyKVwiLGQ9MjtkPG4tMTtkKyspaD1cImludCBiXCIrZCtcIiwgXCIraCxsKj1lW24tZC0xXSxmPVwiYlwiK2QrXCIgKiBcIitsK1wiICsgXCIrZjt2YXIgcD11YSgpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrbytcIihcIitoK1wiKSB7XFxuICAgICAgaW50IGluZGV4ID0gXCIrZitcIjtcXG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gXCIrdStcIjtcXG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIFwiK3UrXCI7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIrdStcIiwgXCIrcytcIik7XFxuICAgICAgcmV0dXJuIFwiK3AudGV4dHVyZTJEK1wiKFwiK3IrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpfX12YXIgdmE9XCJcXG52ZWMyIHV2RnJvbUZsYXQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcbnZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLG1hPVwiXFxudmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgdGV4TnVtUixcXG4gIGludCB0ZXhOdW1DLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgdGV4ZWxJbmRleCA9IChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixnYT1cIlxcbnZlYzIgcGFja2VkVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLFxcbiAgICBpbnQgdGV4ZWxzSW5CYXRjaCwgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IGIsXFxuICAgIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIseWE9XCJcXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xcbiAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XFxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XFxuICB9XFxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xcbiAgICBmbG9hdCBtb2RDb29yZCA9IG1vZChmbG9hdChkaW0pLCAyLik7XFxuICAgIHJldHVybiBtb2RDb29yZCA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZztcXG4gIH1cXG5cIjtmdW5jdGlvbiB4YSh0KXtyZXR1cm5cIm9mZnNldFwiK3R9ZnVuY3Rpb24gYmEodCl7dmFyIGU9dC5uYW1lLG49ayh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO3JldHVybiBuPDI/XCJyZXR1cm4gXCIrZStcIjtcIjpcIlxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK24rXCI7IGkrKykge1xcbiAgICAgIGlmIChpID09IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gXCIrZStcIltpXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIHdhKHQpe2lmKHQ8PTEpcmV0dXJuXCJpbnRcIjtpZigyPT09dClyZXR1cm5cIml2ZWMyXCI7aWYoMz09PXQpcmV0dXJuXCJpdmVjM1wiO2lmKDQ9PT10KXJldHVyblwiaXZlYzRcIjtpZig1PT09dClyZXR1cm5cIml2ZWM1XCI7aWYoNj09PXQpcmV0dXJuXCJpdmVjNlwiO3Rocm93IEVycm9yKFwiR1BVIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9ZnVuY3Rpb24gQ2EodCxlKXt2YXIgbj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQpKTtyZXR1cm4gbi5zaGFwZUluZm8ubG9naWNhbFNoYXBlPWUsbn1mdW5jdGlvbiBFYSh0LGUpe3JldHVybiBlLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KSkuam9pbihcIiwgXCIpfXZhciBSYT1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCxDKHQubGVuZ3RoPjIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQYWNrZWQgYXJnXCIrKG4uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSkrXCIgc3VwcG9ydHMgb25seSBpbnB1dHMgd2l0aCByYW5rIGFib3ZlIDIuXCJ9KSk7dmFyIG89dFt0Lmxlbmd0aC0xXSxhPU1hdGguY2VpbChvL2UpO3RoaXMub3V0cHV0U2hhcGU9dC5zbGljZSgwLC0xKSxhPjEmJnRoaXMub3V0cHV0U2hhcGUucHVzaChhKSxyfHx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJlc3RJbmRpY2VzQVwiKTt2YXIgaSxzLHU9dGhpcy5vdXRwdXRTaGFwZSxjPXUubGVuZ3RoLGw9d2EoYyksaD1zYShcImNvb3Jkc1wiLGMpO2lmKDE9PT1hKXt2YXIgZj13YShzPWMrMSk7aT1cIlxcbiAgICAgICAgXCIrZitcIiBzb3VyY2VMb2NSID0gXCIrZitcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICArK1wiK2hbYy0xXStcIjtcXG4gICAgICAgIFwiK2YrXCIgc291cmNlTG9jRyA9IFwiK2YrXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgKytcIitoW2MtMl0rXCI7XFxuICAgICAgICBcIitmK1wiIHNvdXJjZUxvY0EgPSBcIitmK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgIC0tXCIraFtjLTFdK1wiO1xcbiAgICAgICAgXCIrZitcIiBzb3VyY2VMb2NCID0gXCIrZitcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICAtLVwiK2hbYy0yXStcIjtcIn1lbHNlIHM9YyxpPVwiXFxuICAgICAgICBcIitsK1wiIHNvdXJjZUxvY1IgPSBjb29yZHM7XFxuICAgICAgICArK1wiK2hbYy0xXStcIjtcXG4gICAgICAgIFwiK2wrXCIgc291cmNlTG9jRyA9IGNvb3JkcztcXG4gICAgICAgICsrXCIraFtjLTJdK1wiO1xcbiAgICAgICAgXCIrbCtcIiBzb3VyY2VMb2NBID0gY29vcmRzO1xcbiAgICAgICAgLS1cIitoW2MtMV0rXCI7XFxuICAgICAgICBcIitsK1wiIHNvdXJjZUxvY0IgPSBjb29yZHM7XFxuICAgICAgICAtLVwiK2hbYy0yXStcIjtcIjt2YXIgZD1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAscykscD1cIi5cIitkW3MtMV0sdj1kLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJpbnQgXCIrdH0pKSxtPXNhKFwic291cmNlTG9jUlwiLHMtMSkuY29uY2F0KFwiaW5JZHguclwiKSxnPXNhKFwic291cmNlTG9jR1wiLHMtMSkuY29uY2F0KFwiaW5JZHguZ1wiKSx5PXNhKFwic291cmNlTG9jQlwiLHMtMSkuY29uY2F0KFwiaW5JZHguYlwiKSx4PXNhKFwic291cmNlTG9jQVwiLHMtMSkuY29uY2F0KFwiaW5JZHguYVwiKSxiPVwibWF4XCI9PT1uP1wiZ3JlYXRlclRoYW5cIjpcImxlc3NUaGFuXCIsdz1yP1wiXCI6XCJcXG4gICAgICAgICAgaW5JZHggPSByb3VuZCh2ZWM0KGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIrbS5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIitnLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK3kuam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIreC5qb2luKCkrXCIpKSk7XCIsRT1cInZlYzQoXFxuICAgICAgICAgICAgZ2V0QUNoYW5uZWwoXCIrbS5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBQ2hhbm5lbChcIitnLmpvaW4oKStcIikgOiAwLixcXG4gICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QUNoYW5uZWwoXCIreS5qb2luKCkrXCIpIDogMC4sXFxuICAgICAgICAgICAgaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sID8gZ2V0QUNoYW5uZWwoXCIreC5qb2luKCkrXCIpIDogMC4pXCIsUj1yP1wiXCI6XCJcXG4gICAgICBmbG9hdCBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK3Yuam9pbigpK1wiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRCZXN0SW5kaWNlc0EoXCIrZC5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZC5zbGljZSgtMikuam9pbigpK1wiKSk7XFxuICAgICAgfVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBnZXRBQ2hhbm5lbChcIit2LmpvaW4oKStcIikge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QShcIitkLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZC5zbGljZSgtMikuam9pbigpK1wiKSk7XFxuICAgICAgfVxcbiAgICAgIFwiK1IrXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitsK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gXCIraFtjLTFdK1wiIDwgXCIrKHVbYy0xXS0xKStcIjtcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IFwiK2hbYy0yXStcIiA8IFwiKyh1W2MtMl0tMSkrXCI7XFxuICAgICAgICBcIitpK1wiXFxuICAgICAgICBpdmVjNCBzcmNJZHggPSBpdmVjNChzb3VyY2VMb2NSXCIrcCtcIiwgc291cmNlTG9jR1wiK3ArXCIsXFxuICAgICAgICAgIHNvdXJjZUxvY0JcIitwK1wiLCBzb3VyY2VMb2NBXCIrcCtcIikgKiBcIitlK1wiO1xcbiAgICAgICAgaXZlYzQgaW5JZHggPSBzcmNJZHg7XFxuICAgICAgICB2ZWM0IGJlc3RJbmRleCA9IHZlYzQoaW5JZHgpO1xcbiAgICAgICAgdmVjNCBiZXN0VmFsdWUgPSBcIitFK1wiO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitlK1wiOyBpKyspIHtcXG4gICAgICAgICAgaW5JZHggPSBzcmNJZHg7XFxuICAgICAgICAgIFwiK3crXCJcXG4gICAgICAgICAgdmVjNCBjYW5kaWRhdGUgPSBcIitFK1wiO1xcbiAgICAgICAgICBidmVjNCBuYW4gPSBpc25hbihjYW5kaWRhdGUpO1xcbiAgICAgICAgICBidmVjNCByZXBsYWNlID0gYnZlYzQoXFxuICAgICAgICAgICAgdmVjNChcIitiK1wiKGNhbmRpZGF0ZSwgYmVzdFZhbHVlKSkgKiAodmVjNCgxLjApIC0gdmVjNChuYW4pKSk7XFxuXFxuICAgICAgICAgIGJlc3RWYWx1ZSA9IHZlYzQocmVwbGFjZS54ICA/IGNhbmRpZGF0ZS54IDogYmVzdFZhbHVlLngsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS55ICA/IGNhbmRpZGF0ZS55IDogYmVzdFZhbHVlLnksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS56ICA/IGNhbmRpZGF0ZS56IDogYmVzdFZhbHVlLnosXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS53ICA/IGNhbmRpZGF0ZS53IDogYmVzdFZhbHVlLncpO1xcbiAgICAgICAgICBiZXN0SW5kZXggPSBtaXgoYmVzdEluZGV4LCB2ZWM0KGluSWR4KSwgdmVjNChyZXBsYWNlKSk7XFxuICAgICAgICAgIHNyY0lkeCsrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGJlc3RJbmRleCk7XFxuICAgICAgfVxcbiAgICBcIn0sSWE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVySGVpZ2h0LG49dC5maWx0ZXJXaWR0aCxyPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPXQuZGlsYXRpb25IZWlnaHQsaT10LmRpbGF0aW9uV2lkdGgscz10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsYz1zLTEtdC5wYWRJbmZvLnRvcCxsPXUtMS10LnBhZEluZm8ubGVmdCxoPTEvKGUqbik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitjK1wiLCBcIitsK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoXCIraCtcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrcytcIjtcXG4gICAgICAgICAgICB3UiArPSBcIithK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgd0MrPSBcIitpK1wiKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgaWR5UiwgaWR5QywgZCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGthPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckRlcHRoLG49dC5maWx0ZXJIZWlnaHQscj10LmZpbHRlcldpZHRoLG89dC5zdHJpZGVEZXB0aCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPXQuZGlsYXRpb25EZXB0aCx1PXQuZGlsYXRpb25IZWlnaHQsYz10LmRpbGF0aW9uV2lkdGgsbD10LmVmZmVjdGl2ZUZpbHRlckRlcHRoLGg9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsZj10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGQ9bC0xLXQucGFkSW5mby5mcm9udCxwPWgtMS10LnBhZEluZm8udG9wLHY9Zi0xLXQucGFkSW5mby5sZWZ0LG09MS8oZSpuKnIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrZCtcIiwgXCIrcCtcIiwgXCIrditcIik7XFxuICAgICAgY29uc3QgZmxvYXQgYXZnTXVsdGlwbGllciA9IGZsb2F0KFwiK20rXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIGR5Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5RENvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci56O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCA6LCBjaCkgdG8gZ2V0XFxuICAgICAgICAvLyBkeCh4RCwgeFIsIHhDLCBjaCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgXCIrbCtcIjtcXG4gICAgICAgICAgICB3RCArPSBcIitzK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5RCA9IGZsb2F0KGR5RENvcm5lciArIHdEKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5RCA8IDAuMCB8fCBkeUQgPj0gXCIrdC5vdXREZXB0aCtcIi4wIHx8IGZyYWN0KGR5RCkgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5RCA9IGludChkeUQpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIraCtcIjtcXG4gICAgICAgICAgICAgIHdSICs9IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIithK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrZitcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIrYytcIikge1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIraStcIi4wO1xcblxcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIGF2Z011bHRpcGxpZXI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sU2E9ZnVuY3Rpb24odCxlLG4scixvLGEpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLFJvKHQsZSksUm8odCxuKTt2YXIgaT1cIjAuMFwiO251bGwhPXImJihSbyh0LHIpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGk9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO3ZhciBzPVwiMS4wXCI7bnVsbCE9byYmKFJvKHQsbyksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJzY2FsZVwiKSxzPVwiZ2V0U2NhbGVBdE91dENvb3JkcygpXCIpLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBvZmZzZXQgPSBcIitpK1wiO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBcIitzK1wiO1xcbiAgICAgICAgZmxvYXQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIGZsb2F0KFwiK2ErXCIpKTtcXG4gICAgICAgIHNldE91dHB1dChkb3QodmVjMyh4LCAtbWVhbiwgb2Zmc2V0KSwgdmVjMyhpbnYsIGludiwgMSkpKTtcXG4gICAgICB9XFxuICAgIFwifSxBYT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLFJvKHQsZSksUm8odCxuKTt2YXIgaT1cInZlYzQoMC4wKVwiO251bGwhPXImJihSbyh0LHIpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGk9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO3ZhciBzPVwidmVjNCgxLjApXCI7bnVsbCE9byYmKFJvKHQsbyksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJzY2FsZVwiKSxzPVwiZ2V0U2NhbGVBdE91dENvb3JkcygpXCIpLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCBvZmZzZXQgPSBcIitpK1wiO1xcbiAgICAgICAgdmVjNCBzY2FsZSA9IFwiK3MrXCI7XFxuXFxuICAgICAgICB2ZWM0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIHZlYzQoXCIrYStcIikpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KCh4IC0gbWVhbikgKiBpbnYgKyBvZmZzZXQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LERhPVwicmV0dXJuIGFyZWFsICogYnJlYWwgLSBhaW1hZyAqIGJpbWFnO1wiLFRhPVwicmV0dXJuIGFyZWFsICogYmltYWcgKyBhaW1hZyAqIGJyZWFsO1wiLE5hPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVJlYWxcIixcIkFJbWFnXCIsXCJCUmVhbFwiLFwiQkltYWdcIl0sdGhpcy5vdXRwdXRTaGFwZT1SbyhlLG4pLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBiaW5hcnlPcENvbXBsZXgoXFxuICAgICAgICAgIGZsb2F0IGFyZWFsLCBmbG9hdCBhaW1hZywgZmxvYXQgYnJlYWwsIGZsb2F0IGJpbWFnKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGFyZWFsID0gZ2V0QVJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYWltYWcgPSBnZXRBSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBicmVhbCA9IGdldEJSZWFsQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJpbWFnID0gZ2V0QkltYWdBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wQ29tcGxleChhcmVhbCwgYWltYWcsIGJyZWFsLCBiaW1hZykpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEZhPVwicmV0dXJuIGEgKyBiO1wiLF9hPVwicmV0dXJuIGEgLSBiO1wiLE9hPVwicmV0dXJuIGEgKiBiO1wiLE1hPVwicmV0dXJuIChhIDwgMC4pID8gYiAqIGEgOiBhO1wiLEJhPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiQlwiXSx0aGlzLm91dHB1dFNoYXBlPVJvKGUsbiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFBhPVwiXFxuICB2ZWM0IGFMZXNzVGhhblplcm8gPSB2ZWM0KGxlc3NUaGFuKGEsIHZlYzQoMC4pKSk7XFxuICByZXR1cm4gKGFMZXNzVGhhblplcm8gKiAoYiAqIGEpKSArICgodmVjNCgxLjApIC0gYUxlc3NUaGFuWmVybykgKiBhKTtcXG5cIixMYT1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZz0hMCx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPVJvKGUsbik7dmFyIG89dGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgsYT1cIlwiO2lmKHIpaWYoMD09PW98fDE9PT1rKHRoaXMub3V0cHV0U2hhcGUpKWE9XCJcXG4gICAgICAgICAgcmVzdWx0LnkgPSAwLjtcXG4gICAgICAgICAgcmVzdWx0LnogPSAwLjtcXG4gICAgICAgICAgcmVzdWx0LncgPSAwLjtcXG4gICAgICAgIFwiO2Vsc2UgaWYoYT1cIlxcbiAgICAgICAgICBcIit3YShvKStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiLDE9PT1vKWErPVwiXFxuICAgICAgICAgICAgcmVzdWx0LnkgPSAoY29vcmRzICsgMSkgPj0gXCIrdGhpcy5vdXRwdXRTaGFwZVswXStcIiA/IDAuIDogcmVzdWx0Lnk7XFxuICAgICAgICAgICAgcmVzdWx0LnogPSAwLjtcXG4gICAgICAgICAgICByZXN1bHQudyA9IDAuO1xcbiAgICAgICAgICBcIjtlbHNle3ZhciBpPXNhKFwiY29vcmRzXCIsbyk7YSs9XCJcXG4gICAgICAgICAgICBib29sIG5leHRSb3dPdXRPZkJvdW5kcyA9XFxuICAgICAgICAgICAgICAoXCIraVtvLTJdK1wiICsgMSkgPj0gXCIrdGhpcy5vdXRwdXRTaGFwZVtvLTJdK1wiO1xcbiAgICAgICAgICAgIGJvb2wgbmV4dENvbE91dE9mQm91bmRzID1cXG4gICAgICAgICAgICAgIChcIitpW28tMV0rXCIgKyAxKSA+PSBcIit0aGlzLm91dHB1dFNoYXBlW28tMV0rXCI7XFxuICAgICAgICAgICAgcmVzdWx0LnkgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC55O1xcbiAgICAgICAgICAgIHJlc3VsdC56ID0gbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQuejtcXG4gICAgICAgICAgICByZXN1bHQudyA9IG5leHRDb2xPdXRPZkJvdW5kcyB8fCBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC53O1xcbiAgICAgICAgICBcIn10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdmVjNCBiaW5hcnlPcGVyYXRpb24odmVjNCBhLCB2ZWM0IGIpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gYmluYXJ5T3BlcmF0aW9uKGEsIGIpO1xcbiAgICAgICAgXCIrYStcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sV2E9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBtaW5WYWw7XFxuICAgICAgdW5pZm9ybSBmbG9hdCBtYXhWYWw7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChpc25hbih2YWx1ZSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCBtaW5WYWwsIG1heFZhbCkpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHIsbyl7bnVsbD09bi5taW5Mb2MmJihuLm1pbkxvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1pblZhbFwiKSxuLm1heExvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1heFZhbFwiKSksci5nbC51bmlmb3JtMWYobi5taW5Mb2MsdCksci5nbC51bmlmb3JtMWYobi5tYXhMb2MsZSl9fSx0fSgpLFVhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWluVmFsO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWF4VmFsO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIGlmIChhbnkoaXNuYW4odmFsdWUpKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIHZlYzQobWluVmFsKSwgdmVjNChtYXhWYWwpKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gZnVuY3Rpb24ocixvKXtudWxsPT1uLm1pbkxvYyYmKG4ubWluTG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWluVmFsXCIpLG4ubWF4TG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWF4VmFsXCIpKSxyLmdsLnVuaWZvcm0xZihuLm1pbkxvYyx0KSxyLmdsLnVuaWZvcm0xZihuLm1heExvYyxlKX19LHR9KCksVmE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInJlYWxcIixcImltYWdcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCByZSA9IGFicyhnZXRSZWFsQXRPdXRDb29yZHMoKSk7XFxuICAgICAgICBmbG9hdCBpbSA9IGFicyhnZXRJbWFnQXRPdXRDb29yZHMoKSk7XFxuICAgICAgICBmbG9hdCBteCA9IG1heChyZSwgaW0pO1xcblxcbiAgICAgICAgLy8gc2FkbHkgdGhlIGxlbmd0aCBmdW5jdGlvbiBpbiBnbHNsIGlzIG5vdCB1bmRlcmZsb3ctc2FmZVxcbiAgICAgICAgLy8gKGF0IGxlYXN0IG5vdCBvbiBJbnRlbCBHUFVzKS4gU28gdGhlIHNhZmUgc29sdXRpb24gaXNcXG4gICAgICAgIC8vIHRvIGVuc3VyZSB1bmRlcmZsb3ctc2FmZXR5IGluIGFsbCBjYXNlcy5cXG4gICAgICAgIHNldE91dHB1dChcXG4gICAgICAgICAgbXggPT0gMC4wID8gMC4wIDogbXggKiBsZW5ndGgodmVjMigxLCBtaW4ocmUsIGltKS9teCkpXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgXCJ9LHphPWZ1bmN0aW9uKHQpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1Tbih0LDEpLHRoaXMudmFyaWFibGVOYW1lcz10Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSkpO3ZhciBlPW5ldyBBcnJheSh0Lmxlbmd0aC0xKTtlWzBdPXRbMF1bMV07Zm9yKHZhciBuPTE7bjxlLmxlbmd0aDtuKyspZVtuXT1lW24tMV0rdFtuXVsxXTt2YXIgcj1bXCJpZiAoeUMgPCBcIitlWzBdK1wiKSBzZXRPdXRwdXQoZ2V0VDAoeVIsIHlDKSk7XCJdO2ZvcihuPTE7bjxlLmxlbmd0aDtuKyspe3ZhciBvPWVbbi0xXTtyLnB1c2goXCJlbHNlIGlmICh5QyA8IFwiK2Vbbl0rXCIpIHNldE91dHB1dChnZXRUXCIrbitcIih5UiwgeUMtXCIrbytcIikpO1wiKX12YXIgYT1lLmxlbmd0aCxpPWVbZS5sZW5ndGgtMV07ci5wdXNoKFwiZWxzZSBzZXRPdXRwdXQoZ2V0VFwiK2ErXCIoeVIsIHlDLVwiK2krXCIpKTtcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHlSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgeUMgPSBjb29yZHMueTtcXG5cXG4gICAgICAgIFwiK3Iuam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuICAgICAgfVxcbiAgICBcIn0sR2E9ZnVuY3Rpb24odCxlKXt0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9U24odCxlKTt2YXIgbj10aGlzLm91dHB1dFNoYXBlLHI9bi5sZW5ndGgsbz13YShyKSxhPXNhKFwiY29vcmRzXCIsciksaT1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAscik7dGhpcy52YXJpYWJsZU5hbWVzPXQubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KSk7dmFyIHM9bmV3IEFycmF5KHQubGVuZ3RoLTEpO3NbMF09dFswXVtlXTtmb3IodmFyIHU9MTt1PHMubGVuZ3RoO3UrKylzW3VdPXNbdS0xXSt0W3VdW2VdO3ZhciBjPWlbZV0sbD1pLnNsaWNlKC0yKSxoPWkuam9pbigpLGY9XCJpZiAoXCIrYytcIiA8IFwiK3NbMF0rXCIpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFQwKFwiK2grXCIpLCB2ZWMyKFwiK2wuam9pbigpK1wiKSk7XFxuICAgICAgICB9XCI7Zm9yKHU9MTt1PHMubGVuZ3RoO3UrKyl7dmFyIGQ9c1t1LTFdO2YrPVwiXFxuICAgICAgICBpZiAoXCIrYytcIiA8IFwiK3NbdV0rXCIgICYmIFwiK2MrXCIgPj0gXCIrc1t1LTFdK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFRcIit1K1wiKFwiK0hhKGksYyxkKStcIiksXFxuICAgICAgICAgICAgdmVjMihcIitIYShsLGMsZCkrXCIpKTtcXG4gICAgICAgIH1cIn12YXIgcD1zLmxlbmd0aCx2PXNbcy5sZW5ndGgtMV07Zis9XCJcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICBnZXRUXCIrcCtcIihcIitIYShpLGMsdikrXCIpLFxcbiAgICAgICAgICB2ZWMyKFwiK0hhKGwsYyx2KStcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBnZXRWYWx1ZShcIitpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJpbnQgXCIrdH0pKStcIikge1xcbiAgICAgICAgXCIrZitcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KGdldFZhbHVlKFwiK2ErXCIpLCAwLiwgMC4sIDAuKTtcXG5cXG4gICAgICAgIFwiK2Fbci0xXStcIiA9IFwiK2Fbci0xXStcIiArIDE7XFxuICAgICAgICBpZiAoXCIrYVtyLTFdK1wiIDwgXCIrbltyLTFdK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoXCIrYStcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIithW3ItMl0rXCIgPSBcIithW3ItMl0rXCIgKyAxO1xcbiAgICAgICAgaWYgKFwiK2Fbci0yXStcIiA8IFwiK25bci0yXStcIikge1xcbiAgICAgICAgICByZXN1bHQuYSA9IGdldFZhbHVlKFwiK2ErXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrYVtyLTFdK1wiID0gXCIrYVtyLTFdK1wiIC0gMTtcXG4gICAgICAgIGlmIChcIithW3ItMl0rXCIgPCBcIituW3ItMl0rXCIgJiZcXG4gICAgICAgICAgICBcIithW3ItMV0rXCIgPCBcIituW3ItMV0rXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmIgPSBnZXRWYWx1ZShcIithK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9O2Z1bmN0aW9uIEhhKHQsZSxuKXt2YXIgcj10LmluZGV4T2YoZSk7cmV0dXJuIHQubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBlPT09cj90K1wiIC0gXCIrbjp0fSkpLmpvaW4oKX12YXIgcWE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5maWx0ZXJTaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LnBhZEluZm8udG9wLG89dC5wYWRJbmZvLmxlZnQsYT1cImNoYW5uZWxzTGFzdFwiPT09dC5kYXRhRm9ybWF0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCBkeSg6LCA6LCBkMikgdG8gZ2V0IGR3KHdSLCB3QywgZDEsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIrdC5iYXRjaFNpemUrXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIrZStcIiAtIFwiK3IrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiK3Qub3V0V2lkdGgrXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIituK1wiIC0gXCIrbytcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBkMiwgeVIsIHlDKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCBkMSwgeFIsIHhDKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sS2E9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVySGVpZ2h0LG49dC5maWx0ZXJXaWR0aCxyPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPVwiY2hhbm5lbHNMYXN0XCI9PT10LmRhdGFGb3JtYXQsaT1lLTEtdC5wYWRJbmZvLnRvcCxzPW4tMS10LnBhZEluZm8ubGVmdCx1PWE/MToyLGM9YT8yOjMsbD1hPzM6MTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzW1wiK2wrXCJdO1xcblxcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBpdmVjMihjb29yZHNbXCIrdStcIl0sIGNvb3Jkc1tcIitjK1wiXSkgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2UrXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrZStcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK24rXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIituK1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIit0Lm91dENoYW5uZWxzK1wiOyBkMisrKSB7XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBkMiwgaWR5UiwgaWR5Qyk7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGphPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuZmlsdGVyU2hhcGU7dmFyIGU9dC5zdHJpZGVEZXB0aCxuPXQuc3RyaWRlSGVpZ2h0LHI9dC5zdHJpZGVXaWR0aCxvPXQucGFkSW5mby5mcm9udCxhPXQucGFkSW5mby50b3AsaT10LnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd0YgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIrdC5iYXRjaFNpemUrXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5RiA9IDA7IHlGIDwgXCIrdC5vdXREZXB0aCtcIjsgeUYrKykge1xcbiAgICAgICAgICAgIGludCB4RiA9IHdGICsgeUYgKiBcIitlK1wiIC0gXCIrbytcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49IFwiK3QuaW5EZXB0aCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIit0Lm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiK24rXCIgLSBcIithK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiK3Qub3V0V2lkdGgrXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK3IrXCIgLSBcIitpK1wiO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5RiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeEYsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxYYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJEZXB0aCxuPXQuZmlsdGVySGVpZ2h0LHI9dC5maWx0ZXJXaWR0aCxvPXQuc3RyaWRlRGVwdGgsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz1lLTEtdC5wYWRJbmZvLmZyb250LHU9bi0xLXQucGFkSW5mby50b3AsYz1yLTEtdC5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitzK1wiLCBcIit1K1wiLCBcIitjK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnU7XFxuXFxuXFxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcXG4gICAgICAgIGludCBkeUZDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLnk7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgXCIrZStcIjsgd0YrKykge1xcbiAgICAgICAgICBmbG9hdCBkeUYgPSBmbG9hdChkeUZDb3JuZXIgKyB3RikgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeUYgPCAwLjAgfHwgZHlGID49IFwiK3Qub3V0RGVwdGgrXCIuMCB8fCBmcmFjdChkeUYpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeUYgPSBpbnQoZHlGKTtcXG5cXG4gICAgICAgICAgaW50IHdGUGVybSA9IFwiK2UrXCIgLSAxIC0gd0Y7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIituK1wiOyB3UisrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrYStcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHxcXG4gICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICAgIGludCB3UlBlcm0gPSBcIituK1wiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIityK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitpK1wiLjA7XFxuXFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIityK1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8IFwiK3Qub3V0Q2hhbm5lbHMrXCI7IGQyKyspIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUYsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3RlBlcm0sIHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxZYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmZpbHRlclNoYXBlO3ZhciBlPXQuc3RyaWRlSGVpZ2h0LG49dC5zdHJpZGVXaWR0aCxyPXQucGFkSW5mby50b3Asbz10LnBhZEluZm8ubGVmdCxhPXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkbSA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQyID0gZDEgKiBcIithK1wiICsgZG07XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgLy8gVE8gRE86IFZlYzQgb3ZlciB0aGUgYmF0Y2ggc2l6ZVxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIit0LmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIit0Lm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIitlK1wiIC0gXCIrcitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrdC5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK24rXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sJGE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVySGVpZ2h0LG49dC5maWx0ZXJXaWR0aCxyPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPWUtMS10LnBhZEluZm8udG9wLGk9bi0xLXQucGFkSW5mby5sZWZ0LHM9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHM7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIithK1wiLCBcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2UrXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrZStcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK24rXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIituK1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIC8vIFRPIERPOiBWZWM0IG92ZXIgdGhlIGNoYW5uZWxNdWxcXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgXCIrcytcIjsgZG0rKykge1xcbiAgICAgICAgICAgICAgaW50IGQyID0gZDEgKiBcIitzK1wiICsgZG07XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFFhPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBvPXQucGFkSW5mby50b3AsYT10LnBhZEluZm8ubGVmdCxpPXQuc3RyaWRlSGVpZ2h0LHM9dC5zdHJpZGVXaWR0aCx1PXQuZGlsYXRpb25IZWlnaHQsYz10LmRpbGF0aW9uV2lkdGgsbD10LmZpbHRlckhlaWdodCxoPXQuZmlsdGVyV2lkdGgsZj00Kk1hdGguZmxvb3IodC5pbkNoYW5uZWxzLzQpLGQ9dC5pbkNoYW5uZWxzJTQscD1cImNoYW5uZWxzTGFzdFwiPT09dC5kYXRhRm9ybWF0LHY9cD8xOjIsbT1wPzI6MyxnPXA/MzoxLHk9XCJcIix4PVwiXCI7biYmKHk9cj9cImZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICAgIFwiK24rXCJcXG4gICAgICAgIH1cIjpcIlxcbiAgICAgICAgICBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgICAgICBcIituK1wiXFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiLHg9XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO3ZhciBiPWU/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjtlJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksciYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIit5K1wiXFxuXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitvK1wiLCBcIithK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkc1tcIitnK1wiXTtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9XFxuICAgICAgICAgICAgaXZlYzIoY29vcmRzW1wiK3YrXCJdLCBjb29yZHNbXCIrbStcIl0pICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbCtcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrdStcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2grXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrYytcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIitmK1wiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAyLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDMsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDIsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4UiwgeEMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoXCIrKDE9PT1kKStcIikge1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitmK1wiKSAqXFxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZitcIiwgZDIpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIrZitcIiwgeFIsIHhDKSAqXFxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZitcIiwgZDIpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1kKStcIikge1xcbiAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIgKyAxLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrcCtcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitmK1wiICsgMSlcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIrZitcIiArIDEsIHhSLCB4QylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWQpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZitcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZitcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrcCtcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitmK1wiICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitmK1wiICsgMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIrZitcIiArIDEsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIrZitcIiArIDIsIHhSLCB4QylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBkb3RQcm9kO1xcbiAgICAgICAgXCIrYitcIlxcbiAgICAgICAgXCIreCtcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sSmE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBlPXQucGFkSW5mby5mcm9udCxuPXQucGFkSW5mby50b3Ascj10LnBhZEluZm8ubGVmdCxvPXQuc3RyaWRlRGVwdGgsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz10LmRpbGF0aW9uRGVwdGgsdT10LmRpbGF0aW9uSGVpZ2h0LGM9dC5kaWxhdGlvbldpZHRoLGw9dC5maWx0ZXJEZXB0aCxoPXQuZmlsdGVySGVpZ2h0LGY9dC5maWx0ZXJXaWR0aCxkPTQqTWF0aC5mbG9vcih0LmluQ2hhbm5lbHMvNCkscD10LmluQ2hhbm5lbHMlNDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzMgc3RyaWRlcyA9IGl2ZWMzKFwiK28rXCIsIFwiK2ErXCIsIFwiK2krXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitlK1wiLCBcIituK1wiLCBcIityK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyB4RlJDQ29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgPywgZDEpIHdpdGggdyg6LCA6LCA6LCBkMSwgZDIpIHRvIGdldFxcbiAgICAgICAgLy8geSh5RiwgeVIsIHlDLCBkMikuID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbFxcbiAgICAgICAgLy8gdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgXCIrbCtcIjsgd0YrKykge1xcbiAgICAgICAgICBpbnQgeEYgPSB4RkNvcm5lciArIHdGICogXCIrcytcIjtcXG5cXG4gICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIraCtcIjsgd1IrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIit1K1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitmK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrYytcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiK2QrXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrKDE9PT1wKStcIikge1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZCtcIikgKlxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiwgZDIpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PXApK1wiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZCtcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZCtcIiArIDEpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitkK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitkK1wiICsgMSwgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PXApK1wiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZCtcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZCtcIiArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIgKyAyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sWmE9ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPW51bGwpLHZvaWQgMD09PXImJihyPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIG89dC5pbkhlaWdodCxhPXQuaW5XaWR0aCxpPXQucGFkSW5mby50b3Ascz10LnBhZEluZm8ubGVmdCx1PXQuc3RyaWRlSGVpZ2h0LGM9dC5zdHJpZGVXaWR0aCxsPXQuZGlsYXRpb25IZWlnaHQsaD10LmRpbGF0aW9uV2lkdGgsZj10LmZpbHRlckhlaWdodCxkPXQuZmlsdGVyV2lkdGgscD10Lm91dENoYW5uZWxzL3QuaW5DaGFubmVscyx2PVwiXCIsbT1cIlwiO24mJih2PXI/XCJmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IGEpIHtcXG4gICAgICAgICAgZmxvYXQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIituK1wiXFxuICAgICAgICB9XCI6XCJcXG4gICAgICAgICAgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgICB9XFxuICAgICAgICBcIixtPVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTt2YXIgZz1lP1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7ZSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLHImJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrditcIlxcblxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIit1K1wiLCBcIitjK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDEgPSBkMiAvIFwiK3ArXCI7XFxuICAgICAgICBpbnQgcSA9IGQyIC0gZDEgKiBcIitwK1wiO1xcblxcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgcSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICAvLyBUTyBETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrZitcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrbCtcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2QrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIraCtcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcod1IsIHdDLCBkMSwgcSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gZG90UHJvZDtcXG4gICAgICAgIFwiK2crXCJcXG4gICAgICAgIFwiK20rXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHRpPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO2Zvcih2YXIgbz10LmluSGVpZ2h0LGE9dC5pbldpZHRoLGk9dC5wYWRJbmZvLnRvcCxzPXQucGFkSW5mby5sZWZ0LHU9dC5zdHJpZGVIZWlnaHQsYz10LnN0cmlkZVdpZHRoLGw9dC5kaWxhdGlvbkhlaWdodCxoPXQuZGlsYXRpb25XaWR0aCxmPXQuZmlsdGVySGVpZ2h0LGQ9dC5maWx0ZXJXaWR0aCxwPWQsdj1cImludCB4UjsgaW50IHhDOyBpbnQgeENPZmZzZXQ7XCIsbT0wO208ZjttKyspZm9yKHZhciBnPTA7ZzxkO2crKyl2Kz1cIlxcbiAgICAgICAgICB2ZWM0IHhUZXhlbFJcIittK1wiQ1wiKzIqZytcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICB2ZWM0IHdSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgIHZlYzQgeFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAuKTtcIjtmb3IobT0wO208ZjttKyspZm9yKHZhciB5PTA7eTxwO3krKyl7aWYodis9XCJcXG4gICAgICAgICAgeFIgPSB4UkNvcm5lciArIFwiK20qbCtcIjtcXG4gICAgICAgICAgeEMgPSB4Q0Nvcm5lciArIFwiKyhnPTIqeSkqaCtcIjtcXG4gICAgICAgIFwiLDE9PT1jKXtpZihnPGQmJih2Kz1zJTI9PTE/XCJcXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDE7XFxuICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiICYmIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcblxcbiAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cXG4gICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCArIDEgPj0gXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIi56dyA9IHZlYzIoMC4pO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSAyO1xcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJiB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHZlYzQgcHJldmlvdXMgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG5cXG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXFxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgKyAxID49IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnp3ID0gdmVjMigwLik7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIitnK1wiID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsUlwiK20rXCJDXCIrZytcIi54eSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAsIDAsIHhUZXhlbFJcIittK1wiQ1wiK2crXCIueHkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBcIjpcIlxcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJiB4QyA+PSAwICYmIHhDIDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiK2crXCIgPSB4VGV4ZWxSXCIrbStcIkNcIitnK1wiO1xcbiAgICAgICAgICAgICAgXCIsZysxPGQpKXt2YXIgeD1zJTI9PTA/YihoKTpoO2glMj09MCYmcyUyPT0xfHxoJTIhPTAmJnMlMiE9MT8odis9XCJcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIrcyUyK1wiICsgXCIreCtcIjtcXG5cXG4gICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIixoPjEmJih2Kz1cIlxcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgLT0gMjtcXG4gICAgICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiICYmXFxuICAgICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICBcIiksdis9XCJcXG4gICAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrKGcrMSkrXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIi56dywgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIueHkpO1xcbiAgICAgICAgICAgICAgICBcIik6dis9XCJcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIreCtcIjtcXG5cXG4gICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIisoZysxKStcIiA9IHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiO1xcbiAgICAgICAgICAgICAgICBcIn19ZWxzZSBnPGQmJih2Kz1cIlxcbiAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIpIHtcXG4gICAgICAgICAgICBcIixzJTI9PTE/KHYrPVwiXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gXCIrYytcIjtcXG4gICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmKHhDICsgMSA+PSAwICYmIHhDICsgMSA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4QyArIDEsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIitnK1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiLnp3LCB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIi56dyk7XFxuICAgICAgICAgICAgICBcIixnKzE8ZCYmKHYrPVwiXFxuICAgICAgICAgICAgICAgICAgdmVjNCBmaW5hbCA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxICsgXCIrYytcIjtcXG4gICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiKyhnKzEpK1wiID0gdmVjNCh4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIi54eSwgZmluYWwueHkpO1xcbiAgICAgICAgICAgICAgICBcIikpOih2Kz1cIlxcbiAgICAgICAgICAgICAgICBpZih4QyA+PSAwICYmIHhDIDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK2MrXCI7XFxuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIitnK1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiLnh5LCB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIi54eSk7XFxuICAgICAgICAgICAgICBcIixnKzE8ZCYmKHYrPVwiXFxuICAgICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiKyhnKzEpK1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIuencsIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiLnp3KTtcXG4gICAgICAgICAgICAgICAgXCIpKSx2Kz1cIn1cIik7ZzxkJiYodis9XCJcXG4gICAgICAgICAgICB2ZWM0IHdUZXhlbFJcIittK1wiQ1wiK2crXCIgPSBnZXRXKFwiK20rXCIsIFwiK2crXCIsIGQxLCBxKTtcXG4gICAgICAgICAgICB3UlwiK20rXCJDXCIrZytcIiA9IHZlYzQod1RleGVsUlwiK20rXCJDXCIrZytcIi54eiwgd1RleGVsUlwiK20rXCJDXCIrZytcIi54eik7XFxuICAgICAgICAgIFwiLGcrMTxkJiYodis9XCJcXG4gICAgICAgICAgICAgIHZlYzQgd1RleGVsUlwiK20rXCJDXCIrKGcrMSkrXCIgPSBnZXRXKFwiK20rXCIsIFwiKyhnKzEpK1wiLCBkMSwgcSk7XFxuICAgICAgICAgICAgICB3UlwiK20rXCJDXCIrKGcrMSkrXCIgPVxcbiAgICAgICAgICAgICAgICB2ZWM0KHdUZXhlbFJcIittK1wiQ1wiKyhnKzEpK1wiLnh6LCB3VGV4ZWxSXCIrbStcIkNcIisoZysxKStcIi54eik7XCIpKX1mb3IobT0wO208ZjttKyspZm9yKGc9MDtnPGQ7ZysrKXYrPVwiZG90UHJvZCArPSB4UlwiK20rXCJDXCIrZytcIiAqIHdSXCIrbStcIkNcIitnK1wiO1wiO3ZhciB3PVwiXCIsQz1cIlwiO24mJih3PXI/XCJ2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XFxuICAgICAgICAgIHZlYzQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIituK1wiXFxuICAgICAgICB9XCI6XCJ2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XFxuICAgICAgICAgIFwiK24rXCJcXG4gICAgICAgIH1cIixDPVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTt2YXIgRT1lP1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7ZSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLHImJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrdytcIlxcblxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIit1K1wiLCBcIitjK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcblxcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDEgPSBkMjtcXG4gICAgICAgIGludCBxID0gMDtcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICB2ZWM0IGRvdFByb2QgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIFwiK3YrXCJcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gZG90UHJvZDtcXG4gICAgICAgIFwiK0UrXCJcXG4gICAgICAgIFwiK0MrXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGVpPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCIsXCJCb3hlc1wiLFwiQm94SW5kXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIGE9dFswXSxpPXRbMV0scz10WzJdLHU9dFszXSxjPWVbMF0sbD1uWzBdLGg9blsxXTt0aGlzLm91dHB1dFNoYXBlPVtjLGwsaCx1XTt2YXIgZj1cImJpbGluZWFyXCI9PT1yPzE6MCxkPVtpLTErXCIuMFwiLHMtMStcIi4wXCJdLHA9ZFswXSx2PWRbMV0sbT1sPjE/W1wiXCIrKGktMSkvKGwtMSksXCIoeTIteTEpICogaGVpZ2h0X3JhdGlvXCIsXCJ5MSpcIitwK1wiICsgZmxvYXQoeSkqKGhlaWdodF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh5MSt5MikgKiBcIitwXSxnPW1bMF0seT1tWzFdLHg9bVsyXSxiPWg+MT9bXCJcIisocy0xKS8oaC0xKSxcIih4Mi14MSkgKiB3aWR0aF9yYXRpb1wiLFwieDEqXCIrditcIiArIGZsb2F0KHgpKih3aWR0aF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh4MSt4MikgKiBcIit2XSx3PWJbMF0sQz1iWzFdLEU9YlsyXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0X3JhdGlvID0gZmxvYXQoXCIrZytcIik7XFxuICAgICAgY29uc3QgZmxvYXQgd2lkdGhfcmF0aW8gPSBmbG9hdChcIit3K1wiKTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgLy8gZ2V0IGJveCB2YWxzXFxuICAgICAgICBmbG9hdCB5MSA9IGdldEJveGVzKGIsMCk7XFxuICAgICAgICBmbG9hdCB4MSA9IGdldEJveGVzKGIsMSk7XFxuICAgICAgICBmbG9hdCB5MiA9IGdldEJveGVzKGIsMik7XFxuICAgICAgICBmbG9hdCB4MiA9IGdldEJveGVzKGIsMyk7XFxuXFxuICAgICAgICAvLyBnZXQgaW1hZ2UgaW4gYmF0Y2ggaW5kZXhcXG4gICAgICAgIGludCBiSW5kID0gcm91bmQoZ2V0Qm94SW5kKGIpKTtcXG4gICAgICAgIGlmKGJJbmQgPCAwIHx8IGJJbmQgPj0gXCIrYStcIikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCBoZWlnaHRfc2NhbGUgPSBcIit5K1wiO1xcbiAgICAgICAgZmxvYXQgd2lkdGhfc2NhbGUgPSBcIitDK1wiO1xcblxcbiAgICAgICAgZmxvYXQgaW5feSA9IFwiK3grXCI7XFxuICAgICAgICBpZiggaW5feSA8IDAuMCB8fCBpbl95ID4gXCIrcCtcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK28rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgaW5feCA9IFwiK0UrXCI7XFxuICAgICAgICBpZiggaW5feCA8IDAuMCB8fCBpbl94ID4gXCIrditcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK28rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhDUiA9IHZlYzIoaW5feCxpbl95KTtcXG4gICAgICAgIGlmKFwiK2YrXCIgPT0gMSkge1xcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgICAgaXZlYzIgc291cmNlRmxvb3JDUiA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleENSKTtcXG4gICAgICAgICAgaXZlYzIgc291cmNlQ2VpbENSID0gaXZlYzIoY2VpbChzb3VyY2VGcmFjSW5kZXhDUikpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbENSLnksIHNvdXJjZUZsb29yQ1IueCwgZCk7XFxuICAgICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbENSLnksIHNvdXJjZUNlaWxDUi54LCBkKTtcXG5cXG4gICAgICAgICAgdmVjMiBmcmFjQ1IgPSBzb3VyY2VGcmFjSW5kZXhDUiAtIHZlYzIoc291cmNlRmxvb3JDUik7XFxuXFxuICAgICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNDUi54O1xcbiAgICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjQ1IueDtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNDUi55O1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZU5lYXJlc3RDUiA9IGl2ZWMyKGZsb29yKFxcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleENSICsgdmVjMigwLjUsMC41KSkpO1xcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEltYWdlKGIsIHNvdXJjZU5lYXJlc3RDUi55LCBzb3VyY2VOZWFyZXN0Q1IueCwgZCk7XFxuICAgICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn0sbmk9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgcj10Lmxlbmd0aCxvPXRbdC5sZW5ndGgtMV0sYT1uP1wiPFwiOlwiPlwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBpbnQgZ2V0SW5kZXgoaW50IGkpIHtcXG4gICAgICAgIFwiKyhuP1wicmV0dXJuIFwiK28rXCIgLWkgLSAxO1wiOlwicmV0dXJuIGk7XCIpK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK3dhKHIpK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGVuZCA9IFwiK3JpKHIsXCJjb29yZHNcIikrXCI7XFxuICAgICAgICBmbG9hdCB2YWwgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBpID0gXCIrbytcIiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XFxuICAgICAgICAgIGludCBpZHggPSBnZXRJbmRleChpKTtcXG4gICAgICAgICAgaWYgKGlkeCBcIithK1wiIGVuZCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChpZHggPT0gZW5kICYmIFwiK2UrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBcIityaShyLFwiY29vcmRzXCIpK1wiID0gaWR4O1xcbiAgICAgICAgICB2YWwgKz0gZ2V0WChcIitmdW5jdGlvbih0LGUpe2lmKDE9PT10KXJldHVyblwiXCIrZTtpZigyPT09dClyZXR1cm4gZStcIi54LCBcIitlK1wiLnlcIjtpZigzPT09dClyZXR1cm4gZStcIi54LCBcIitlK1wiLnksIFwiK2UrXCIuelwiO2lmKDQ9PT10KXJldHVybiBlK1wiLngsIFwiK2UrXCIueSwgXCIrZStcIi56LCBcIitlK1wiLndcIjt0aHJvdyBFcnJvcihcIkN1bXVsYXRpdmUgc3VtIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9KHIsXCJjb29yZHNcIikrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIn07ZnVuY3Rpb24gcmkodCxlKXtpZigxPT09dClyZXR1cm5cIlwiK2U7aWYoMj09PXQpcmV0dXJuIGUrXCIueVwiO2lmKDM9PT10KXJldHVybiBlK1wiLnpcIjtpZig0PT09dClyZXR1cm4gZStcIi53XCI7dGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfXZhciBvaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dFBhY2tpbmdTY2hlbWU9VnQuREVOU0U7dmFyIGU9WXQodCksbj11YSgpO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgaXZlYzMgb3V0Q29vcmRzRnJvbUZsYXRJbmRleChpbnQgaW5kZXgpIHtcXG4gICAgICAgIFwiK2NhKFtcInJcIixcImNcIixcImRcIl0sdCkrXCJcXG4gICAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gNCAqIChyZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnkpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGZvciAoaW50IGk9MDsgaTw0OyBpKyspIHtcXG4gICAgICAgICAgaW50IGZsYXRJbmRleCA9IGluZGV4ICsgaTtcXG4gICAgICAgICAgaXZlYzMgcmMgPSBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGZsYXRJbmRleCk7XFxuICAgICAgICAgIHJlc3VsdFtpXSA9IGdldEEocmMueCwgcmMueSwgcmMueik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIituLm91dHB1dCtcIiA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifSxhaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dFBhY2tpbmdTY2hlbWU9VnQuREVOU0U7dmFyIGU9WXQodCksbj11YSgpO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgaXZlYzMgb3V0Q29vcmRzRnJvbUZsYXRJbmRleChpbnQgaW5kZXgpIHtcXG4gICAgICAgIFwiK2NhKFtcInJcIixcImNcIixcImRcIl0sdCkrXCJcXG4gICAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gNCAqIChyZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnkpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGZvciAoaW50IGk9MDsgaTw0OyBpKyspIHtcXG4gICAgICAgICAgaW50IGZsYXRJbmRleCA9IGluZGV4ICsgaTtcXG4gICAgICAgICAgaXZlYzMgcmMgPSBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGZsYXRJbmRleCk7XFxuICAgICAgICAgIHJlc3VsdFtpXSA9IGdldENoYW5uZWwoZ2V0QShyYy54LCByYy55LCByYy56KSwgdmVjMihyYy55LCByYy56KSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIituLm91dHB1dCtcIiA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifSxpaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMuYmxvY2tTaXplPWUsdGhpcy5kYXRhRm9ybWF0PW4sdGhpcy51c2VyQ29kZT1cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgaW50IGggPSBcIit0aGlzLmdldEhlaWdodENvb3JkU3RyaW5nKCkrXCI7XFxuICAgICAgaW50IHcgPSBcIit0aGlzLmdldFdpZHRoQ29vcmRTdHJpbmcoKStcIjtcXG4gICAgICBpbnQgZCA9IFwiK3RoaXMuZ2V0RGVwdGhDb29yZFN0cmluZygpK1wiO1xcblxcbiAgICAgIGludCBpbl9oID0gaCAvIFwiK2UrXCI7XFxuICAgICAgaW50IG9mZnNldF9oID0gaW1vZChoLCBcIitlK1wiKTtcXG4gICAgICBpbnQgaW5fdyA9IHcgLyBcIitlK1wiO1xcbiAgICAgIGludCBvZmZzZXRfdyA9IGltb2QodywgXCIrZStcIik7XFxuICAgICAgaW50IG9mZnNldF9kID0gKG9mZnNldF9oICogXCIrZStcIiArIG9mZnNldF93KSAqXFxuICAgICAgICBcIit0aGlzLmdldE91dHB1dERlcHRoU2l6ZSgpK1wiO1xcbiAgICAgIGludCBpbl9kID0gZCArIG9mZnNldF9kO1xcblxcbiAgICAgIGZsb2F0IHJlc3VsdCA9IFwiK3RoaXMuZ2V0SW5wdXRTYW1wbGluZ1N0cmluZygpK1wiO1xcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICB9XFxuICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0SGVpZ2h0Q29vcmRTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImNvb3Jkc1sxXVwiOlwiY29vcmRzWzJdXCJ9LHQucHJvdG90eXBlLmdldFdpZHRoQ29vcmRTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImNvb3Jkc1syXVwiOlwiY29vcmRzWzNdXCJ9LHQucHJvdG90eXBlLmdldERlcHRoQ29vcmRTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImNvb3Jkc1szXVwiOlwiY29vcmRzWzFdXCJ9LHQucHJvdG90eXBlLmdldE91dHB1dERlcHRoU2l6ZT1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P3RoaXMub3V0cHV0U2hhcGVbM106dGhpcy5vdXRwdXRTaGFwZVsxXX0sdC5wcm90b3R5cGUuZ2V0SW5wdXRTYW1wbGluZ1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiZ2V0WChiLCBpbl9oLCBpbl93LCBpbl9kKVwiOlwiZ2V0WChiLCBpbl9kLCBpbl9oLCBpbl93KVwifSx0fSgpLHNpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJYXCJdLHRoaXMub3V0cHV0U2hhcGU9W3QsdF0sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGZsb2F0IHZhbCA9IGNvb3Jkc1swXSA9PSBjb29yZHNbMV0gPyBnZXRYKGNvb3Jkc1swXSkgOiAwLjA7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHVpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0VGV4VXNhZ2U9enQuRE9XTkxPQUQ7dmFyIGU9dWEoKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2hhK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgXCIrZS5vdXRwdXQrXCIgPSBlbmNvZGVfZmxvYXQoeCk7XFxuICAgICAgfVxcbiAgICBcIn0sY2k9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITEsdGhpcy5vdXRUZXhVc2FnZT16dC5ET1dOTE9BRDt2YXIgZT11YSgpO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIraGErXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRDaGFubmVsKGdldEFBdE91dENvb3JkcygpLCB2ZWMyKGNvb3Jkcy55LCBjb29yZHMueikpO1xcbiAgICAgICAgXCIrZS5vdXRwdXQrXCIgPSBlbmNvZGVfZmxvYXQoeCk7XFxuICAgICAgfVxcbiAgICBcIn0sbGk9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgcj11YSgpLG89ZVswXSxhPWVbMV07dGhpcy5vdXRwdXRTaGFwZT10O3ZhciBpPVwicmVzdWx0XCI7biYmKGk9XCJmbG9vcihyZXN1bHQgKiAyNTUuICsgMC41KVwiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrbGEodCkrXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIGludCBmbGF0SW5kZXggPSBnZXRGbGF0SW5kZXgoY29vcmRzKTtcXG4gICAgICAgIGludCBvZmZzZXQgPSBpbW9kKGZsYXRJbmRleCwgNCk7XFxuXFxuICAgICAgICBmbGF0SW5kZXggPSBpZGl2KGZsYXRJbmRleCwgNCwgMS4pO1xcbiAgICAgICAgXFxuICAgICAgICBpbnQgciA9IGZsYXRJbmRleCAvIFwiK2ErXCI7XFxuICAgICAgICBpbnQgYyA9IGltb2QoZmxhdEluZGV4LCBcIithK1wiKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjLCByKSArIGhhbGZDUikgLyB2ZWMyKFwiK2ErXCIuMCwgXCIrbytcIi4wKTtcXG4gICAgICAgIHZlYzQgdmFsdWVzID0gXCIrci50ZXh0dXJlMkQrXCIoQSwgdXYpO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0O1xcblxcbiAgICAgICAgaWYob2Zmc2V0ID09IDApIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzBdO1xcbiAgICAgICAgfSBlbHNlIGlmKG9mZnNldCA9PSAxKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1sxXTtcXG4gICAgICAgIH0gZWxzZSBpZihvZmZzZXQgPT0gMikge1xcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMl07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbM107XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIityLm91dHB1dCtcIiA9IHZlYzQoXCIraStcIiwgMC4sIDAuLCAwLik7XFxuICAgICAgfVxcbiAgICBcIn0saGk9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMDt2YXIgcj11YSgpLG89ZVswXSxhPWVbMV07dGhpcy5vdXRwdXRTaGFwZT10O3ZhciBpPVwiXCIscz1cInJlc3VsdFwiO24mJihzPVwiZmxvb3IocmVzdWx0ICogMjU1LiArIDAuNSlcIik7Zm9yKHZhciB1PTA7dTw9MTt1KyspZm9yKHZhciBjPTA7Yzw9MTtjKyspe3ZhciBsPTIqdStjO2krPVwiXFxuICAgICAgICAgIGxvY2FsQ29vcmRzID0gY29vcmRzO1xcbiAgICAgICAgICBpZihsb2NhbENvb3Jkc1syXSArIFwiK2MrXCIgPCBcIit0WzJdK1wiKSB7XFxuICAgICAgICAgICAgbG9jYWxDb29yZHNbMl0gKz0gXCIrYytcIjtcXG4gICAgICAgICAgICBpZihsb2NhbENvb3Jkc1sxXSArIFwiK3UrXCIgPCBcIit0WzFdK1wiKSB7XFxuICAgICAgICAgICAgICBsb2NhbENvb3Jkc1sxXSArPSBcIit1K1wiO1xcblxcbiAgICAgICAgICAgICAgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KGxvY2FsQ29vcmRzKTtcXG4gICAgICAgICAgICAgIG9mZnNldCA9IGltb2QoZmxhdEluZGV4LCA0KTtcXG5cXG4gICAgICAgICAgICAgIGZsYXRJbmRleCA9IGlkaXYoZmxhdEluZGV4LCA0LCAxLik7XFxuXFxuICAgICAgICAgICAgICByID0gZmxhdEluZGV4IC8gXCIrYStcIjtcXG4gICAgICAgICAgICAgIGMgPSBpbW9kKGZsYXRJbmRleCwgXCIrYStcIik7XFxuICAgICAgICAgICAgICB1diA9ICh2ZWMyKGMsIHIpICsgaGFsZkNSKSAvIHZlYzIoXCIrYStcIi4wLCBcIitvK1wiLjApO1xcbiAgICAgICAgICAgICAgdmFsdWVzID0gXCIrci50ZXh0dXJlMkQrXCIoQSwgdXYpO1xcblxcbiAgICAgICAgICAgICAgaWYob2Zmc2V0ID09IDApIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0W1wiK2wrXCJdID0gdmFsdWVzWzBdO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKG9mZnNldCA9PSAxKSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdFtcIitsK1wiXSA9IHZhbHVlc1sxXTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihvZmZzZXQgPT0gMikge1xcbiAgICAgICAgICAgICAgICByZXN1bHRbXCIrbCtcIl0gPSB2YWx1ZXNbMl07XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXN1bHRbXCIrbCtcIl0gPSB2YWx1ZXNbM107XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICBcIn10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrbGEodCkrXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBpbnQgZmxhdEluZGV4LCByLCBjLCBvZmZzZXQ7XFxuICAgICAgICBpdmVjMyBsb2NhbENvb3JkcztcXG4gICAgICAgIHZlYzIgdXY7XFxuICAgICAgICB2ZWM0IHZhbHVlcztcXG5cXG4gICAgICAgIFwiK2krXCJcXG5cXG4gICAgICAgIFwiK3Iub3V0cHV0K1wiID0gXCIrcytcIjtcXG4gICAgICB9XFxuICAgIFwifSxmaT1cInJldHVybiByZWFsICogZXhwUiAtIGltYWcgKiBleHBJO1wiLGRpPVwicmV0dXJuIHJlYWwgKiBleHBJICsgaW1hZyAqIGV4cFI7XCIscGk9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJyZWFsXCIsXCJpbWFnXCJdO3ZhciByPWVbMV07dGhpcy5vdXRwdXRTaGFwZT1lO3ZhciBvPW4/XCIyLjAgKiBcIitNYXRoLlBJOlwiLTIuMCAqIFwiK01hdGguUEksYT1uP3IrXCIuMFwiOlwiMS4wXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGV4cG9uZW50TXVsdGlwbGllciA9IFwiK28rXCI7XFxuXFxuICAgICAgZmxvYXQgdW5hcnlPcENvbXBsZXgoZmxvYXQgcmVhbCwgZmxvYXQgZXhwUiwgZmxvYXQgaW1hZywgZmxvYXQgZXhwSSkge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBtdWxNYXRERlQoaW50IGJhdGNoLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4UmF0aW8gPSBmbG9hdChpbmRleCkgLyBmbG9hdChcIityK1wiKTtcXG4gICAgICAgIGZsb2F0IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyA9XFxuICAgICAgICAgICAgZXhwb25lbnRNdWx0aXBsaWVyICogaW5kZXhSYXRpbztcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcitcIjsgaSsrKSB7XFxuICAgICAgICAgIC8vIHggPSAoLTJ8MiAqIFBJIC8gTikgKiBpbmRleCAqIGk7XFxuICAgICAgICAgIGZsb2F0IHggPSBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gKiBmbG9hdChpKTtcXG4gICAgICAgICAgZmxvYXQgZXhwUiA9IGNvcyh4KTtcXG4gICAgICAgICAgZmxvYXQgZXhwSSA9IHNpbih4KTtcXG4gICAgICAgICAgZmxvYXQgcmVhbCA9IGdldFJlYWwoYmF0Y2gsIGkpO1xcbiAgICAgICAgICBmbG9hdCBpbWFnID0gZ2V0SW1hZyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIHJlc3VsdCArPVxcbiAgICAgICAgICAgICAgdW5hcnlPcENvbXBsZXgocmVhbCwgZXhwUiwgaW1hZywgZXhwSSkgLyBcIithK1wiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQobXVsTWF0REZUKGNvb3Jkc1swXSwgY29vcmRzWzFdKSk7XFxuICAgICAgfVxcbiAgICBcIn0sdmk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgdmFsdWU7XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgLy8gSW5wdXQgY2FuIGJlIG9idGFpbmVkIGZyb20gdW5pZm9ybSB2YWx1ZS5cXG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS52YWx1ZUxvYyYmKGUudmFsdWVMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJ2YWx1ZVwiKSksbi5nbC51bmlmb3JtMWYoZS52YWx1ZUxvYyx0KX19LHR9KCksbWk9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJpbmRpY2VzXCJdO3ZhciByPXQuc2xpY2UoKTtyW25dPWUsdGhpcy5vdXRwdXRTaGFwZT1yLHRoaXMucmFuaz1yLmxlbmd0aDt2YXIgbz13YSh0aGlzLnJhbmspLGE9ZnVuY3Rpb24odCxlKXt2YXIgbj10Lmxlbmd0aDtpZihuPjQpdGhyb3cgRXJyb3IoXCJHYXRoZXIgZm9yIHJhbmsgXCIrbitcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09bilyZXR1cm5cImludChnZXRJbmRpY2VzKHJlc1JDKSlcIjtmb3IodmFyIHI9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxvPVtdLGE9MDthPHQubGVuZ3RoO2ErKylhPT09ZT9vLnB1c2goXCJpbnQoZ2V0SW5kaWNlcyhcIityW2FdK1wiKSlcIik6by5wdXNoKFwiXCIrclthXSk7cmV0dXJuIG8uam9pbigpfSh0LG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIithK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn07dmFyIGdpPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnNsaWNlRGltPXQsdGhpcy5zdHJpZGVzPWUsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImluZGljZXNcIl0sdGhpcy5vdXRwdXRTaGFwZT1uO3ZhciByPXdhKGUubGVuZ3RoKSxvPXdhKG4ubGVuZ3RoKSxhPXRoaXMuc2xpY2VEaW0+MT9cInN0cmlkZXNbal1cIjpcInN0cmlkZXNcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICBcIityK1wiIHN0cmlkZXMgPSBcIityK1wiKFwiK3RoaXMuc3RyaWRlcytcIik7XFxuICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIitvK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgZmxhdHRlbkluZGV4ID0gMDtcXG4gICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIit0aGlzLnNsaWNlRGltK1wiOyBqKyspIHtcXG4gICAgICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkc1swXSwgaikpO1xcbiAgICAgICAgICAgIGZsYXR0ZW5JbmRleCArPSBpbmRleCAqIFwiK2ErXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoZmxhdHRlbkluZGV4LCBjb29yZHNbMV0pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn07ZnVuY3Rpb24geWkodCxlKXt2YXIgbj11YSgpO3JldHVybiBvZSh0LGUsbi52ZXJzaW9uK1wiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgXCIrbi5hdHRyaWJ1dGUrXCIgdmVjMyBjbGlwU3BhY2VQb3M7XFxuICAgIFwiK24uYXR0cmlidXRlK1wiIHZlYzIgdXY7XFxuICAgIFwiK24udmFyeWluZ1ZzK1wiIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcXG4gICAgICByZXN1bHRVViA9IHV2O1xcbiAgICB9XCIpfWZ1bmN0aW9uIHhpKHQsZSl7cmV0dXJuIGZlKHQsZSxuZXcgRmxvYXQzMkFycmF5KFstMSwxLDAsMCwxLC0xLC0xLDAsMCwwLDEsMSwwLDEsMSwxLC0xLDAsMSwwXSkpfWZ1bmN0aW9uIGJpKHQsZSl7cmV0dXJuIGRlKHQsZSxuZXcgVWludDE2QXJyYXkoWzAsMSwyLDIsMSwzXSkpfWZ1bmN0aW9uIHdpKHQsZSxuLHIsbyxhLGkpe3ZlKG4scik7dmFyIHM9cGUodCxlKSx1PXQuVEVYVFVSRV8yRDtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHUscyl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfV1JBUF9TLHQuQ0xBTVBfVE9fRURHRSl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfV1JBUF9ULHQuQ0xBTVBfVE9fRURHRSl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfTUlOX0ZJTFRFUix0Lk5FQVJFU1QpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX01BR19GSUxURVIsdC5ORUFSRVNUKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4SW1hZ2UyRCh1LDAsbyxuLHIsMCxhLGksbnVsbCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pKSxzfWZ1bmN0aW9uIENpKHQsZSxuLHIsbyl7dmFyIGE9WHQobixyKTtyZXR1cm4gd2kodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0RmxvYXQsby50ZXh0dXJlRm9ybWF0RmxvYXQsdC5GTE9BVCl9ZnVuY3Rpb24gRWkodCxlLG4scixvKXt2YXIgYT1YdChuLHIpO3JldHVybiB3aSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQsby50ZXh0dXJlRm9ybWF0RmxvYXQsby50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24gUmkodCxlLG4scixvKXt2YXIgYT1YdChuLHIpO3JldHVybiB3aSh0LGUsYVswXSxhWzFdLHQuUkdCQSx0LlJHQkEsdC5VTlNJR05FRF9CWVRFKX1mdW5jdGlvbiBJaSh0LGUsbixyLG8pe3ZhciBhPSR0KG4scik7cmV0dXJuIHdpKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0LHQuUkdCQSx0LkZMT0FUKX1mdW5jdGlvbiBraSh0LGUsbixyLG8pe3ZhciBhPSR0KG4scik7cmV0dXJuIHdpKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdCx0LlJHQkEsby50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24gU2kodCxlLG4scil7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLHIpfSkpLGdlKHQsZSxuLFwiY2xpcFNwYWNlUG9zXCIsciwzLDIwLDApJiZnZSh0LGUsbixcInV2XCIsciwyLDIwLDEyKX1mdW5jdGlvbiBBaSh0LGUsbixyLG8sYSxpKXt2YXIgcyx1LGM7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKX0pKSxhIGluc3RhbmNlb2YgVWludDhBcnJheT8ocz1uZXcgVWludDhBcnJheShyKm8qNCksdT10LlVOU0lHTkVEX0JZVEUsYz10LlJHQkEpOihzPW5ldyBGbG9hdDMyQXJyYXkocipvKjQpLHU9dC5GTE9BVCxjPWkuaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdCkscy5zZXQoYSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsYyxyLG8sMCx0LlJHQkEsdSxzKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSkpfWZ1bmN0aW9uIERpKHQsZSxuLHIpe0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbil9KSksci5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheT9KdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCx0LlJHQkEsci53aWR0aCxyLmhlaWdodCwwLHQuUkdCQSx0LlVOU0lHTkVEX0JZVEUsci5kYXRhKX0pKTpKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCx0LlJHQkEsdC5SR0JBLHQuVU5TSUdORURfQllURSxyKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSkpfWZ1bmN0aW9uIFRpKHQsZSxuLHIsbyl7dmFyIGE9dC5jcmVhdGVCdWZmZXIoKTtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LlBJWEVMX1BBQ0tfQlVGRkVSLGEpfSkpO3ZhciBpPTE2Km4qcjtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5QSVhFTF9QQUNLX0JVRkZFUixpLHQuU1RSRUFNX1JFQUQpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkUGl4ZWxzKDAsMCxyLG4sdC5SR0JBLHQuRkxPQVQsMCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5QSVhFTF9QQUNLX0JVRkZFUixudWxsKX0pKSxhfWZ1bmN0aW9uIE5pKHQsZSxuKXt2YXIgcj10LG89bmV3IEZsb2F0MzJBcnJheShuKTtyZXR1cm4gci5iaW5kQnVmZmVyKHIuUElYRUxfUEFDS19CVUZGRVIsZSksci5nZXRCdWZmZXJTdWJEYXRhKHIuUElYRUxfUEFDS19CVUZGRVIsMCxvKSxyLmJpbmRCdWZmZXIoci5QSVhFTF9QQUNLX0JVRkZFUixudWxsKSxvfWZ1bmN0aW9uIEZpKHQsZSxuLHIsbyl7dmFyIGE9WHQobixyKSxpPWFbMF0scz1hWzFdLHU9bmV3IFVpbnQ4QXJyYXkobipyKjQpO3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAsaSxzLG8uZG93bmxvYWRUZXh0dXJlRm9ybWF0LHQuVU5TSUdORURfQllURSx1KX0pKSxuZXcgRmxvYXQzMkFycmF5KHUuYnVmZmVyKX1mdW5jdGlvbiBfaSh0LGUsbixyLG8sYSxpLHMpe3ZhciB1PXQsYz1uZXcgRmxvYXQzMkFycmF5KGZ1bmN0aW9uKHQsZSl7dmFyIG49JHQodCxlKTtyZXR1cm4gblswXSpuWzFdKjR9KGEsaSkpO3JldHVybiB1LmJpbmRCdWZmZXIodS5QSVhFTF9QQUNLX0JVRkZFUixlKSx1LmdldEJ1ZmZlclN1YkRhdGEodS5QSVhFTF9QQUNLX0JVRkZFUiwwLGMpLHUuYmluZEJ1ZmZlcih1LlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpLGN9ZnVuY3Rpb24gT2kodCxlLG4scil7dmFyIG89bmV3IEZsb2F0MzJBcnJheShuKnIqNCk7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkUGl4ZWxzKDAsMCxyLG4sdC5SR0JBLHQuRkxPQVQsbyl9KSksb312YXIgTWk9T2JqZWN0LmZyZWV6ZSh7Y3JlYXRlVmVydGV4U2hhZGVyOnlpLGNyZWF0ZVZlcnRleEJ1ZmZlcjp4aSxjcmVhdGVJbmRleEJ1ZmZlcjpiaSxjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZTpDaSxjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZTpFaSxjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZTpSaSxjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlOklpLGNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlOmtpLGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtczpTaSx1cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZTpBaSx1cGxvYWRQaXhlbERhdGFUb1RleHR1cmU6RGksY3JlYXRlQnVmZmVyRnJvbU91dHB1dFRleHR1cmU6VGksZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcjpOaSxkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTpGaSxkb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXI6X2ksZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZTpPaX0pLEJpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLm91dHB1dFRleHR1cmU9bnVsbCx0aGlzLnByb2dyYW09bnVsbCx0aGlzLmRpc3Bvc2VkPSExLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdO3ZhciBlPWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpO251bGwhPXQ/KHRoaXMuZ2w9dCxLdChlLHQpKTp0aGlzLmdsPWp0KGUpO3ZhciBuPVwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCI7aWYoMT09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKXtpZih0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbj1yZSh0aGlzLmdsLHRoaXMuZGVidWcsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSxQZSh0aGlzLmdsLFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb249cmUodGhpcy5nbCx0aGlzLmRlYnVnLFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKTtlbHNlIGlmKGkoKS5nZXQoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIikpdGhyb3cgbmV3IEVycm9yKFwiR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGhhbGYgZmxvYXQgdGV4dHVyZXMsIHlldCB0aGUgZW52aXJvbm1lbnQgZmxhZyBXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMgaXMgc2V0IHRvIHRydWUuXCIpO2lmKHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihuKSxQZSh0aGlzLmdsLFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKXRoaXMuY29sb3JCdWZmZXJIYWxmRmxvYXRFeHRlbnNpb249cmUodGhpcy5nbCx0aGlzLmRlYnVnLFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpO2Vsc2UgaWYoaSgpLmdldChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiKSl0aHJvdyBuZXcgRXJyb3IoXCJHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgY29sb3IgcmVuZGVyYWJsZSBoYWxmIGZsb2F0cywgeWV0IHRoZSBlbnZpcm9ubWVudCBmbGFnIFdFQkdMX0ZPUkNFX0YxNl9URVhUVVJFUyBpcyBzZXQgdG8gdHJ1ZS5cIil9ZWxzZSBpZihuPVwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiLFBlKHRoaXMuZ2wsbikpdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKG4pO2Vsc2V7aWYoIVBlKHRoaXMuZ2wsXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikpdGhyb3cgbmV3IEVycm9yKFwiR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGNvbG9yIHJlbmRlcmFibGUgZmxvYXRzXCIpO3RoaXMuY29sb3JCdWZmZXJIYWxmRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIil9dGhpcy52ZXJ0ZXhCdWZmZXI9eGkodGhpcy5nbCx0aGlzLmRlYnVnKSx0aGlzLmluZGV4QnVmZmVyPWJpKHRoaXMuZ2wsdGhpcy5kZWJ1ZyksdGhpcy5mcmFtZWJ1ZmZlcj1tZSh0aGlzLmdsLHRoaXMuZGVidWcpLHRoaXMudGV4dHVyZUNvbmZpZz1RdCh0aGlzLmdsLHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbil9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImRlYnVnXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBpKCkuZ2V0Qm9vbChcIkRFQlVHXCIpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKCF0aGlzLmRpc3Bvc2VkKXtudWxsIT10aGlzLnByb2dyYW0mJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIFdlYkdMUHJvZ3JhbS4gVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuXCIpLG51bGwhPXRoaXMub3V0cHV0VGV4dHVyZSYmY29uc29sZS53YXJuKFwiRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlIGRpc3Bvc2luZy5cIik7dmFyIGU9dGhpcy5nbDtKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZmluaXNoKCl9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpfSkpLEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWxldGVGcmFtZWJ1ZmZlcih0LmZyYW1lYnVmZmVyKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUixudWxsKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEJ1ZmZlcihlLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG51bGwpfSkpLEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWxldGVCdWZmZXIodC5pbmRleEJ1ZmZlcil9KSksdGhpcy5kaXNwb3NlZD0hMH19LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQ2kodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEVpKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxSaSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZT1mdW5jdGlvbih0LGUpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksRGkodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSl9LHQucHJvdG90eXBlLnVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksQWkodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSxuLHIsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxraSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxJaSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmRlbGV0ZU1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMub3V0cHV0VGV4dHVyZT09PXQmJihFZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5vdXRwdXRUZXh0dXJlPW51bGwpLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC5kZWxldGVUZXh0dXJlKHQpfSkpfSx0LnByb3RvdHlwZS5kb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0LChmdW5jdGlvbigpe3JldHVybiBGaShyLmdsLHIuZGVidWcsZSxuLHIudGV4dHVyZUNvbmZpZyl9KSl9LHQucHJvdG90eXBlLmRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcj1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIF9pKHRoaXMuZ2wsdCwwLDAsMCxvLGEsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcj1mdW5jdGlvbih0LGUpe3JldHVybiBOaSh0aGlzLmdsLHQsZSl9LHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcih0KTt2YXIgcj1UaSh0aGlzLmdsLHRoaXMuZGVidWcsZSxuLHRoaXMudGV4dHVyZUNvbmZpZyk7cmV0dXJuIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKSxyfSx0LnByb3RvdHlwZS5jcmVhdGVBbmRXYWl0Rm9yRmVuY2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNyZWF0ZUZlbmNlKHRoaXMuZ2wpO3JldHVybiB0aGlzLnBvbGxGZW5jZSh0KX0sdC5wcm90b3R5cGUuY3JlYXRlRmVuY2U9ZnVuY3Rpb24odCl7dmFyIGUsbixyPXRoaXM7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiKSl7dmFyIG89dCxhPW8uZmVuY2VTeW5jKG8uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7dC5mbHVzaCgpLG49ZnVuY3Rpb24oKXt2YXIgdD1vLmNsaWVudFdhaXRTeW5jKGEsMCwwKTtyZXR1cm4gdD09PW8uQUxSRUFEWV9TSUdOQUxFRHx8dD09PW8uQ09ORElUSU9OX1NBVElTRklFRH0sZT1hfWVsc2UgaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjA/KGU9dGhpcy5iZWdpblF1ZXJ5KCksdGhpcy5lbmRRdWVyeSgpLG49ZnVuY3Rpb24oKXtyZXR1cm4gci5pc1F1ZXJ5QXZhaWxhYmxlKGUsaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKX0pOm49ZnVuY3Rpb24oKXtyZXR1cm4hMH07cmV0dXJue3F1ZXJ5OmUsaXNGZW5jZVBhc3NlZDpufX0sdC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0LChmdW5jdGlvbigpe3JldHVybiBPaShyLmdsLHIuZGVidWcsZSxuKX0pKX0sdC5wcm90b3R5cGUuY3JlYXRlUHJvZ3JhbT1mdW5jdGlvbih0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciBlPXRoaXMuZ2wsbj1hZShlLHRoaXMuZGVidWcsdCkscj15aShlLHRoaXMuZGVidWcpLG89Y2UoZSx0aGlzLmRlYnVnKTtyZXR1cm4gSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmF0dGFjaFNoYWRlcihvLHIpfSkpLEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5hdHRhY2hTaGFkZXIobyxuKX0pKSxsZShlLHRoaXMuZGVidWcsbyksdGhpcy5kZWJ1ZyYmaGUoZSx0aGlzLmRlYnVnLG8pLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZHx8KHRoaXMuc2V0UHJvZ3JhbShvKSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQ9U2koZSx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSx0aGlzLnZlcnRleEJ1ZmZlcikpLG99LHQucHJvdG90eXBlLmRlbGV0ZVByb2dyYW09ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHQ9PT10aGlzLnByb2dyYW0mJih0aGlzLnByb2dyYW09bnVsbCksbnVsbCE9dCYmSnQodGhpcy5nbCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmdsLmRlbGV0ZVByb2dyYW0odCl9KSl9LHQucHJvdG90eXBlLnNldFByb2dyYW09ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucHJvZ3JhbT10LG51bGwhPXRoaXMucHJvZ3JhbSYmdGhpcy5kZWJ1ZyYmaGUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSksSnQodGhpcy5nbCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmdsLnVzZVByb2dyYW0odCl9KSl9LHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG4/eGUodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSk6YmUodGhpcy5nbCx0LGUpfSx0LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksSnQodGhpcy5nbCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBuLmdsLmdldEF0dHJpYkxvY2F0aW9uKHQsZSl9KSl9LHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3c9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUpfSx0LnByb3RvdHlwZS5zZXRJbnB1dE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCksd2UodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSx0LGUsbil9LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcih0LG4sZSl9LHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIHI9JHQoZSxuKSxvPXJbMF0sYT1yWzFdO3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcih0LG8sYSl9LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIobix0LHIsZSl9LHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcInNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uIG5vdCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLmRlYnVnVmFsaWRhdGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnByb2dyYW0mJmhlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0pLFJlKHRoaXMuZ2wpfSx0LnByb3RvdHlwZS5leGVjdXRlUHJvZ3JhbT1mdW5jdGlvbigpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7dmFyIHQ9dGhpcy5nbDt0aGlzLmRlYnVnJiZ0aGlzLmRlYnVnVmFsaWRhdGUoKSxKdCh0LHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZHJhd0VsZW1lbnRzKHQuVFJJQU5HTEVTLDYsdC5VTlNJR05FRF9TSE9SVCwwKX0pKX0sdC5wcm90b3R5cGUuYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gdC5nbC5maW5pc2goKX0pKX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbj1mdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbiYmKHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9uPXJlKHRoaXMuZ2wsdGhpcy5kZWJ1ZywyPT09aSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpP1wiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiOlwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XCIpKSx0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbn0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKX0sdC5wcm90b3R5cGUuYmVnaW5RdWVyeT1mdW5jdGlvbigpe2lmKDI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpe3ZhciB0PXRoaXMuZ2wsZT10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKSxuPXQuY3JlYXRlUXVlcnkoKTtyZXR1cm4gdC5iZWdpblF1ZXJ5KGUuVElNRV9FTEFQU0VEX0VYVCxuKSxufXZhciByPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpLG89ci5jcmVhdGVRdWVyeUVYVCgpO3JldHVybiByLmJlZ2luUXVlcnlFWFQoci5USU1FX0VMQVBTRURfRVhULG8pLG99LHQucHJvdG90eXBlLmVuZFF1ZXJ5PWZ1bmN0aW9uKCl7aWYoMiE9PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl7dmFyIHQ9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7dC5lbmRRdWVyeUVYVCh0LlRJTUVfRUxBUFNFRF9FWFQpfWVsc2V7dmFyIGU9dGhpcy5nbCxuPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO2UuZW5kUXVlcnkobi5USU1FX0VMQVBTRURfRVhUKX19LHQucHJvdG90eXBlLndhaXRGb3JRdWVyeUFuZEdldFRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxGKChmdW5jdGlvbigpe3JldHVybiBlLmRpc3Bvc2VkfHxlLmlzUXVlcnlBdmFpbGFibGUodCxpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpfSkpXTtjYXNlIDE6cmV0dXJuIG4uc2VudCgpLFsyLHRoaXMuZ2V0UXVlcnlUaW1lKHQsaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKV19fSkpfSkpfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWU9ZnVuY3Rpb24odCxlKXtpZigwPT09ZSlyZXR1cm4gbnVsbDtpZigyPT09ZSl7dmFyIG49dGhpcy5nbDtyZXR1cm4gbi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUKS8xZTZ9dmFyIHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7cmV0dXJuIHIuZ2V0UXVlcnlPYmplY3RFWFQodCxyLlFVRVJZX1JFU1VMVF9FWFQpLzFlNn0sdC5wcm90b3R5cGUuaXNRdWVyeUF2YWlsYWJsZT1mdW5jdGlvbih0LGUpe2lmKDA9PT1lKXJldHVybiEwO2lmKDI9PT1lKXt2YXIgbj10aGlzLmdsLHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCksbz1uLmdldFF1ZXJ5UGFyYW1ldGVyKHQsbi5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIoci5HUFVfRElTSk9JTlRfRVhUKSksbyYmIXRoaXMuZGlzam9pbnR9bz0ocj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSkuZ2V0UXVlcnlPYmplY3RFWFQodCxyLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKTtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIoci5HUFVfRElTSk9JTlRfRVhUKSksbyYmIXRoaXMuZGlzam9pbnR9LHQucHJvdG90eXBlLnBvbGxGZW5jZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obil7ZS5hZGRJdGVtVG9Qb2xsKChmdW5jdGlvbigpe3JldHVybiB0LmlzRmVuY2VQYXNzZWQoKX0pLChmdW5jdGlvbigpe3JldHVybiBuKCl9KSl9KSl9LHQucHJvdG90eXBlLnBvbGxJdGVtcz1mdW5jdGlvbigpe2Zvcih2YXIgdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoOysrZSl7aWYoIXRbZV0oKSlicmVha31yZXR1cm4gZS0xfSh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNEb25lRm59KSkpLGU9MDtlPD10OysrZSl7KDAsdGhpcy5pdGVtc1RvUG9sbFtlXS5yZXNvbHZlRm4pKCl9dGhpcy5pdGVtc1RvUG9sbD10aGlzLml0ZW1zVG9Qb2xsLnNsaWNlKHQrMSl9LHQucHJvdG90eXBlLmFkZEl0ZW1Ub1BvbGw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3RoaXMuaXRlbXNUb1BvbGwucHVzaCh7aXNEb25lRm46dCxyZXNvbHZlRm46ZX0pLHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoPjF8fEYoKGZ1bmN0aW9uKCl7cmV0dXJuIG4ucG9sbEl0ZW1zKCksMD09PW4uaXRlbXNUb1BvbGwubGVuZ3RofSkpfSx0LnByb3RvdHlwZS5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXI9ZnVuY3Rpb24odCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxDZSh0aGlzLmdsLHRoaXMuZGVidWcsdCx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmRlYnVnJiZSZSh0aGlzLmdsKX0sdC5wcm90b3R5cGUudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXI9ZnVuY3Rpb24oKXtudWxsIT10aGlzLm91dHB1dFRleHR1cmU/KENlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLm91dHB1dFRleHR1cmUsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmUmUodGhpcy5nbCkpOkVlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLmZyYW1lYnVmZmVyKX0sdC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXI9ZnVuY3Rpb24odCxlKXt0aGlzLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcih0KTt2YXIgbj1lKCk7cmV0dXJuIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKSxufSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciByPXRoaXMuZ2w7Q2Uocix0aGlzLmRlYnVnLHQsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmUmUociksdGhpcy5vdXRwdXRUZXh0dXJlPXQsSnQocix0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiByLnZpZXdwb3J0KDAsMCxlLG4pfSkpLEp0KHIsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gci5zY2lzc29yKDAsMCxlLG4pfSkpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksSnQodGhpcy5nbCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBvLmdsLnNjaXNzb3IodCxlLG4scil9KSl9LHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZD1mdW5jdGlvbigpe2lmKHRoaXMuZGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHVzZSBkaXNwb3NlZCBHUEdQVUNvbnRleHQuXCIpfSx0LnByb3RvdHlwZS50aHJvd0lmTm9Qcm9ncmFtPWZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5wcm9ncmFtKXRocm93IG5ldyBFcnJvcihcIk5vIEdQVSBwcm9ncmFtIGlzIGN1cnJlbnRseSBzZXQuXCIpfSx0fSgpO2Z1bmN0aW9uIFBpKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBcIit0Lmxlbmd0aCtcIiBpbnB1dHMsIGJ1dCB3YXMgZXhlY3V0ZWQgd2l0aCBcIitlLmxlbmd0aCtcIiBpbnB1dHNcIik7dC5mb3JFYWNoKChmdW5jdGlvbih0LG4pe3ZhciByPXQubG9naWNhbFNoYXBlLG89ZVtuXSxhPW8uc2hhcGU7aWYoIVMocixhKSl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgc2hhcGVzIHRoYW4gdGhlIGN1cnJlbnQgYXJncy4gU2hhcGVzIFwiK3IrXCIgYW5kIFwiK2ErXCIgbXVzdCBtYXRjaFwiKTtpZighdC5pc1VuaWZvcm18fCFvLmlzVW5pZm9ybSl7dmFyIGk9dC50ZXhTaGFwZSxzPW8uaXNVbmlmb3JtP251bGw6by50ZXhEYXRhLnRleFNoYXBlO2lmKCFTKGkscykpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHRleHR1cmUgc2hhcGVzIHRoYW4gdGhlIGN1cnJlbnQgYXJncy4gU2hhcGUgXCIraStcIiBhbmQgXCIrcytcIiBtdXN0IG1hdGNoXCIpfX0pKX12YXIgTGk9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dDtmb3IodmFyIHI9bi5maWx0ZXJXaWR0aCxvPW4uaW5DaGFubmVscyxhPW4uc3RyaWRlV2lkdGgsaT1uLnN0cmlkZUhlaWdodCxzPW4ucGFkSW5mbyx1PW4ub3V0V2lkdGgsYz1uLmRpbGF0aW9uV2lkdGgsbD1uLmRpbGF0aW9uSGVpZ2h0LGg9bi5kYXRhRm9ybWF0LGY9cy5sZWZ0LGQ9cy50b3AscD1vKnIsdj11YSgpLG09XCJjaGFubmVsc0xhc3RcIj09PWgsZz1tPzA6MSx5PW0/MToyLHg9XCJcIixiPTA7Yjw9MTtiKyspZm9yKHZhciB3PTA7dzw9MTt3KyspeCs9XCJcXG4gICAgICAgICAgYmxvY2tJbmRleCA9IHJjLnkgKyBcIit3K1wiO1xcbiAgICAgICAgICBwb3MgPSByYy54ICsgXCIrYitcIjtcXG5cXG4gICAgICAgICAgaWYoYmxvY2tJbmRleCA8IFwiK3RbMV0rXCIgJiYgcG9zIDwgXCIrdFswXStcIikge1xcbiAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvIChcIit1K1wiKSkgKiBcIitpK1wiIC0gXCIrZCtcIjtcXG4gICAgICAgICAgICBkMCA9IG9mZnNldFkgKyBcIitsK1wiICogKHBvcyAvIFwiK3ArXCIpO1xcblxcbiAgICAgICAgICAgIGlmKGQwIDwgXCIrZVtnXStcIiAmJiBkMCA+PSAwKSB7XFxuXFxuICAgICAgICAgICAgICBvZmZzZXRYID0gaW50KG1vZChmbG9hdChibG9ja0luZGV4KSwgXCIrdStcIi4pICogXCIrYStcIi4gLSBcIitmK1wiLik7XFxuICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyBcIitjK1wiICogKGludChtb2QoZmxvYXQocG9zKSwgXCIrcCtcIi4pIC8gXCIrbytcIi4pKTtcXG5cXG4gICAgICAgICAgICAgIGlmKGQxIDwgXCIrZVt5XStcIiAmJiBkMSA+PSAwKSB7XFxuXFxuICAgICAgICAgICAgICAgIGNoID0gaW50KG1vZChmbG9hdChwb3MpLCBcIitvK1wiLikpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoXCIrbStcIikge1xcbiAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDEsIGNoKTtcXG4gICAgICAgICAgICAgICAgICByZXN1bHRbXCIrKDIqYit3KStcIl0gPSBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QShkMCwgaW50KGlubmVyRGltcy54KSxcXG4gICAgICAgICAgICAgICAgICAgIGludChpbm5lckRpbXMueSkpLCBpbm5lckRpbXMpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDAsIGQxKTtcXG4gICAgICAgICAgICAgICAgICByZXN1bHRbXCIrKDIqYit3KStcIl0gPSBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QShjaCwgaW50KGlubmVyRGltcy54KSxcXG4gICAgICAgICAgICAgICAgICAgIGludChpbm5lckRpbXMueSkpLCBpbm5lckRpbXMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcXG5cXG4gICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XFxuICAgICAgICB2ZWMyIGlubmVyRGltcztcXG5cXG4gICAgICAgIFwiK3grXCJcXG5cXG4gICAgICAgIFwiK3Yub3V0cHV0K1wiID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgXCJ9LFdpPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgYSxpPWUscz10WzNdLTE7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciB1PVwiZmxvYXQoXCIrbitcIikgKyBmbG9hdChcIityK1wiKSAqIHN1bVwiO2E9LjU9PT1vP1wiaW52ZXJzZXNxcnQoXCIrdStcIilcIjoxPT09bz9cIjEuMC8oXCIrdStcIilcIjpcImV4cChsb2coXCIrdStcIikgKiBmbG9hdCgtXCIrbytcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFgoYiwgciwgYywgZCk7XFxuICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBqID0gLVwiK2krXCI7IGogPD0gXCIraStcIjsgaisrKSB7XFxuICAgICAgICAgIGludCBpZHggPSBkICsgajtcXG4gICAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8PSAgXCIrcytcIikge1xcbiAgICAgICAgICAgIGZsb2F0IHogPSBnZXRYKGIsIHIsIGMsIGlkeCk7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCB2YWwgPSB4ICogXCIrYStcIjtcXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFVpPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImlucHV0SW1hZ2VcIixcIm91dHB1dEltYWdlXCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLmRlcHRoPXRbM10sdGhpcy5kZXB0aFJhZGl1cz1lLHRoaXMuYmlhcz1uLHRoaXMuYWxwaGE9cix0aGlzLmJldGE9byx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBkID0gMDsgZCA8IFwiK3RoaXMuZGVwdGgrXCI7ICsrZCkge1xcbiAgICAgICAgICBpbnQgZGVwdGhCZWdpbiA9IGludChtYXgoMC4wLCBmbG9hdChkIC0gXCIrZStcIikpKTtcXG4gICAgICAgICAgaW50IGRlcHRoRW5kID0gaW50KG1pbihmbG9hdChcIit0aGlzLmRlcHRoK1wiKSxcXG4gICAgICAgICAgICAgIGZsb2F0KGQgKyBcIitlK1wiICsgMSkpKTtcXG5cXG4gICAgICAgICAgY29uc3QgaW50IE1JTl9ERVBUSF9CRUdJTiA9IDA7XFxuICAgICAgICAgIGNvbnN0IGludCBNQVhfREVQVEhfRU5EID0gXCIrdGhpcy5kZXB0aCtcIjtcXG5cXG4gICAgICAgICAgZmxvYXQgbm9ybSA9IDAuMDtcXG4gICAgICAgICAgZm9yIChpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsraykge1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCkge1xcbiAgICAgICAgICAgICAgbm9ybSArPSBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspICogZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbm9ybSA9IGZsb2F0KFwiK3IrXCIpICogbm9ybSArIGZsb2F0KFwiK24rXCIpO1xcblxcbiAgICAgICAgICBmb3IoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spe1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCl7XFxuICAgICAgICAgICAgICBmbG9hdCBkeWkgPSAtMi4wICogZmxvYXQoXCIrcitcIilcXG4gICAgICAgICAgICAgICAgKiBmbG9hdChcIitvK1wiKVxcbiAgICAgICAgICAgICAgICAqIGdldElucHV0SW1hZ2UoYiAsciAsYywgaykgKiBnZXRPdXRwdXRJbWFnZShiLCByLCBjLCBkKVxcbiAgICAgICAgICAgICAgICAvIG5vcm07XFxuICAgICAgICAgICAgICBpZiAoayA9PSBkKSB7XFxuICAgICAgICAgICAgICAgIGR5aSArPSBwb3cobm9ybSwgLTEuMCAqIFwiK28rXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKGsgPT0gY29vcmRzWzNdKSB7XFxuICAgICAgICAgICAgICAgIGR5aSAqPSBnZXREeShiLCByLCBjLCBkKTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGR5aTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sVmk9ZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwO3ZhciBhLGk9ZSxzPXRbM10tMTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHU9XCJmbG9hdChcIituK1wiKSArIGZsb2F0KFwiK3IrXCIpICogc3VtXCI7YT0uNT09PW8/XCJpbnZlcnNlc3FydChcIit1K1wiKVwiOjE9PT1vP1wiMS4wLyhcIit1K1wiKVwiOlwiZXhwKGxvZyhcIit1K1wiKSAqIGZsb2F0KC1cIitvK1wiKSk7XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCByID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQgPSBjb29yZHMudztcXG5cXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IGQgPCBcIit0aGlzLm91dHB1dFNoYXBlWzNdK1wiO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gYyA8IFwiK3RoaXMub3V0cHV0U2hhcGVbMl0rXCI7XFxuXFxuICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4pO1xcbiAgICAgICAgdmVjNCB4RnJhZ0F0T3V0cHV0Q29vcmRzID0gZ2V0WChiLCByLCBjLCBkKTtcXG5cXG4gICAgICAgIHZlYzQgeEF0T3V0cHV0Q29vcmRzID0gdmVjNChcXG4gICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMsIGQpKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMsIGQgKyAxKSkgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgP1xcbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcyAsIHZlYzIoYyArIDEsIGQpKSA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjICsgMSwgZCArIDEpKSA6IDAuMFxcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIGludCBmaXJzdENoYW5uZWwgPSBkIC0gXCIraStcIjtcXG4gICAgICAgIHZlYzIgY2FjaGUgPSB2ZWMyKDAuKTtcXG4gICAgICAgIGlmKGZpcnN0Q2hhbm5lbCA+PSAwKXtcXG4gICAgICAgICAgdmVjNCBmaXJzdENoYW5uZWxGcmFnID0gZ2V0WChiLCByLCBjLCBmaXJzdENoYW5uZWwpO1xcbiAgICAgICAgICBjYWNoZS54ID0gZ2V0Q2hhbm5lbChmaXJzdENoYW5uZWxGcmFnLCB2ZWMyKGMsIGZpcnN0Q2hhbm5lbCkpO1xcbiAgICAgICAgICAgIGlmKGhhc05leHRSb3cpe1xcbiAgICAgICAgICAgICAgY2FjaGUueSA9IGdldENoYW5uZWwoZmlyc3RDaGFubmVsRnJhZywgdmVjMihjICsgMSwgZmlyc3RDaGFubmVsKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaXZlYzIgZGVwdGggPSBpdmVjMihkLCBkICsgMSk7XFxuICAgICAgICBmb3IgKGludCBqID0gLSBcIitpK1wiOyBqIDw9IFwiK2krXCI7IGorKykge1xcbiAgICAgICAgICBpdmVjMiBpZHggPSBkZXB0aCArIGo7XFxuICAgICAgICAgIGJ2ZWMyIGFib3ZlTG93ZXJCb3VuZCA9IGdyZWF0ZXJUaGFuRXF1YWwoaWR4LCBpdmVjMigwKSk7XFxuICAgICAgICAgIGJ2ZWMyIGJlbG93VXBwZXJCb3VuZCA9IGxlc3NUaGFuRXF1YWwoaWR4LCBpdmVjMihcIitzK1wiKSk7XFxuXFxuICAgICAgICAgIGJvb2wgZGVwdGhJblJhbmdlID0gYWJvdmVMb3dlckJvdW5kLnggJiYgYmVsb3dVcHBlckJvdW5kLng7XFxuICAgICAgICAgIGJvb2wgZGVwdGhQbHVzT25lSW5SYW5nZSA9IGFib3ZlTG93ZXJCb3VuZC55ICYmIGJlbG93VXBwZXJCb3VuZC55O1xcblxcbiAgICAgICAgICBpZihkZXB0aEluUmFuZ2UgfHwgZGVwdGhQbHVzT25lSW5SYW5nZSl7XFxuICAgICAgICAgICAgdmVjNCB6ID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgdmVjNCB4RnJhZ0F0Q3VycmVudERlcHRoO1xcbiAgICAgICAgICAgIHoueHogPSBjYWNoZS54eTtcXG4gICAgICAgICAgICBpZihkZXB0aFBsdXNPbmVJblJhbmdlICYmIGhhc05leHRDb2wpe1xcbiAgICAgICAgICAgICAgeEZyYWdBdEN1cnJlbnREZXB0aCA9IGlkeC55ICE9IGQgP1xcbiAgICAgICAgICAgICAgICBnZXRYKGIsIHIsIGMsIGlkeC55KSA6IHhGcmFnQXRPdXRwdXRDb29yZHM7XFxuICAgICAgICAgICAgICB6LnkgPSBnZXRDaGFubmVsKHhGcmFnQXRDdXJyZW50RGVwdGgsIHZlYzIoYywgaWR4LnkpKTtcXG4gICAgICAgICAgICAgIGlmKGhhc05leHRSb3cpe1xcbiAgICAgICAgICAgICAgICB6LncgPSBnZXRDaGFubmVsKHhGcmFnQXRDdXJyZW50RGVwdGgsIHZlYzIoYyArIDEsIGlkeC55KSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhY2hlLnh5ID0gei55dztcXG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0geEF0T3V0cHV0Q29vcmRzICogXCIrYStcIjtcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHppPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuc3RyaWRlSGVpZ2h0LG49dC5zdHJpZGVXaWR0aCxyPXQuZGlsYXRpb25IZWlnaHQsbz10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxhPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaT1vLTEtdC5wYWRJbmZvLnRvcCxzPWEtMS10LnBhZEluZm8ubGVmdCx1PW8qYS0xO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbytcIjtcXG4gICAgICAgICAgd1IgKz0gXCIrcitcIikge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIitlK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIithK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbitcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgaWR5UiwgaWR5QywgZCk7XFxuICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gXCIrdStcIiAtIGludChnZXRNYXhQb3MoYiwgaWR5UiwgaWR5QywgZCkpO1xcblxcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXFxuICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID0gd1IgKiBcIithK1wiICsgd0M7XFxuICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sR2k9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJtYXhQb3NcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5zdHJpZGVEZXB0aCxuPXQuc3RyaWRlSGVpZ2h0LHI9dC5zdHJpZGVXaWR0aCxvPXQuZGlsYXRpb25EZXB0aCxhPXQuZGlsYXRpb25IZWlnaHQsaT10LmRpbGF0aW9uV2lkdGgscz10LmVmZmVjdGl2ZUZpbHRlckRlcHRoLHU9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYz10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGw9cy0xLXQucGFkSW5mby5mcm9udCxoPXUtMS10LnBhZEluZm8udG9wLGY9Yy0xLXQucGFkSW5mby5sZWZ0LGQ9cyp1KmMtMTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK2wrXCIsIFwiK2grXCIsIFwiK2YrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIGR5Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5RENvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci56O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgPywgY2gpIHdpdGggcG9zIG1hc2soOiwgOiwgOiwgZCkgdG8gZ2V0XFxuICAgICAgICAvLyBkeCh4RCwgeFIsIHhDLCBjaCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgXCIrcytcIjtcXG4gICAgICAgICAgIHdEICs9IFwiK28rXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlEID0gZmxvYXQoZHlEQ29ybmVyICsgd0QpIC8gXCIrZStcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlEIDwgMC4wIHx8IGR5RCA+PSBcIit0Lm91dERlcHRoK1wiLjAgfHwgZnJhY3QoZHlEKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlEID0gaW50KGR5RCk7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIit1K1wiO1xcbiAgICAgICAgICAgICAgd1IgKz0gXCIrYStcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK24rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitjK1wiO1xcbiAgICAgICAgICAgICAgICB3QyArPSBcIitpK1wiKSB7XFxuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5RCwgaWR5UiwgaWR5QywgY2gpO1xcbiAgICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gXCIrZCtcIiAtXFxuICAgICAgICAgICAgICAgICAgaW50KGdldE1heFBvcyhiYXRjaCwgaWR5RCwgaWR5UiwgaWR5QywgY2gpKTtcXG5cXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcXG4gICAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cXG4gICAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9XFxuICAgICAgICAgICAgICAgICAgd0QgKiBcIit1K1wiICogXCIrYytcIiArXFxuICAgICAgICAgICAgICAgICAgd1IgKiBcIitjK1wiICsgd0M7XFxuICAgICAgICAgICAgICBmbG9hdCBtYXNrID0gZmxvYXQobWF4UG9zVmFsdWUgPT0gY3VyUG9zVmFsdWUgPyAxLjAgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxIaT1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpLHZvaWQgMD09PW8mJihvPSExKSx2b2lkIDA9PT1hJiYoYT1udWxsKSx2b2lkIDA9PT1pJiYoaT0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIm1hdHJpeEFcIixcIm1hdHJpeEJcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1lO3ZhciBzPW4/dFsxXTp0WzJdLHU9TWF0aC5jZWlsKHMvMiksYz1uP1wiaSAqIDIsIHJjLnlcIjpcInJjLnksIGkgKiAyXCIsbD1yP1wicmMueiwgaSAqIDJcIjpcImkgKiAyLCByYy56XCIsaD1uP1tcImEueHh5eVwiLFwiYS56end3XCJdOltcImEueHh6elwiLFwiYS55eXd3XCJdLGY9cj9bXCJiLnh6eHpcIixcImIueXd5d1wiXTpbXCJiLnh5eHlcIixcImIuend6d1wiXSxkPVwiXCIscD1cIlwiO2EmJihkPWk/XCJ2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XFxuICAgICAgICAgIHZlYzQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIithK1wiXFxuICAgICAgICB9XCI6XCJ2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XFxuICAgICAgICAgIFwiK2ErXCJcXG4gICAgICAgIH1cIixwPVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTt2YXIgdj1vP1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7byYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLGkmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrZCtcIlxcblxcbiAgICAgIGNvbnN0IGZsb2F0IHNoYXJlZERpbWVuc2lvbiA9IFwiK3UrXCIuMDtcXG5cXG4gICAgICB2ZWM0IGRvdDJ4MkFSb3dCQ29sKGl2ZWMzIHJjKSB7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3UrXCI7IGkrKykge1xcbiAgICAgICAgICB2ZWM0IGEgPSBnZXRNYXRyaXhBKHJjLngsIFwiK2MrXCIpO1xcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRNYXRyaXhCKHJjLngsIFwiK2wrXCIpO1xcblxcbiAgICAgICAgICAvLyBUaGVzZSBzd2l6emxlZCBwcm9kdWN0cyBuZWVkIHRvIGJlIHNlcGFyYXRlbHkgYWRkZWQuXFxuICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvMTczNVxcbiAgICAgICAgICByZXN1bHQgKz0gKFwiK2hbMF0rXCIgKiBcIitmWzBdK1wiKTtcXG4gICAgICAgICAgcmVzdWx0ICs9IChcIitoWzFdK1wiICogXCIrZlsxXStcIik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSBkb3QyeDJBUm93QkNvbChyYyk7XFxuXFxuICAgICAgICBcIit2K1wiXFxuXFxuICAgICAgICBcIitwK1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxxaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJwcm9ic1wiXSx0aGlzLm91dHB1dFNoYXBlPVt0LG5dLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuXFxuICAgICAgICBmbG9hdCByID0gcmFuZG9tKHNlZWQpO1xcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIisoZS0xKStcIjsgaSsrKSB7XFxuICAgICAgICAgIGNkZiArPSBnZXRQcm9icyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIGlmIChyIDwgY2RmKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGkpKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIElmIG5vIG90aGVyIGV2ZW50IGhhcHBlbmVkLCBsYXN0IGV2ZW50IGhhcHBlbmVkLlxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiKyhlLTEpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS5zZWVkTG9jJiYoZS5zZWVkTG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHIsXCJzZWVkXCIpKSxuLmdsLnVuaWZvcm0xZihlLnNlZWRMb2MsdCl9fSx0fSgpLEtpPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9W3QsZV0sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIityK1wiKSwgZmxvYXQoXCIrbitcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGppPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSExLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgZT10Lmxlbmd0aDtpZigwPT09ZSl0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2ZWM0KGdldEEoKSwgMC4sIDAuLCAwLikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2Vsc2V7dmFyIG49c2EoXCJyY1wiLGUpLHI9d2EoZSksbz1mdW5jdGlvbih0LGUsbil7aWYoMT09PXQpcmV0dXJuXCJyYyA+IFwiK2VbMF07Zm9yKHZhciByPVwiXCIsbz10LTI7bzx0O28rKylyKz1uW29dK1wiID49IFwiK2Vbb10sbzx0LTEmJihyKz1cInx8XCIpO3JldHVybiByfShlLHQsbiksYT1mdW5jdGlvbih0LGUsbixyKXtpZigxPT09dClyZXR1cm5cIlwiO3ZhciBvPXIuc2xpY2UoLTIpO3JldHVyblwiXFxuICAgIGludCByID0gXCIrb1swXStcIjtcXG4gICAgaW50IGMgPSBcIitvWzFdK1wiO1xcbiAgICBpbnQgcnAxID0gciArIDE7XFxuICAgIGludCBjcDEgPSBjICsgMTtcXG5cXG4gICAgYm9vbCBjRWRnZSA9IGNwMSA+PSBcIitlK1wiO1xcbiAgICBib29sIHJFZGdlID0gcnAxID49IFwiK24rXCI7XFxuICBcIn0oZSx0W3QubGVuZ3RoLTFdLHRbdC5sZW5ndGgtMl0sbiksaT1mdW5jdGlvbih0LGUpe3ZhciBuPXQubGVuZ3RoLHI9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W10scj0wO3I8PTE7cisrKWZvcih2YXIgbz0wO288PTE7bysrKXtmb3IodmFyIGE9KDA9PT1yP1wiclwiOlwicnAxXCIpK1wiLCBcIisoMD09PW8/XCJjXCI6XCJjcDFcIiksaT0yO2k8dDtpKyspYT1lW2UubGVuZ3RoLTEtaV0rXCIsXCIrYTtuLnB1c2goYSl9cmV0dXJuIG59KG4sZSk7cmV0dXJuIDE9PT1uP1wiZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49IFwiK3RbMF0rXCIgPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwXCI6XCJnZXRBKFwiK3JbMF0rXCIpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QShcIityWzFdK1wiKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoXCIrclsyXStcIiksXFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKFwiK3JbM10rXCIpXCJ9KHQsbik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIityK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICAgIGlmKFwiK28rXCIpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNCgwKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgXCIrYStcIlxcblxcbiAgICAgICAgICAgIHNldE91dHB1dCh2ZWM0KFwiK2krXCIpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIFwifX07dmFyIFhpPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPWUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl0rZVsxXX0pKTt2YXIgcj10Lmxlbmd0aCxvPXdhKHIpLGE9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpLmpvaW4oXCIsXCIpLGk9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXX0pKS5qb2luKFwiLFwiKSxzPVtcImNvb3Jkc1swXVwiLFwiY29vcmRzWzFdXCIsXCJjb29yZHNbMl1cIixcImNvb3Jkc1szXVwiXS5zbGljZSgwLHIpO3RoaXMudXNlckNvZGU9MSE9PXI/XCJcXG4gICAgICBcIitvK1wiIHN0YXJ0ID0gXCIrbytcIihcIithK1wiKTtcXG4gICAgICBcIitvK1wiIGVuZCA9IFwiK28rXCIoXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoYW55KGxlc3NUaGFuKG91dEMsIHN0YXJ0KSkgfHwgYW55KGdyZWF0ZXJUaGFuRXF1YWwob3V0QywgZW5kKSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIFwiK28rXCIgY29vcmRzID0gb3V0QyAtIHN0YXJ0O1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIitzK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIjpcIlxcbiAgICAgICAgaW50IHN0YXJ0ID0gXCIrYStcIjtcXG4gICAgICAgIGludCBlbmQgPSBcIitpK1wiO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0IHx8IG91dEMgPj0gZW5kKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChvdXRDIC0gc3RhcnQpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIFwifSxZaT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1lLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dK2VbMV19KSk7Zm9yKHZhciByPXQubGVuZ3RoLG89d2EociksYT1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSkuam9pbihcIixcIiksaT1lLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dfSkpLmpvaW4oXCIsXCIpLHM9c2EoXCJyY1wiLHIpLHU9c2EoXCJzb3VyY2VcIixyKSxjPXNbci0xXStcIiA8IFwiK3RoaXMub3V0cHV0U2hhcGVbci0xXSxsPTE9PT1yP1wic291cmNlXCI6XCJ2ZWMyKFwiK3Uuc2xpY2UoLTIpLmpvaW4oKStcIilcIixoPVtvK1wiIHJjID0gb3V0cHV0TG9jO1wiLHNbci0xXStcIiArPSAxO1xcbiAgICAgICBpZihcIitjK1wiKSB7XFxuICAgICAgXCIsMT09PXI/XCJcIjpcIn1cXG4gICAgICAgcmMgPSBvdXRwdXRMb2M7XFxuICAgICAgIFwiK3Nbci0yXStcIiArPSAxO1xcbiAgICAgICBpZihcIitzW3ItMl0rXCIgPCBcIit0aGlzLm91dHB1dFNoYXBlW3ItMl0rXCIpIHtcIiwxPT09cj9cIlwiOlwiICBcIitzW3ItMV0rXCIgKz0gMTtcXG4gICAgICAgICBpZihcIitjK1wiKSB7XCJdLGY9MT09PXI/XCJyYyA8IHN0YXJ0IHx8IHJjID49IGVuZFwiOlwiYW55KGxlc3NUaGFuKHJjLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKHJjLCBlbmQpKVwiLGQ9XCJcIixwPTAsdj0xPT09cj8yOjQ7cDx2O3ArKylkKz1cIlxcbiAgICAgICAgXCIraFtwXStcIlxcbiAgICAgICAgaWYgKFwiK2YrXCIpIHtcXG4gICAgICAgICAgcmVzdWx0W1wiK3ArXCJdID0gZmxvYXQoXCIrbitcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBcIitvK1wiIHNvdXJjZSA9IHJjIC0gc3RhcnQ7XFxuICAgICAgICAgIHJlc3VsdFtcIitwK1wiXSA9IGdldENoYW5uZWwoZ2V0WChcIit1LmpvaW4oKStcIiksIFwiK2wrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2QrPTE9PT1yP1wifSBcIjpcIn19XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IFwiK28rXCIgc3RhcnQgPSBcIitvK1wiKFwiK2ErXCIpO1xcbiAgICAgIGNvbnN0IFwiK28rXCIgZW5kID0gXCIrbytcIihcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIG91dHB1dExvYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIFwiK2QrXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LCRpPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSxcImF2Z1wiPT09ZSYmbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC5cIik7dmFyIHI9dC5maWx0ZXJXaWR0aCxvPXQuc3RyaWRlSGVpZ2h0LGE9dC5zdHJpZGVXaWR0aCxpPXQuZGlsYXRpb25IZWlnaHQscz10LmRpbGF0aW9uV2lkdGgsdT10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxjPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsbD10LnBhZEluZm8udG9wLGg9dC5wYWRJbmZvLmxlZnQ7dGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBmPVwiYXZnXCI9PT1lLGQ9XCIwLjBcIjtpZihmfHwoZD1cIi0xLjAgLyAxZS0yMFwiKSxuKXRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitvK1wiLCBcIithK1wiKTtcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitsK1wiLCBcIitoK1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcXG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcXG4gICAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIit1K1wiO1xcbiAgICAgICAgICAgICAgd1IgKz0gXCIraStcIikge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2MrXCI7XFxuICAgICAgICAgICAgICAgIHdDICs9IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gY3Vyck1pbk1heFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XFxuICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gd1IgKiBcIitjK1wiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2Vsc2V7dmFyIHA9ZStcIihcIitlK1wiKFwiK2UrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcImF2Z1wiPT09ZSYmKHA9XCJhdmdWYWx1ZSAvIGNvdW50XCIpO3ZhciB2PTQqTWF0aC5mbG9vcihyLzQpLG09ciU0LGc9XCJcXG4gICAgICBpZiAoXCIrZitcIikge1xcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gbWF4KHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitvK1wiLCBcIithK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrbCtcIiwgXCIraCtcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2QrXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGNvdW50ID0gMC4wO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhSLCBpbnQgeEMsIGludCBkKSB7XFxuICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvdW50ICs9IDEuMDtcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIrZCtcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG4gICAgICAgIGNvdW50ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIraStcIikge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrditcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitzK1wiO1xcblxcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAzICogXCIrcytcIiwgZClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiK3YrXCI7XFxuICAgICAgICAgIGlmIChcIisoMT09PW0pK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PW0pK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09bSkrXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIitwK1wiKTtcXG4gICAgICB9XFxuICAgIFwifX0sUWk9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLFwiYXZnXCI9PT1lJiZuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLlwiKTt2YXIgcj10LmZpbHRlcldpZHRoLG89dC5zdHJpZGVEZXB0aCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPXQuZGlsYXRpb25EZXB0aCx1PXQuZGlsYXRpb25IZWlnaHQsYz10LmRpbGF0aW9uV2lkdGgsbD10LmVmZmVjdGl2ZUZpbHRlckRlcHRoLGg9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsZj10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGQ9dC5wYWRJbmZvLmZyb250LHA9dC5wYWRJbmZvLnRvcCx2PXQucGFkSW5mby5sZWZ0O3RoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgbT1cImF2Z1wiPT09ZSxnPVwiMC4wXCI7aWYobXx8KGc9XCItMS4wIC8gMWUtMjBcIiksbil0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID1cXG4gICAgICAgICAgICBpdmVjMyhcIitvK1wiLCBcIithK1wiLCBcIitpK1wiKTtcXG4gICAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitkK1wiLCBcIitwK1wiLCBcIit2K1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgICAgaXZlYzMgeENvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4RENvcm5lciA9IHhDb3JuZXIueDtcXG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geENvcm5lci55O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4Q29ybmVyLno7XFxuXFxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCA/LCBjaCkgdG8gZ2V0IHkoeUQsIHlSLCB5QywgY2gpLlxcbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcXG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiK2wrXCI7XFxuICAgICAgICAgICAgICB3RCArPSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgaW50IHhEID0geERDb3JuZXIgKyB3RDtcXG5cXG4gICAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49IFwiK3QuaW5EZXB0aCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitoK1wiO1xcbiAgICAgICAgICAgICAgICB3UiArPSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2YrXCI7XFxuICAgICAgICAgICAgICAgICAgd0MgKz0gXCIrYytcIikge1xcbiAgICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WChiYXRjaCwgeEQsIHhSLCB4QywgY2gpO1xcblxcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1pbiAvIG1heCB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGZvdW5kLCB1c2UgaXQuIElmIG5vdCxcXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgbWluTWF4VmFsdWUsIG1pbk1heFZhbHVlRm91bmQpO1xcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gY3Vyck1pbk1heFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID1cXG4gICAgICAgICAgICAgICAgICAgICAgd0QgKiBcIitoK1wiICogXCIrZitcIiArXFxuICAgICAgICAgICAgICAgICAgICAgIHdSICogXCIrZitcIiArIHdDOztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtlbHNle3ZhciB5PWUrXCIoXCIrZStcIihcIitlK1wiKG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pXCI7XCJhdmdcIj09PWUmJih5PVwiYXZnVmFsdWUgLyBjb3VudFwiKTt2YXIgeD00Kk1hdGguZmxvb3Ioci80KSxiPXIlNCx3PVwiXFxuICAgICAgaWYgKFwiK20rXCIpIHtcXG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IG1heCh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID1cXG4gICAgICAgIGl2ZWMzKFwiK28rXCIsIFwiK2ErXCIsIFwiK2krXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitkK1wiLCBcIitwK1wiLCBcIit2K1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIrZytcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgeEQsIGludCB4UiwgaW50IHhDLCBpbnQgY2gpIHtcXG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgY291bnQgKz0gMS4wO1xcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgaXZlYzMgeENvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeERDb3JuZXIgPSB4Q29ybmVyLng7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4Q29ybmVyLnk7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4Q29ybmVyLno7XFxuXFxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgPywgZCkgdG8gZ2V0IHkoeUQsIHlSLCB5QywgY2gpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiK2crXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuICAgICAgICBjb3VudCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCBcIitsK1wiO1xcbiAgICAgICAgICAgIHdEICs9IFwiK3MrXCIpIHtcXG4gICAgICAgICAgaW50IHhEID0geERDb3JuZXIgKyB3RDtcXG5cXG4gICAgICAgICAgaWYgKHhEIDwgMCB8fCB4RCA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIraCtcIjtcXG4gICAgICAgICAgICB3UiArPSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIreCtcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2MrXCI7XFxuXFxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgXCIrYytcIiwgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIDIgKiBcIitjK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMyAqIFwiK2MrXCIsIGNoKVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIFwiK3crXCJcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyBcIit4K1wiO1xcbiAgICAgICAgICAgIGlmIChcIisoMT09PWIpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIit3K1wiXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWIpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgXCIrYytcIiwgY2gpLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgXCIrdytcIlxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1iKStcIikge1xcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIFwiK2MrXCIsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAyICogXCIrYytcIiwgY2gpLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgXCIrdytcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoXCIreStcIik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19LEppPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIG49dC53aW5kb3dTaXplLHI9dC5iYXRjaFNpemUsbz10LmluU2l6ZSxhPU1hdGguY2VpbChvL24pO3RoaXMub3V0cHV0U2hhcGU9W3IsYV07dmFyIGk9XCIwLjBcIixzPVwiXCI7XCJwcm9kXCI9PT1lP2k9XCIxLjBcIjpcIm1pblwiPT09ZT8oaT1cIjEuMCAvIDFlLTIwXCIscz1cIm1pblwiKTpcIm1heFwiPT09ZSYmKGk9XCItMS4wIC8gMWUtMjBcIixzPVwibWF4XCIpO3ZhciB1PWUrXCIoXCIrZStcIihcIitlK1wiKG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pXCI7XCJzdW1cIj09PWU/dT1cInN1bVZhbHVlXCI6XCJwcm9kXCI9PT1lP3U9XCJwcm9kVmFsdWVcIjpcImFsbFwiPT09ZT91PVwiYWxsVmFsdWVcIjpcImFueVwiPT09ZSYmKHU9XCJhbnlWYWx1ZVwiKTt2YXIgYz00Kk1hdGguZmxvb3Iobi80KSxsPW4lNCxoPVwiXFxuICAgICAgaWYgKFwiKyhcInN1bVwiPT09ZSkrXCIpIHtcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIrKFwicHJvZFwiPT09ZSkrXCIpIHtcXG4gICAgICAgIHZlYzIgdG1wID0gdmVjMih2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgKiB2ZWMyKHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcXG4gICAgICAgIHByb2RWYWx1ZSAqPSB0bXBbMF0gKiB0bXBbMV07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gXCIrcytcIih2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiLGY9XCJ2ZWM0XCI7XCJhbGxcIj09PWU/KGk9XCIxLjBcIixoPVwiXFxuICAgICAgICBib29sIHJlZHVjZWRBbGxWYWx1ZSA9IGFsbCh2YWx1ZXMpO1xcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbGxWYWx1ZSk7XFxuICAgICAgICBhbGxWYWx1ZSA9IGZsb2F0KGFsbFZhbHVlID49IDEuMCAmJiBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID49IDEuMCk7XFxuICAgICAgXCIsZj1cImJ2ZWM0XCIpOlwiYW55XCI9PT1lJiYoaT1cIjAuMFwiLGg9XCJcXG4gICAgICAgIGJvb2wgcmVkdWNlZEFueVZhbHVlID0gYW55KHZhbHVlcyk7XFxuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFueVZhbHVlID0gZmxvYXQocmVkdWNlZEFueVZhbHVlKTtcXG4gICAgICAgIGFueVZhbHVlID0gZmxvYXQoYW55VmFsdWUgPj0gMS4wIHx8IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPj0gMS4wKTtcXG4gICAgICBcIixmPVwiYnZlYzRcIik7dmFyIGQ9XCJcIjtvJW4+MCYmKGQ9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIitpK1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIrZCtcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIrbitcIjtcXG5cXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiK2krXCIpO1xcbiAgICAgICAgZmxvYXQgcHJvZFZhbHVlID0gMS4wO1xcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuICAgICAgICBmbG9hdCBhbGxWYWx1ZSA9IDEuMDtcXG4gICAgICAgIGZsb2F0IGFueVZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitjK1wiOyBpICs9IDQpIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xcbiAgICAgICAgICBcIitmK1wiIHZhbHVlcyA9IFwiK2YrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiK2MrXCI7XFxuICAgICAgICBpZiAoXCIrKDE9PT1sKStcIikge1xcbiAgICAgICAgICBcIitmK1wiIHZhbHVlcyA9IFwiK2YrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09bCkrXCIpIHtcXG4gICAgICAgICAgXCIrZitcIiB2YWx1ZXMgPSBcIitmK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1sKStcIikge1xcbiAgICAgICAgICBcIitmK1wiIHZhbHVlcyA9IFwiK2YrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIit1K1wiKTtcXG4gICAgICB9XFxuICAgIFwifSxaaT1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dDtmb3IodmFyIG49XCJcIixyPTA7cjw0O3IrKyl7dmFyIG89XCJ0aGlzUkMgPSByYztcIjtyJTI9PTEmJihvKz1cInRoaXNSQy56ICs9IDE7XCIpLHI+MSYmKG8rPVwidGhpc1JDLnkgKz0gMTtcIiksbis9XCJcXG4gICAgICAgIFwiK28rXCJcXG4gICAgICAgIFwiKyhyPjA/XCJpZih0aGlzUkMueSA8IHJvd3MgJiYgdGhpc1JDLnogPCBjb2xzKXtcIjpcIlwiKStcIlxcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KHRoaXNSQyk7XFxuXFxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0SW5kZXgpO1xcbiAgICAgICAgICB2ZWMyIGlucHV0UkNJbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XFxuXFxuICAgICAgICAgIHJlc3VsdFtcIityK1wiXSA9XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbChnZXRBKGlucHV0UkMueCwgaW5wdXRSQy55LCBpbnB1dFJDLnopLCBpbnB1dFJDSW5uZXJEaW1zKTtcXG4gICAgICAgIFwiKyhyPjA/XCJ9XCI6XCJcIikrXCJcXG4gICAgICBcIn10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xcbiAgICAgIFwiK2NhKFtcInJcIixcImNcIixcImRcIl0sZSkrXCJcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFxcbiAgICAgIFwiK2xhKHQpK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBpdmVjMyB0aGlzUkM7XFxuICAgICAgICBpbnQgcm93cyA9IFwiK3RbMV0rXCI7XFxuICAgICAgICBpbnQgY29scyA9IFwiK3RbMl0rXCI7XFxuXFxuICAgICAgICBcIituK1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifTt2YXIgdHM9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9ZS5zaGFwZTt2YXIgcj1lLnNoYXBlLG89clsxXSxhPXJbMl0saT10LnNoYXBlLHM9aVsxXSx1PWlbMl0sYz1bbiYmcz4xP28tMTpvLG4mJnU+MT9hLTE6YV0sbD1bbiYmcz4xP3MtMTpzLG4mJnU+MT91LTE6dV0saD1jWzBdL2xbMF0sZj1jWzFdL2xbMV0sZD0xL2gscD0xL2Ysdj0yKk1hdGguY2VpbChkKSsyLG09MipNYXRoLmNlaWwocCkrMjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIGZsb2F0IGFjY3VtdWxhdG9yID0gMC4wO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0U2NhbGUgPSBmbG9hdChcIitoK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IHdpZHRoU2NhbGUgPSBmbG9hdChcIitmK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGludkhlaWdodFNjYWxlID0gZmxvYXQoXCIrZCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZXaWR0aFNjYWxlID0gZmxvYXQoXCIrcCtcIik7XFxuXFxuICAgICAgICBjb25zdCBpbnQgd2luSGVpZ2h0ID0gaW50KFwiK3YrXCIpO1xcbiAgICAgICAgY29uc3QgaW50IHdpbldpZHRoID0gaW50KFwiK20rXCIpO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xcbiAgICAgICAgZmxvYXQgc3RhcnRSTGVycCA9IGZsb29yKGZsb2F0KHIpICogaW52SGVpZ2h0U2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5QyA9IGludChzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcXG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XFxuXFxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBkeFIgPSBmbG9hdChkeVIpICogaGVpZ2h0U2NhbGU7XFxuICAgICAgICAgICAgaW50IHRvcER4UkluZGV4ID0gaW50KGZsb29yKGR4UikpO1xcbiAgICAgICAgICAgIGludCBib3R0b21EeFJJbmRleCA9IGludChtaW4oY2VpbChkeFIpLCBcIisoby0xKStcIi4wKSk7XFxuICAgICAgICAgICAgZmxvYXQgZHhSTGVycCA9IGR4UiAtIGZsb2F0KHRvcER4UkluZGV4KTtcXG4gICAgICAgICAgICBmbG9hdCBpbnZlcnNlRHhSTGVycCA9IDEuMCAtIGR4UkxlcnA7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHhDID0gZmxvYXQoZHlDKSAqIHdpZHRoU2NhbGU7XFxuICAgICAgICAgICAgaW50IGxlZnREeENJbmRleCA9IGludChmbG9vcihkeEMpKTtcXG4gICAgICAgICAgICBpbnQgcmlnaHREeENJbmRleCA9IGludChtaW4oY2VpbChkeEMpLCBcIisoYS0xKStcIi4wKSk7XFxuICAgICAgICAgICAgZmxvYXQgZHhDTGVycCA9IGR4QyAtIGZsb2F0KGxlZnREeENJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4Q0xlcnAgPSAxLjAgLSBkeENMZXJwO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BMZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPVxcbiAgICAgICAgICAgICAgICBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcFJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21MZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcXG4gICAgICB9XFxuICAgIFwifSxlcz1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBvPXRbMF0sYT10WzFdLGk9dFsyXSxzPXRbM107dGhpcy5vdXRwdXRTaGFwZT1bbyxlLG4sc107dmFyIHU9W3ImJmU+MT9hLTE6YSxyJiZuPjE/aS0xOmldLGM9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIit1WzBdL2NbMF0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vY1sxXStcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiK2ErXCIuMCwgXCIraStcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMiBzb3VyY2VGbG9vclJDID0gaXZlYzIoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuXFxuICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcblxcbiAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifSxucz1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBvPXRbMF0sYT10WzFdLGk9dFsyXSxzPXRbM107dGhpcy5vdXRwdXRTaGFwZT1bbyxlLG4sc107dmFyIHU9W3ImJmU+MT9hLTE6YSxyJiZuPjE/aS0xOmldLGM9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMzIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMzKFxcbiAgICAgICAgICBcIit1WzBdL2NbMF0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vY1sxXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9jWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMzIGlucHV0U2hhcGVSQyA9IHZlYzMoXCIrYStcIi4wLCBcIitpK1wiLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiK2krXCIuMCk7XFxuXFxuICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCBiLCBpbnQgciwgaW50IGMsIGludCBkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKGIsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlcyBmb3IgbmV4dCBjb2x1bW4gaW4geVJDLnouXFxuICAgICAgICBpdmVjMyB5UkMgPSBjb29yZHMueXp6ICsgaXZlYzMoMCwgMCwgMSk7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzMgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMzKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMyBzb3VyY2VGbG9vclJDID0gaXZlYzMoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzMgc291cmNlQ2VpbFJDID0gaXZlYzMoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuXFxuICAgICAgICAvLyBTaG91bGQgd2UgY2FsY3VsYXRlIG5leHQgY29sdW1uIGFuZCByb3cgZWxlbWVudHMgaW4gMngyIHBhY2tlZCBjZWxsLlxcbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gZCA8IFwiKyhzLTEpK1wiO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gY29vcmRzLnogPCBcIisobi0xKStcIjtcXG5cXG4gICAgICAgIC8vIEluIHBhcmFsbGVsLCBjb25zdHJ1Y3QgZm91ciBjb3JuZXJzIGZvciBhbGwgZm91ciBjb21wb25lbnRzIGluXFxuICAgICAgICAvLyBwYWNrZWQgMngyIGNlbGwuXFxuICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IHRvcFJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzQgYm90dG9tUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWMzIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMyhzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBmcmFjUkMueXl6eik7XFxuICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgZnJhY1JDLnl5enopO1xcbiAgICAgICAgdmVjNCBuZXdWYWx1ZSA9IG1peCh0b3AsIGJvdHRvbSwgZnJhY1JDLngpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifSxycz1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLnNoYXBlO3ZhciByPWUuc2hhcGUsbz1yWzFdLGE9clsyXSxpPXQuc2hhcGUscz1pWzFdLHU9aVsyXSxjPVtuJiZzPjE/by0xOm8sbiYmdT4xP2EtMTphXSxsPVtuJiZzPjE/cy0xOnMsbiYmdT4xP3UtMTp1XSxoPWNbMF0vbFswXSxmPWNbMV0vbFsxXSxkPTEvaCxwPTEvZix2PTIqTWF0aC5jZWlsKGQpKzIsbT0yKk1hdGguY2VpbChwKSsyO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2grXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KFwiK2YrXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIitkK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdChcIitwK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIrditcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIrbStcIik7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXFxuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeVIgPSBpbnQoZmxvb3Ioc3RhcnRSTGVycCAtIGZsb2F0KHdpbkhlaWdodCAvIDIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5QyA9IGludChmbG9vcihzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSkpO1xcblxcbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XFxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XFxuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcXG5cXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY1JvdyA9XFxuICAgICAgICAgICAgICBmbG9hdChcIitjWzBdK1wiKSAqXFxuICAgICAgICAgICAgICAgIChmbG9hdChkeVIpIC8gZmxvYXQoXCIrbFswXStcIikpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNDb2wgPVxcbiAgICAgICAgICAgICAgICBmbG9hdChcIitjWzFdK1wiKSAqXFxuICAgICAgICAgICAgICAgICAgKGZsb2F0KGR5QykgLyBmbG9hdChcIitsWzFdK1wiKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RSb3cgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIrbytcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrbitcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNSb3cpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNSb3cpKSkpO1xcblxcbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Q29sID0gaW50KG1pbihcXG4gICAgICAgICAgICAgICAgZmxvYXQoaW50KFwiK2ErXCIpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiK24rXCIgPyBmbG9hdChyb3VuZChzb3VyY2VGcmFjQ29sKSkgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdChmbG9vcihzb3VyY2VGcmFjQ29sKSkpKTtcXG5cXG4gICAgICAgICAgICBpZiAociA9PSBzb3VyY2VOZWFyZXN0Um93ICYmIGMgPT0gc291cmNlTmVhcmVzdENvbCkge1xcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcXG4gICAgICB9XFxuICAgIFwifSxvcz1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBvPXRbMF0sYT10WzFdLGk9dFsyXSxzPXRbM107dGhpcy5vdXRwdXRTaGFwZT1bbyxlLG4sc107dmFyIHU9W3ImJmU+MT9hLTE6YSxyJiZuPjE/aS0xOmldLGM9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGw9cj9cIjAuNVwiOlwiMC4wXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiK3VbMF0vY1swXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9jWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIrYStcIi4wLCBcIitpK1wiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZU5lYXJlc3RSQyA9IGl2ZWMyKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBmbG9vcihzb3VyY2VGcmFjSW5kZXhSQyArIFwiK2wrXCIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEEoYiwgc291cmNlTmVhcmVzdFJDLngsIHNvdXJjZU5lYXJlc3RSQy55LCBkKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn0sYXM9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTt2YXIgbj10Lmxlbmd0aDtpZihuPjQpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLVwiK24rXCIgdGVuc29yIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKHRoaXMub3V0cHV0U2hhcGU9dCwxIT09bil7dmFyIHI9dC5tYXAoKGZ1bmN0aW9uKG4scil7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybi0xIT09ZS5pbmRleE9mKG4pJiYxIT09dFtuXT90W25dK1wiIC0gY29vcmRzW1wiK24rXCJdIC0gMVwiOlwiY29vcmRzW1wiK24rXCJdXCJ9KHIpfSkpLmpvaW4oXCIsXCIpLG89d2Eobik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIityK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1lbHNlIHRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaW50IGNvb3JkID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKFwiK3RbMF0rXCIgLSBjb29yZCAtIDEpKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn0saXM9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMDt2YXIgbj10Lmxlbmd0aDtpZihuPjQpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLVwiK24rXCIgdGVuc29yIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgcj1zYShcInJjXCIsbiksbz1yW24tMV0rXCIgKyAxIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtuLTFdLGE9cltuLTJdK1wiICsgMSA8IFwiK3RoaXMub3V0cHV0U2hhcGVbbi0yXSxpPXdhKG4pO2Z1bmN0aW9uIHMobil7dmFyIHI9dC5tYXAoKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIGZ1bmN0aW9uKG4scil7cmV0dXJuLTEhPT1lLmluZGV4T2YobikmJjEhPT10W25dP3Rbbl0rXCIgLSBcIityW25dK1wiIC0gMVwiOlwiXCIrcltuXX0obyxuKX0pKTtyZXR1cm5cImdldENoYW5uZWwoZ2V0WChcIityLmpvaW4oXCIsXCIpK1wiKSwgdmVjMihcIityLnNsaWNlKC0yKS5qb2luKFwiLFwiKStcIikpXCJ9dGhpcy51c2VyQ29kZT0xPT09bj9cIlxcbiAgICAgICAgdm9pZCBtYWluKCl7XFxuICAgICAgICAgIGludCByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgICByZXN1bHQuciA9IGdldENoYW5uZWwoZ2V0WChcIit0WzBdK1wiIC0gcmMgLSAxKSxcXG4gICAgICAgICAgICBcIit0WzBdK1wiIC0gcmMgLSAxKTtcXG4gICAgICAgICAgaWYoXCIrbytcIil7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldENoYW5uZWwoZ2V0WChcIit0WzBdK1wiIC0gKHJjICArIDEpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiK3RbMF0rXCIgLSAocmMgICsgMSkgLSAxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjpcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIitpK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICAgIHJlc3VsdC5yID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgIGlmKFwiK28rXCIpe1xcbiAgICAgICAgICAgIHJlc3VsdC5nID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHRbbi0xXT1cIihcIit0W24tMV0rXCIgKyAxKVwiLHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYoXCIrYStcIikge1xcbiAgICAgICAgICAgIHJlc3VsdC5iID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHRbbi0yXT1cIihcIit0W24tMl0rXCIgKyAxKVwiLHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgICAgaWYoXCIrbytcIikge1xcbiAgICAgICAgICAgICAgcmVzdWx0LmEgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTFdPVwiKFwiK3Rbbi0xXStcIiArIDEpXCIsdFtuLTJdPVwiKFwiK3Rbbi0yXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgICB9XFxuICAgIFwifSxzcz1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT0hMCksdGhpcy52YXJpYWJsZU5hbWVzPVtcInVwZGF0ZXNcIixcImluZGljZXNcIixcImRlZmF1bHRWYWx1ZVwiXSx0aGlzLm91dHB1dFNoYXBlPWE7dmFyIHM9d2Eoby5sZW5ndGgpLHU9d2EoYS5sZW5ndGgpLGM9XCJcIjsxPT09bj9jPVwiaVwiOjI9PT1uJiYoYz1cImksIGpcIik7dmFyIGw9XCJnZXRJbmRpY2VzKFwiK2MrXCIpXCIsaD1cIlwiOzE9PT1yP2g9XCJpXCI6Mj09PXImJihoPVwiaSwgY29vcmRzWzFdXCIpO3ZhciBmPVwiZ2V0VXBkYXRlcyhcIitoK1wiKVwiLGQ9ZT4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIFwiK3MrXCIgc3RyaWRlcyA9IFwiK3MrXCIoXCIrbytcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK3UrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgICAgYm9vbCBmb3VuZCA9IGZhbHNlO1xcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3QrXCI7IGkrKykge1xcbiAgICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IDA7XFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIitlK1wiOyBqKyspIHtcXG4gICAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKFwiK2wrXCIpO1xcbiAgICAgICAgICAgICAgZmxhdHRlbmVkSW5kZXggKz0gaW5kZXggKiBcIitkK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoZmxhdHRlbmVkSW5kZXggPT0gY29vcmRzWzBdKSB7XFxuICAgICAgICAgICAgICBzdW0gKz0gXCIrZitcIjtcXG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KG1peChnZXREZWZhdWx0VmFsdWUoKSwgc3VtLCBmbG9hdChmb3VuZCkpKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn0sdXM9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwic2VnbWVudElkc1wiXTt2YXIgbj10LndpbmRvd1NpemUscj10LmJhdGNoU2l6ZSxvPXQuaW5TaXplLGE9dC5udW1TZWdtZW50cyxpPWEqTWF0aC5jZWlsKG8vbik7dGhpcy5vdXRwdXRTaGFwZT1bcixpXTt2YXIgcz00Kk1hdGguZmxvb3Iobi80KSx1PW4lNCxjPVwiXFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBzZWdGaWx0ZXIpO1xcbiAgICBcIixsPVwiXCI7byVuPjAmJihsPVwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiK28rXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgXCIpO3ZhciBoPVwiXCI7byVuPjAmJihoPVwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiK28rXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIC0xLjA7XFxuICAgICAgICB9XFxuICAgICAgXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gMC4wO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIitsK1wiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBnZXRTZWdtZW50SWRBdEluZGV4KGludCBpbklkeCkge1xcbiAgICAgICAgXCIraCtcIlxcbiAgICAgICAgcmV0dXJuIGdldFNlZ21lbnRJZHMoaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBpbnQoZmxvb3IoZmxvYXQob3V0SWR4KSAvIGZsb2F0KFxcbiAgICAgICAgICBcIithK1wiKSkgKiBmbG9hdChcIituK1wiKSk7XFxuICAgICAgICBpbnQgY3VycmVudFNlZyA9IGludChtb2QoZmxvYXQob3V0SWR4KSwgZmxvYXQoXCIrYStcIikpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitzK1wiOyBpICs9IDQpIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMikpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDMpKSA9PSBjdXJyZW50U2VnID8gMSA6IDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBcIitzK1wiO1xcbiAgICAgICAgaWYgKFwiKygxPT09dSkrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgaW50IGluSWR4U2VnID0gaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2MrXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgICAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2MrXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHN1bVZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifSxjcz1mdW5jdGlvbih0LGUsbil7dmFyIHIsbztpZih0aGlzLnZhcmlhYmxlTmFtZXM9W1wiY1wiLFwiYVwiLFwiYlwiXSx0aGlzLm91dHB1dFNoYXBlPWUsbj40KXRocm93IEVycm9yKFwiV2hlcmUgZm9yIHJhbmsgXCIrbitcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09bilvPVwicmVzUkNcIixyPVwicmVzUkNcIjtlbHNle2Zvcih2YXIgYT1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCJdLGk9W10scz1bXSx1PTA7dTxlLmxlbmd0aDt1Kyspcy5wdXNoKFwiXCIrYVt1XSksdTx0JiZpLnB1c2goXCJcIithW3VdKTtyPWkuam9pbigpLG89cy5qb2luKCl9dmFyIGM9d2Eobik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2MrXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGNWYWwgPSBnZXRDKFwiK3IrXCIpO1xcbiAgICAgICAgaWYgKGNWYWwgPj0gMS4wKSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRBKFwiK28rXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRCKFwiK28rXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwifSxscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInNvdXJjZVwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5yYW5rPXQubGVuZ3RoO3ZhciBlLG49d2EodGhpcy5yYW5rKSxyPVwidW5pZm9ybSBpbnQgc3RhcnRbXCIrdGhpcy5yYW5rK1wiXTtcIixvPWZ1bmN0aW9uKHQpe2lmKDE9PT10KXJldHVyblwic291cmNlTG9jXCI7aWYodDw9NilyZXR1cm4gaHMuc2xpY2UoMCx0KS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwic291cmNlTG9jLlwiK3R9KSkuam9pbihcIixcIik7dGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9KHRoaXMucmFuayk7ZT1cIlxcbiAgICAgICAgXCIrbitcIiBzb3VyY2VMb2M7XFxuICAgICAgICBcIituK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIrdC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJzb3VyY2VMb2MuXCIraHNbZV0rXCIgPSBzdGFydFtcIitlK1wiXSArIGNvb3Jkcy5cIitoc1tlXStcIjtcIn0pKS5qb2luKFwiXFxuXCIpK1wiXFxuICAgICAgXCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3IrXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKFwiK28rXCIpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0Lmxlbmd0aCE9PXRoaXMucmFuayl0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIit0aGlzLnJhbmsrXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBzdGFydCAoXCIrdC5sZW5ndGgrXCIpXCIpO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc3RhcnRMb2MmJihlLnN0YXJ0TG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwic3RhcnRcIiksbnVsbD09ZS5zdGFydExvYyl8fG4uZ2wudW5pZm9ybTFpdihlLnN0YXJ0TG9jLHQpfX0sdH0oKSxocz1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdO3ZhciBmcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInNvdXJjZVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5yYW5rPXQubGVuZ3RoO3ZhciBlPXdhKHRoaXMucmFuayksbj1zYShcImNvb3Jkc1wiLHRoaXMucmFuaykscj1zYShcInNvdXJjZUxvY1wiLHRoaXMucmFuayksbz0xPT09dGhpcy5yYW5rP1wic291cmNlTG9jXCI6XCJ2ZWMyKFwiK3Iuc2xpY2UoLTIpLmpvaW4oKStcIilcIixhPVwiZ2V0Q2hhbm5lbChnZXRTb3VyY2UoXCIrci5qb2luKCkrXCIpLCBcIitvK1wiKVwiLGk9XCJcXG4gICAgICByZXN1bHQueCA9IFwiK2ErXCI7XFxuICAgICAgaWYgKCsrXCIrblt0aGlzLnJhbmstMV0rXCIgPCBcIit0W3RoaXMucmFuay0xXStcIikge1xcbiAgICAgICAgKytcIityW3RoaXMucmFuay0xXStcIjtcXG4gICAgICAgIHJlc3VsdC55ID0gXCIrYStcIjtcXG4gICAgICAgIC0tXCIrclt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgfVxcbiAgICBcIixzPTE9PT10aGlzLnJhbms/XCJcIjpcIlxcbiAgICAgIC0tXCIrblt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgaWYgKCsrXCIrblt0aGlzLnJhbmstMl0rXCIgPCBcIit0W3RoaXMucmFuay0yXStcIikge1xcbiAgICAgICAgKytcIityW3RoaXMucmFuay0yXStcIjtcXG4gICAgICAgIHJlc3VsdC56ID0gXCIrYStcIjtcXG4gICAgICAgIGlmICgrK1wiK25bdGhpcy5yYW5rLTFdK1wiIDwgXCIrdFt0aGlzLnJhbmstMV0rXCIpIHtcXG4gICAgICAgICAgKytcIityW3RoaXMucmFuay0xXStcIjtcXG4gICAgICAgICAgcmVzdWx0LncgPSBcIithK1wiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCIsdT10aGlzLnJhbms8PTQ/XCJzb3VyY2VMb2MgPSBjb29yZHMgK1xcbiAgICAgICAgICAgIFwiK2UrXCIoXCIrdC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJzdGFydFtcIitlK1wiXVwifSkpLmpvaW4oKStcIik7XCI6dC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJbZV0rXCIgPSBcIituW2VdK1wiICsgc3RhcnRbXCIrZStcIl07XCJ9KSkuam9pbihcIlxcblwiKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBpbnQgc3RhcnRbXCIrdGhpcy5yYW5rK1wiXTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitlK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIrZStcIiBzb3VyY2VMb2M7XFxuICAgICAgICBcIit1K1wiXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgXCIraStcIlxcbiAgICAgICAgXCIrcytcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYodC5sZW5ndGghPT10aGlzLnJhbmspdGhyb3cgRXJyb3IoXCJUaGUgcmFuayAoXCIrdGhpcy5yYW5rK1wiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2Ygc3RhcnQgKFwiK3QubGVuZ3RoK1wiKVwiKTtyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnN0YXJ0TG9jJiYoZS5zdGFydExvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cocixcInN0YXJ0XCIpLG51bGw9PWUuc3RhcnRMb2MpfHxuLmdsLnVuaWZvcm0xaXYoZS5zdGFydExvYyx0KX19LHR9KCksZHM9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9bjt2YXIgcj1uLmxlbmd0aCxvPXdhKG4ubGVuZ3RoKSxhPXdhKG4ubGVuZ3RoKSxpPVwiXCI7aWYoMT09PXIpaT1cImNvb3JkcyAqIHN0cmlkZXMgKyBiZWdpblwiO2Vsc2V7dmFyIHM9MDtpPW4ubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBzKyssMT09PW4ubGVuZ3RoP1wiY29vcmRzICogc3RyaWRlc1tcIitlK1wiXSArIGJlZ2luW1wiK2UrXCJdXCI6XCJjb29yZHNbXCIrKHMtMSkrXCJdICogc3RyaWRlc1tcIitlK1wiXSArIGJlZ2luW1wiK2UrXCJdXCJ9KSkuam9pbihcIixcIil9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK28rXCIgYmVnaW4gPSBcIitvK1wiKFwiK3QrXCIpO1xcbiAgICAgIFwiK28rXCIgc3RyaWRlcyA9IFwiK28rXCIoXCIrZStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrYStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiK2krXCIpKTtcXG4gICAgICB9XFxuICAgIFwifSxwcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5ncGdwdT10LHRoaXMubnVtVXNlZFRleHR1cmVzPTAsdGhpcy5udW1GcmVlVGV4dHVyZXM9MCx0aGlzLmZyZWVUZXh0dXJlcz17fSx0aGlzLmxvZ0VuYWJsZWQ9ITEsdGhpcy51c2VkVGV4dHVyZXM9e319cmV0dXJuIHQucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPXZzKGUsbiksYT1tcyh0LG8sbik7aWYoYSBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW2FdPVtdKSxhIGluIHRoaXMudXNlZFRleHR1cmVzfHwodGhpcy51c2VkVGV4dHVyZXNbYV09W10pLHRoaXMuZnJlZVRleHR1cmVzW2FdLmxlbmd0aD4wKXt0aGlzLm51bUZyZWVUZXh0dXJlcy0tLHRoaXMubnVtVXNlZFRleHR1cmVzKyssdGhpcy5sb2coKTt2YXIgaT10aGlzLmZyZWVUZXh0dXJlc1thXS5zaGlmdCgpO3JldHVybiB0aGlzLnVzZWRUZXh0dXJlc1thXS5wdXNoKGkpLGl9cmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzKyssdGhpcy5sb2coKSxvPT09R3QuUEFDS0VEXzJYMl9GTE9BVDMyP3I9dGhpcy5ncGdwdS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PUd0LlBBQ0tFRF8yWDJfRkxPQVQxNj9yPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09R3QuVU5QQUNLRURfRkxPQVQzMj9yPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09R3QuVU5QQUNLRURfRkxPQVQxNj9yPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09R3QuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFJiYocj10aGlzLmdwZ3B1LmNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSkpLHRoaXMudXNlZFRleHR1cmVzW2FdLnB1c2gocikscn0sdC5wcm90b3R5cGUucmVsZWFzZVRleHR1cmU9ZnVuY3Rpb24odCxlLG4scil7aWYobnVsbCE9dGhpcy5mcmVlVGV4dHVyZXMpe3ZhciBvPW1zKGUsdnMobixyKSxyKTtvIGluIHRoaXMuZnJlZVRleHR1cmVzfHwodGhpcy5mcmVlVGV4dHVyZXNbb109W10pLHRoaXMuZnJlZVRleHR1cmVzW29dLnB1c2godCksdGhpcy5udW1GcmVlVGV4dHVyZXMrKyx0aGlzLm51bVVzZWRUZXh0dXJlcy0tO3ZhciBhPXRoaXMudXNlZFRleHR1cmVzW29dLGk9YS5pbmRleE9mKHQpO2lmKGk8MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVsZWFzZSBhIHRleHR1cmUgdGhhdCB3YXMgbmV2ZXIgcHJvdmlkZWQgYnkgdGhpcyB0ZXh0dXJlIG1hbmFnZXJcIik7YS5zcGxpY2UoaSwxKSx0aGlzLmxvZygpfX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKCl7aWYodGhpcy5sb2dFbmFibGVkKXt2YXIgdD10aGlzLm51bUZyZWVUZXh0dXJlcyt0aGlzLm51bVVzZWRUZXh0dXJlcztjb25zb2xlLmxvZyhcIkZyZWUvVXNlZFwiLHRoaXMubnVtRnJlZVRleHR1cmVzK1wiIC8gXCIrdGhpcy5udW1Vc2VkVGV4dHVyZXMsXCIoXCIrdCtcIilcIil9fSx0LnByb3RvdHlwZS5nZXROdW1Vc2VkVGV4dHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXN9LHQucHJvdG90eXBlLmdldE51bUZyZWVUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlc30sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYobnVsbCE9dGhpcy5mcmVlVGV4dHVyZXMpe2Zvcih2YXIgZSBpbiB0aGlzLmZyZWVUZXh0dXJlcyl0aGlzLmZyZWVUZXh0dXJlc1tlXS5mb3JFYWNoKChmdW5jdGlvbihlKXt0LmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoZSl9KSk7Zm9yKHZhciBlIGluIHRoaXMudXNlZFRleHR1cmVzKXRoaXMudXNlZFRleHR1cmVzW2VdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZShlKX0pKTt0aGlzLmZyZWVUZXh0dXJlcz1udWxsLHRoaXMudXNlZFRleHR1cmVzPW51bGwsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wfX0sdH0oKTtmdW5jdGlvbiB2cyh0LGUpe2lmKHQ9PT16dC5VUExPQUQpcmV0dXJuIEd0LlBBQ0tFRF8yWDJfRkxPQVQzMjtpZih0PT09enQuUkVOREVSfHxudWxsPT10KXJldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gaSgpLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpP3Q/R3QuUEFDS0VEXzJYMl9GTE9BVDMyOkd0LlVOUEFDS0VEX0ZMT0FUMzI6dD9HdC5QQUNLRURfMlgyX0ZMT0FUMTY6R3QuVU5QQUNLRURfRkxPQVQxNn0oZSk7aWYodD09PXp0LkRPV05MT0FEfHx0PT09enQuUElYRUxTKXJldHVybiBHdC5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBsb2dpY2FsIHRleHR1cmUgdHlwZSBcIit0KX1mdW5jdGlvbiBtcyh0LGUsbil7cmV0dXJuIHRbMF0rXCJfXCIrdFsxXStcIl9cIitlK1wiX1wiK259dmFyIGdzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtyXSplW3JdO3RoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGg7dmFyIG89d2EodGhpcy5yYW5rKSxhPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU+NSl0aHJvdyBFcnJvcihcIlRpbGUgZm9yIHJhbmsgXCIrZStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09ZSlyZXR1cm5cImltb2QocmVzUkMsIFwiK3RbMF0rXCIpXCI7Zm9yKHZhciBuPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIl0scj1bXSxvPTA7bzx0Lmxlbmd0aDtvKyspci5wdXNoKFwiaW1vZChcIituW29dK1wiLCBcIit0W29dK1wiKVwiKTtyZXR1cm4gci5qb2luKCl9KHQpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIithK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn07dmFyIHlzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtlW3JdXTt0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoO3ZhciBvPXdhKHRoaXMucmFuayksYT1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPjYpdGhyb3cgRXJyb3IoXCJUcmFuc3Bvc2UgZm9yIHJhbmsgXCIrZStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtmb3IodmFyIG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiLFwicmVzUkMudlwiXSxyPW5ldyBBcnJheShlKSxvPTA7bzx0Lmxlbmd0aDtvKyspclt0W29dXT1uW29dO3JldHVybiByLmpvaW4oKX0oZSk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgfVxcbiAgICBcIn07dmFyIHhzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtlW3JdXTtpZih0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoLHRoaXMucmFuaz42KXRocm93IEVycm9yKFwiUGFja2VkIHRyYW5zcG9zZSBmb3IgcmFuayBcIit0aGlzLnJhbmsrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuXCIpO3ZhciBvPXdhKHRoaXMucmFuayksYT1pYShcInJjXCIsdGhpcy5yYW5rKSxpPW5ldyBBcnJheSh0aGlzLnJhbmspO2ZvcihyPTA7cjxlLmxlbmd0aDtyKyspaVtlW3JdXT1hW3JdO3ZhciBzPVwidmVjMihcIitpLnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsdT1cIisrXCIrYVt0aGlzLnJhbmstMV0rXCIgPCBcIituW3RoaXMucmFuay0xXSxjPVwiZ2V0Q2hhbm5lbChnZXRBKFwiK2kuam9pbigpK1wiKSwgXCIrcytcIilcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIitvK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICByZXN1bHRbMF0gPSBcIitjK1wiO1xcbiAgICAgIGlmKFwiK3UrXCIpIHtcXG4gICAgICAgIHJlc3VsdFsxXSA9IFwiK2MrXCI7XFxuICAgICAgfVxcbiAgICAgIC0tXCIrYVt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgaWYoKytcIithW3RoaXMucmFuay0yXStcIiA8IFwiK25bdGhpcy5yYW5rLTJdK1wiKSB7XFxuICAgICAgICByZXN1bHRbMl0gPSBcIitjK1wiO1xcbiAgICAgICAgaWYoXCIrdStcIikge1xcbiAgICAgICAgICByZXN1bHRbM10gPSBcIitjK1wiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgfVxcbiAgICBcIn0sYnM9MS43NTgwOTkzNDA4NDczNzY4LHdzPTEuMDUwNzAwOTg3MzU1NDgwNSxDcz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgdW5hcnlPcGVyYXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIn0sRXM9XCJpZiAoaXNuYW4oeCkpIHJldHVybiB4O1wiLFJzPVwicmV0dXJuIHg7XCIsSXM9XCJyZXR1cm4gYWJzKHgpO1wiLGtzPUVzK1wiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogeDtcXG5cIixTcz1FcytcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IG1pbig2LjAsIHgpO1xcblwiLEFzPVwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCIsRHM9XCJcXG4gIC8vIFN0YWJsZSBhbmQgQXR0cmFjdGluZyBGaXhlZCBQb2ludCAoMCwgMSkgZm9yIE5vcm1hbGl6ZWQgV2VpZ2h0cy5cXG4gIC8vIHNlZTogaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDI1MTVcXG4gIGZsb2F0IHNjYWxlQWxwaGEgPSBcIiticytcIjtcXG4gIGZsb2F0IHNjYWxlID0gXCIrd3MrXCI7XFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHNjYWxlICogeCA6IHNjYWxlQWxwaGEgKiAoZXhwKHgpIC0gMS4wKTtcXG5cIjt2YXIgVHM9XCJyZXR1cm4gLXg7XCIsTnM9XCJyZXR1cm4gY2VpbCh4KTtcIixGcz1cInJldHVybiBmbG9vcih4KTtcIixfcz1cInJldHVybiBleHAoeCk7XCIsT3M9XCJyZXR1cm4gZXhwKHgpIC0gMS4wO1wiLE1zPUVzK1wiXFxuICByZXR1cm4gc2luKHgpO1xcblwiLEJzPUVzK1wiXFxuICByZXR1cm4gY29zKHgpO1xcblwiLFBzPUVzK1wiXFxuICBpZiAoYWJzKHgpID4gMS4pIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIHJldHVybiBhc2luKHgpO1xcblwiLExzPUVzK1wiXFxuICBpZiAoYWJzKHgpID4gMS4pIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIHJldHVybiBhY29zKHgpO1xcblwiLFdzPUVzK1wiXFxuICByZXR1cm4gYXRhbih4KTtcXG5cIixVcz1FcytcInJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxLjApKTtcIixWcz1FcytcIlxcbiAgaWYgKHggPCAxLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMS4wKSk7XCIsenM9RXMrXCJcXG4gIGlmICgoeCA8IC0xLjApIHx8ICh4ID4gMS4wKSkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiAobG9nKDEuMCArIHgpIC0gbG9nKDEuMCAtIHgpKSAvIDIuMDtcIixHcz1cInJldHVybiB4O1wiLEhzPVwicmV0dXJuIHg7XCIscXM9XCJcXG4gIHZlYzQgcmVzdWx0ID0geCAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcXG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XFxuXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsS3M9XCJcXG4gIHZlYzQgcmVzdWx0ID0gbWluKHgsIHZlYzQoNi4pKSAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcXG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XFxuXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsanM9XCJcXG4gIHZlYzQgcmVzdWx0O1xcblxcbiAgcmVzdWx0LnIgPSAoeC5yID49IDAuMCkgPyB4LnIgOiAoZXhwKHgucikgLSAxLjApO1xcbiAgcmVzdWx0LmcgPSAoeC5nID49IDAuMCkgPyB4LmcgOiAoZXhwKHguZykgLSAxLjApO1xcbiAgcmVzdWx0LmIgPSAoeC5iID49IDAuMCkgPyB4LmIgOiAoZXhwKHguYikgLSAxLjApO1xcbiAgcmVzdWx0LmEgPSAoeC5hID49IDAuMCkgPyB4LmEgOiAoZXhwKHguYSkgLSAxLjApO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixYcz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdmVjNCB1bmFyeU9wZXJhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwifSxZcz1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMSx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGU9dC5sZW5ndGgsbj1zYShcInJjXCIsZSkscj13YShlKSxvPWZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2Zvcih2YXIgbj1cIlwiLHI9MDtyPHQ7cisrKW4rPWVbcl0scjx0LTEmJihuKz1cIixcIik7cmV0dXJuIG59KGUsbiksYT1uLnNsaWNlKC0yKSxpPWU8PTE/XCJyY1wiOlwidmVjMihcIithLmpvaW4oXCIsXCIpK1wiKVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIityK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QShcIitvK1wiKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChnZXRDaGFubmVsKHBhY2tlZElucHV0LCBcIitpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn0sJHM9e307ZnVuY3Rpb24gUXModCxlKXtpZih2b2lkIDA9PT1lJiYoZT0hMSksXCJsaW5lYXJcIj09PXQpcmV0dXJuIGU/SHM6UnM7aWYoXCJyZWx1XCI9PT10KXJldHVybiBlP3FzOmtzO2lmKFwiZWx1XCI9PT10KXJldHVybiBlP2pzOkFzO2lmKFwicmVsdTZcIj09PXQpcmV0dXJuIGU/S3M6U3M7aWYoXCJwcmVsdVwiPT09dClyZXR1cm4gZT9QYTpNYTt0aHJvdyBuZXcgRXJyb3IoXCJBY3RpdmF0aW9uIFwiK3QrXCIgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgV2ViR0wgYmFja2VuZC5cIil9dmFyIEpzPTYwMDt2YXIgWnM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlKXt2YXIgbixyPXQuY2FsbCh0aGlzKXx8dGhpcztpZihyLnBlbmRpbmdSZWFkPW5ldyBXZWFrTWFwLHIucGVuZGluZ0Rpc3Bvc2FsPW5ldyBXZWFrU2V0LHIuZGF0YVJlZkNvdW50PW5ldyBXZWFrTWFwLHIubnVtQnl0ZXNJbkdQVT0wLHIudXBsb2FkV2FpdE1zPTAsci5kb3dubG9hZFdhaXRNcz0wLHIud2FybmVkQWJvdXRNZW1vcnk9ITEsci5wZW5kaW5nRGVsZXRlcz0wLHIuZGlzcG9zZWQ9ITEsIWkoKS5nZXRCb29sKFwiSEFTX1dFQkdMXCIpKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7aWYobnVsbD09ZSl7dmFyIG89anQoaSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpO3IuYmluYXJ5Q2FjaGU9KG49aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpaW4gJHM/JHNbbl06KCRzW25dPXt9LCRzW25dKSxyLmdwZ3B1PW5ldyBCaShvKSxyLmNhbnZhcz1vLmNhbnZhcyxyLmdwZ3B1Q3JlYXRlZExvY2FsbHk9ITB9ZWxzZSByLmdwZ3B1PWUsci5iaW5hcnlDYWNoZT17fSxyLmdwZ3B1Q3JlYXRlZExvY2FsbHk9ITEsci5jYW52YXM9ZS5nbC5jYW52YXM7cmV0dXJuIHIudGV4dHVyZU1hbmFnZXI9bmV3IHBzKHIuZ3BncHUpLHIubnVtTUJCZWZvcmVXYXJuaW5nPW51bGw9PWkoKS5nbG9iYWwuc2NyZWVuPzEwMjQ6aSgpLmdsb2JhbC5zY3JlZW4uaGVpZ2h0KmkoKS5nbG9iYWwuc2NyZWVuLndpZHRoKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKkpzLzEwMjQvMTAyNCxyLnRleERhdGE9bmV3IHhvKHIsTHQpLHJ9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5udW1EYXRhSWRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4RGF0YS5udW1EYXRhSWRzKCkrKHRoaXMuY3B1QmFja2VuZD90aGlzLmNwdUJhY2tlbmQubnVtRGF0YUlkcygpOjApLXRoaXMucGVuZGluZ0RlbGV0ZXN9LG8ucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSxuKXtpZihpKCkuZ2V0Qm9vbChcIkRFQlVHXCIpJiZ0aGlzLmNoZWNrTnVtZXJpY2FsUHJvYmxlbXModCksXCJjb21wbGV4NjRcIj09PW4mJm51bGwhPXQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIHRvIGEgY29tcGxleDY0IGR0eXBlLiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3ZhciByPXt9O3JldHVybiB0aGlzLnRleERhdGEuc2V0KHIse3NoYXBlOmUsZHR5cGU6bix2YWx1ZXM6dCx1c2FnZTp6dC5VUExPQUR9KSxyfSxvLnByb3RvdHlwZS5tb3ZlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKGkoKS5nZXRCb29sKFwiREVCVUdcIikmJnRoaXMuY2hlY2tOdW1lcmljYWxQcm9ibGVtcyhlKSxcImNvbXBsZXg2NFwiPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gYSBjb21wbGV4NjQgZHR5cGUuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7dGhpcy50ZXhEYXRhLnNldCh0LHtzaGFwZTpuLGR0eXBlOnIsdmFsdWVzOmUsdXNhZ2U6enQuVVBMT0FEfSl9LG8ucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCksbj1lLnZhbHVlcyxyPWUuZHR5cGUsbz1lLmNvbXBsZXhUZW5zb3JzLGE9ZS5zbGljZSxpPWUuc2hhcGUscz1lLmlzUGFja2VkO2lmKG51bGwhPWEpe3ZhciB1PXZvaWQgMDt1PXM/bmV3IFhzKGksR3MpOm5ldyBDcyhpLEdzKTt2YXIgYz10aGlzLnJ1bldlYkdMUHJvZ3JhbSh1LFt7ZGF0YUlkOnQsc2hhcGU6aSxkdHlwZTpyfV0sciksbD10aGlzLnJlYWRTeW5jKGMuZGF0YUlkKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShjLmRhdGFJZCksbH1pZihudWxsIT1uKXJldHVybiB0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQpO2lmKFwic3RyaW5nXCI9PT1yKXJldHVybiBuO3ZhciBoLGYsZD1udWxsIT10aGlzLmFjdGl2ZVRpbWVyczsoZCYmKGg9ZXQoKSksXCJjb21wbGV4NjRcIj09PXIpP2Y9Vm8oby5yZWFsLmRhdGFTeW5jKCksby5pbWFnLmRhdGFTeW5jKCkpOmY9dGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZSh0KTtyZXR1cm4gZCYmKHRoaXMuZG93bmxvYWRXYWl0TXMrPWV0KCktaCksdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LGYpfSxvLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYSxzLHUsYyxsLGgsZixkLHAsdixtLGcseSx4LGIsdyxDLEUsUjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMucGVuZGluZ1JlYWQuaGFzKHQpKXJldHVybiBlPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHQpLFsyLG5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gZS5wdXNoKHQpfSkpXTtpZihuPXRoaXMudGV4RGF0YS5nZXQodCksbz1uLnZhbHVlcyxhPW4uc2hhcGUscz1uLnNsaWNlLHU9bi5kdHlwZSxjPW4uY29tcGxleFRlbnNvcnMsbD1uLmlzUGFja2VkLG51bGwhPXMpcmV0dXJuIGg9dm9pZCAwLGg9bD9uZXcgWHMoYSxHcyk6bmV3IENzKGEsR3MpLGY9dGhpcy5ydW5XZWJHTFByb2dyYW0oaCxbe2RhdGFJZDp0LHNoYXBlOmEsZHR5cGU6dX1dLHUpLGQ9dGhpcy5yZWFkKGYuZGF0YUlkKSx0aGlzLmRpc3Bvc2VEYXRhKGYuZGF0YUlkKSxbMixkXTtpZihudWxsIT1vKXJldHVyblsyLHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCldO2lmKCFpKCkuZ2V0Qm9vbChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikmJjI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IuZGF0YSgpIHdpdGggV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRD1mYWxzZSBhbmQgV0VCR0xfVkVSU0lPTj0yIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtyZXR1cm4gcD1udWxsLFwiY29tcGxleDY0XCIhPT11JiZpKCkuZ2V0KFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiKSYmKHY9dGhpcy5kZWNvZGUodCksbT10aGlzLnRleERhdGEuZ2V0KHYuZGF0YUlkKSxwPShSPXRoaXMuZ3BncHUpLmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlLmFwcGx5KFIsW20udGV4dHVyZV0uY29uY2F0KFl0KGEpKSkpLHRoaXMucGVuZGluZ1JlYWQuc2V0KHQsW10pLFwiY29tcGxleDY0XCI9PT11P1szLDJdOls0LHRoaXMuZ3BncHUuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCldO2Nhc2UgMTpyLnNlbnQoKSxyLmxhYmVsPTI7Y2FzZSAyOnJldHVyblwiY29tcGxleDY0XCIhPT11P1szLDRdOls0LFByb21pc2UuYWxsKFtjLnJlYWwuZGF0YSgpLGMuaW1hZy5kYXRhKCldKV07Y2FzZSAzOnJldHVybiB5PXIuc2VudCgpLHg9eVswXSxiPXlbMV0sZz1Wbyh4LGIpLFszLDVdO2Nhc2UgNDpudWxsPT1wP2c9dGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZSh0KToodz1rKGEpLGc9dGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKHAsdykpLHIubGFiZWw9NTtjYXNlIDU6cmV0dXJuIG51bGwhPXYmJnRoaXMuZGlzcG9zZURhdGEodi5kYXRhSWQpLEM9dGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LGcpLEU9dGhpcy5wZW5kaW5nUmVhZC5nZXQodCksdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUodCksRS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdChDKX0pKSx0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXModCkmJih0aGlzLnBlbmRpbmdEaXNwb3NhbC5kZWxldGUodCksdGhpcy5kaXNwb3NlRGF0YSh0KSx0aGlzLnBlbmRpbmdEZWxldGVzLS0pLFsyLENdfX0pKX0pKX0sby5wcm90b3R5cGUuY2hlY2tOdW1lcmljYWxQcm9ibGVtcz1mdW5jdGlvbih0KXtpZihudWxsIT10KWZvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdO2lmKCFlZShuKSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFXCIpKXRocm93IEVycm9yKFwiVGhlIHZhbHVlIFwiK24rXCIgY2Fubm90IGJlIHJlcHJlc2VudGVkIHdpdGggeW91ciBjdXJyZW50IHNldHRpbmdzLiBDb25zaWRlciBlbmFibGluZyBmbG9hdDMyIHJlbmRlcmluZzogJ3RmLmVudigpLnNldCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcsIHRydWUpOydcIik7dGhyb3cgRXJyb3IoXCJUaGUgdmFsdWUgXCIrbitcIiBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgb24gdGhpcyBkZXZpY2UuXCIpfX19LG8ucHJvdG90eXBlLmdldFZhbHVlc0Zyb21UZXh0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcy50ZXhEYXRhLmdldCh0KSxyPW4uc2hhcGUsbz1uLmR0eXBlLGE9bi5pc1BhY2tlZCxzPWsocik7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpKXt2YXIgdT10aGlzLmRlY29kZSh0KSxjPXRoaXMudGV4RGF0YS5nZXQodS5kYXRhSWQpLGw9KGU9dGhpcy5ncGdwdSkuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZS5hcHBseShlLFtjLnRleHR1cmVdLmNvbmNhdChZdChyKSkpLnN1YmFycmF5KDAscyk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEodS5kYXRhSWQpLGx9dmFyIGg9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpJiYhMD09PWEsZj1oP1RlKHIpOnIsZD1oP25ldyBjaShmKTpuZXcgdWkoZikscD10aGlzLnJ1bldlYkdMUHJvZ3JhbShkLFt7c2hhcGU6ZixkdHlwZTpvLGRhdGFJZDp0fV0sXCJmbG9hdDMyXCIpLHY9dGhpcy50ZXhEYXRhLmdldChwLmRhdGFJZCksbT10aGlzLmdwZ3B1LmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKHYudGV4dHVyZSx2LnRleFNoYXBlWzBdLHYudGV4U2hhcGVbMV0pLnN1YmFycmF5KDAscyk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEocC5kYXRhSWQpLG19LG8ucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhLHMsdSxjO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9dGhpcy5hY3RpdmVUaW1lcnMsbj1bXSxvPSExLG51bGw9PXRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPyh0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1uLG89ITApOnRoaXMuYWN0aXZlVGltZXJzLnB1c2gobiksdGhpcy5hY3RpdmVUaW1lcnM9bix0KCksYT1JKHRoaXMuYWN0aXZlVGltZXJzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucXVlcnl9KSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9KSkscz1JKHRoaXMuYWN0aXZlVGltZXJzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pKSx0aGlzLmFjdGl2ZVRpbWVycz1lLG8mJih0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1udWxsKSx1PXt1cGxvYWRXYWl0TXM6dGhpcy51cGxvYWRXYWl0TXMsZG93bmxvYWRXYWl0TXM6dGhpcy5kb3dubG9hZFdhaXRNcyxrZXJuZWxNczpudWxsLHdhbGxNczpudWxsfSxpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjA/WzQsUHJvbWlzZS5hbGwoYSldOlszLDJdO2Nhc2UgMTpyZXR1cm4gYz1yLnNlbnQoKSx1Lmtlcm5lbE1zPXcoYyksdS5nZXRFeHRyYVByb2ZpbGVJbmZvPWZ1bmN0aW9uKCl7cmV0dXJuIGMubWFwKChmdW5jdGlvbih0LGUpe3JldHVybntuYW1lOnNbZV0sbXM6dH19KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lK1wiOiBcIit0Lm1zfSkpLmpvaW4oXCIsIFwiKX0sWzMsM107Y2FzZSAyOnUua2VybmVsTXM9e2Vycm9yOlwiV2ViR0wgcXVlcnkgdGltZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuXCJ9LHIubGFiZWw9MztjYXNlIDM6cmV0dXJuIHRoaXMudXBsb2FkV2FpdE1zPTAsdGhpcy5kb3dubG9hZFdhaXRNcz0wLFsyLHVdfX0pKX0pKX0sby5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJue3VucmVsaWFibGU6ITEsbnVtQnl0ZXNJbkdQVTp0aGlzLm51bUJ5dGVzSW5HUFV9fSxvLnByb3RvdHlwZS5zdGFydFRpbWVyPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MD90aGlzLmdwZ3B1LmJlZ2luUXVlcnkoKTp7c3RhcnRNczpldCgpLGVuZE1zOm51bGx9fSxvLnByb3RvdHlwZS5lbmRUaW1lcj1mdW5jdGlvbih0KXtyZXR1cm4gaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wPyh0aGlzLmdwZ3B1LmVuZFF1ZXJ5KCksdCk6KHQuZW5kTXM9ZXQoKSx0KX0sby5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4gaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wP1syLHRoaXMuZ3BncHUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0KV06WzIsKGU9dCkuZW5kTXMtZS5zdGFydE1zXX0pKX0pKX0sby5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24odCl7aWYoIXRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyh0KSl7aWYodGhpcy5wZW5kaW5nUmVhZC5oYXModCkpcmV0dXJuIHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmFkZCh0KSx2b2lkIHRoaXMucGVuZGluZ0RlbGV0ZXMrKztpZih0aGlzLnRleERhdGEuaGFzKHQpKXt0aGlzLnJlbGVhc2VHUFVEYXRhKHQpO3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCkuY29tcGxleFRlbnNvcnM7bnVsbCE9ZSYmKGUucmVhbC5kaXNwb3NlKCksZS5pbWFnLmRpc3Bvc2UoKSksdGhpcy50ZXhEYXRhLmRlbGV0ZSh0KX19fSxvLnByb3RvdHlwZS5yZWxlYXNlR1BVRGF0YT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQpLG49ZS50ZXh0dXJlLHI9ZS5kdHlwZSxvPWUudGV4U2hhcGUsYT1lLnVzYWdlLGk9ZS5pc1BhY2tlZCxzPWUuc2xpY2UsdT1zJiZzLm9yaWdEYXRhSWR8fHQsYz10aGlzLmRhdGFSZWZDb3VudC5nZXQodSk7Yz4xP3RoaXMuZGF0YVJlZkNvdW50LnNldCh1LGMtMSk6KHRoaXMuZGF0YVJlZkNvdW50LmRlbGV0ZSh1KSxudWxsIT1uJiYodGhpcy5udW1CeXRlc0luR1BVLT10aGlzLmNvbXB1dGVCeXRlcyhvLHIpLHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUobixvLGEsaSkpKTt2YXIgbD10aGlzLnRleERhdGEuZ2V0KHQpO2wudGV4dHVyZT1udWxsLGwudGV4U2hhcGU9bnVsbCxsLmlzUGFja2VkPSExLGwuc2xpY2U9bnVsbH0sby5wcm90b3R5cGUuZ2V0VGV4dHVyZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy51cGxvYWRUb0dQVSh0KSx0aGlzLnRleERhdGEuZ2V0KHQpLnRleHR1cmV9LG8ucHJvdG90eXBlLmdldERhdGFJbmZvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQpfSxvLnByb3RvdHlwZS5nZXRDUFVCYWNrZW5kPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiV0VCR0xfQ1BVX0ZPUldBUkRcIik/KG51bGw9PXRoaXMuY3B1QmFja2VuZCYmKHRoaXMuY3B1QmFja2VuZD1MdC5maW5kQmFja2VuZChcImNwdVwiKSksdGhpcy5jcHVCYWNrZW5kKTpudWxsfSxvLnByb3RvdHlwZS5zaG91bGRFeGVjdXRlT25DUFU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiB2b2lkIDA9PT1lJiYoZT0xMjgpLG51bGwhPXRoaXMuZ2V0Q1BVQmFja2VuZCgpJiZ0LmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09bi50ZXhEYXRhLmdldCh0LmRhdGFJZCkudGV4dHVyZSYmdC5zaXplPGV9KSl9LG8ucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdwZ3B1fSxvLnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5tYWtlT3V0cHV0KHQuc2hhcGUsXCJjb21wbGV4NjRcIik7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQobi5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzPXtyZWFsOkx0LmtlZXAodC5jbG9uZSgpKSxpbWFnOkx0LmtlZXAoZS5jbG9uZSgpKX0sbn0sby5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5jbG9uZSgpfSxvLnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5pbWFnLmNsb25lKCl9LG8ucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc2xpY2UodCxlLG4pO2lmKDA9PT1rKG4pKXJldHVybiBGbihbXSxuLHQuZHR5cGUpO3ZhciByPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmlzUGFja2VkLG89aW8odC5zaGFwZSxlLG4pO2lmKHJ8fCFvKXt2YXIgYT1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgZnMobik6bmV3IGxzKG4pLHM9YS5nZXRDdXN0b21TZXR1cEZ1bmMoZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFt0XSxudWxsLHMpfXJldHVybiB0aGlzLnVwbG9hZFRvR1BVKHQuZGF0YUlkKSx0aGlzLnNoYWxsb3dTbGljZSh0LGUsbil9LG8ucHJvdG90eXBlLnNoYWxsb3dTbGljZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksbz10aGlzLm1ha2VPdXRwdXQobix0LmR0eXBlKSxhPXRoaXMudGV4RGF0YS5nZXQoby5kYXRhSWQpO09iamVjdC5hc3NpZ24oYSxyKSxhLnNoYXBlPW4sYS5kdHlwZT10LmR0eXBlO3ZhciBpPXNvKGUsdC5zdHJpZGVzKTtyLnNsaWNlJiYoaSs9ci5zbGljZS5mbGF0T2Zmc2V0KSxhLnNsaWNlPXtmbGF0T2Zmc2V0Omksb3JpZ0RhdGFJZDpyLnNsaWNlJiZyLnNsaWNlLm9yaWdEYXRhSWR8fHQuZGF0YUlkfTt2YXIgcz10aGlzLmRhdGFSZWZDb3VudC5nZXQoYS5zbGljZS5vcmlnRGF0YUlkKXx8MTtyZXR1cm4gdGhpcy5kYXRhUmVmQ291bnQuc2V0KGEuc2xpY2Uub3JpZ0RhdGFJZCxzKzEpLG99LG8ucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc3RyaWRlZFNsaWNlKHQsZSxuLHIpO3ZhciBvPXJvKGUsbixyKTtpZihvLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dH0pKSlyZXR1cm4gRm4oW10sbyk7dmFyIGE9bmV3IGRzKGUscixvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEsW3RdKX0sby5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBpcyh0LnNoYXBlLGUpOm5ldyBhcyh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSxvLnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dFswXS5kdHlwZSl7dmFyIG49dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBUbih0KX0pKSxyPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gTm4odCl9KSk7cmV0dXJuIERuKHRoaXMuY29uY2F0KG4sZSksdGhpcy5jb25jYXQocixlKSl9aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUodCkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5jb25jYXQodCxlKTtpZigxPT09dC5sZW5ndGgpcmV0dXJuIHRbMF07aWYodC5sZW5ndGg+aSgpLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIikpe3ZhciBvPU1hdGguZmxvb3IodC5sZW5ndGgvMiksYT10aGlzLmNvbmNhdCh0LnNsaWNlKDAsbyksZSkscz10aGlzLmNvbmNhdCh0LnNsaWNlKG8pLGUpO3JldHVybiB0aGlzLmNvbmNhdChbYSxzXSxlKX1pZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKSYmdFswXS5yYW5rPjEpe3ZhciB1PW5ldyBHYSh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih1LHQpfXZhciBjPVNuKHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSxlKSxsPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hczJEKC0xLGsodC5zaGFwZS5zbGljZShlKSkpfSkpLGg9bmV3IHphKGwubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLGwpLnJlc2hhcGUoYyl9LG8ucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubmVnKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxUcyx0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxUcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW4/dC5zaGFwZVsyXTp0LnNoYXBlWzFdLGE9cj9lLnNoYXBlWzFdOmUuc2hhcGVbMl0saT1uP3Quc2hhcGVbMV06dC5zaGFwZVsyXSxzPXQuc2hhcGVbMF07aWYoKDE9PT1vfHwxPT09YSkmJmk+MWUzKXtuJiYodD10LnRyYW5zcG9zZShbMCwyLDFdKSksciYmKGU9ZS50cmFuc3Bvc2UoWzAsMiwxXSkpO3ZhciB1PTE9PT1hP3Q6dC5hczNEKHMsaSwxKSxjPTE9PT1hPzI6MSxsPTE9PT1hP2UuYXMzRChzLDEsaSk6ZTtyZXR1cm4gdGhpcy5tdWx0aXBseSh1LGwpLnN1bShjLCEwKX12YXIgaD1EdCh0LmR0eXBlLGUuZHR5cGUpLGY9bmV3IEhpKHQuc2hhcGUsW3MsbyxhXSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZixbdCxlXSxoKX0sby5wcm90b3R5cGUuZnVzZWRCYXRjaE1hdE11bD1mdW5jdGlvbih0KXt2YXIgZT10LmEsbj10LmIscj10LnRyYW5zcG9zZUEsbz10LnRyYW5zcG9zZUIsYT10LmJpYXMsaT10LmFjdGl2YXRpb24scz10LnByZWx1QWN0aXZhdGlvbldlaWdodHMsdT1yP2Uuc2hhcGVbMl06ZS5zaGFwZVsxXSxjPW8/bi5zaGFwZVsxXTpuLnNoYXBlWzJdLGw9ZS5zaGFwZVswXSxoPUR0KGUuZHR5cGUsbi5kdHlwZSksZj1udWxsIT1hLGQ9bnVsbCE9cyxwPWk/UXMoaSwhMCk6bnVsbCx2PW5ldyBIaShlLnNoYXBlLFtsLHUsY10scixvLGYscCxkKSxtPVtlLG5dO3JldHVybiBhJiZtLnB1c2goYSkscyYmbS5wdXNoKHMpLHRoaXMuY29tcGlsZUFuZFJ1bih2LG0saCl9LG8ucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLHI9dGhpcy50ZXhEYXRhLmdldChlLmRhdGFJZCksbz1uZXcgTmEoRGEsdC5zaGFwZSxlLnNoYXBlKSxhPW5ldyBOYShUYSx0LnNoYXBlLGUuc2hhcGUpLHM9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsbi5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LG4uY29tcGxleFRlbnNvcnMuaW1hZyksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8oZSxyLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKGUsci5jb21wbGV4VGVuc29ycy5pbWFnKV0sdT10aGlzLmNvbXBpbGVBbmRSdW4obyxzKSxjPXRoaXMuY29tcGlsZUFuZFJ1bihhLHMpLGw9dGhpcy5jb21wbGV4KHUsYyk7cmV0dXJuIHUuZGlzcG9zZSgpLGMuZGlzcG9zZSgpLGx9aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubXVsdGlwbHkodCxlKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLE9hLHQuZHR5cGUpO3ZhciBoPW5ldyBCYShPYSx0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxbdCxlXSx0LmR0eXBlKX0sby5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgcz1bdCxlLG5dLHU9bnVsbDtudWxsIT1hJiYodT1hLnNoYXBlLHMucHVzaChhKSk7dmFyIGM9bnVsbDtpZihudWxsIT1vJiYoYz1vLnNoYXBlLHMucHVzaChvKSksaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIikpe3ZhciBsPW5ldyBBYSh0LnNoYXBlLGUuc2hhcGUsbi5zaGFwZSx1LGMscik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihsLHMpfXZhciBoPW5ldyBTYSh0LnNoYXBlLGUuc2hhcGUsbi5zaGFwZSx1LGMscik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLHMpfSxvLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIik/bmV3IFZpKHQuc2hhcGUsZSxuLHIsbyk6bmV3IFdpKHQuc2hhcGUsZSxuLHIsbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFt0XSl9LG8ucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dmFyIHM9bmV3IFVpKGUuc2hhcGUscixvLGEsaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLFtlLG4sdF0pfSxvLnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQsZSl7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpe3ZhciBuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG90KHQpfSkpO3JldHVybiB0YShkcih0LnNoYXBlLHQuZHR5cGUsbiksZSl9dmFyIHI9bmV3IGdzKHQuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LG8ucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUsbil7dmFyIHI9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IFlpKHQuc2hhcGUsZSxuKTpuZXcgWGkodC5zaGFwZSxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0pfSxvLnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQudHJhbnNwb3NlKHQsZSk7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IHhzKHQuc2hhcGUsZSk6bmV3IHlzKHQuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LG8ucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZ2F0aGVyKHQsZSxuKTt2YXIgcj1uZXcgbWkodC5zaGFwZSxlLnNpemUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe0ModC5yYW5rPD00LChmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hUb1NwYWNlTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIn0pKTt2YXIgcj1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpLG89enIodC5zaGFwZSxlLHIpLGE9R3Ioby5sZW5ndGgsZS5sZW5ndGgpLGk9SHIodC5zaGFwZSxlLHIpLHM9cXIobixlLmxlbmd0aCksdT1LcihpLG4sZS5sZW5ndGgpO3JldHVybiB0LnJlc2hhcGUobykudHJhbnNwb3NlKGEpLnJlc2hhcGUoaSkuc2xpY2Uocyx1KX0sby5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlLG4pe0ModC5yYW5rPD00LChmdW5jdGlvbigpe3JldHVyblwic3BhY2VUb0JhdGNoTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIn0pKTt2YXIgcj1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpLG89W1swLDBdXTtvLnB1c2guYXBwbHkobyxuKTtmb3IodmFyIGE9MStlLmxlbmd0aDthPHQuc2hhcGUubGVuZ3RoOysrYSlvLnB1c2goWzAsMF0pO3ZhciBpPXQucGFkKG8pLHM9enIoaS5zaGFwZSxlLHIsITEpLHU9R3Iocy5sZW5ndGgsZS5sZW5ndGgsITEpLGM9SHIoaS5zaGFwZSxlLHIsITEpO3JldHVybiBpLnJlc2hhcGUocykudHJhbnNwb3NlKHUpLnJlc2hhcGUoYyl9LG8ucHJvdG90eXBlLnJlZHVjZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dC5zaGFwZVswXSxvPXQuc2hhcGVbMV0sYT0kcihvKSxpPW5ldyBKaSh7d2luZG93U2l6ZTphLGluU2l6ZTpvLGJhdGNoU2l6ZTpyfSxlKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihpLFt0XSxuKTtyZXR1cm4gMT09PXMuc2hhcGVbMV0/czp0aGlzLnJlZHVjZShzLGUsbil9LG8ucHJvdG90eXBlLmFyZ1JlZHVjZT1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49bnVsbCk7dmFyIHI9dC5zaGFwZVswXSxvPXQuc2hhcGVbMV07bnVsbCE9biYmKHI9bi5zaGFwZVswXSxvPW4uc2hhcGVbMV0pO3ZhciBhPSRyKG8pLGk9bmV3IGFhKHt3aW5kb3dTaXplOmEsaW5TaXplOm8sYmF0Y2hTaXplOnJ9LGUsbnVsbD09bikscz1bdF07bnVsbCE9biYmcy5wdXNoKG4pO3ZhciB1PXRoaXMuY29tcGlsZUFuZFJ1bihpLHMsXCJpbnQzMlwiKTtyZXR1cm4gMT09PXUuc2hhcGVbMV0/dTp0aGlzLmFyZ1JlZHVjZSh0LGUsdSl9LG8ucHJvdG90eXBlLmFyZ1JlZHVjZVBhY2tlZD1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49bnVsbCk7dmFyIHI9bnVsbCE9bj9uLnNoYXBlOnQuc2hhcGUsbz0kcihyW3IubGVuZ3RoLTFdKSxhPW5ldyBSYShyLG8sZSxudWxsPT1uKSxpPW51bGw9PW4/W3RdOlt0LG5dLHM9dGhpcy5jb21waWxlQW5kUnVuKGEsaSxcImludDMyXCIpO3JldHVybiBzLnJhbms9PT10LnJhbms/dGhpcy5hcmdSZWR1Y2VQYWNrZWQodCxlLHMpOnN9LG8ucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe0NuKFwic3VtXCIsZSx0LnJhbmspO3ZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89ayhuWzFdKSxhPXQuYXMyRCgtMSxvKSxpPVR0KHQuZHR5cGUpO3JldHVybiB0aGlzLnJlZHVjZShhLFwic3VtXCIsaSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5wcm9kKHQsZSk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pLGk9VHQodC5kdHlwZSk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJwcm9kXCIsaSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj0wLG89RW4oW3JdLHQucmFuayksYT10O251bGwhPW8mJihhPXQudHJhbnNwb3NlKG8pLHI9SW4oMSx0LnJhbmspWzBdKTt2YXIgaT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPVtdLG89dC5sZW5ndGgsYT0wO2E8bzthKyspYSE9PWU/ci5wdXNoKHRbYV0pOnIucHVzaChuKTtyZXR1cm4gcn0oYS5zaGFwZSxyLG4pLHM9ayhbYS5zaGFwZVtyXV0pLHU9YS5hczJEKC0xLHMpLGM9VHQodC5kdHlwZSksbD10aGlzLnNlZ09wQ29tcHV0ZSh1LFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsZSxjLG4pLnJlc2hhcGUoaSk7cmV0dXJuIG51bGwhPW8mJihsPWwudHJhbnNwb3NlKFJuKG8pKSksbH0sby5wcm90b3R5cGUuc2VnT3BDb21wdXRlPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9dC5zaGFwZVswXSxpPXQuc2hhcGVbMV0scz1mdW5jdGlvbih0LGUpe3ZhciBuLHI9ITE7Zm9yKHQ8PVlyPyhuPXQscj0hMCk6bj1ZKHQsTWF0aC5mbG9vcihNYXRoLnNxcnQodCkpKTshcjspbj5lfHxuPT09dD9yPSEwOm49WSh0LG4rMSk7cmV0dXJuIG59KGksbyksdT1uZXcgdXMoe3dpbmRvd1NpemU6cyxpblNpemU6aSxiYXRjaFNpemU6YSxudW1TZWdtZW50czpvfSxlKSxjPXRoaXMuY29tcGlsZUFuZFJ1bih1LFt0LG5dLHIpO3JldHVybiBjLnNoYXBlWzFdPT09bz9jOihuPUtuKDAsbykudGlsZShbaS9zXSksdGhpcy5zZWdPcENvbXB1dGUoYyxlLG4scixvKSl9LG8ucHJvdG90eXBlLmFyZ01pbk1heFJlZHVjZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9W2VdO2lmKENuKFwiYXJnXCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLHIsdC5yYW5rKSwhaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1JFRFVDRVwiKXx8dC5yYW5rPD0yKXt2YXIgbz1ibih0LnNoYXBlLHIpLGE9b1swXSxzPWsob1sxXSksdT10LmFzMkQoLTEscyk7cmV0dXJuIHRoaXMuYXJnUmVkdWNlKHUsbikucmVzaGFwZShhKX1yZXR1cm4gdGhpcy5hcmdSZWR1Y2VQYWNrZWQodCxuKX0sby5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXJnTWluTWF4UmVkdWNlKHQsZSxcIm1pblwiKX0sby5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXJnTWluTWF4UmVkdWNlKHQsZSxcIm1heFwiKX0sby5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKGUhPT10LnJhbmstMSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBjdW1zdW0gc2hhZGVyIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiKyh0LnJhbmstMSkrXCIgYnV0IGdvdCBheGlzPVwiK2UpO3ZhciBvPW5ldyBuaSh0LnNoYXBlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LG8ucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoZXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSA9PSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQobm90RXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSAhPSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5sZXNzKHQsZSk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQobGVzc1RoYW4oYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSA8IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQobGVzc1RoYW5FcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhIDw9IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmdyZWF0ZXIodCxlKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChncmVhdGVyVGhhbihhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhID4gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgPj0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KCEoeCA+PSAxLjApKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICpcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgPj0gMS4wICYmIGIgPj0gMS4wKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiBtaW4oXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCB2ZWM0KDEuMCkpKSArXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDEuMCkpKSxcXG4gICAgdmVjNCgxLjApKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgPj0gMS4wIHx8IGIgPj0gMS4wKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGNzKHQucmFuayxlLnNoYXBlLGUucmFuayk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGUsbl0sRHQoZS5kdHlwZSxuLmR0eXBlKSl9LG8ucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQpe2RuKFwidGYud2hlcmUoKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLndoZXJlQXN5bmMoKSBpbnN0ZWFkXCIpO3ZhciBlPXQuZGF0YVN5bmMoKTtyZXR1cm4gbmEodC5zaGFwZSxlKX0sby5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGVhKHQuZGF0YVN5bmMoKSx0LnNoYXBlLHQuZHR5cGUsZSl9LG8ucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe0NuKFwibWluXCIsZSx0LnJhbmspO3ZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89ayhuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcIm1pblwiLGEuZHR5cGUpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5taW5pbXVtKHQsZSk7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShcIlxcbiAgdmVjNCByZXN1bHQgPSB2ZWM0KG1pbihhLCBiKSk7XFxuICB2ZWM0IGlzTmFOID0gbWluKHZlYzQoaXNuYW4oYSkpICsgdmVjNChpc25hbihiKSksIHZlYzQoMS4wKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IEJhKFwiXFxuICBpZiAoaXNuYW4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzbmFuKGIpKSByZXR1cm4gYjtcXG5cXG4gIHJldHVybiBtaW4oYSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSxvLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFwiXFxuICB2ZWM0IHJlc3VsdCA9IG1vZChhLCBiKTtcXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGVxdWFsKGIsIHZlYzQoMC4wKSkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBCYShcImlmIChiID09IDAuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBtb2QoYSwgYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSxvLnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWF4KHQsZSk7Q24oXCJtYXhcIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwibWF4XCIsYS5kdHlwZSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1heGltdW0odCxlKTt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFwiXFxuICB2ZWM0IHJlc3VsdCA9IHZlYzQobWF4KGEsIGIpKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgQmEoXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIG1heChhLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe0NuKFwiYWxsXCIsZSx0LnJhbmspO3ZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89ayhuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcImFsbFwiLGEuZHR5cGUpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe0NuKFwiYW55XCIsZSx0LnJhbmspO3ZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89ayhuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcImFueVwiLGEuZHR5cGUpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpe3JldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgLy8gdmVjNCBvbmUgPSB2ZWM0KGVxdWFsKGEsIGIpKTtcXG4gIC8vIHJldHVybiBvbmUgKyAodmVjNCgxLjApIC0gb25lKSAqIGEgLyBiO1xcbiAgdmVjNCByZXN1bHQgPSBhIC8gYjtcXG4gIGlmKGEueCA9PSBiLngpIHtcXG4gICAgcmVzdWx0LnggPSAxLjtcXG4gIH1cXG4gIGlmKGEueSA9PSBiLnkpIHtcXG4gICAgcmVzdWx0LnkgPSAxLjtcXG4gIH1cXG4gIGlmKGEueiA9PSBiLnopIHtcXG4gICAgcmVzdWx0LnogPSAxLjtcXG4gIH1cXG4gIGlmKGEudyA9PSBiLncpIHtcXG4gICAgcmVzdWx0LncgPSAxLjtcXG4gIH1cXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsXCJmbG9hdDMyXCIsITApfXZhciBuPW5ldyBCYShcIlxcbmlmIChhID09IGIpIHtcXG4gIHJldHVybiAxLjA7XFxufTtcXG5yZXR1cm4gYSAvIGI7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIGl2ZWM0IGlhID0gcm91bmQoYSk7XFxuICBpdmVjNCBpYiA9IHJvdW5kKGIpO1xcbiAgYnZlYzQgY29uZCA9IG5vdEVxdWFsKGliLCBpdmVjNCgwKSk7XFxuICBpdmVjNCByZXN1bHQgPSBpdmVjNCgwKTtcXG4gIHZlYzQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xcblxcbiAgLy8gV2luZG93cyAoRDNEKSB3YW50cyBndWFyYW50ZWVkIG5vbi16ZXJvIGludCBkaXZpc2lvbiBhdCBjb21waWxlLXRpbWUuXFxuICBpZiAoY29uZFswXSkge1xcbiAgICByZXN1bHRbMF0gPSBpZGl2KGlhWzBdLCBpYlswXSwgc1swXSk7XFxuICB9XFxuICBpZiAoY29uZFsxXSkge1xcbiAgICByZXN1bHRbMV0gPSBpZGl2KGlhWzFdLCBpYlsxXSwgc1sxXSk7XFxuICB9XFxuICBpZiAoY29uZFsyXSkge1xcbiAgICByZXN1bHRbMl0gPSBpZGl2KGlhWzJdLCBpYlsyXSwgc1syXSk7XFxuICB9XFxuICBpZiAoY29uZFszXSkge1xcbiAgICByZXN1bHRbM10gPSBpZGl2KGlhWzNdLCBpYlszXSwgc1szXSk7XFxuICB9XFxuICByZXR1cm4gdmVjNChyZXN1bHQpO1xcblwiLFwiaW50MzJcIik7dmFyIG49bmV3IEJhKFwiXFxuICBmbG9hdCBzID0gc2lnbihhKSAqIHNpZ24oYik7XFxuICBpbnQgaWEgPSByb3VuZChhKTtcXG4gIGludCBpYiA9IHJvdW5kKGIpO1xcbiAgaWYgKGliICE9IDApIHtcXG4gICAgLy8gV2luZG93cyAoRDNEKSB3YW50cyBndWFyYW50ZWVkIG5vbi16ZXJvIGludCBkaXZpc2lvbiBhdCBjb21waWxlLXRpbWUuXFxuICAgIHJldHVybiBmbG9hdChpZGl2KGlhLCBpYiwgcykpO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImludDMyXCIpfSxvLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSYmXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpcmV0dXJuIHRoaXMuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wKHQsZSxGYSk7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuYWRkKHQsZSk7dmFyIG49RHQodC5kdHlwZSxlLmR0eXBlKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLEZhLG4pO3ZhciByPW5ldyBCYShGYSx0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSxuKX0sby5wcm90b3R5cGUucGFja2VkVW5hcnlPcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IFhzKHQuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxuKX0sby5wcm90b3R5cGUucGFja2VkQmluYXJ5T3A9ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz0hMSk7dmFyIGE9bmV3IExhKG4sdC5zaGFwZSxlLnNoYXBlLG8pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxbdCxlXSxyKX0sby5wcm90b3R5cGUuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLG89dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksYT10aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxpPVtbby5jb21wbGV4VGVuc29ycy5yZWFsLGEuY29tcGxleFRlbnNvcnMucmVhbF0sW28uY29tcGxleFRlbnNvcnMuaW1hZyxhLmNvbXBsZXhUZW5zb3JzLmltYWddXS5tYXAoKGZ1bmN0aW9uKG8pe3ZhciBhPW9bMF0saT1vWzFdLHM9ci5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxhKSx1PXIubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKGUsaSksYz1uZXcgQmEobix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiByLmNvbXBpbGVBbmRSdW4oYyxbcyx1XSxEdChhLmR0eXBlLGkuZHR5cGUpKX0pKSxzPWlbMF0sdT1pWzFdLGM9dGhpcy5jb21wbGV4KHMsdSk7cmV0dXJuIHMuZGlzcG9zZSgpLHUuZGlzcG9zZSgpLGN9LG8ucHJvdG90eXBlLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbz1mdW5jdGlvbih0LGUpe3JldHVybntkYXRhSWQ6ZS5kYXRhSWQsZHR5cGU6ZS5kdHlwZSxzaGFwZTp0LnNoYXBlfX0sby5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXtpZigxPT09dC5sZW5ndGgpcmV0dXJuIHRbMF07aWYodC5sZW5ndGg+aSgpLmdldChcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIikpe3ZhciBlPU1hdGguZmxvb3IodC5sZW5ndGgvMiksbj10aGlzLmFkZE4odC5zbGljZSgwLGUpKSxyPXRoaXMuYWRkTih0LnNsaWNlKGUpKTtyZXR1cm4gdGhpcy5hZGROKFtuLHJdKX12YXIgbz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZHR5cGV9KSkucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiBEdCh0LGUpfSkpLGE9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLHM9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBvYSh0WzBdLnNoYXBlLGEpOm5ldyByYSh0WzBdLnNoYXBlLGEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocyx0LG8pfSxvLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlJiZcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSlyZXR1cm4gdGhpcy5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AodCxlLF9hKTtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zdWJ0cmFjdCh0LGUpO3ZhciBuPUR0KHQuZHR5cGUsZS5kdHlwZSk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxfYSx0LmR0eXBlKTt2YXIgcj1uZXcgQmEoX2EsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0sbil9LG8ucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoXCJcXG4gIC8vIGlzTW9kUm91bmQxIGhhcyAxIGZvciBjb21wb25lbnRzIHdpdGggcm91bmQobW9kKGIsIDIuMCkpID09IDEsIDAgb3RoZXJ3aXNlLlxcbiAgdmVjNCBpc01vZFJvdW5kMSA9IHZlYzQoZXF1YWwocm91bmQobW9kKGIsIDIuMCkpLCBpdmVjNCgxKSkpO1xcbiAgdmVjNCBtdWx0aXBsaWVyID0gc2lnbihhKSAqIGlzTW9kUm91bmQxICsgKHZlYzQoMS4wKSAtIGlzTW9kUm91bmQxKTtcXG4gIHZlYzQgcmVzdWx0ID0gbXVsdGlwbGllciAqIHBvdyhhYnMoYSksIGIpO1xcblxcbiAgLy8gRW5zdXJlIHRoYXQgYV4wID0gMSwgaW5jbHVkaW5nIDBeMCA9IDEgYXMgdGhpcyBjb3JyZXNwb25kIHRvIFRGIGFuZCBKU1xcbiAgYnZlYzQgaXNFeHBaZXJvID0gZXF1YWwoYiwgdmVjNCgwLjApKTtcXG4gIHJlc3VsdC5yID0gaXNFeHBaZXJvLnIgPyAxLjAgOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNFeHBaZXJvLmcgPyAxLjAgOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNFeHBaZXJvLmIgPyAxLjAgOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNFeHBaZXJvLmEgPyAxLjAgOiByZXN1bHQuYTtcXG5cXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGxlc3NUaGFuKGEsIHZlYzQoMC4wKSkpICogdmVjNChsZXNzVGhhbihmbG9vcihiKSwgYikpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBCYShcIlxcbmlmKGEgPCAwLjAgJiYgZmxvb3IoYikgPCBiKXtcXG4gIHJldHVybiBOQU47XFxufVxcbmlmIChiID09IDAuMCkge1xcbiAgcmV0dXJuIDEuMDtcXG59XFxucmV0dXJuIChyb3VuZChtb2QoYiwgMi4wKSkgIT0gMSkgP1xcbiAgICBwb3coYWJzKGEpLCBiKSA6IHNpZ24oYSkgKiBwb3coYWJzKGEpLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpLHI9RHQodC5kdHlwZSxlLmR0eXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmNlaWwodCk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LE5zLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLE5zKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmZsb29yKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxGcyx0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxGcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJcXG4gIGlmIChpc25hbih4KSkgeyByZXR1cm4gMC4wOyB9XFxuICByZXR1cm4gc2lnbih4KTtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KGlzbmFuKHgpKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KGlzaW5mKHgpKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KCFpc25hbih4KSAmJiAhaXNpbmYoeCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJcXG4gIC8vIE9wZW5HTCBFUyBkb2VzIG5vdCBzdXBwb3J0IHJvdW5kIGZ1bmN0aW9uLlxcbiAgLy8gVGhlIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBiYW5rZXIncyByb3VuZGluZy5cXG4gIGZsb2F0IGJhc2UgPSBmbG9vcih4KTtcXG4gIGlmICgoeCAtIGJhc2UpIDwgMC41KSB7XFxuICAgIHJldHVybiBmbG9vcih4KTtcXG4gIH0gZWxzZSBpZiAoKHggLSBiYXNlKSA+IDAuNSkge1xcbiAgICByZXR1cm4gY2VpbCh4KTtcXG4gIH0gZWxzZSB7XFxuICAgIGlmIChtb2QoYmFzZSwgMi4wKSA9PSAwLjApIHtcXG4gICAgICByZXR1cm4gYmFzZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gYmFzZSArIDEuMDtcXG4gICAgfVxcbiAgfVxcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5leHAodCk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LF9zLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLF9zKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmV4cG0xKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxPcyx0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxPcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnNvZnRtYXg9ZnVuY3Rpb24odCxlKXt2YXIgbj1PKFtlXSx0LnNoYXBlKSxyPXRoaXMubWF4KHQsbiksbz13bihyLnNoYXBlLG4pLGE9dGhpcy5zdWJ0cmFjdCh0LHIucmVzaGFwZShvKSksaT10aGlzLmV4cChhKSxzPXRoaXMuc3VtKGksbikucmVzaGFwZShvKTtyZXR1cm4gdGhpcy5yZWFsRGl2aWRlKGkscyl9LG8ucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubG9nKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxcIlxcbiAgdmVjNCByZXN1bHQgPSBsb2coeCk7XFxuICB2ZWM0IGlzTmFOID0gdmVjNChsZXNzVGhhbih4LCB2ZWM0KDAuMCkpKTtcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA9PSAxLjAgPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA9PSAxLjAgPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA9PSAxLjAgPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA9PSAxLjAgPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJpZiAoeCA8IDAuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBsb2coeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBsb2coMS4wICsgeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIHNxcnQoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQucnNxcnQodCk7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gaW52ZXJzZXNxcnQoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIDEuMCAvIHg7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgWHModC5zaGFwZSxxcyk6bmV3IENzKHQuc2hhcGUsa3MpLHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnJlbHU2PWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgWHModC5zaGFwZSxLcyk6bmV3IENzKHQuc2hhcGUsU3MpLHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShQYSx0LnNoYXBlLGUuc2hhcGUpOm5ldyBCYShNYSx0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsanMsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsQXMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFwiXFxuICB2ZWM0IGJHVEVaZXJvID0gdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMC4pKSk7XFxuICByZXR1cm4gKGJHVEVaZXJvICogYSkgKyAoKHZlYzQoMS4wKSAtIGJHVEVaZXJvKSAqIChhICogKGIgKyB2ZWM0KDEuMCkpKSk7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgQmEoXCJyZXR1cm4gKGIgPj0gMS4wKSA/IGEgOiBhICogKGIgKyAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxEcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmludD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBmbG9hdChpbnQoeCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLFwiaW50MzJcIil9LG8ucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89KHI9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0NMSVBcIik/bmV3IFVhKHQuc2hhcGUpOm5ldyBXYSh0LnNoYXBlKSkuZ2V0Q3VzdG9tU2V0dXBGdW5jKGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxudWxsLG8pfSxvLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmFicyh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsSXMsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsSXMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLG49bmV3IFZhKHQuc2hhcGUpLHI9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsZS5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LGUuY29tcGxleFRlbnNvcnMuaW1hZyldO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixyKX0sby5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcIlxcbiAgZmxvYXQgZXBzaWxvbiA9IDEuMTkyMDkyODk1NTA3ODEyNWUtNztcXG4gIGZsb2F0IHRocmVzaG9sZCA9IGxvZyhlcHNpbG9uKSArIDIuMDtcXG5cXG4gIGJvb2wgdG9vX2xhcmdlID0geCA+IC10aHJlc2hvbGQ7XFxuICBib29sIHRvb19zbWFsbCA9IHggPCB0aHJlc2hvbGQ7XFxuXFxuICBmbG9hdCByZXN1bHQ7XFxuICBmbG9hdCBleHBfeCA9IGV4cCh4KTtcXG5cXG4gIGlmICh0b29fbGFyZ2Upe1xcbiAgICByZXN1bHQgPSB4O1xcbiAgfVxcbiAgZWxzZSBpZiAodG9vX3NtYWxsKXtcXG4gICAgcmVzdWx0ID0gZXhwX3g7XFxuICB9XFxuICBlbHNle1xcbiAgICByZXN1bHQgPSBsb2coZXhwX3ggKyAxLjApO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxNcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxCcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiB0YW4oeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFBzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxMcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsV3MpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoXCJcXG4gIHZlYzQgcmVzdWx0ID0gYXRhbihhLCBiKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgQmEoXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIGF0YW4oYSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoeCk7XFxuICByZXR1cm4gKGUyeCAtIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoLXgpO1xcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUudGFuaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnMoeCkpO1xcbiAgcmV0dXJuIHNpZ24oeCkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsVXMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxWcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLHpzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLCdcXG4gIC8vIEVycm9yIGZ1bmN0aW9uIGlzIGNhbGN1bGF0ZWQgYXBwcm94aW1hdGVseSB3aXRoIGVsZW1lbnRhcnkgZnVuY3Rpb24uXFxuICAvLyBTZWUgXCJIYW5kYm9vayBvZiBNYXRoZW1hdGljYWwgRnVuY3Rpb25zIHdpdGggRm9ybXVsYXMsXFxuICAvLyBHcmFwaHMsIGFuZCBNYXRoZW1hdGljYWwgVGFibGVzXCIsIEFicmFtb3dpdHogYW5kIFN0ZWd1bi5cXG4gIGZsb2F0IHAgPSAwLjMyNzU5MTE7XFxuICBmbG9hdCBhMSA9IDAuMjU0ODI5NTkyO1xcbiAgZmxvYXQgYTIgPSAtMC4yODQ0OTY3MzY7XFxuICBmbG9hdCBhMyA9IDEuNDIxNDEzNzQxO1xcbiAgZmxvYXQgYTQgPSAtMS40NTMxNTIwMjc7XFxuICBmbG9hdCBhNSA9IDEuMDYxNDA1NDI5O1xcblxcbiAgZmxvYXQgc2lnbiA9IHNpZ24oeCk7XFxuICB4ID0gYWJzKHgpO1xcbiAgZmxvYXQgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XFxuICByZXR1cm4gc2lnbiAqICgxLjAgLSAoKCgoKGE1KnQgKyBhNCkqdCkgKyBhMykqdCArIGEyKSp0ICsgYTEpKnQqZXhwKC14KngpKTtcXG4nKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBDcyh0LnNoYXBlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxFcytcIlxcbiAgICByZXR1cm4geCA+IDAuMCA/IDEuMCA6IGZsb2F0KFwiK3QrXCIpO1xcbiAgXCJ9KGUpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sby5wcm90b3R5cGUuY29udjJkQnlNYXRNdWw9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBzPXQuc2hhcGUsdT10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxjPW4uaW5DaGFubmVscyxsPXNbMF0qc1sxXSpzWzJdLGg9bi5vdXRDaGFubmVscyxmPVwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQsZD0oMT09PWx8fDE9PT1oKSYmYz4xZTMscD1zWzJdJTIhPTAmJiEhdS5pc1BhY2tlZDtpZihkfHwhaSgpLmdldEJvb2woXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIpfHwhaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpfHwhcCl7dmFyIHY9Zj9zWzBdKnNbMV0qc1syXTpzWzBdKnNbMl0qc1szXSxtPXRoaXMucmVzaGFwZSh0LFsxLHYsbi5pbkNoYW5uZWxzXSksZz10aGlzLnJlc2hhcGUoZSxbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc10pO3JldHVybiB0aGlzLnJlc2hhcGUodGhpcy5mdXNlZEJhdGNoTWF0TXVsKHthOm0sYjpnLHRyYW5zcG9zZUE6ITEsdHJhbnNwb3NlQjohMSxiaWFzOnIsYWN0aXZhdGlvbjpvLHByZWx1QWN0aXZhdGlvbldlaWdodHM6YX0pLG4ub3V0U2hhcGUpfXZhciB5PWY/c1swXSpzWzFdKihzWzJdKzEpOnNbMF0qc1syXSooc1szXSsxKSx4PXtkYXRhSWQ6dC5kYXRhSWQsc2hhcGU6WzEseSxuLmluQ2hhbm5lbHNdLGR0eXBlOnQuZHR5cGV9LGI9dS5zaGFwZTt1LnNoYXBlPXUuc2hhcGUuc2xpY2UoKSx1LnNoYXBlW3Uuc2hhcGUubGVuZ3RoLTJdKyssQyhfZSh1LnNoYXBlLHguc2hhcGUpLChmdW5jdGlvbigpe3JldHVyblwicGFja2VkIHJlc2hhcGUgXCIrdS5zaGFwZStcIiB0byBcIit4LnNoYXBlK1wiIGlzbid0IGZyZWVcIn0pKTt2YXIgdz10aGlzLnJlc2hhcGUoZSxbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc10pLEU9dGhpcy5mdXNlZEJhdGNoTWF0TXVsKHthOngsYjp3LHRyYW5zcG9zZUE6ITEsdHJhbnNwb3NlQjohMSxiaWFzOnIsYWN0aXZhdGlvbjpvLHByZWx1QWN0aXZhdGlvbldlaWdodHM6YX0pLFI9dGhpcy50ZXhEYXRhLmdldChFLmRhdGFJZCk7cmV0dXJuIEMoUi5pc1BhY2tlZCwoZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoTWF0TXVsIHJlc3VsdCBpcyBleHBlY3RlZCB0byBiZSBwYWNrZWRcIn0pKSx1LnNoYXBlPWIsUi5zaGFwZT1uLm91dFNoYXBlLEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKEUuZGF0YUlkLG4ub3V0U2hhcGUsRS5kdHlwZSl9LG8ucHJvdG90eXBlLmNvbnYyZFdpdGhJbTJSb3c9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW4uZmlsdGVyV2lkdGgscz1uLmZpbHRlckhlaWdodCx1PW4uaW5DaGFubmVscyxjPW4ub3V0V2lkdGgsbD1uLm91dEhlaWdodCxoPVwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQsZj1pKnMqdSxkPWwqYyxwPVtmLGRdLHY9dC5zcXVlZXplKFswXSksbT1lLnJlc2hhcGUoWzEsZiwtMV0pLGc9bmV3IExpKHAsdi5zaGFwZSxuKSx5PXRoaXMuY29tcGlsZUFuZFJ1bihnLFt2XSkucmVzaGFwZShbMSxwWzBdLHBbMV1dKSx4PW51bGwhPXIsYj1udWxsIT1hLHc9bz9RcyhvLCEwKTpudWxsLEM9bmV3IEhpKHkuc2hhcGUsWzEsZCxuLm91dENoYW5uZWxzXSwhMCwhMSx4LHcsYiksRT1beSxtXTtyJiZFLnB1c2gociksYiYmRS5wdXNoKGEpO3ZhciBSPXRoaXMuY29tcGlsZUFuZFJ1bihDLEUpO3JldHVybiBoP1IucmVzaGFwZShbMSxsLGMsbi5vdXRDaGFubmVsc10pOlIucmVzaGFwZShbMSxuLm91dENoYW5uZWxzLGwsY10pfSxvLnByb3RvdHlwZS5mdXNlZENvbnYyZD1mdW5jdGlvbih0KXt2YXIgZT10LmlucHV0LG49dC5maWx0ZXIscj10LmNvbnZJbmZvLG89dC5iaWFzLGE9dC5hY3RpdmF0aW9uLHM9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO2lmKDE9PT1yLmZpbHRlckhlaWdodCYmMT09PXIuZmlsdGVyV2lkdGgmJjE9PT1yLmRpbGF0aW9uSGVpZ2h0JiYxPT09ci5kaWxhdGlvbldpZHRoJiYxPT09ci5zdHJpZGVIZWlnaHQmJjE9PT1yLnN0cmlkZVdpZHRoJiYoXCJTQU1FXCI9PT1yLnBhZEluZm8udHlwZXx8XCJWQUxJRFwiPT09ci5wYWRJbmZvLnR5cGUpKXJldHVybiB0aGlzLmNvbnYyZEJ5TWF0TXVsKGUsbixyLG8sYSxzKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX0NPTlZfSU0yQ09MXCIpJiYxPT09ZS5zaGFwZVswXSlyZXR1cm4gdGhpcy5jb252MmRXaXRoSW0yUm93KGUsbixyLG8sYSxzKTt2YXIgdT1udWxsIT1vLGM9bnVsbCE9cyxsPWE/UXMoYSwhMSk6bnVsbCxoPW5ldyBRYShyLHUsbCxjKSxmPVtlLG5dO3JldHVybiBvJiZmLnB1c2gobykscyYmZi5wdXNoKHMpLHRoaXMuY29tcGlsZUFuZFJ1bihoLGYpfSxvLnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT1uLmZpbHRlckhlaWdodCYmMT09PW4uZmlsdGVyV2lkdGgmJjE9PT1uLmRpbGF0aW9uSGVpZ2h0JiYxPT09bi5kaWxhdGlvbldpZHRoJiYxPT09bi5zdHJpZGVIZWlnaHQmJjE9PT1uLnN0cmlkZVdpZHRoJiYoXCJTQU1FXCI9PT1uLnBhZEluZm8udHlwZXx8XCJWQUxJRFwiPT09bi5wYWRJbmZvLnR5cGUpKXJldHVybiB0aGlzLmNvbnYyZEJ5TWF0TXVsKHQsZSxuKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX0NPTlZfSU0yQ09MXCIpJiYxPT09dC5zaGFwZVswXSlyZXR1cm4gdGhpcy5jb252MmRXaXRoSW0yUm93KHQsZSxuKTt2YXIgcj1uZXcgUWEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBLYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBxYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5mdXNlZERlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0KXt2YXIgZSxuPXQuaW5wdXQscj10LmZpbHRlcixvPXQuY29udkluZm8sYT10LmJpYXMscz10LmFjdGl2YXRpb24sdT10LnByZWx1QWN0aXZhdGlvbldlaWdodHMsYz1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiKSYmby5zdHJpZGVXaWR0aDw9MiYmby5vdXRDaGFubmVscy9vLmluQ2hhbm5lbHM9PTEsbD1zP1FzKHMsYyk6bnVsbCxoPVtuLHJdLGY9bnVsbCE9YSxkPW51bGwhPXU7cmV0dXJuIGYmJmgucHVzaChhKSxkJiZoLnB1c2godSksYz8oZT1uZXcgdGkobyxmLGwsZCksdGhpcy5jb21waWxlQW5kUnVuKGUsaCkpOihlPW5ldyBaYShvLGYsbCxkKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxoKSl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7dmFyIHI7cmV0dXJuIGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIpJiZuLnN0cmlkZVdpZHRoPD0yJiZuLm91dENoYW5uZWxzL24uaW5DaGFubmVscz09MT8ocj1uZXcgdGkobiksdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pKToocj1uZXcgWmEobiksdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pKX0sby5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyAkYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBZYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBKYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252M2REZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IFhhKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmNvbnYzZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGphKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgJGkoZSxcIm1heFwiLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sby5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyAkaShlLFwiYXZnXCIsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3ICRpKHIsXCJtYXhcIiwhMCksYT10aGlzLmNvbXBpbGVBbmRSdW4obyxbZV0pLGk9bmV3IHppKHIpLHM9dGhpcy5jb21waWxlQW5kUnVuKGksW3QsYV0sZS5kdHlwZSk7cmV0dXJuIGEuZGlzcG9zZSgpLHN9LG8ucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IElhKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sZS5kdHlwZSl9LG8ucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gUG8odCxlLHRoaXMpfSxvLnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbZV0scj1uZXcgQXJyYXkodC5yYW5rLTEpLG89MCxhPTA7YTx0LnJhbms7YSsrKWEhPT1lJiYocltvKytdPXQuc2hhcGVbYV0pO3ZhciBpPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCkscz10LnNoYXBlLnNsaWNlKCk7c1tlXT0xO3ZhciB1PW5ldyBBcnJheShuKTtmb3IoYT0wO2E8dS5sZW5ndGg7YSsrKWlbZV09YSx1W2FdPXRoaXMuc2xpY2UodCxpLHMpLnJlc2hhcGUocik7cmV0dXJuIHV9LG8ucHJvdG90eXBlLmF2Z1Bvb2wzZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBRaShlLFwiYXZnXCIsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hdmdQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGthKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sZS5kdHlwZSl9LG8ucHJvdG90eXBlLm1heFBvb2wzZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBRaShlLFwibWF4XCIsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5tYXhQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgUWkocixcIm1heFwiLCEwKSxhPXRoaXMuY29tcGlsZUFuZFJ1bihvLFtlXSksaT1uZXcgR2kocikscz10aGlzLmNvbXBpbGVBbmRSdW4oaSxbdCxhXSxlLmR0eXBlKTtyZXR1cm4gYS5kaXNwb3NlKCksc30sby5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpO2lmKG4uaXNQYWNrZWQmJiFfZSh0LnNoYXBlLGUpJiYobnVsbD09PW4udGV4dHVyZXx8IV9lKG4uc2hhcGUsZSkpKXt2YXIgcj10aGlzLnBhY2tlZFJlc2hhcGUodCxlKTtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQoci5kYXRhSWQsci5zaGFwZSxyLmR0eXBlKX1yZXR1cm4gTG8odCxlKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIik/bmV3IG5zKHQuc2hhcGUsZSxuLHIpOm5ldyBlcyh0LnNoYXBlLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IHRzKHQsZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sby5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyBvcyh0LnNoYXBlLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sby5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBycyh0LGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LG8ucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWU/dDpnbyh0KSxhPW8uc2hhcGVbMF0saT1vLnNoYXBlWzFdLHM9bmV3IHFpKGEsaSxuKSx1PXMuZ2V0Q3VzdG9tU2V0dXBGdW5jKHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocyxbb10sXCJpbnQzMlwiLHUpfSxvLnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IEtpKHQuc2l6ZSxlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LG8ucHJvdG90eXBlLmRpYWc9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHNpKHQuc2l6ZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGRuKFwidGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkXCIpLGpvKHQuZGF0YVN5bmMoKSxlLmRhdGFTeW5jKCksbixyLG8pfSxvLnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1uZXcgZWkodC5zaGFwZSxlLnNoYXBlLHIsbyxhKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW3QsZSxuXSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7QyhlPjEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIitlfSkpO3ZhciByPXQuc2hhcGVbMF0sbz1cIk5IV0NcIj09PW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLGE9XCJOSFdDXCI9PT1uP3Quc2hhcGVbMl06dC5zaGFwZVszXSxpPVwiTkhXQ1wiPT09bj90LnNoYXBlWzNdOnQuc2hhcGVbMV0scz1vKmUsdT1hKmUsYz1pLyhlKmUpLGw9bmV3IGlpKFwiTkhXQ1wiPT09bj9bcixzLHUsY106W3IsYyxzLHVdLGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihsLFt0XSl9LG8ucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gWm8odCxlLG4pfSxvLnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVpyKDAsdCxuKSxvPXIuc2xpY2VSYW5rLGE9ci5udW1VcGRhdGVzLGk9ci5zbGljZVNpemUscz1yLnN0cmlkZXMsdT1yLm91dHB1dFNpemUsYz1bdS9pLGldLGw9dC5yZXNoYXBlKFthLG9dKSxoPWUucmVzaGFwZShbYSxpXSk7aWYoMD09PXUpcmV0dXJuIExvKEZuKFtdKSxuKTt2YXIgZj1PbigwKSxkPW5ldyBzcyhhLG8sbC5yYW5rLGgucmFuayxzLGMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZCxbaCxsLGZdKS5yZXNoYXBlKG4pfSxvLnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPVpyKDAsdCxuKSxhPW8uc2xpY2VSYW5rLGk9by5udW1VcGRhdGVzLHM9by5zdHJpZGVzLHU9by5vdXRwdXRTaXplLGM9bmV3IHNzKGksYSx0LnJhbmssZS5yYW5rLHMsW3UsMV0sITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYyxbZSx0LHJdKS5yZXNoYXBlKG4pfSxvLnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0SW1wbCh0LCExKX0sby5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITApfSxvLnByb3RvdHlwZS5mZnRJbXBsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkscj1uZXcgcGkoZmksdC5zaGFwZSxlKSxvPW5ldyBwaShkaSx0LnNoYXBlLGUpLGE9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsbi5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LG4uY29tcGxleFRlbnNvcnMuaW1hZyldLGk9dGhpcy5jb21waWxlQW5kUnVuKHIsYSkscz10aGlzLmNvbXBpbGVBbmRSdW4obyxhKSx1PXRoaXMuY29tcGxleChpLHMpLmFzMkQodC5zaGFwZVswXSx0LnNoYXBlWzFdKTtyZXR1cm4gaS5kaXNwb3NlKCkscy5kaXNwb3NlKCksdX0sby5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPWpyKHQsZSksYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGM9ZS5yZXNoYXBlKFtpLHJdKSxsPXQucmVzaGFwZShbdC5zaXplL3Msc10pLGg9bmV3IGdpKHIsdSxbaSxzXSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLFtsLGNdKS5yZXNoYXBlKGEpfSxvLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXtpZihcInN0cmluZ1wiPT09KG49bnx8aihlKSkpe3ZhciByPVAobixrKHQpKTtyZXR1cm4gci5maWxsKGUpLEx0Lm1ha2VUZW5zb3Iocix0LG4sdGhpcyl9dmFyIG89bmV3IHZpKHQsZSksYT1vLmdldEN1c3RvbVNldHVwRnVuYyhlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW10sbixhKX0sby5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwib25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCB1bmRlciBzdHJpbmcgZHR5cGVcIik7cmV0dXJuIHRoaXMuZmlsbCh0LnNoYXBlLDEsdC5kdHlwZSl9LG8ucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsXCJzdHJpbmdcIj09PXQuZHR5cGU/XCJcIjowLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5saW5zcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIFdvKHQsZSxuKX0sby5wcm90b3R5cGUubWFrZVRlbnNvckluZm89ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLndyaXRlKG51bGwsdCxlKTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChuKS51c2FnZT1udWxsLHtkYXRhSWQ6bixzaGFwZTp0LGR0eXBlOmV9fSxvLnByb3RvdHlwZS5tYWtlT3V0cHV0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5tYWtlVGVuc29ySW5mbyh0LGUpLmRhdGFJZDtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQobix0LGUsdGhpcyl9LG8ucHJvdG90eXBlLnVucGFja1RlbnNvcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgWXModC5zaGFwZSk7cmV0dXJuIHRoaXMucnVuV2ViR0xQcm9ncmFtKGUsW3RdLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5wYWNrVGVuc29yPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBqaSh0LnNoYXBlKTtyZXR1cm4gdGhpcy5ydW5XZWJHTFByb2dyYW0oZSxbdF0sdC5kdHlwZSxudWxsLCEwKX0sby5wcm90b3R5cGUucGFja2VkUmVzaGFwZT1mdW5jdGlvbih0LGUpe3ZhciBuPVtBZSh0LnNoYXBlKV0uY29uY2F0KERlKHQuc2hhcGUpKSxyPXtkdHlwZTp0LmR0eXBlLHNoYXBlOm4sZGF0YUlkOnQuZGF0YUlkfSxvPVtBZShlKV0uY29uY2F0KERlKGUpKSxhPW5ldyBaaShvLG4pLGk9dGhpcy5ydW5XZWJHTFByb2dyYW0oYSxbcl0sdC5kdHlwZSxudWxsLCEwKTtyZXR1cm57ZGF0YUlkOmkuZGF0YUlkLHNoYXBlOmUsZHR5cGU6aS5kdHlwZX19LG8ucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMudGV4RGF0YS5nZXQodCkscj1uLmlzUGFja2VkLG89bi5zaGFwZSxhPW4uZHR5cGUsaT1UZShvKTtlPXI/bmV3IGFpKGkpOm5ldyBvaShpKTtyZXR1cm57ZHR5cGU6YSxzaGFwZTpvLGRhdGFJZDp0aGlzLnJ1bldlYkdMUHJvZ3JhbShlLFt7c2hhcGU6aSxkdHlwZTphLGRhdGFJZDp0fV0sYSxudWxsLCEwKS5kYXRhSWR9fSxvLnByb3RvdHlwZS5ydW5XZWJHTFByb2dyYW09ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10aGlzO3ZvaWQgMD09PW8mJihvPSExKTt2YXIgcz10aGlzLm1ha2VUZW5zb3JJbmZvKHQub3V0cHV0U2hhcGUsbiksdT10aGlzLnRleERhdGEuZ2V0KHMuZGF0YUlkKTtpZih0LnBhY2tlZE91dHB1dCYmKHUuaXNQYWNrZWQ9ITApLHQub3V0UGFja2luZ1NjaGVtZT09PVZ0LkRFTlNFKXt2YXIgYz1ZdCh0Lm91dHB1dFNoYXBlKTt1LnRleFNoYXBlPWMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gMip0fSkpfWlmKG51bGwhPXQub3V0VGV4VXNhZ2UmJih1LnVzYWdlPXQub3V0VGV4VXNhZ2UpLDA9PT1rKHMuc2hhcGUpKXJldHVybiB1LnZhbHVlcz1CKHMuZHR5cGUsMCksczt2YXIgbD1bXSxoPWUubWFwKChmdW5jdGlvbihlKXtpZihcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJHUEdQVVByb2dyYW0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgaW5wdXQuIEZvciBjb21wbGV4NjQgZHR5cGVzLCBwbGVhc2Ugc2VwYXJhdGUgdGhlIHByb2dyYW0gaW50byByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMuXCIpO3ZhciBuPWEudGV4RGF0YS5nZXQoZS5kYXRhSWQpO2lmKG51bGw9PW4udGV4dHVyZSl7aWYoIXQucGFja2VkSW5wdXRzJiZrKGUuc2hhcGUpPD1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiKSlyZXR1cm57c2hhcGU6ZS5zaGFwZSx0ZXhEYXRhOm51bGwsaXNVbmlmb3JtOiEwLHVuaWZvcm1WYWx1ZXM6bi52YWx1ZXN9O3QucGFja2VkSW5wdXRzJiYobi5pc1BhY2tlZD0hMCxuLnNoYXBlPWUuc2hhcGUpfWVsc2UgaWYoISFuLmlzUGFja2VkIT0hIXQucGFja2VkSW5wdXRzKWU9bi5pc1BhY2tlZD9hLnVucGFja1RlbnNvcihlKTphLnBhY2tUZW5zb3IoZSksbC5wdXNoKGUpLG49YS50ZXhEYXRhLmdldChlLmRhdGFJZCk7ZWxzZSBpZihuLmlzUGFja2VkJiYhX2Uobi5zaGFwZSxlLnNoYXBlKSl7dmFyIHI9ZSxvPWUuc2hhcGU7ZS5zaGFwZT1uLnNoYXBlLGU9YS5wYWNrZWRSZXNoYXBlKGUsbyksbC5wdXNoKGUpLG49YS50ZXhEYXRhLmdldChlLmRhdGFJZCksci5zaGFwZT1vfXJldHVybiBhLnVwbG9hZFRvR1BVKGUuZGF0YUlkKSx7c2hhcGU6ZS5zaGFwZSx0ZXhEYXRhOm4saXNVbmlmb3JtOiExfX0pKTt0aGlzLnVwbG9hZFRvR1BVKHMuZGF0YUlkKTt2YXIgZixkPXtzaGFwZTpzLnNoYXBlLHRleERhdGE6dSxpc1VuaWZvcm06ITF9LHA9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVwiXCI7ZS5jb25jYXQobikuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9bnVsbCE9dC50ZXhEYXRhJiZudWxsIT10LnRleERhdGEuc2xpY2UmJnQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0PjAsbj10LmlzVW5pZm9ybT9cInVuaWZvcm1cIjp0LnRleERhdGEudGV4U2hhcGU7cis9dC5zaGFwZStcIl9cIituK1wiX1wiK2V9KSk7dmFyIG89dC51c2VyQ29kZSxhPXQuY29uc3RydWN0b3IubmFtZTtyZXR1cm4gYSs9XCJfXCIrcitcIl9cIitvfSh0LGgsZCksdj10aGlzLmdldEFuZFNhdmVCaW5hcnkocCwoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZS51c2VyQ29kZSxhPW4ubWFwKChmdW5jdGlvbih0LG4pe3ZhciByPXtsb2dpY2FsU2hhcGU6dC5zaGFwZSx0ZXhTaGFwZTp0LmlzVW5pZm9ybT9udWxsOnQudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06dC5pc1VuaWZvcm0saXNQYWNrZWQ6IXQuaXNVbmlmb3JtJiZ0LnRleERhdGEuaXNQYWNrZWQsZmxhdE9mZnNldDpudWxsfTtyZXR1cm4gbnVsbCE9dC50ZXhEYXRhJiZudWxsIT10LnRleERhdGEuc2xpY2UmJnQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0PjAmJihyLmZsYXRPZmZzZXQ9dC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQpLHtuYW1lOmUudmFyaWFibGVOYW1lc1tuXSxzaGFwZUluZm86cn19KSkscz1hLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGVJbmZvfSkpLHU9e2xvZ2ljYWxTaGFwZTpyLnNoYXBlLHRleFNoYXBlOnIudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06ITEsaXNQYWNrZWQ6ci50ZXhEYXRhLmlzUGFja2VkLGZsYXRPZmZzZXQ6bnVsbH0sYz1mYShhLHUsbyxlLnBhY2tlZElucHV0cyksbD10LmNyZWF0ZVByb2dyYW0oYyksaD1udWxsLGY9dC5nZXRVbmlmb3JtTG9jYXRpb24obCxcIk5BTlwiLCExKTsxPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikmJihoPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGwsXCJJTkZJTklUWVwiLCExKSk7Zm9yKHZhciBkPXt9LHA9MDtwPGUudmFyaWFibGVOYW1lcy5sZW5ndGg7cCsrKXt2YXIgdj1lLnZhcmlhYmxlTmFtZXNbcF07ZFt2XT10LmdldFVuaWZvcm1Mb2NhdGlvbihsLHYsITEpLGRbXCJvZmZzZXRcIit2XT10LmdldFVuaWZvcm1Mb2NhdGlvbihsLFwib2Zmc2V0XCIrdiwhMSl9cmV0dXJue3Byb2dyYW06ZSxzb3VyY2U6Yyx3ZWJHTFByb2dyYW06bCx1bmlmb3JtTG9jYXRpb25zOmQsaW5TaGFwZUluZm9zOnMsb3V0U2hhcGVJbmZvOnUsaW5mTG9jOmgsbmFuTG9jOmZ9fShhLmdwZ3B1LHQsaCxkKX0pKSxtPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzO2lmKG0mJihmPXRoaXMuc3RhcnRUaW1lcigpKSxmdW5jdGlvbih0LGUsbixyLG8pe1BpKGUuaW5TaGFwZUluZm9zLG4pLFBpKFtlLm91dFNoYXBlSW5mb10sW3JdKTt2YXIgYT1yLnRleERhdGEudGV4dHVyZSxzPXIudGV4RGF0YS50ZXhTaGFwZTtyLnRleERhdGEuaXNQYWNrZWQ/dC5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlKGEsc1swXSxzWzFdKTp0LnNldE91dHB1dE1hdHJpeFRleHR1cmUoYSxzWzBdLHNbMV0pLHQuc2V0UHJvZ3JhbShlLndlYkdMUHJvZ3JhbSksMT09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpJiZudWxsIT09ZS5pbmZMb2MmJnQuZ2wudW5pZm9ybTFmKGUuaW5mTG9jLDEvMCksbnVsbCE9PWUubmFuTG9jJiZ0LmdsLnVuaWZvcm0xZihlLm5hbkxvYyxOYU4pLG4uZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1lLnByb2dyYW0udmFyaWFibGVOYW1lc1tyXSxhPWUudW5pZm9ybUxvY2F0aW9uc1tvXSxpPWUudW5pZm9ybUxvY2F0aW9uc1tcIm9mZnNldFwiK29dO2lmKG51bGwhPWEpaWYobi5pc1VuaWZvcm0paWYoayhuLnNoYXBlKTwyKXQuZ2wudW5pZm9ybTFmKGEsbi51bmlmb3JtVmFsdWVzWzBdKTtlbHNle3ZhciBzPW4udW5pZm9ybVZhbHVlcztzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHwocz1uZXcgRmxvYXQzMkFycmF5KHMpKSx0LmdsLnVuaWZvcm0xZnYoYSxzKX1lbHNlIG51bGwhPW4udGV4RGF0YS5zbGljZSYmbnVsbCE9aSYmdC5nbC51bmlmb3JtMWkoaSxuLnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCksdC5zZXRJbnB1dE1hdHJpeFRleHR1cmUobi50ZXhEYXRhLnRleHR1cmUsYSxyKX0pKSxudWxsIT1vJiZvKHQsZS53ZWJHTFByb2dyYW0pLHQuZXhlY3V0ZVByb2dyYW0oKX0odGhpcy5ncGdwdSx2LGgsZCxyKSxsLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBhLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKX0pKSxtJiYoZj10aGlzLmVuZFRpbWVyKGYpLHRoaXMuYWN0aXZlVGltZXJzLnB1c2goe25hbWU6dC5jb25zdHJ1Y3Rvci5uYW1lLHF1ZXJ5OnRoaXMuZ2V0UXVlcnlUaW1lKGYpfSkpLCFpKCkuZ2V0Qm9vbChcIldFQkdMX0xBWklMWV9VTlBBQ0tcIikmJnUuaXNQYWNrZWQmJiExPT09byl7dmFyIGc9dGhpcy51bnBhY2tUZW5zb3Iocyk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEocy5kYXRhSWQpLGd9cmV0dXJuIHN9LG8ucHJvdG90eXBlLmNvbXBpbGVBbmRSdW49ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz0hMSksbj1ufHxlWzBdLmR0eXBlO3ZhciBhPXRoaXMucnVuV2ViR0xQcm9ncmFtKHQsZSxuLHIsbyk7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKGEuZGF0YUlkLGEuc2hhcGUsYS5kdHlwZSl9LG8ucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbiB0aGlzLmJpbmFyeUNhY2hlfHwodGhpcy5iaW5hcnlDYWNoZVt0XT1lKCkpLHRoaXMuYmluYXJ5Q2FjaGVbdF19LG8ucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXJ9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKCF0aGlzLmRpc3Bvc2VkKXtpZighaSgpLmdldEJvb2woXCJJU19URVNUXCIpKU9iamVjdC5rZXlzKHRoaXMuYmluYXJ5Q2FjaGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QuZ3BncHUuZGVsZXRlUHJvZ3JhbSh0LmJpbmFyeUNhY2hlW2VdLndlYkdMUHJvZ3JhbSksZGVsZXRlIHQuYmluYXJ5Q2FjaGVbZV19KSk7dGhpcy50ZXh0dXJlTWFuYWdlci5kaXNwb3NlKCksbnVsbCE9dGhpcy5jYW52YXMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCYmdGhpcy5jYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudD90aGlzLmNhbnZhcy5yZW1vdmUoKTp0aGlzLmNhbnZhcz1udWxsLHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSYmKHRoaXMuZ3BncHUucHJvZ3JhbT1udWxsLHRoaXMuZ3BncHUuZGlzcG9zZSgpKSx0aGlzLmRpc3Bvc2VkPSEwfX0sby5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBudWxsPT10aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWUmJih0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWU9WmUoKGZ1bmN0aW9uKCl7aWYoIWkoKS5nZXQoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpKXt2YXIgZT1pKCkuZ2V0Qm9vbChcIkRFQlVHXCIpO2koKS5zZXQoXCJERUJVR1wiLCExKTt2YXIgbj10LmFicyhPbigxZS04KSkuZGF0YVN5bmMoKVswXTtpZihpKCkuc2V0KFwiREVCVUdcIixlKSxuPjApcmV0dXJuIDMyfXJldHVybiAxNn0pKSksdGhpcy5mbG9hdFByZWNpc2lvblZhbHVlfSxvLnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyPT09dGhpcy5mbG9hdFByZWNpc2lvbigpPzFlLTc6MWUtNH0sby5wcm90b3R5cGUudXBsb2FkVG9HUFU9ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5zaGFwZSxvPW4uZHR5cGUsYT1uLnZhbHVlcyxpPW4udGV4dHVyZSxzPW4udXNhZ2UsdT1uLmlzUGFja2VkO2lmKG51bGw9PWkpe3ZhciBjLGw9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7bCYmKGM9ZXQoKSk7dmFyIGg9bi50ZXhTaGFwZTtpZihudWxsPT1oJiYoaD1OZShyLHUpLG4udGV4U2hhcGU9aCksbnVsbCE9YSl7dmFyIGY9VGUociksZD12b2lkIDAscD1oWzFdLHY9aFswXSxtPWEgaW5zdGFuY2VvZiBVaW50OEFycmF5O3U/KHA9KGU9JHQoaFswXSxoWzFdKSlbMF0sdj1lWzFdLGQ9bmV3IGhpKGYsW3YscF0sbSkpOmQ9bmV3IGxpKGYsW3YscF0sbSk7dmFyIGc9dGhpcy5tYWtlVGVuc29ySW5mbyhbdixwXSxvKTt0aGlzLnRleERhdGEuZ2V0KGcuZGF0YUlkKS51c2FnZT1tP3p0LlBJWEVMUzp6dC5VUExPQUQsdGhpcy5ncGdwdS51cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZSh0aGlzLmdldFRleHR1cmUoZy5kYXRhSWQpLHAsdixhKTt2YXIgeT10aGlzLnJ1bldlYkdMUHJvZ3JhbShkLFtnXSxvLG51bGwsITApLHg9dGhpcy50ZXhEYXRhLmdldCh5LmRhdGFJZCk7bi50ZXh0dXJlPXgudGV4dHVyZSxuLnRleFNoYXBlPXgudGV4U2hhcGUsbi5pc1BhY2tlZD14LmlzUGFja2VkLG4udXNhZ2U9eC51c2FnZSx0aGlzLmRpc3Bvc2VEYXRhKGcuZGF0YUlkKSx0aGlzLnRleERhdGEuZGVsZXRlKHkuZGF0YUlkKSxuLnZhbHVlcz1udWxsLGwmJih0aGlzLnVwbG9hZFdhaXRNcys9ZXQoKS1jKX1lbHNle3ZhciBiPXRoaXMuYWNxdWlyZVRleHR1cmUoaCxzLG8sdSk7bi50ZXh0dXJlPWJ9fX0sby5wcm90b3R5cGUuY29udmVydEFuZENhY2hlT25DUFU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5kdHlwZTtyZXR1cm4gdGhpcy5yZWxlYXNlR1BVRGF0YSh0KSxudWxsIT1lJiYobi52YWx1ZXM9ZnVuY3Rpb24odCxlKXtpZihcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiB0O2lmKFwiaW50MzJcIj09PWV8fFwiYm9vbFwiPT09ZSl7Zm9yKHZhciBuPVwiaW50MzJcIj09PWU/bmV3IEludDMyQXJyYXkodC5sZW5ndGgpOm5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDsrK3IpbltyXT1NYXRoLnJvdW5kKHRbcl0pO3JldHVybiBufXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrZSl9KGUscikpLG4udmFsdWVzfSxvLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXtpZih0aGlzLm51bUJ5dGVzSW5HUFUrPXRoaXMuY29tcHV0ZUJ5dGVzKHQsbiksIXRoaXMud2FybmVkQWJvdXRNZW1vcnkmJnRoaXMubnVtQnl0ZXNJbkdQVT4xMDI0KnRoaXMubnVtTUJCZWZvcmVXYXJuaW5nKjEwMjQpe3ZhciBvPSh0aGlzLm51bUJ5dGVzSW5HUFUvMTAyNC8xMDI0KS50b0ZpeGVkKDIpO3RoaXMud2FybmVkQWJvdXRNZW1vcnk9ITAsY29uc29sZS53YXJuKFwiSGlnaCBtZW1vcnkgdXNhZ2UgaW4gR1BVOiBcIitvK1wiIE1CLCBtb3N0IGxpa2VseSBkdWUgdG8gYSBtZW1vcnkgbGVha1wiKX1yZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0LGUscil9LG8ucHJvdG90eXBlLmNvbXB1dGVCeXRlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0WzBdKnRbMV0qeihlKX0sb30oYm8pO1d0KCkmJkx0LnJlZ2lzdGVyQmFja2VuZChcIndlYmdsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBac30pLDIpO3ZhciB0dT1Bbih7c3F1YXJlXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic3F1YXJlXCIpLG49W2VdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3JldHVybiBuKFtlXSksdC5zcXVhcmUoZSl9KSx7eDplfSxudWxsLFwiU3F1YXJlXCIse30sbixbXSl9fSksZXU9XCJTcXVhcmVkRGlmZmVyZW5jZVwiO3ZhciBudT1Bbih7c3F1YXJlZERpZmZlcmVuY2VfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwic3F1YXJlZERpZmZlcmVuY2VcIiksbz1tbihlLFwiYlwiLFwic3F1YXJlZERpZmZlcmVuY2VcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV0sUm8oci5zaGFwZSxvLnNoYXBlKTt2YXIgYT17YTpyLGI6b30saT1bcixvXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LnNxdWFyZWREaWZmZXJlbmNlKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSxhLChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89T24oMik7cmV0dXJue2E6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5zdWIocikubXVsKG8pKX0sYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChyLnN1YihuKS5tdWwobykpfX19KSxldSx7fSxpLFtdKX19KTt2YXIgcnU9QW4oe2Fic186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImFic1wiKTtyZXR1cm5cImNvbXBsZXg2NFwiPT09ZS5kdHlwZT9MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21wbGV4QWJzKGUpfSkseyR4OmV9KTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYWJzKGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi50b0Zsb2F0KCkuc3RlcCgtMSkpfX19KSxcIkFic1wiKX19KSxvdT1Bbih7YWNvc186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImFjb3NcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hY29zKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChPbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSkubmVnKCl9fX0pKX19KSxhdT1Bbih7YWNvc2hfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJhY29zaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFjb3NoKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChuLnRvRmxvYXQoKS5zcXVhcmUoKS5zdWIoMSkuc3FydCgpKX19fSkpfX0pLGl1PUFuKHthc2luXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiYXNpblwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFzaW4oZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KE9uKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKX19fSkpfX0pLHN1PUFuKHthc2luaF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImFzaW5oXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXNpbmgoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KE9uKDEpLmFkZChuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKX19fSkpfX0pLHV1PUFuKHthdGFuXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiYXRhblwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmF0YW4oZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpLnNxdWFyZSgpLmFkZCgxKSl9fX0pKX19KSxjdT1Bbih7YXRhbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJhdGFuaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmF0YW5oKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihPbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpKX19fSkpfX0pLGx1PUFuKHtjZWlsXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiY2VpbFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2VpbChlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksaHU9QW4oe2NsaXBCeVZhbHVlXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcImNsaXBCeVZhbHVlXCIpO0MoZTw9biwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNsaXA6IG1pbiAoXCIrZStcIikgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4IChcIituK1wiKS5cIn0pKTt2YXIgbz1bcl0sYT17bWluOmUsbWF4Om59O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG8pe3ZhciBhPXQuY2xpcChyLGUsbik7cmV0dXJuIG8oW3JdKSxhfSkse3g6cn0sKGZ1bmN0aW9uKHQscil7dmFyIG89clswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LndoZXJlKG8uZ3JlYXRlckVxdWFsKGUpLmxvZ2ljYWxBbmQoby5sZXNzRXF1YWwobikpLFhuKHQpKX19fSksXCJDbGlwQnlWYWx1ZVwiLGEsbyl9fSksZnU9QW4oe2Nvc186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImNvc1wiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmNvcyhlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLnNpbigpLm5lZygpLm11bCh0KX19fSksXCJDb3NcIix7fSxuKX19KSxkdT1Bbih7Y29zaF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImNvc2hcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5jb3NoKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5zaW5oKCkubXVsU3RyaWN0KHQpfX19KSl9fSkscHU9QW4oe2VyZl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImVyZlwiKTtyZXR1cm4gQyhcImludDMyXCI9PT1lLmR0eXBlfHxcImZsb2F0MzJcIj09PWUuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnB1dCBkdHlwZSBtdXN0IGJlIGBpbnQzMmAgb3IgYGZsb2F0MzJgLlwifSkpLFwiaW50MzJcIj09PWUuZHR5cGUmJihlPWUudG9GbG9hdCgpKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuZXJmKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnNxdWFyZSgpLm5lZygpLmV4cCgpLm11bCgyL01hdGguc3FydChNYXRoLlBJKSkpfX19KSl9fSksdnU9QW4oe2V4cF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImV4cFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmV4cChlKTtyZXR1cm4gbihbcl0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChlWzBdKX19fSksXCJFeHBcIix7fSxbXSxbITBdKX19KSxtdT1Bbih7ZXhwbTFfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJleHBtMVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmV4cG0xKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmV4cCgpKX19fSkpfX0pLGd1PUFuKHtmbG9vcl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImZsb29yXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5mbG9vcihlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSkseXU9QW4oe2xvZ186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImxvZ1wiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZyhlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpKX19fSksXCJMb2dcIix7fSxuKX19KSx4dT1Bbih7bG9nMXBfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJsb2cxcFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZzFwKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLmFkZCgxKSl9fX0pKX19KSxidT1Bbih7bG9nU2lnbW9pZF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImxvZ1NpZ21vaWRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zb2Z0cGx1cyhlLm5lZygpKS5uZWcoKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5uZWcoKS5zaWdtb2lkKCkpfX19KSl9fSksd3U9QW4oe25lZ186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcIm5lZ1wiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubmVnKGUpfSkse3g6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubmVnKCl9fX0pLFwiTmVnXCIse30sbil9fSksQ3U9QW4oe3JlY2lwcm9jYWxfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJyZWNpcHJvY2FsXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQucmVjaXByb2NhbChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5zcXVhcmUoKS5uZWcoKSl9fX0pKX19KSxFdT1Bbih7cm91bmRfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJyb3VuZFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucm91bmQoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLFJ1PUFuKHtyc3FydF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInJzcXJ0XCIpLG49W2VdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQucnNxcnQoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnBvdygxLjUpLm11bCgyKSkubmVnKCl9fX0pLFwiUnNxcnRcIix7fSxuKX19KSxJdT1Bbih7c2lnbW9pZF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNpZ21vaWRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaWdtb2lkKGUpO3JldHVybiBuKFtyXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5tdWwoT24oMSkuc3ViKG4pKSl9fX0pLFwiU2lnbW9pZFwiKX19KSxrdT1Bbih7c2lnbl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNpZ25cIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNpZ24oZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLFN1PUFuKHtpc05hTl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImlzTmFOXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc05hTihlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksQXU9QW4oe2lzSW5mXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiaXNJbmZcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzSW5mKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxEdT1Bbih7aXNGaW5pdGVfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJpc0Zpbml0ZVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNGaW5pdGUoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLFR1PUFuKHtzaW5fOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzaW5cIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaW4oZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5jb3MoKS5tdWwodCl9fX0pLFwiU2luXCIse30sbil9fSksTnU9QW4oe3NpbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzaW5oXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2luaChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuY29zaCgpLm11bFN0cmljdCh0KX19fSkpfX0pLEZ1PUFuKHtzb2Z0cGx1c186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNvZnRwbHVzXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc29mdHBsdXMoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc2lnbW9pZCgpKX19fSkpfX0pLF91PUFuKHtzcXJ0XzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic3FydFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNxcnQoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpLnNxcnQoKS5tdWwoMikpfX19KSl9fSksT3U9QW4oe3N0ZXBfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49bW4odCxcInhcIixcInN0ZXBcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0ZXAobixlKX0pLHskeDpufSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksTXU9QW4oe3Rhbl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInRhblwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnRhbihlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5jb3MoKS5zcXVhcmUoKSl9fX0pKX19KSxCdT1Bbih7dGFuaF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInRhbmhcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC50YW5oKGUpO3JldHVybiBuKFtyXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gT24oMSkuc3ViKG4uc3F1YXJlKCkpLm11bFN0cmljdCh0KX19fSksXCJUYW5oXCIse30sbnVsbCxbITBdKX19KTtmdW5jdGlvbiBQdSh0LGUsbixyLG8sYSl7dmFyIGkscyx1PW1uKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksYz1tbihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGw9bW4obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7cmV0dXJuIG51bGwhPW8mJihpPW1uKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz1tbihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLEMoMj09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQygyPT09Yy5yYW5rfHwxPT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IG1lYW4gbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQygyPT09bC5yYW5rfHwxPT09bC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSkpLG51bGwhPWkmJkMoMj09PWkucmFua3x8MT09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pKSxudWxsIT1zJiZDKDI9PT1zLnJhbmt8fDE9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogb2Zmc2V0IG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSkpLFV1KHUsYyxsLHMsaSxhKX1mdW5jdGlvbiBMdSh0LGUsbixyLG8sYSl7dmFyIGkscyx1PW1uKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksYz1tbihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGw9bW4obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7cmV0dXJuIG51bGwhPW8mJihpPW1uKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz1tbihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLEMoMz09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQygzPT09Yy5yYW5rfHwxPT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IG1lYW4gbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQygzPT09bC5yYW5rfHwxPT09bC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSkpLG51bGwhPWkmJkMoMz09PWkucmFua3x8MT09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pKSxudWxsIT1zJiZDKDM9PT1zLnJhbmt8fDE9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogb2Zmc2V0IG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSkpLFV1KHUsYyxsLHMsaSxhKX1mdW5jdGlvbiBXdSh0LGUsbixyLG8sYSl7dmFyIGkscyx1PW1uKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksYz1tbihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGw9bW4obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7cmV0dXJuIG51bGwhPW8mJihpPW1uKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz1tbihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyg0PT09Yy5yYW5rfHwxPT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IG1lYW4gbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg0PT09bC5yYW5rfHwxPT09bC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSkpLG51bGwhPWkmJkMoND09PWkucmFua3x8MT09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiBzY2FsZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pKSxudWxsIT1zJiZDKDQ9PT1zLnJhbmt8fDE9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogb2Zmc2V0IG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSkpLFV1KHUsYyxsLHMsaSxhKX1mdW5jdGlvbiBVdSh0LGUsbixyLG8sYSl7bnVsbD09YSYmKGE9LjAwMSk7dmFyIGkscyx1LGM9bW4odCxcInhcIixcImJhdGNoTm9ybVwiKSxsPW1uKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksaD1tbihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtudWxsIT1vJiYoaT1tbihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9bW4ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxDKGwucmFuaz09PWgucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgdmFyaWFuY2UgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pKSxDKG51bGw9PXN8fGwucmFuaz09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgb2Zmc2V0IHRvIGhhdmUgZXF1YWwgcmFua3MuXCJ9KSksQyhudWxsPT1pfHxsLnJhbms9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHNjYWxlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCJ9KSksdT0wPT09Yy5yYW5rfHwxPT09Yy5yYW5rP2MuYXM0RCgxLDEsMSxjLnNpemUpOjI9PT1jLnJhbms/Yy5hczREKDEsMSxjLnNoYXBlWzBdLGMuc2hhcGVbMV0pOjM9PT1jLnJhbms/Yy5hczREKDEsYy5zaGFwZVswXSxjLnNoYXBlWzFdLGMuc2hhcGVbMl0pOmM7dmFyIGY9W2MsbCxoLGldO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuYmF0Y2hOb3JtYWxpemF0aW9uKHUsVnUobCksVnUoaCksYSxWdShpKSxWdShzKSk7cmV0dXJuIGUoW2MsbCxoLGldKSxufSkse3g6YyxtZWFuOmwsdmFyaWFuY2U6aCxzY2FsZTppLG9mZnNldDpzfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lLHI9blswXSxvPW5bMV0saT1uWzJdLHM9blszXSxjPW51bGw9PXM/T24oMSk6cyxsPUVvKG8uc2hhcGUsdS5zaGFwZSksaD1bXTtpZigxPT09by5yYW5rKXtmb3IodmFyIGY9MDtmPHUuc2hhcGUubGVuZ3RoLTE7KytmKWgucHVzaCh1LnNoYXBlW2ZdKTtoLnB1c2goMSl9dmFyIGQ9ci5zdWIobykscD10Lm11bChjKSx2PVJ1KGkuYWRkKE9uKGEpKSksbT12Lm11bCh2KS5tdWwodikubXVsKE9uKC0uNSkpO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1vLnJhbms/dC5tdWwoTHIodi5hczREKDEsMSwxLG8uc2hhcGVbMF0pLGgpKS5tdWwoYykucmVzaGFwZShyLnNoYXBlKTp0Lm11bCh2KS5tdWwoYykucmVzaGFwZShyLnNoYXBlKX0sbWVhbjpmdW5jdGlvbigpe3ZhciB0PXYubXVsKE9uKC0xKSkubXVsKHApO3JldHVybiAxPT09by5yYW5rJiYodD10LnN1bShsKSksdC5yZXNoYXBlKG8uc2hhcGUpfSx2YXJpYW5jZTpmdW5jdGlvbigpe3ZhciB0PW0ubXVsKGQpLm11bChwKTtyZXR1cm4gMT09PW8ucmFuayYmKHQ9dC5zdW0obCkpLHQucmVzaGFwZShvLnNoYXBlKX0sc2NhbGU6ZnVuY3Rpb24oKXt2YXIgZT1kLm11bCh2KSxuPXQubXVsKGUpO3JldHVybiAxPT09by5yYW5rJiYobj1uLnN1bShsKSksbi5yZXNoYXBlKG8uc2hhcGUpfSxvZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgZT10O3JldHVybiAxPT09by5yYW5rJiYoZT1lLnN1bShsKSksZS5yZXNoYXBlKG8uc2hhcGUpfX19KSxcIkJhdGNoTm9ybWFsaXphdGlvblwiLHt2YXJpYW5jZUVwc2lsb246YX0sZikucmVzaGFwZShjLnNoYXBlKX1mdW5jdGlvbiBWdSh0KXtyZXR1cm4gbnVsbD09dD9udWxsOjA9PT10LnJhbms/dC5hczFEKCk6MT09PXQucmFuaz90OjI9PT10LnJhbms/dC5hczREKDEsMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0pOjM9PT10LnJhbms/dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pOnR9ZnVuY3Rpb24genUoKXtYZShcInRmLmJhdGNoTm9ybWFsaXphdGlvbigpIGlzIGdvaW5nIGF3YXkuIFVzZSB0Zi5iYXRjaE5vcm0oKSBpbnN0ZWFkLCBhbmQgbm90ZSB0aGUgcG9zaXRpb25hbCBhcmd1bWVudCBjaGFuZ2Ugb2Ygc2NhbGUsIG9mZnNldCwgYW5kIHZhcmlhbmNlRXBzaWxvblwiKX12YXIgR3U9QW4oe2JhdGNoTm9ybWFsaXphdGlvbjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLHp1KCksUHUodCxlLG4sYSxvLHIpfX0pLEh1PUFuKHtiYXRjaE5vcm1hbGl6YXRpb24zZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSx6dSgpLEx1KHQsZSxuLGEsbyxyKX19KSxxdT1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uNGRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksenUoKSxXdSh0LGUsbixhLG8scil9fSksS3U9QW4oe2JhdGNoTm9ybWFsaXphdGlvbl86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSx6dSgpLFV1KHQsZSxuLGEsbyxyKX19KSxqdT1Bbih7YmF0Y2hOb3JtXzpVdX0pLFh1PUFuKHtiYXRjaE5vcm0yZF86UHV9KSxZdT1Bbih7YmF0Y2hOb3JtM2RfOkx1fSksJHU9QW4oe2JhdGNoTm9ybTRkXzpXdX0pO3ZhciBRdT1Bbih7bG9naWNhbEFuZF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibG9naWNhbEFuZFwiLFwiYm9vbFwiKSxyPW1uKGUsXCJiXCIsXCJsb2dpY2FsQW5kXCIsXCJib29sXCIpO3JldHVybiBSbyhuLnNoYXBlLHIuc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvZ2ljYWxBbmQobixyKX0pLHthOm4sYjpyfSxudWxsLFwiTG9naWNhbEFuZFwiKX19KSxKdT1Bbih7bG9naWNhbE5vdF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImxvZ2ljYWxOb3RcIixcImJvb2xcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvZ2ljYWxOb3QoZSl9KSx7JHg6ZX0pfX0pLFp1PUFuKHtsb2dpY2FsT3JfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKSxyPW1uKGUsXCJiXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIik7cmV0dXJuIFJvKG4uc2hhcGUsci5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9naWNhbE9yKG4scil9KSx7JGE6biwkYjpyfSl9fSksdGM9QW4oe2xvZ2ljYWxYb3JfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImxvZ2ljYWxYb3JcIixcImJvb2xcIikscj1tbihlLFwiYlwiLFwibG9naWNhbFhvclwiLFwiYm9vbFwiKTtyZXR1cm4gUm8obi5zaGFwZSxyLnNoYXBlKSxadSh0LGUpLmxvZ2ljYWxBbmQoUXUodCxlKS5sb2dpY2FsTm90KCkpfX0pLGVjPUFuKHt3aGVyZV86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKGUsXCJhXCIsXCJ3aGVyZVwiKSxvPW1uKG4sXCJiXCIsXCJ3aGVyZVwiKSxhPW1uKHQsXCJjb25kaXRpb25cIixcIndoZXJlXCIsXCJib29sXCIpO3JldHVybiBFKHIuc2hhcGUsby5zaGFwZSxcIkVycm9yIGluIHdoZXJlOiBcIiksMT09PWEucmFuaz9DKGEuc2hhcGVbMF09PT1yLnNoYXBlWzBdLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBgYWAgbXVzdCBtYXRjaCB0aGUgc2l6ZSBvZiBgY29uZGl0aW9uYC5cIn0pKTpFKGEuc2hhcGUsby5zaGFwZSxcIkVycm9yIGluIHdoZXJlOiBcIiksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LnNlbGVjdChhLHIsbyk7cmV0dXJuIGUoW2FdKSxufSkseyRjb25kaXRpb246YSwkYTpyLCRiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyRjb25kaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gWG4obikudG9GbG9hdCgpfSwkYTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmNhc3QodC5kdHlwZSkpfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmxvZ2ljYWxOb3QoKS5jYXN0KHQuZHR5cGUpKX19fSkpfX0pLG5jPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG87cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCwoZT1tbih0LFwiY29uZGl0aW9uXCIsXCJ3aGVyZUFzeW5jXCIsXCJib29sXCIpKS5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gbj1yLnNlbnQoKSxvPW5hKGUuc2hhcGUsbiksdCE9PWUmJmUuZGlzcG9zZSgpLFsyLG9dfX0pKX0pKX07dmFyIHJjPUFuKHthZGRfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiYWRkXCIpLG89bW4oZSxcImJcIixcImFkZFwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGQocixvKX0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCl7cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT10LG49RW8oci5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShyLnNoYXBlKX0sYjpmdW5jdGlvbigpe3ZhciBlPXQsbj1FbyhvLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5yZXNoYXBlKG8uc2hhcGUpfX19KSxcIkFkZFwiKX19KSxvYz1Bbih7YWRkTl86ZnVuY3Rpb24odCl7QyhBcnJheS5pc0FycmF5KHQpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBiZSBhIGxpc3Qgb2YgdGVuc29yc1wifSkpLEModC5sZW5ndGg+PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJNdXN0IHBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byB0Zi5hZGROKCksIGJ1dCBnb3QgXCIrdC5sZW5ndGh9KSk7dmFyIGU9dC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIG1uKHQsXCJ0ZW5zb3JzXCIrZSxcImFkZE5cIil9KSksbj1lWzBdO2UuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYodC5kdHlwZSE9PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGVcIil9KSksZS5mb3JFYWNoKChmdW5jdGlvbih0KXtpZighUyh0LnNoYXBlLG4uc2hhcGUpKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfSkpO3ZhciByPWU7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFkZE4oZSl9KSxyLChmdW5jdGlvbih0KXt2YXIgbj17fTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlLHIpe25bcl09ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9uZSgpfX0pKSxufSksXCJBZGROXCIpfX0pLGFjPUFuKHthZGRTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImFkZFN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJhZGRTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gYWRkU3RyaWN0OiBcIiksbi5hZGQocil9fSksaWM9QW4oe2F0YW4yXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImF0YW4yXCIpLG89bW4oZSxcImJcIixcImF0YW4yXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5hdGFuMihyLG8pO3JldHVybiBlKFtyLG9dKSxufSkseyRhOnIsJGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9cmMobi5zcXVhcmUoKSxyLnNxdWFyZSgpKSxvPXQubXVsKHIuZGl2KGUpKSxpPUVvKG4uc2hhcGUsYSk7cmV0dXJuIGkubGVuZ3RoPjAmJihvPW8uc3VtKGkpKSxvLnJlc2hhcGUobi5zaGFwZSl9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9cmMobi5zcXVhcmUoKSxyLnNxdWFyZSgpKSxvPXd1KHQubXVsKG4uZGl2KGUpKSksaT1FbyhyLnNoYXBlLGEpO3JldHVybiBpLmxlbmd0aD4wJiYobz1vLnN1bShpKSksby5yZXNoYXBlKHIuc2hhcGUpfX19KSl9fSksc2M9QW4oe2Rpdl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJkaXZcIiksbz1tbihlLFwiYlwiLFwiZGl2XCIpO2lmKG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFwiaW50MzJcIj09PXIuZHR5cGUmJlwiaW50MzJcIj09PW8uZHR5cGUpcmV0dXJuIGxjKHIsbyk7dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LnJlYWxEaXZpZGUocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQuZGl2KHIudG9GbG9hdCgpKSxvPUVvKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89RW8oci5zaGFwZSxhKTtvLmxlbmd0aD4wJiYoZT1lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpKTt2YXIgaT1yLnNxdWFyZSgpO3JldHVybiBlLmRpdihpLnRvRmxvYXQoKSkubmVnKCl9fX0pLFwiRGl2XCIpfX0pLHVjPUFuKHtkaXZOb05hbl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJkaXZcIiksbz1tbihlLFwiYlwiLFwiZGl2XCIpO3I9KG49TnQocixvKSlbMF0sbz1uWzFdO3ZhciBhPXNjKHIsbyksaT1YbihhKSxzPW8uZXF1YWwoaSk7cmV0dXJuIGVjKHMsaSxhKX19KSxjYz1Bbih7ZGl2U3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJkaXZcIikscj1tbihlLFwiYlwiLFwiZGl2XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGRpdmlkZVN0cmljdDogXCIpLG4uZGl2KHIpfX0pLGxjPUFuKHtmbG9vckRpdl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJmbG9vckRpdlwiKSxvPW1uKGUsXCJiXCIsXCJmbG9vckRpdlwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZmxvb3JEaXYocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQuZGl2KHIudG9GbG9hdCgpKSxvPUVvKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89RW8oci5zaGFwZSxhKTtvLmxlbmd0aD4wJiYoZT1lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpKTt2YXIgaT1yLnNxdWFyZSgpO3JldHVybiBlLmRpdihpLnRvRmxvYXQoKSkubmVnKCl9fX0pLFwiRmxvb3JEaXZcIil9fSksaGM9QW4oe21heGltdW1fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwibWF4aW11bVwiKSxvPW1uKGUsXCJiXCIsXCJtYXhpbXVtXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSxvPW8udG9JbnQoKSksUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4aW11bShyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uZ3JlYXRlckVxdWFsKHIpLnRvRmxvYXQoKSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sZXNzKHIpLnRvRmxvYXQoKSl9fX0pLFwiTWF4aW11bVwiKX19KSxmYz1Bbih7bWF4aW11bVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibWF4aW11bVN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJtYXhpbXVtU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1heGltdW1TdHJpY3Q6IFwiKSxuLm1heGltdW0ocil9fSksZGM9QW4oe21pbmltdW1fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwibWluaW11bVwiKSxvPW1uKGUsXCJiXCIsXCJtaW5pbXVtXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSxvPW8udG9JbnQoKSksUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWluaW11bShyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubGVzc0VxdWFsKHIpLnRvRmxvYXQoKSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5ncmVhdGVyKHIpLnRvRmxvYXQoKSl9fX0pLFwiTWluaW11bVwiKX19KSxwYz1Bbih7bWluaW11bVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibWluaW11bVN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJtaW5pbXVtU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1pbmltdW1TdHJpY3Q6IFwiKSxuLm1pbmltdW0ocil9fSksdmM9QW4oe21vZF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJtb2RcIiksbz1tbihlLFwiYlwiLFwibW9kXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tb2QocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHskYTpyLCRiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPUVvKG4uc2hhcGUsYSk7cmV0dXJuIGUubGVuZ3RoPjA/dC5zdW0oZSkucmVzaGFwZShuLnNoYXBlKTp0fSwkYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4uZGl2KHIpLmZsb29yKCkubmVnKCkpLG89RW8oci5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpOmV9fX0pKX19KSxtYz1Bbih7bW9kU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJtb2RTdHJpY3RcIikscj1tbihlLFwiYlwiLFwibW9kU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1vZFN0cmljdDogXCIpLG4ubW9kKHIpfX0pLGdjPUFuKHttdWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwibXVsXCIpLG89bW4oZSxcImJcIixcIm11bFwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubXVsdGlwbHkocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQubXVsKHIudG9GbG9hdCgpKSxvPUVvKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89RW8oci5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpOmV9fX0pLFwiTXVsXCIpfX0pLHljPUFuKHttdWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcIm11bFwiKSxyPW1uKGUsXCJiXCIsXCJtdWxcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbXVsdGlwbHlTdHJpY3Q6IFwiKSxuLm11bChyKX19KSx4Yz1Bbih7cG93XzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImJhc2VcIixcInBvd1wiKSxvPW1uKGUsXCJleHBcIixcInBvd1wiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpLGk9W3Isb107cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5wb3cocixvKTtyZXR1cm4gZShbcixvLG5dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89ZVsyXTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXIudG9GbG9hdCgpLG89dC5tdWwoZS5tdWwobi5wb3coZS5zdWIoT24oMSkpKSkpLGk9RW8obi5zaGFwZSxhKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG89by5zdW0oaSkpLG8ucmVzaGFwZShuLnNoYXBlKX0sYjpmdW5jdGlvbigpe3ZhciBlPW4uZ3JlYXRlcigwKSxpPW4ubG9nKCkud2hlcmUoZSxYbihuKSkscz10Lm11bChvLm11bChpKSksdT1FbyhyLnNoYXBlLGEpO3JldHVybiB1Lmxlbmd0aD4wJiYocz1zLnN1bSh1KSkscy5yZXNoYXBlKHIuc2hhcGUpfX19KSxcIlBvd1wiLHt9LGksWyEwXSl9fSksYmM9QW4oe3Bvd1N0cmljdF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gRSh0LnNoYXBlLGUuc2hhcGUsXCJFcnJvciBpbiBwb3dTdHJpY3Q6IFwiKSx0LnBvdyhlKX19KSx3Yz1Bbih7c3F1YXJlZERpZmZlcmVuY2VTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0OiBcIiksbi5zcXVhcmVkRGlmZmVyZW5jZShyKX19KSxDYz1Bbih7c3ViXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcInN1YlwiKSxvPW1uKGUsXCJiXCIsXCJzdWJcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3VidHJhY3QocixvKX0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCl7cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT10LG49RW8oci5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShyLnNoYXBlKX0sYjpmdW5jdGlvbigpe3ZhciBlPXQsbj1FbyhvLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5uZWcoKS5yZXNoYXBlKG8uc2hhcGUpfX19KSxcIlN1YlwiKX19KSxFYz1Bbih7c3ViU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJzdWJTdHJpY3RcIikscj1tbihlLFwiYlwiLFwic3ViU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHN1YlN0cmljdDogXCIpLG4uc3ViKHIpfX0pO3ZhciBSYz1Bbih7ZXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiZXF1YWxcIiksbz1tbihlLFwiYlwiLFwiZXF1YWxcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXF1YWwocixvKX0pLHskYTpyLCRiOm99KX19KSxJYz1Bbih7ZXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImVxdWFsU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcImVxdWFsU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGVxdWFsU3RyaWN0OiBcIiksbi5lcXVhbChyKX19KSxrYz1Bbih7Z3JlYXRlcl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJncmVhdGVyXCIpLG89bW4oZSxcImJcIixcImdyZWF0ZXJcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZ3JlYXRlcihyLG8pfSkse2E6cixiOm99LG51bGwsXCJHcmVhdGVyXCIpfX0pLFNjPUFuKHtncmVhdGVyRXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiZ3JlYXRlckVxdWFsXCIpLG89bW4oZSxcImJcIixcImdyZWF0ZXJFcXVhbFwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ3JlYXRlckVxdWFsKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue2E6ZnVuY3Rpb24oKXtyZXR1cm4gWG4obil9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gWG4ocil9fX0pLFwiR3JlYXRlckVxdWFsXCIpfX0pLEFjPUFuKHtncmVhdGVyRXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImdyZWF0ZXJFcXVhbFN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJncmVhdGVyRXF1YWxTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZ3JlYXRlckVxdWFsU3RyaWN0OiBcIiksbi5ncmVhdGVyRXF1YWwocil9fSksRGM9QW4oe2dyZWF0ZXJTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImdyZWF0ZXJTdHJpY3RcIikscj1tbihlLFwiYlwiLFwiZ3JlYXRlclN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBncmVhdGVyU3RyaWN0OiBcIiksbi5ncmVhdGVyKHIpfX0pLFRjPUFuKHtsZXNzXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImxlc3NcIiksbz1tbihlLFwiYlwiLFwibGVzc1wiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sZXNzKHIsbyl9KSx7YTpyLGI6b30sbnVsbCxcIkxlc3NcIil9fSksTmM9QW4oe2xlc3NFcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJsZXNzRXF1YWxcIiksbz1tbihlLFwiYlwiLFwibGVzc0VxdWFsXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5sZXNzRXF1YWwocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSxudWxsLFwiTGVzc0VxdWFsXCIpfX0pLEZjPUFuKHtsZXNzRXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImxlc3NFcXVhbFN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJsZXNzRXF1YWxTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbGVzc0VxdWFsU3RyaWN0OiBcIiksbi5sZXNzRXF1YWwocil9fSksX2M9QW4oe2xlc3NTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImxlc3NTdHJpY3RcIikscj1tbihlLFwiYlwiLFwibGVzc1N0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBsZXNzU3RyaWN0OiBcIiksbi5sZXNzKHIpfX0pLE9jPUFuKHtub3RFcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJub3RFcXVhbFwiKSxvPW1uKGUsXCJiXCIsXCJub3RFcXVhbFwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5ub3RFcXVhbChyLG8pfSkse2E6cixiOm99LG51bGwsXCJOb3RFcXVhbFwiKX19KSxNYz1Bbih7bm90RXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcIm5vdEVxdWFsU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcIm5vdEVxdWFsU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG5vdEVxdWFsU3RyaWN0OiBcIiksbi5ub3RFcXVhbChyKX19KTtmdW5jdGlvbiBCYyh0LGUpe2Zvcih2YXIgbj1bXSxyPXQ7cjxlOysrciluLnB1c2gocik7cmV0dXJuIG59ZnVuY3Rpb24gUGModCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbilmb3IodmFyIHI9MDtyPHRbbl0ubGVuZ3RoOysrcillLnB1c2godFtuXVtyXSk7cmV0dXJuIGV9dmFyIExjPUFuKHtnYXRoZXJfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0wKTt2YXIgcj1tbih0LFwieFwiLFwiZ2F0aGVyXCIpLG89bW4oZSxcImluZGljZXNcIixcImdhdGhlclwiLFwiaW50MzJcIik7bj1PKG4sci5zaGFwZSlbMF07dmFyIGE9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj10LnNoYXBlW25dLG89W10sYT0xLGk9MSxzPTA7czxuO3MrKylvLnB1c2godC5zaGFwZVtzXSksYSo9dC5zaGFwZVtzXTtmb3Iocz0wO3M8ZS5yYW5rO3MrKylvLnB1c2goZS5zaGFwZVtzXSk7Zm9yKHM9bisxO3M8dC5yYW5rO3MrKylvLnB1c2godC5zaGFwZVtzXSksaSo9dC5zaGFwZVtzXTtyZXR1cm57YmF0Y2hTaXplOmEsc2xpY2VTaXplOmksZGltU2l6ZTpyLG91dHB1dFNoYXBlOm99fShyLG8sbik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIGE9dC5nYXRoZXIocixvLmZsYXR0ZW4oKSxuKTtyZXR1cm4gZShbb10pLGF9KSx7eDpyLGluZGljZXM6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG89ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3ZhciBlPXIuc2hhcGUsYT1vLnNpemUsaT1lLnNsaWNlKDAsbikscz1pLmxlbmd0aCx1PWUuc2xpY2UobixlLmxlbmd0aCkuc2xpY2UoMSksYz11Lmxlbmd0aCxsPUJjKDAscyksaD1CYyhzKzEscysxK2MpLGY9UGMoW2ksW2FdLHVdKSxkPXQucmVzaGFwZShmKSxwPW8ucmVzaGFwZShbYV0pLHY9UGMoW1tzXSxsLGhdKSxtPWQudHJhbnNwb3NlKHYpLGc9V2MobSxwLHIuc2hhcGVbbl0pLHk9Um4odik7cmV0dXJuIGc9Zy50cmFuc3Bvc2UoeSl9LGluZGljZXM6ZnVuY3Rpb24oKXtyZXR1cm4gb319fSksXCJHYXRoZXJcIix7YXhpczpufSkucmVzaGFwZShhLm91dHB1dFNoYXBlKX19KSxXYz1Bbih7dW5zb3J0ZWRTZWdtZW50U3VtXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcInVuc29ydGVkU2VnbWVudFN1bVwiKSxvPW1uKGUsXCJzZWdtZW50SWRzXCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIixcImludDMyXCIpO3JldHVybiBDKEEobiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJudW1TZWdtZW50cyBtdXN0IGJlIG9mIGR0eXBlIGludFwifSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIGE9dC51bnNvcnRlZFNlZ21lbnRTdW0ocixvLG4pO3JldHVybiBlKFtvXSksYX0pLHskeDpyfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1oYyhlLFhuKGUpKSxyPUxjKHQsbiksbz1TYyhlLE9uKDAsXCJpbnQzMlwiKSksYT1yLnJhbmstby5yYW5rLGk9MDtpPGE7KytpKW89d3IobyxpKzEpO289UXUobyx6bihyLnNoYXBlLFwiYm9vbFwiKSk7dmFyIHM9WG4ocik7cmV0dXJuIGVjKG8scixzKX0odCxuKX19fSkpfX0pO3ZhciBVYz1mdW5jdGlvbih0LGUsbyl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGEsaSxzLHUsYyxsLGgsZixkLHAsdixtO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6Zm9yKG49bW4odCxcInRlbnNvclwiLFwiYm9vbE1hc2tcIiksYT1tbihlLFwibWFza1wiLFwiYm9vbE1hc2tcIixcImJvb2xcIiksaT1udWxsPT1vPzA6byxzPWEucmFuayx1PW4uc2hhcGUsQyhzPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJtYXNrIGNhbm5vdCBiZSBzY2FsYXJcIn0pKSxFKHUuc2xpY2UoaSxpK3MpLGEuc2hhcGUsXCJtYXNrJ3Mgc2hhcGUgbXVzdCBtYXRjaCB0aGUgZmlyc3QgSyBkaW1lbnNpb25zIG9mIHRlbnNvcidzIHNoYXBlLFwiKSxjPTEsbD1pO2w8aStzO2wrKyljKj11W2xdO3JldHVybiBoPXUuc2xpY2UoMCxpKS5jb25jYXQoW2NdLHUuc2xpY2UoaStzKSksZj1uLnJlc2hhcGUoaCksZD1hLnJlc2hhcGUoWy0xXSksWzQsbmMoZCldO2Nhc2UgMTpyZXR1cm4gcD1yLnNlbnQoKSx2PXAuc3F1ZWV6ZShbMV0pLG09TGMoZix2LGkpLHQhPT1uJiZuLmRpc3Bvc2UoKSxlIT09YSYmYS5kaXNwb3NlKCksdi5kaXNwb3NlKCksZi5kaXNwb3NlKCksZC5kaXNwb3NlKCkscC5kaXNwb3NlKCksWzIsbV19fSkpfSkpfTtmdW5jdGlvbiBWYyh0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT1cIk5IV0NcIiksQyh0Lmxlbmd0aD09PWUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkxlbmd0aCBvZiBpblNoYXBlIChcIit0Lmxlbmd0aCtcIikgYW5kIHJhbmsgb2YgZHkgKFwiK2UucmFuaytcIikgbXVzdCBtYXRjaFwifSkpO3ZhciBzPXQsdT1lLGM9ITE7Mz09PWUucmFuayYmKGM9ITAsdT1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkscz1bMSx0WzBdLHRbMV0sdFsyXV0pLEMoND09PXMubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBsZW5ndGggXCIrcy5sZW5ndGgrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rfSkpLEMoND09PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIituLnJhbmt9KSk7dmFyIGw9XCJOSFdDXCI9PT1hP3NbM106c1sxXSxoPVwiTkhXQ1wiPT09YT91LnNoYXBlWzNdOnUuc2hhcGVbMV07QyhsPT09bi5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoXCIrbCtcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbMl0rXCIuXCJ9KSksQyhoPT09bi5zaGFwZVszXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiK2grXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVszXStcIi5cIn0pKSxudWxsIT1pJiZDKEEobyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpO3ZhciBmPUJvKGEpLGQ9U28ocyxuLnNoYXBlLHIsMSxvLGksITEsZikscD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciByPXQuY29udjJkRGVySW5wdXQodSxuLGQpO3JldHVybiBlKFtuLHVdKSxyfSkse2R5NEQ6dSxmaWx0ZXI6bn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxzPWVbMV07cmV0dXJue2R5NEQ6ZnVuY3Rpb24oKXtyZXR1cm4gcWModCxuLHIsbyxhLDEsaSl9LGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBqYyh0LHMsbi5zaGFwZSxyLG8sYSxpKX19fSkpO3JldHVybiBjP3AuYXMzRChwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXSk6cH1mdW5jdGlvbiB6Yyh0KXt2YXIgZT1mdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9bdCx0LHRdOjI9PT10Lmxlbmd0aD9bdFswXSx0WzFdLDFdOnR9KHQpLG49ZVswXSxyPWVbMV0sbz1lWzJdO3JldHVybiAxPT09biYmMT09PXImJjE9PT1vfWZ1bmN0aW9uIEdjKHQsZSxuLHIsbyl7Qyh0Lmxlbmd0aD09PWUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkxlbmd0aCBvZiBpblNoYXBlIChcIit0Lmxlbmd0aCtcIikgYW5kIHJhbmsgb2YgZHkgKFwiK2UucmFuaytcIikgbXVzdCBtYXRjaFwifSkpO3ZhciBhPXQsaT1lLHM9ITE7ND09PWUucmFuayYmKHM9ITAsaT1lLmFzNUQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdKSxhPVsxLHRbMF0sdFsxXSx0WzJdLHRbM11dKTt2YXIgdT1hWzRdLGM9aS5zaGFwZVs0XTtDKDU9PT1hLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBpblNoYXBlIG11c3QgYmUgbGVuZ3RoIDUsIGJ1dCBnb3QgbGVuZ3RoIFwiK2EubGVuZ3RoK1wiLlwifSkpLEMoNT09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK2kucmFua30pKSxDKDU9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIrbi5yYW5rfSkpLEModT09PW4uc2hhcGVbM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiK3UrXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzNdK1wiLlwifSkpLEMoYz09PW4uc2hhcGVbNF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIitjK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbNF0rXCIuXCJ9KSk7dmFyIGw9QW8oYSxuLnNoYXBlLHIsMSxvKSxoPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnYzZERlcklucHV0KGksbixsKX0pLHtkeTVEOml9KTtyZXR1cm4gcz9oLmFzNEQoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10saC5zaGFwZVs0XSk6aH12YXIgSGM9QW4oe2NvbnYxZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09byYmKG89XCJOV0NcIiksdm9pZCAwPT09YSYmKGE9MSk7dmFyIHM9bW4odCxcInhcIixcImNvbnYxZFwiKSx1PW1uKGUsXCJmaWx0ZXJcIixcImNvbnYxZFwiKSxjPXMsbD0hMTsyPT09cy5yYW5rJiYobD0hMCxjPXMuYXMzRCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSkpLEMoMz09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogaW5wdXQgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQygzPT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSksQyhjLnNoYXBlWzJdPT09dS5zaGFwZVsxXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogZGVwdGggb2YgaW5wdXQgKFwiK2Muc2hhcGVbMl0rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIit1LnNoYXBlWzFdK1wiLlwifSkpLEMoTW8obixhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxRDogRWl0aGVyIHN0cmlkZSBvciBkaWxhdGlvbiBtdXN0IGJlIDEuIEdvdCBzdHJpZGUgXCIrbitcIiBhbmQgZGlsYXRpb24gJ1wiK2ErXCInXCJ9KSksQyhcIk5XQ1wiPT09bywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogZ290IGRhdGFGb3JtYXQgb2YgXCIrbytcIiBidXQgb25seSBOV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pKTt2YXIgaD11LmFzNEQoMSx1LnNoYXBlWzBdLHUuc2hhcGVbMV0sdS5zaGFwZVsyXSksZj1jLmFzNEQoYy5zaGFwZVswXSwxLGMuc2hhcGVbMV0sYy5zaGFwZVsyXSksZD1xYyhmLGgsWzEsbl0scixcIk5IV0NcIixbMSxhXSxpKTtyZXR1cm4gbD9kLmFzMkQoZC5zaGFwZVsyXSxkLnNoYXBlWzNdKTpkLmFzM0QoZC5zaGFwZVswXSxkLnNoYXBlWzJdLGQuc2hhcGVbM10pfX0pLHFjPUFuKHtjb252MmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTkhXQ1wiKSx2b2lkIDA9PT1hJiYoYT1bMSwxXSk7dmFyIHM9bW4odCxcInhcIixcImNvbnYyZFwiKSx1PW1uKGUsXCJmaWx0ZXJcIixcImNvbnYyZFwiKSxjPXMsbD0hMTszPT09cy5yYW5rJiYobD0hMCxjPXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSksQyg0PT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxudWxsIT1pJiZDKEEociksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pKTt2YXIgaD1cIk5IV0NcIj09PW8/Yy5zaGFwZVszXTpjLnNoYXBlWzFdO0MoaD09PXUuc2hhcGVbMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0IChcIitoK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdS5zaGFwZVsyXStcIi5cIn0pKSxDKE1vKG4sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MkQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKTt2YXIgZj1CbyhvKSxkPVNvKGMuc2hhcGUsdS5zaGFwZSxuLGEscixpLCExLGYpLHA9W3UsY10sdj1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuY29udjJkKGMsdSxkKTtyZXR1cm4gZShbdSxjXSksbn0pLHt4OmMsZmlsdGVyOnV9LChmdW5jdGlvbih0LGUpe3ZhciBpPWUscz1pWzBdLHU9aVsxXTtyZXR1cm4gQyhPbyhhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGNvbnYyRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKSx7eDpmdW5jdGlvbigpe3JldHVybiBYYyh1LnNoYXBlLHQscyxuLHIsbyl9LGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBqYyh1LHQscy5zaGFwZSxuLHIsbyl9fX0pLFwiQ29udjJEXCIsZCxwKTtyZXR1cm4gbD92LmFzM0Qodi5zaGFwZVsxXSx2LnNoYXBlWzJdLHYuc2hhcGVbM10pOnZ9fSksS2M9QW4oe2NvbnYzZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZvaWQgMD09PW8mJihvPVwiTkRIV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMSwxXSk7dmFyIGk9bW4odCxcInhcIixcImNvbnYzZFwiKSxzPW1uKGUsXCJmaWx0ZXJcIixcImNvbnYzZFwiKSx1PWksYz0hMTs0PT09aS5yYW5rJiYoYz0hMCx1PWkuYXM1RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM10pKSxDKDU9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGlucHV0IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoNT09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogZmlsdGVyIG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSkpLEModS5zaGFwZVs0XT09PXMuc2hhcGVbM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGRlcHRoIG9mIGlucHV0IChcIit1LnNoYXBlWzRdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrcy5zaGFwZVszXStcIi5cIn0pKSxDKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHpjKHQpfHx6YyhlKX0obixhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSkpLEMoXCJOREhXQ1wiPT09bywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogZ290IGRhdGFGb3JtYXQgb2YgXCIrbytcIiBidXQgb25seSBOREhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwifSkpO3ZhciBsPUFvKHUuc2hhcGUscy5zaGFwZSxuLGEsciksaD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuY29udjNkKHUscyxsKTtyZXR1cm4gZShbdSxzXSksbn0pLHt4OnUsJGZpbHRlcjpzfSwoZnVuY3Rpb24odCxlKXtDKHpjKGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgY29udjNEOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICdcIithK1wiJ1wifSkpO3ZhciBvPWVbMF0saT1lWzFdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIEdjKG8uc2hhcGUsdCxpLG4scil9LCRmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10OzQ9PT10LnJhbmsmJihhPXQuYXM1RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdLHQuc2hhcGVbM10pKTt2YXIgaT1lOzQ9PT1pLnJhbmsmJihpPWUuYXM1RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM10pKTtDKDU9PT1hLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHNoYXBlIFwiK2Euc2hhcGUrXCIuXCJ9KSksQyg1PT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCBzaGFwZSBcIitpLnNoYXBlK1wiLlwifSkpLEMoNT09PW4ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA1LCBidXQgZ290IFwiK24rXCIuXCJ9KSksQyhhLnNoYXBlWzRdPT09blszXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgXCIrYS5zaGFwZVs0XStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiK25bM10rXCIuXCJ9KSksQyhpLnNoYXBlWzRdPT09bls0XSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiK2kuc2hhcGVbNF0rXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiK25bNF0rXCIpLlwifSkpO3ZhciBzPUFvKGEuc2hhcGUsbixyLDEsbyk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnYzZERlckZpbHRlcihhLGkscyl9KSx7eDVEOmEsZHk1RDppfSl9KG8sdCxpLnNoYXBlLG4scil9fX0pKTtyZXR1cm4gYz9oLmFzNEQoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10saC5zaGFwZVs0XSk6aH19KSxqYz1Bbih7Y29udjJkRGVyRmlsdGVyXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT1cIk5IV0NcIik7dmFyIHM9dDszPT09dC5yYW5rJiYocz10LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSkpO3ZhciB1PWU7Mz09PXUucmFuayYmKHU9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKSxDKDQ9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiK3Muc2hhcGUrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIit1LnNoYXBlK1wiLlwifSkpLEMoND09PW4ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiK24rXCIuXCJ9KSk7dmFyIGM9XCJOSFdDXCI9PT1hP3Muc2hhcGVbM106cy5zaGFwZVsxXSxsPVwiTkhXQ1wiPT09YT91LnNoYXBlWzNdOnUuc2hhcGVbMV07QyhjPT09blsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgXCIrYytcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiK25bMl0rXCIuXCJ9KSksQyhsPT09blszXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiK2wrXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiK25bM10rXCIpLlwifSkpLG51bGwhPWkmJkMoQShvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpO3ZhciBoPUJvKGEpLGY9U28ocy5zaGFwZSxuLHIsMSxvLGksITEsaCk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnYyZERlckZpbHRlcihzLHUsZil9KSx7eDREOnMsZHk0RDp1fSl9fSksWGM9QW4oe2NvbnYyZERlcklucHV0XzpWY30pLFljPUFuKHtkZXB0aHdpc2VDb252MmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTkhXQ1wiKSx2b2lkIDA9PT1hJiYoYT1bMSwxXSk7dmFyIHM9bW4odCxcInhcIixcImRlcHRod2lzZUNvbnYyZFwiKSx1PW1uKGUsXCJmaWx0ZXJcIixcImRlcHRod2lzZUNvbnYyZFwiKSxjPXMsbD0hMTszPT09cy5yYW5rJiYobD0hMCxjPXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSksQyg0PT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKGMuc2hhcGVbM109PT11LnNoYXBlWzJdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgKFwiK2Muc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGZpbHRlciBcIit1LnNoYXBlWzJdK1wiLlwifSkpLG51bGw9PWEmJihhPVsxLDFdKSxDKE1vKG4sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKSxudWxsIT1pJiZDKEEociksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pKTt2YXIgaD1TbyhjLnNoYXBlLHUuc2hhcGUsbixhLHIsaSwhMCksZj1bYyx1XSxkPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5kZXB0aHdpc2VDb252MkQoYyx1LGgpO3JldHVybiBlKFtjLHVdKSxufSkse3g6YyxmaWx0ZXI6dX0sKGZ1bmN0aW9uKHQsZSl7QyhPbyhhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICdcIithK1wiJ1wifSkpO3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuICRjKG4uc2hhcGUsdCxyLGgpfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gUWMobix0LHIuc2hhcGUsaCl9fX0pLFwiRGVwdGh3aXNlQ29udjJkTmF0aXZlXCIsaCxmKTtyZXR1cm4gbD9kLmFzM0QoZC5zaGFwZVsxXSxkLnNoYXBlWzJdLGQuc2hhcGVbM10pOmR9fSksJGM9QW4oe2RlcHRod2lzZUNvbnYyZERlcklucHV0XzpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1lLGE9ITE7Mz09PWUucmFuayYmKGE9ITAsbz1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpO3ZhciBpPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRod2lzZUNvbnYyRERlcklucHV0KG8sbixyKX0pLHtkeTREOm99KTtyZXR1cm4gYT9pLmFzM0QoaS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM10pOml9fSksUWM9QW4oe2RlcHRod2lzZUNvbnYyZERlckZpbHRlcl86ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dDszPT09dC5yYW5rJiYobz10LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSkpO3ZhciBhPWU7cmV0dXJuIDM9PT1hLnJhbmsmJihhPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyKG8sYSxyKX0pLHt4NEQ6byxkeTREOmF9KX19KSxKYz1Bbih7c2VwYXJhYmxlQ29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT1bMSwxXSksdm9pZCAwPT09aSYmKGk9XCJOSFdDXCIpO3ZhciBzPW1uKHQsXCJ4XCIsXCJzZXBhcmFibGVDb252MmRcIiksdT1tbihlLFwiZGVwdGh3aXNlRmlsdGVyXCIsXCJzZXBhcmFibGVDb252MmRcIiksYz1tbihuLFwicG9pbnR3aXNlRmlsdGVyXCIsXCJzZXBhcmFibGVDb252MmRcIiksbD1zLGg9ITE7aWYoMz09PXMucmFuayYmKGg9ITAsbD1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLFwiTkNIV1wiPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJzZXBhcmFibGVDb252MmQgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgZGF0YUZvcm1hdCBOQ0hXOyBvbmx5IE5IV0MgaXMgc3VwcG9ydGVkXCIpO0MoND09PWwucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBkZXB0aHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDE9PT1jLnNoYXBlWzBdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgZmlyc3QgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgIG11c3QgYmUgMSwgYnV0IGdvdCBcIitjLnNoYXBlWzBdK1wiLlwifSkpLEMoMT09PWMuc2hhcGVbMV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSBzZWNvbmQgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSAxLCBidXQgZ290IFwiK2Muc2hhcGVbMV0rXCIuXCJ9KSk7dmFyIGY9dS5zaGFwZVsyXSxkPXUuc2hhcGVbM107QyhjLnNoYXBlWzJdPT09ZipkLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgdGhpcmQgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSBcIitmKmQrXCIsIGJ1dCBnb3QgXCIrYy5zaGFwZVsyXStcIi5cIn0pKTt2YXIgcD1ZYyhsLHUscixvLGksYSksdj1xYyhwLGMsMSxcInZhbGlkXCIsaSk7cmV0dXJuIGg/di5hczNEKHYuc2hhcGVbMV0sdi5zaGFwZVsyXSx2LnNoYXBlWzNdKTp2fX0pLFpjPUFuKHtjb252MmRUcmFuc3Bvc2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gVmMobixtbih0LFwieFwiLFwiY29udjJkVHJhbnNwb3NlXCIpLG1uKGUsXCJmaWx0ZXJcIixcImNvbnYyZFRyYW5zcG9zZVwiKSxyLG8sXCJOSFdDXCIsYSl9fSksdGw9QW4oe2NvbnYzZFRyYW5zcG9zZV86ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gR2Mobixtbih0LFwieFwiLFwiY29udjNkVHJhbnNwb3NlXCIpLG1uKGUsXCJmaWx0ZXJcIixcImNvbnYzZFRyYW5zcG9zZVwiKSxyLG8pfX0pO3ZhciBlbD1Bbih7bWF0TXVsXzpmdW5jdGlvbih0LGUsbixyKXt2YXIgbzt2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBhPW1uKHQsXCJhXCIsXCJtYXRNdWxcIiksaT1tbihlLFwiYlwiLFwibWF0TXVsXCIpO289TnQoYSxpKSxhPW9bMF0saT1vWzFdO3ZhciBzPW4/YS5zaGFwZVthLnJhbmstMl06YS5zaGFwZVthLnJhbmstMV0sdT1yP2kuc2hhcGVbaS5yYW5rLTFdOmkuc2hhcGVbaS5yYW5rLTJdLGM9bj9hLnNoYXBlW2EucmFuay0xXTphLnNoYXBlW2EucmFuay0yXSxsPXI/aS5zaGFwZVtpLnJhbmstMl06aS5zaGFwZVtpLnJhbmstMV0saD1hLnNoYXBlLnNsaWNlKDAsLTIpLGY9aS5zaGFwZS5zbGljZSgwLC0yKSxkPWsoaCkscD1rKGYpO0MoYS5yYW5rPj0yJiZpLnJhbms+PTImJmEucmFuaz09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1hdE11bDogaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIG9mIGF0IGxlYXN0IDIsIGdvdCByYW5rcyBcIithLnJhbmsrXCIgYW5kIFwiK2kucmFuaytcIi5cIn0pKSxDKFMoaCxmKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1hdE11bDogb3V0ZXIgZGltZW5zaW9ucyAoXCIraCtcIikgYW5kIChcIitmK1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK2Euc2hhcGUrXCIgYW5kIFwiK2kuc2hhcGUrXCIgbXVzdCBtYXRjaC5cIn0pKSxDKHM9PT11LChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKFwiK3MrXCIpIGFuZCAoXCIrdStcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIithLnNoYXBlK1wiIGFuZCBcIitpLnNoYXBlK1wiIGFuZCB0cmFuc3Bvc2VBPVwiK24rXCIgYW5kIHRyYW5zcG9zZUI9XCIrcitcIiBtdXN0IG1hdGNoLlwifSkpO3ZhciB2PWEuc2hhcGUuc2xpY2UoMCwtMikuY29uY2F0KFtjLGxdKSxtPW4/YS5hczNEKGQscyxjKTphLmFzM0QoZCxjLHMpLGc9cj9pLmFzM0QocCxsLHUpOmkuYXMzRChwLHUsbCkseT17dHJhbnNwb3NlQTpuLHRyYW5zcG9zZUI6cn07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5iYXRjaE1hdE11bChtLGcsbixyKTtyZXR1cm4gZShbbSxnXSksb30pLHthOm0sYjpnfSwoZnVuY3Rpb24odCxlKXt2YXIgbz1lLGE9b1swXSxpPW9bMV07cmV0dXJuIG58fHI/IW4mJnI/e2E6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoaSwhMSwhMSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoYSwhMCwhMSl9fTpuJiYhcj97YTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bCh0LCExLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiBhLm1hdE11bCh0LCExLCExKX19OnthOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHQsITAsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGEsITAsITApfX06e2E6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoaSwhMSwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gYS5tYXRNdWwodCwhMCwhMSl9fX0pLFwiQmF0Y2hNYXRNdWxcIix5KS5yZXNoYXBlKHYpfX0pLG5sPUFuKHtkb3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInQxXCIsXCJkb3RcIikscj1tbihlLFwidDJcIixcImRvdFwiKTtDKCEoMSE9PW4ucmFuayYmMiE9PW4ucmFua3x8MSE9PXIucmFuayYmMiE9PXIucmFuayksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkb3Q6IGlucHV0cyBtdXN0IGFsbCBiZSByYW5rIDEgb3IgMiwgYnV0IGdvdCByYW5rcyBcIituLnJhbmsrXCIgYW5kIFwiK3IucmFuaytcIi5cIn0pKTt2YXIgbz0xPT09bi5yYW5rP24uc2l6ZTpuLnNoYXBlWzFdLGE9MT09PXIucmFuaz9yLnNpemU6ci5zaGFwZVswXTtyZXR1cm4gQyhvPT09YSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRvdDogaW5uZXIgZGltZW5zaW9ucyBvZiBpbnB1dHMgbXVzdCBtYXRjaCwgYnV0IGdvdCBcIitvK1wiIGFuZCBcIithK1wiLlwifSkpLDE9PT1uLnJhbmsmJjE9PT1yLnJhbms/bi5hczJEKDEsLTEpLm1hdE11bChyLmFzMkQoLTEsMSkpLmFzU2NhbGFyKCk6MT09PW4ucmFuayYmMj09PXIucmFuaz9uLmFzMkQoMSwtMSkubWF0TXVsKHIuYXMyRChyLnNoYXBlWzBdLHIuc2hhcGVbMV0pKS5hczFEKCk6Mj09PW4ucmFuayYmMT09PXIucmFuaz9uLm1hdE11bChyLmFzMkQoLTEsMSkpLmFzMUQoKTpuLm1hdE11bChyLmFzMkQoci5zaGFwZVswXSxyLnNoYXBlWzFdKSl9fSkscmw9QW4oe291dGVyUHJvZHVjdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwidjFcIixcIm91dGVyUHJvZHVjdFwiKSxyPW1uKGUsXCJ2MlwiLFwib3V0ZXJQcm9kdWN0XCIpO3JldHVybiBDKDE9PT1uLnJhbmsmJjE9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIituLnJhbmsrXCIgYW5kIFwiK3IucmFuaytcIi5cIn0pKSxuLmFzMkQoLTEsMSkubWF0TXVsKHIuYXMyRCgxLC0xKSl9fSk7dmFyIG9sPUFuKHtyZXZlcnNlXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO2lmKDA9PT1uLnJhbmspcmV0dXJuIG4uY2xvbmUoKTt2YXIgcj1PKGUsbi5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJldmVyc2UobixyKX0pLHskeDpufSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQucmV2ZXJzZShyKX19fSkpLnJlc2hhcGVBcyhuKX19KSxhbD1Bbih7cmV2ZXJzZTFkXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gQygxPT09ZS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTFEOiB4IG11c3QgYmUgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitlLnJhbmsrXCIuXCJ9KSksb2woZSwwKX19KSxpbD1Bbih7cmV2ZXJzZTJkXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBDKDI9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlMkQ6IHggbXVzdCBiZSByYW5rIDIgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIn0pKSxvbChuLGUpfX0pLHNsPUFuKHtyZXZlcnNlM2RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEMoMz09PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2UzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwifSkpLG9sKG4sZSl9fSksdWw9QW4oe3JldmVyc2U0ZF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gQyg0PT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTREOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCJ9KSksb2wobixlKX19KTtmdW5jdGlvbiBjbCh0LGUsbixyLG8sYSl7dmFyIGk9bW4odCxcInhcIixcIm1heFBvb2xcIikscz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLG51bGw9PXImJihyPVsxLDFdKSxDKDQ9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSkpLEMoTW8obixyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrcitcIidcIn0pKSxudWxsIT1hJiZDKEEobyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIithK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KSk7dmFyIGM9SW8ocy5zaGFwZSxlLG4scixvLGEpO2lmKDE9PT1jLmZpbHRlcldpZHRoJiYxPT09Yy5maWx0ZXJIZWlnaHQmJlMoYy5pblNoYXBlLGMub3V0U2hhcGUpKXJldHVybiBpLmNsb25lKCk7dmFyIGw9W3NdLGg9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heFBvb2wocyxjKTtyZXR1cm4gZShbcyxuXSksbn0pLHt4OnN9LChmdW5jdGlvbih0LGEpe3ZhciBpPWFbMF0scz1hWzFdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9bW4odCxcImR5XCIsXCJtYXhQb29sQmFja3Byb3BcIiksYz1tbihlLFwiaW5wdXRcIixcIm1heFBvb2xCYWNrcHJvcFwiKSxsPW1uKG4sXCJvdXRwdXRcIixcIm1heFBvb2xCYWNrcHJvcFwiKTtDKGMucmFuaz09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIlJhbmsgb2YgaW5wdXQgKFwiK2MucmFuaytcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIrdS5yYW5rK1wiKVwifSkpLG51bGw9PWEmJihhPVsxLDFdKTtDKE1vKG8sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja1Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK28rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyg0PT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLG51bGwhPXMmJkMoQShpKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrcytcIiBidXQgZ290IHBhZCBcIitpK1wiLlwifSkpO3ZhciBoPUlvKGMuc2hhcGUscixvLGEsaSxzKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubWF4UG9vbEJhY2twcm9wKHUsYyxsLGgpfSkseyRkeTp1LCRpbnB1dDpjfSl9KHQsaSxzLGUsbixyLG8pfX19KSxcIk1heFBvb2xcIixjLGwpO3JldHVybiB1P2guYXMzRChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSk6aH1mdW5jdGlvbiBsbCh0LGUsbixyLG8sYSl7dmFyIGk9bW4odCxcInhcIixcImF2Z1Bvb2xcIixcImZsb2F0MzJcIik7bnVsbD09ciYmKHI9WzEsMV0pLEMoTW8obixyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrcitcIidcIn0pKTt2YXIgcz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLEMoND09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2w6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxudWxsIT1hJiZDKEEobyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIithK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KSk7dmFyIGM9SW8ocy5zaGFwZSxlLG4scixvLGEpO2lmKDE9PT1jLmZpbHRlcldpZHRoJiYxPT09Yy5maWx0ZXJIZWlnaHQmJlMoYy5pblNoYXBlLGMub3V0U2hhcGUpKXJldHVybiBpLmNsb25lKCk7dmFyIGw9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbChzLGMpfSkse3g6c30sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1tbih0LFwiZHlcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKSxzPW1uKGUsXCJpbnB1dFwiLFwiYXZnUG9vbEJhY2twcm9wXCIpO0Mocy5yYW5rPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiUmFuayBvZiBpbnB1dCAoXCIrcy5yYW5rK1wiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIitpLnJhbmsrXCIpXCJ9KSksbnVsbD09byYmKG89WzEsMV0pO0MoTW8ocixvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIitvK1wiJ1wifSkpO3ZhciB1PXMsYz1pLGw9ITE7Mz09PXMucmFuayYmKGw9ITAsdT1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSksYz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpO0MoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSk7dmFyIGg9SW8odS5zaGFwZSxuLHIsbyxhKSxmPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF2Z1Bvb2xCYWNrcHJvcChjLHUsaCl9KSx7ZHk0RDpjLGlucHV0NEQ6dX0pO2lmKGwpcmV0dXJuIGYuYXMzRChmLnNoYXBlWzFdLGYuc2hhcGVbMl0sZi5zaGFwZVszXSk7cmV0dXJuIGZ9KHQscyxlLG4scixvKX19fSksXCJBdmdQb29sXCIsYyk7cmV0dXJuIGw9bC5jYXN0KGkuZHR5cGUpLHU/bC5hczNEKGwuc2hhcGVbMV0sbC5zaGFwZVsyXSxsLnNoYXBlWzNdKTpsfXZhciBobD1Bbih7bWF4UG9vbF86ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gY2wodCxlLG4sMSxyLG8pfX0pLGZsPUFuKHthdmdQb29sXzpmdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBsbCh0LGUsbiwxLHIsbyl9fSksZGw9QW4oe3Bvb2xfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtudWxsPT1vJiYobz1bMSwxXSksbnVsbD09YSYmKGE9MSksMD09PXImJihyPVwidmFsaWRcIik7dmFyIGk9bW4odCxcInhcIixcIm1heFBvb2xcIikscz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLEMoTW8oYSxvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK2ErXCIgYW5kIGRpbGF0aW9ucyAnXCIrbytcIidcIn0pKTt2YXIgYyxsPUlvKHMuc2hhcGUsZSxhLG8sciksaD1bbC5kaWxhdGlvbkhlaWdodCxsLmRpbGF0aW9uV2lkdGhdO2M9XCJzYW1lXCI9PT1yP2Z1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXAoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQrKHQtMSkqKGVbbl0tMSl9KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC0xfSkpLHI9bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmZsb29yKHQvMil9KSksbz1uLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC1yW2VdfSkpO3JldHVybiBuLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5bcltlXSxvW2VdXX0pKX0oW2wuZmlsdGVySGVpZ2h0LGwuZmlsdGVyV2lkdGhdLGgpOltbMCwwXSxbMCwwXV07dmFyIGY9MT09PWhbMF0mJjE9PT1oWzFdLGQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKSxvPW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFsxXX0pKSxhPXQuY29uY2F0KHIsbyksaT1lLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4odC1hW2VdJXQpJXR9KSkscz1vLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtpW2VdfSkpLHU9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuW3JbZV0sc1tlXV19KSksYz1lLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5bMCxpW2VdXX0pKTtyZXR1cm5bdSxjXX0oW2wuaW5IZWlnaHQsbC5pbldpZHRoXSxoLGMpLHA9ZFswXSx2PWRbMV0sbT1mP3I6XCJ2YWxpZFwiLGc9Zj9zOk1yKHMsaCxwKSx5PShcImF2Z1wiPT09bj9mdW5jdGlvbigpe3JldHVybiBsbChnLGUsYSwxLG0pfTpmdW5jdGlvbigpe3JldHVybiBjbChnLGUsYSwxLG0pfSkoKSx4PWY/eTp2cih5LGgsdik7cmV0dXJuIHU/eC5hczNEKHguc2hhcGVbMV0seC5zaGFwZVsyXSx4LnNoYXBlWzNdKTp4fX0pLHBsPUFuKHttYXhQb29sM2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPVwiTkRIV0NcIik7dmFyIHM9bW4odCxcInhcIixcIm1heFBvb2wzZFwiKSx1PXMsYz0hMTs0PT09cy5yYW5rJiYoYz0hMCx1PXMuYXM1RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdLHMuc2hhcGVbM10pKSxudWxsPT1pJiYoaT1bMSwxLDFdKSxDKDU9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2Q6IHggbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKFwiTkRIV0NcIj09PWEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2Q6IE9ubHkgTkRIV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZCwgYnV0IGdvdCBkYXRhRm9ybWF0IG9mIFwiK2F9KSksQyhNbyhuLGkpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2krXCInXCJ9KSksbnVsbCE9byYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitvK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSk7dmFyIGw9a28odS5zaGFwZSxlLG4saSxyLG8sYSksaD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4UG9vbDNkKHUsbCk7cmV0dXJuIGUoW3Usbl0pLG59KSx7eDp1fSwoZnVuY3Rpb24odCxhKXt2YXIgcz1hWzBdLHU9YVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3ZhciB1PW1uKHQsXCJkeVwiLFwibWF4UG9vbDNkQmFja3Byb3BcIiksYz1tbihlLFwiaW5wdXRcIixcIm1heFBvb2wzZEJhY2twcm9wXCIpLGw9bW4obixcIm91dHB1dFwiLFwibWF4UG9vbDNkQmFja3Byb3BcIiksaD11LGY9YyxkPWwscD0hMTs0PT09Yy5yYW5rJiYocD0hMCxoPXUuYXM1RCgxLHUuc2hhcGVbMF0sdS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pLGY9Yy5hczVEKDEsYy5zaGFwZVswXSxjLnNoYXBlWzFdLGMuc2hhcGVbMl0sYy5zaGFwZVszXSksZD1sLmFzNUQoMSxsLnNoYXBlWzBdLGwuc2hhcGVbMV0sbC5zaGFwZVsyXSxsLnNoYXBlWzNdKSk7Qyg1PT09aC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIitoLnJhbmsrXCIuXCJ9KSksQyg1PT09Zi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIitmLnJhbmsrXCIuXCJ9KSksQyg1PT09ZC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkQmFja3Byb3A6IG91dHB1dCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIrZC5yYW5rK1wiLlwifSkpLG51bGw9PWEmJihhPVsxLDEsMV0pO0MoTW8obyxhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIitvK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSksbnVsbCE9cyYmQyhBKGkpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkQmFja3Byb3A6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK3MrXCIgYnV0IGdvdCBwYWQgXCIraStcIi5cIn0pKTt2YXIgdj1rbyhmLnNoYXBlLHIsbyxhLGkscyksbT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXhQb29sM2RCYWNrcHJvcChoLGYsZCx2KX0pLHtkeTVEOmgsaW5wdXQ1RDpmfSk7aWYocClyZXR1cm4gbS5hczREKG0uc2hhcGVbMV0sbS5zaGFwZVsyXSxtLnNoYXBlWzNdLG0uc2hhcGVbNF0pO3JldHVybiBtfSh0LHMsdSxlLG4saSxyLG8pfX19KSk7cmV0dXJuIGM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9fSksdmw9QW4oe2F2Z1Bvb2wzZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9XCJOREhXQ1wiKTt2YXIgcz1tbih0LFwieFwiLFwiYXZnUG9vbDNkXCIsXCJmbG9hdDMyXCIpLHU9cyxjPSExOzQ9PT1zLnJhbmsmJihjPSEwLHU9cy5hczVEKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0scy5zaGFwZVszXSkpLG51bGw9PWkmJihpPVsxLDEsMV0pLEMoNT09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2wzZDogeCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoXCJOREhXQ1wiPT09YSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2wzZDogT25seSBOREhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLCBidXQgZ290IGRhdGFGb3JtYXQgb2YgXCIrYX0pKSxDKE1vKG4saSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2Q6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIraStcIidcIn0pKSxudWxsIT1vJiZDKEEociksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2Q6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK28rXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pKTt2YXIgbD1rbyh1LnNoYXBlLGUsbixpLHIsbyxhKSxoPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF2Z1Bvb2wzZCh1LGwpfSkse3g6dX0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZhciBzPW1uKHQsXCJkeVwiLFwiYXZnUG9vbDNkQmFja3Byb3BcIiksdT1tbihlLFwiaW5wdXRcIixcImF2Z1Bvb2wzZEJhY2twcm9wXCIpLGM9cyxsPXUsaD0hMTs0PT09dS5yYW5rJiYoaD0hMCxjPXMuYXM1RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdLHMuc2hhcGVbM10pLGw9dS5hczVEKDEsdS5zaGFwZVswXSx1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSkpO0MoNT09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2wzZEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoNT09PWwucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2wzZEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSkpLG51bGw9PW8mJihvPVsxLDEsMV0pO0MoTW8ocixvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2wzZEJhY2twcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCJ9KSksbnVsbCE9aSYmQyhBKGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkQmFja3Byb3A6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrYStcIi5cIn0pKTt2YXIgZj1rbyhsLnNoYXBlLG4scixvLGEsaSksZD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sM2RCYWNrcHJvcChjLGwsZil9KSx7ZHk1RDpjLGlucHV0NUQ6bH0pO2lmKGgpcmV0dXJuIGQuYXM0RChkLnNoYXBlWzFdLGQuc2hhcGVbMl0sZC5zaGFwZVszXSxkLnNoYXBlWzRdKTtyZXR1cm4gZH0odCx1LGUsbixpLHIsbyl9fX0pKTtyZXR1cm4gaD1oLmNhc3QodS5kdHlwZSksYz9oLmFzNEQoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10saC5zaGFwZVs0XSk6aH19KTt2YXIgbWw9QW4oe3NsaWNlXzpmdW5jdGlvbih0LGUsbil7dmFyIHIsbyxhPW1uKHQsXCJ4XCIsXCJzbGljZVwiKTtpZigwPT09YS5yYW5rKXRocm93IG5ldyBFcnJvcihcIlNsaWNpbmcgc2NhbGFyIGlzIG5vdCBwb3NzaWJsZVwiKTsocj1cIm51bWJlclwiPT10eXBlb2YgZT9bZV0uY29uY2F0KG5ldyBBcnJheShhLnJhbmstMSkuZmlsbCgwKSk6ZS5sZW5ndGg8YS5yYW5rP2UuY29uY2F0KG5ldyBBcnJheShhLnJhbmstZS5sZW5ndGgpLmZpbGwoMCkpOmUuc2xpY2UoKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7QygtMSE9PXQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZSgpIGRvZXMgbm90IHN1cHBvcnQgbmVnYXRpdmUgYmVnaW4gaW5kZXhpbmcuXCJ9KSl9KSksbz0obz1udWxsPT1uP25ldyBBcnJheShhLnJhbmspLmZpbGwoLTEpOlwibnVtYmVyXCI9PXR5cGVvZiBuP1tuXS5jb25jYXQobmV3IEFycmF5KGEucmFuay0xKS5maWxsKC0xKSk6bi5sZW5ndGg8YS5yYW5rP24uY29uY2F0KG5ldyBBcnJheShhLnJhbmstbi5sZW5ndGgpLmZpbGwoLTEpKTpuKS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+PTA/dDooQygtMT09PXQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBzaXplIHZhbHVlcyBzaG91bGQgYmUgZXhhY3RseSAtMSBidXQgZ290IFwiK3QrXCIgZm9yIHRoZSBzbGljZSgpIHNpemUgYXQgaW5kZXggXCIrZStcIi5cIn0pKSxhLnNoYXBlW2VdLXJbZV0pfSkpLGVvKGEscixvKTt2YXIgaT1hLnNoYXBlLHM9e2JlZ2luOnIsc2l6ZTpvfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2xpY2UoYSxyLG8pfSkse3g6YX0sKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0LnJhbms7bisrKWUucHVzaChbcltuXSxpW25dLXJbbl0tb1tuXV0pO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQucGFkKGUpfX19KSxcIlNsaWNlXCIscyl9fSksZ2w9QW4oe3NsaWNlMWRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwic2xpY2UxZFwiKTtyZXR1cm4gQygxPT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwic2xpY2UxZCBleHBlY3RzIGEgcmFuay0xIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSkpLG1sKHIsW2VdLFtuXSl9fSkseWw9QW4oe3NsaWNlMmRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwic2xpY2UyZFwiKTtyZXR1cm4gQygyPT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwic2xpY2UyZCBleHBlY3RzIGEgcmFuay0yIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSkpLG1sKHIsZSxuKX19KSx4bD1Bbih7c2xpY2UzZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJzbGljZTNkXCIpO3JldHVybiBDKDM9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTNkIGV4cGVjdHMgYSByYW5rLTMgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSksbWwocixlLG4pfX0pLGJsPUFuKHtzbGljZTRkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcInNsaWNlNGRcIik7cmV0dXJuIEMoND09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlNGQgZXhwZWN0cyBhIHJhbmstNCB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pKSxtbChyLGUsbil9fSk7ZnVuY3Rpb24gd2wodCxlLG4scixvKXtyZXR1cm4gZS5yYW5rPG4ucmFuayYmKGU9ZS5yZXNoYXBlKHduKGUuc2hhcGUscikpKSx0LnJhbms8bi5yYW5rJiYodD10LnJlc2hhcGUod24odC5zaGFwZSxyKSkpLHt4OmZ1bmN0aW9uKCl7dmFyIHI9dC5tdWwobi5lcXVhbChlKS5jYXN0KHQuZHR5cGUpKTtyZXR1cm4gbnVsbD09bz9yOnIudHJhbnNwb3NlKG8pfX19dmFyIENsPUFuKHthbGxfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcImFsbFwiLFwiYm9vbFwiKSxvPU8oZSxyLnNoYXBlKSxhPW8saT1FbihhLHIucmFuayk7bnVsbCE9aSYmKHI9ci50cmFuc3Bvc2UoaSksYT1JbihhLmxlbmd0aCxyLnJhbmspKTt2YXIgcz1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hbGwocixhKX0pLHskeDpyfSk7aWYobil7dmFyIHU9d24ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfX0pLEVsPUFuKHthbnlfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcImFueVwiLFwiYm9vbFwiKSxvPU8oZSxyLnNoYXBlKSxhPW8saT1FbihhLHIucmFuayk7bnVsbCE9aSYmKHI9ci50cmFuc3Bvc2UoaSksYT1JbihhLmxlbmd0aCxyLnJhbmspKTt2YXIgcz1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hbnkocixhKX0pLHskeDpyfSk7aWYobil7dmFyIHU9d24ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfX0pLFJsPUFuKHthcmdNYXhfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49bW4odCxcInhcIixcImFyZ01heFwiKTtudWxsPT1lJiYoZT0wKTt2YXIgcj1PKGUsbi5zaGFwZSksbz1FbihyLG4ucmFuayk7bnVsbCE9byYmKG49bi50cmFuc3Bvc2Uobykscj1JbihyLmxlbmd0aCxuLnJhbmspKTt2YXIgYT17YXhpczpyWzBdfSxpPVtuXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbz10LmFyZ01heChuLHJbMF0pO3JldHVybiBlKFtuXSksb30pLHt4Om59LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gWG4obil9fX0pLFwiQXJnTWF4XCIsYSxpKX19KSxJbD1Bbih7YXJnTWluXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPW1uKHQsXCJ4XCIsXCJhcmdNaW5cIik7bnVsbD09ZSYmKGU9MCk7dmFyIHI9TyhlLG4uc2hhcGUpLG89RW4ocixuLnJhbmspO3JldHVybiBudWxsIT1vJiYobj1uLnRyYW5zcG9zZShvKSxyPUluKHIubGVuZ3RoLG4ucmFuaykpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5hcmdNaW4obixyWzBdKTtyZXR1cm4gZShbbl0pLG99KSx7JHg6bn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4obil9fX0pKX19KSxrbD1Bbih7bG9nU3VtRXhwXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJsb2dTdW1FeHBcIiksbz1PKGUsci5zaGFwZSksYT1yLm1heChvLCEwKSxpPXIuc3ViKGEpLmV4cCgpLnN1bShvKS5sb2coKSxzPWEucmVzaGFwZShpLnNoYXBlKS5hZGQoaSk7aWYobil7dmFyIHU9d24ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfX0pLFNsPUFuKHttYXhfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcIm1heFwiKSxvPXIsYT1PKGUsci5zaGFwZSksaT1hLHM9RW4oaSxyLnJhbmspO251bGwhPXMmJihyPXIudHJhbnNwb3NlKHMpLGk9SW4oaS5sZW5ndGgsci5yYW5rKSk7dmFyIHU9W3JdLGM9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heChyLGkpO3JldHVybiBlKFtvLG5dKSxufSkse3g6cn0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdsKHQsZVsxXSxlWzBdLGEscyl9KSxcIk1heFwiLHtheGVzOml9LHUsWyEwXSk7aWYobil7dmFyIGw9d24oYy5zaGFwZSxhKTtjPWMucmVzaGFwZShsKX1yZXR1cm4gY319KSxBbD1Bbih7bWVhbl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwibWVhblwiKSxvPU8oZSxyLnNoYXBlKSxhPWsoYm4oci5zaGFwZSxvKVsxXSk7cmV0dXJuIHZvKChmdW5jdGlvbih0KXt2YXIgcj1PbihhKTtyZXR1cm57dmFsdWU6KHIuZHR5cGU9PT10LmR0eXBlP3Q6dC5jYXN0KHIuZHR5cGUpKS5kaXYocikuc3VtKGUsbiksZ3JhZEZ1bmM6ZnVuY3Rpb24oZSl7dmFyIG49dC5zaGFwZS5zbGljZSgpO3JldHVybiBvLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF09MX0pKSxlLnJlc2hhcGUobikubXVsKHpuKHQuc2hhcGUsXCJmbG9hdDMyXCIpKS5kaXYoYSl9fX0pKShyKX19KSxEbD1Bbih7bWluXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJtaW5cIiksbz1yLGE9TyhlLHIuc2hhcGUpLGk9YSxzPUVuKGksci5yYW5rKTtudWxsIT1zJiYocj1yLnRyYW5zcG9zZShzKSxpPUluKGkubGVuZ3RoLHIucmFuaykpO3ZhciB1PVtyXSxjPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5taW4ocixpKTtyZXR1cm4gZShbbyxuXSksbn0pLHt4OnJ9LChmdW5jdGlvbih0LGUpe3JldHVybiB3bCh0LGVbMV0sZVswXSxhLHMpfSksXCJNaW5cIix7YXhlczppfSx1LFshMF0pO2lmKG4pe3ZhciBsPXduKGMuc2hhcGUsYSk7Yz1jLnJlc2hhcGUobCl9cmV0dXJuIGN9fSksVGw9QW4oe21vbWVudHNfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9TyhlLCh0PW1uKHQsXCJ4XCIsXCJtb21lbnRzXCIpKS5zaGFwZSksbz10Lm1lYW4ocixuKSxhPW8uc2hhcGU7bnx8KGE9d24oby5zaGFwZSxyKSk7dmFyIGk9dC50b0Zsb2F0KCkuc3ViKG8ucmVzaGFwZShhKSkuc3F1YXJlKCk7cmV0dXJue21lYW46byx2YXJpYW5jZTppLm1lYW4ocixuKX19fSksTmw9QW4oe3N1bV86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwic3VtXCIpO1wiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpKTt2YXIgbz1PKGUsci5zaGFwZSk7cmV0dXJuIHZvKChmdW5jdGlvbih0KXt2YXIgZT1FbihvLHQucmFuaykscj1vLGE9dDtudWxsIT1lJiYoYT10LnRyYW5zcG9zZShlKSxyPUluKHIubGVuZ3RoLHQucmFuaykpO3ZhciBpPWZ1bmN0aW9uKGUpe3ZhciBuPXQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gby5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPTF9KSksZS5yZXNoYXBlKG4pLm11bCh6bih0LnNoYXBlLFwiZmxvYXQzMlwiKSl9LHM9e2F4ZXM6cn0sdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdW0oYSxyKX0pLHt4OmF9LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBpKHQpfX19KSxcIlN1bVwiLHMpO2lmKG4pe3ZhciBjPXduKHUuc2hhcGUsbyk7dT11LnJlc2hhcGUoYyl9cmV0dXJue3ZhbHVlOnUsZ3JhZEZ1bmM6aX19KSkocil9fSksRmw9QW4oe3Byb2RfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcInByb2RcIik7XCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCkpO3ZhciBvPU8oZSxyLnNoYXBlKSxhPUVuKG8sci5yYW5rKSxpPW8scz1yO251bGwhPWEmJihzPXIudHJhbnNwb3NlKGEpLGk9SW4oaS5sZW5ndGgsci5yYW5rKSk7dmFyIHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucHJvZChzLGkpfSkse3Blcm11dGVkWDpzfSk7aWYobil7dmFyIGM9d24odS5zaGFwZSxvKTt1PXUucmVzaGFwZShjKX1yZXR1cm4gdX19KTt2YXIgX2w9QW4oe2VsdV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImVsdVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmVsdShlKTtyZXR1cm4gbihbcl0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZWx1RGVyKHQsbil9KSx7ZHk6dCx5Om59KX19fSkpfX0pLE9sPUFuKHtsZWFreVJlbHVfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9LjIpO3ZhciBuPW1uKHQsXCJ4XCIsXCJsZWFreVJlbHVcIik7cmV0dXJuIGhjKE9uKGUpLm11bChuKSxuKX19KSxNbD1Bbih7cHJlbHVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInByZWx1XCIpLHI9bW4oZSxcImFscGhhXCIsXCJwcmVsdVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbz10LnByZWx1KG4scik7cmV0dXJuIGUoW24scl0pLG99KSx7eDpuLGFscGhhOnJ9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89bi5ncmVhdGVyKDApO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGVjKG8sdCx0Lm11bChyKSl9LGFscGhhOmZ1bmN0aW9uKCl7dmFyIGU9ZWMobyxYbih0KSx0Lm11bChuKSksYT1FbyhyLnNoYXBlLHQuc2hhcGUpO3JldHVybiBhLmxlbmd0aD4wJiYoZT1lLnN1bShhKSksZS5yZXNoYXBlKHIuc2hhcGUpfX19KSxcIlByZWx1XCIpfX0pLEJsPUFuKHtyZWx1XzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwicmVsdVwiKTtyZXR1cm5cImJvb2xcIj09PWUuZHR5cGU/ZS50b0ludCgpOkx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5yZWx1KGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWxTdHJpY3Qobi5zdGVwKCkudG9GbG9hdCgpKX19fSksXCJSZWx1XCIpfX0pLFBsPUFuKHtyZWx1Nl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInJlbHU2XCIpO3JldHVyblwiYm9vbFwiPT09ZS5kdHlwZT9lLnRvSW50KCk6THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJlbHU2KGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1uLmxlc3NFcXVhbCg2KS5tdWwobi5zdGVwKCkpO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KHIudG9GbG9hdCgpKX19fSksXCJSZWx1NlwiKX19KSxMbD1Bbih7c2VsdV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNlbHVcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zZWx1KGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3ZhciBlPW4uZ3JlYXRlcihPbigwKSkscj1Pbihicyksbz1Pbih3cyksYT10Lm11bChvKSxpPXQubXVsKHIpLm11bChuLnRvRmxvYXQoKS5leHAoKSk7cmV0dXJuIGVjKGUsYSxpKX19fSkpfX0pO3ZhciBXbD1Bbih7dHJhbnNwb3NlXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJ0cmFuc3Bvc2VcIik7aWYobnVsbD09ZSYmKGU9bi5zaGFwZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV9KSkucmV2ZXJzZSgpKSxDKG4ucmFuaz09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiK24ucmFuaytcIiBtdXN0IG1hdGNoIGxlbmd0aCBvZiBwZXJtIFwiK2UrXCIuXCJ9KSksZS5mb3JFYWNoKChmdW5jdGlvbih0KXtDKHQ+PTAmJnQ8bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQWxsIGVudHJpZXMgaW4gJ3Blcm0nIG11c3QgYmUgYmV0d2VlbiAwIGFuZCBcIisobi5yYW5rLTEpK1wiIGJ1dCBnb3QgXCIrZX0pKX0pKSxuLnJhbms8PTEpcmV0dXJuIG4uY2xvbmUoKTt2YXIgcj17cGVybTplfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJhbnNwb3NlKG4sZSl9KSx7eDpufSwoZnVuY3Rpb24odCl7dmFyIG49Um4oZSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC50cmFuc3Bvc2Uobil9fX0pLFwiVHJhbnNwb3NlXCIscil9fSk7dmFyIFVsPUFuKHtsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbl86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1lJiYoZT01KSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1vJiYobz0uNSk7dmFyIGE9bW4odCxcInhcIixcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIpO0MoND09PWEucmFua3x8Mz09PWEucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiB4IG11c3QgYmUgcmFuayAzIG9yIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICAgIHJhbmsgXCIrYS5yYW5rK1wiLlwifSkpLEMoQShlKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiBkZXB0aFJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXIgYnV0IGdvdCBkZXB0aFJhZGl1cyBcIitlK1wiLlwifSkpO3ZhciBpPWEscz0hMTszPT09YS5yYW5rJiYocz0hMCxpPWEuYXM0RCgxLGEuc2hhcGVbMF0sYS5zaGFwZVsxXSxhLnNoYXBlWzJdKSk7dmFyIHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxhKXt2YXIgcz10LmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQoaSxlLG4scixvKTtyZXR1cm4gYShbaSxzXSksc30pLHt4NEQ6aX0sKGZ1bmN0aW9uKHQsYSl7dmFyIGk9YVswXSxzPWFbMV07cmV0dXJue3g0RDpmdW5jdGlvbigpe3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihhKXtyZXR1cm4gYS5MUk5HcmFkKHQsaSxzLGUsbixyLG8pfSkse30pfX19KSk7cmV0dXJuIHM/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fX0pO3ZhciBWbD1Bbih7bm9ybV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPWZ1bmN0aW9uIHQoZSxuLHIpe3ZvaWQgMD09PXImJihyPW51bGwpO2lmKDA9PT1lLnJhbmspcmV0dXJuIGUuYWJzKCk7aWYoMSE9PWUucmFuayYmbnVsbD09PXIpcmV0dXJuIHQoZS5yZXNoYXBlKFstMV0pLG4scik7aWYoMT09PWUucmFua3x8XCJudW1iZXJcIj09dHlwZW9mIHJ8fEFycmF5LmlzQXJyYXkocikmJjE9PT1yLmxlbmd0aCl7aWYoMT09PW4pcmV0dXJuIGUuYWJzKCkuc3VtKHIpO2lmKG49PT0xLzApcmV0dXJuIGUuYWJzKCkubWF4KHIpO2lmKG49PT0tMS8wKXJldHVybiBlLmFicygpLm1pbihyKTtpZihcImV1Y2xpZGVhblwiPT09bnx8Mj09PW4pcmV0dXJuIGUuYWJzKCkucG93KE9uKDIsXCJpbnQzMlwiKSkuc3VtKHIpLnNxcnQoKTt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIrbil9aWYoQXJyYXkuaXNBcnJheShyKSYmMj09PXIubGVuZ3RoKXtpZigxPT09bilyZXR1cm4gZS5hYnMoKS5zdW0oclswXSkubWF4KHJbMV0tMSk7aWYobj09PTEvMClyZXR1cm4gZS5hYnMoKS5zdW0oclsxXSkubWF4KHJbMF0pO2lmKG49PT0tMS8wKXJldHVybiBlLmFicygpLnN1bShyWzFdKS5taW4oclswXSk7aWYoXCJmcm9cIj09PW58fFwiZXVjbGlkZWFuXCI9PT1uKXJldHVybiBlLnNxdWFyZSgpLnN1bShyKS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK24pfXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgYXhpczogXCIrcil9KHQ9bW4odCxcInhcIixcIm5vcm1cIiksZSxuKSxhPW8uc2hhcGU7aWYocil7dmFyIGk9TyhuLHQuc2hhcGUpO2E9d24oby5zaGFwZSxpKX1yZXR1cm4gby5yZXNoYXBlKGEpfX0pO3ZhciB6bD1Bbih7YmFzaWNMU1RNQ2VsbF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW1uKHQsXCJmb3JnZXRCaWFzXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHM9bW4oZSxcImxzdG1LZXJuZWxcIixcImJhc2ljTFNUTUNlbGxcIiksdT1tbihuLFwibHN0bUJpYXNcIixcImJhc2ljTFNUTUNlbGxcIiksYz1tbihyLFwiZGF0YVwiLFwiYmFzaWNMU1RNQ2VsbFwiKSxsPW1uKG8sXCJjXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGg9bW4oYSxcImhcIixcImJhc2ljTFNUTUNlbGxcIiksZj1jLmNvbmNhdChoLDEpLm1hdE11bChzKS5hZGQodSksZD1mLnNoYXBlWzBdLHA9Zi5zaGFwZVsxXS80LHY9W2QscF0sbT1mLnNsaWNlKFswLDBdLHYpLGc9Zi5zbGljZShbMCxwXSx2KSx5PWYuc2xpY2UoWzAsMipwXSx2KSx4PWYuc2xpY2UoWzAsMypwXSx2KSxiPW0uc2lnbW9pZCgpLm11bFN0cmljdChnLnRhbmgoKSkuYWRkU3RyaWN0KGwubXVsU3RyaWN0KGkuYWRkKHkpLnNpZ21vaWQoKSkpLHc9Yi50YW5oKCkubXVsU3RyaWN0KHguc2lnbW9pZCgpKTtyZXR1cm5bYix3XX19KSxHbD1Bbih7bXVsdGlSTk5DZWxsXzpmdW5jdGlvbih0LGUsbixyKXtmb3IodmFyIG89bW4oZSxcImRhdGFcIixcIm11bHRpUk5OQ2VsbFwiKSxhPWduKG4sXCJjXCIsXCJtdWx0aVJOTkNlbGxcIiksaT1nbihyLFwiaFwiLFwibXVsdGlSTk5DZWxsXCIpLHM9byx1PVtdLGM9MDtjPHQubGVuZ3RoO2MrKyl7dmFyIGw9dFtjXShzLGFbY10saVtjXSk7dS5wdXNoKGxbMF0pLHUucHVzaChsWzFdKSxzPWxbMV19dmFyIGg9W10sZj1bXTtmb3IoYz0wO2M8dS5sZW5ndGg7Yys9MiloLnB1c2godVtjXSksZi5wdXNoKHVbYysxXSk7cmV0dXJuW2gsZl19fSk7dmFyIEhsPUFuKHttb3ZpbmdBdmVyYWdlXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPSEwKTt2YXIgYT1tbih0LFwidlwiLFwibW92aW5nQXZlcmFnZVwiKSxpPW1uKGUsXCJ4XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLHM9bW4obixcImRlY2F5XCIsXCJtb3ZpbmdBdmVyYWdlXCIpO0Z0KGEsaSksQyhTKGEuc2hhcGUsaS5zaGFwZSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJTaGFwZSBtaXNtYXRjaCBpbiB2IGFuZCB4XCJ9KSk7dmFyIHU9T24oMSksYz11LnN1YihzKSxsPWkuc3ViKGEpLm11bChjKTtpZihvKXtDKG51bGwhPXIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJXaGVuIHVzaW5nIHplcm9EZWJpYXM6IHRydWUsIHN0ZXAgaXMgcmVxdWlyZWQuXCJ9KSk7dmFyIGg9bW4ocixcInN0ZXBcIixcIm1vdmluZ0F2ZXJhZ2VcIik7bD1sLmRpdih1LnN1Yih4YyhzLGgpKSl9cmV0dXJuIGEuYWRkKGwpfX0pO3ZhciBxbD1Bbih7c3RyaWRlZFNsaWNlXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSl7aWYodm9pZCAwPT09byYmKG89MCksdm9pZCAwPT09YSYmKGE9MCksdm9pZCAwPT09aSYmKGk9MCksdm9pZCAwPT09cyYmKHM9MCksdm9pZCAwPT09dSYmKHU9MCksbnVsbD09ciYmKHI9bmV3IEFycmF5KGUubGVuZ3RoKSksMCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiZWxsaXBzaXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt2YXIgYz1tbih0LFwieFwiLFwic3RyaWRlZFNsaWNlXCIpLGw9bm8ocyksaD1jLnNoYXBlLnNsaWNlKCk7bC5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPTAsblt0XT0xLGguc3BsaWNlKHQsMCwxKX0pKSxjPWMucmVzaGFwZShoKTtmb3IodmFyIGY9MDtmPGMucmFuaztmKyspZVtmXT1vbyhvLGUscixjLnNoYXBlLGYpLG5bZl09YW8oYSxuLHIsYy5zaGFwZSxmKSxyW2ZdPXJbZl18fDE7dmFyIGQ9bm8odSk7ZC5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPWVbdF0rMSxyW3RdPTF9KSk7dmFyIHA9cm8oZSxuLHIpLHY9cC5maWx0ZXIoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuLTE9PT1kLmluZGV4T2YoZSl9KSk7cmV0dXJuIHIuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiAxPT09dH0pKT9tbChjLGUscCkucmVzaGFwZSh2KTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdHJpZGVkU2xpY2UoYyxlLG4scil9KSx7JHg6Y30pLnJlc2hhcGUodil9fSk7dmFyIEtsPUFuKHt0b3BrXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9MSksdm9pZCAwPT09biYmKG49ITApO3ZhciByPW1uKHQsXCJ4XCIsXCJ0b3BrXCIpO2lmKDA9PT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidG9waygpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIG9mIHJhbmsgMSBvciBoaWdoZXJcIik7dmFyIG89ci5zaGFwZVtyLnNoYXBlLmxlbmd0aC0xXTtpZihlPm8pdGhyb3cgbmV3IEVycm9yKFwiJ2snIHBhc3NlZCB0byB0b3BrKCkgbXVzdCBiZSA8PSB0aGUgbGFzdCBkaW1lbnNpb24gKFwiK28rXCIpIGJ1dCBnb3QgXCIrZSk7dmFyIGE9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9wayhyLGUsbil9KSx7JHg6cn0pO3JldHVybnt2YWx1ZXM6YVswXSxpbmRpY2VzOmFbMV19fX0pO3ZhciBqbD1Bbih7c2NhdHRlck5EXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcImluZGljZXNcIixcInNjYXR0ZXJORFwiLFwiaW50MzJcIiksbz1tbihlLFwidXBkYXRlc1wiLFwic2NhdHRlck5EXCIpO3JldHVybiBKcihvLHIsbiksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2NhdHRlck5EKHIsbyxuKX0pLHtpbmRpY2VzOnIsdXBkYXRlczpvfSxudWxsLFwiU2NhdHRlck5kXCIse3NoYXBlOm59KX19KTt2YXIgWGw9QW4oe2ZmdF86ZnVuY3Rpb24odCl7QyhcImNvbXBsZXg2NFwiPT09dC5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBmb3IgdGYuc3BlY3RyYWwuZmZ0KCkgbXVzdCBiZSBjb21wbGV4NjQgYnV0IGdvdCBcIit0LmR0eXBlK1wiLlwifSkpO3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZSxyPXQuYXMyRChuLGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5mZnQocil9KSx7aW5wdXQ6dH0pLnJlc2hhcGUodC5zaGFwZSl9fSksWWw9QW4oe2lmZnRfOmZ1bmN0aW9uKHQpe0MoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmlmZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290IFwiK3QuZHR5cGUrXCIuXCJ9KSk7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lLHI9dC5hczJEKG4sZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlmZnQocil9KSx7aW5wdXQ6dH0pLnJlc2hhcGUodC5zaGFwZSl9fSksJGw9QW4oe3JmZnRfOmZ1bmN0aW9uKHQsZSl7QyhcImZsb2F0MzJcIj09PXQuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHJmZnQoKSBtdXN0IGJlIHJlYWwgdmFsdWUgYnV0IGdvdCBcIit0LmR0eXBlfSkpO3ZhciBuLHI9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxvPXQuc2l6ZS9yO2lmKG51bGwhPWUmJmU8cil7dmFyIGE9dC5zaGFwZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiAwfSkpLGk9dC5zaGFwZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpO2lbdC5zaGFwZS5sZW5ndGgtMV09ZSxuPXQuc2xpY2UoYSxpKSxyPWV9ZWxzZSBpZihudWxsIT1lJiZlPnIpe3ZhciBzPXQuc2hhcGUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKTtzW3Quc2hhcGUubGVuZ3RoLTFdPWUtcixuPXQuY29uY2F0KEduKHMpLHQuc2hhcGUubGVuZ3RoLTEpLHI9ZX1lbHNlIG49dDt2YXIgdT1uLnplcm9zTGlrZSgpLGM9RG4obix1KS5hczJEKG8sciksbD1YbChjKSxoPU1hdGguZmxvb3Ioci8yKSsxLGY9VG4obCksZD1ObihsKSxwPWYuc3BsaXQoW2gsci1oXSxmLnNoYXBlLmxlbmd0aC0xKSx2PWQuc3BsaXQoW2gsci1oXSxkLnNoYXBlLmxlbmd0aC0xKSxtPW4uc2hhcGUuc2xpY2UoKTtyZXR1cm4gbVtuLnNoYXBlLmxlbmd0aC0xXT1oLERuKHBbMF0sdlswXSkucmVzaGFwZShtKX19KSxRbD1Bbih7aXJmZnRfOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZTtpZihlPD0yKXt2YXIgcj10LmFzMkQobixlKSxvPVlsKHIpO3JldHVybiBUbihvKX12YXIgYT1bbiwyKihlLTEpXSxpPVRuKHQpLmFzMkQobixlKSxzPU5uKHQpLmFzMkQobixlKSx1PWkuc2xpY2UoWzAsMV0sW24sZS0yXSkucmV2ZXJzZSgxKSxjPXMuc2xpY2UoWzAsMV0sW24sZS0yXSkucmV2ZXJzZSgxKS5tdWwoT24oLTEpKSxsPWkuY29uY2F0KHUsMSksaD1zLmNvbmNhdChjLDEpO3JldHVybiByPURuKGwsaCkuYXMyRChhWzBdLGFbMV0pLG89WWwociksVG4obyl9fSksSmw9T2JqZWN0LmZyZWV6ZSh7ZmZ0OlhsLGlmZnQ6WWwscmZmdDokbCxpcmZmdDpRbH0pO3ZhciBabD1Bbih7c3BhcnNlVG9EZW5zZV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9MCk7dmFyIG89bW4odCxcInNwYXJzZUluZGljZXNcIixcInNwYXJzZVRvRGVuc2VcIixcImludDMyXCIpLGE9bW4oZSxcInNwYXJzZVZhbHVlc1wiLFwic3BhcnNlVG9EZW5zZVwiKSxpPW1uKHIsXCJkZWZhdWx0VmFsdWVcIixcInNwYXJzZVRvRGVuc2VcIixhLmR0eXBlKTtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7aWYoXCJpbnQzMlwiIT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5zcGFyc2VUb0RlbnNlKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyBcIit0LmR0eXBlK1wiLlwiKTtpZih0LnJhbms+Mil0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VJbmRpY2VzIHNob3VsZCBiZSBhIHNjYWxhciwgdmVjdG9yLCBvciBtYXRyaXgsIGJ1dCBnb3Qgc2hhcGUgXCIrdC5zaGFwZStcIi5cIik7dmFyIG89dC5yYW5rPjA/dC5zaGFwZVswXToxLGE9dC5yYW5rPjE/dC5zaGFwZVsxXToxO2lmKG4ubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRTaGFwZSBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBlbGVtZW50czosIFwiK24ubGVuZ3RoK1wiLCBzaG91bGQgYmU6IFwiK2ErXCIuXCIpO3ZhciBpPWUuc2l6ZTtpZigwIT09ZS5yYW5rJiYoMSE9PWUucmFua3x8aSE9PW8pKXRocm93IG5ldyBFcnJvcihcInNwYXJzZVZhbHVlcyBoYXMgaW5jb3JyZWN0IHNoYXBlIFwiK2Uuc2hhcGUrXCIsIHNob3VsZCBiZSBbXSBvciBbXCIrbytcIl1cIik7aWYoZS5kdHlwZSE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzLmR0eXBlIG11c3QgbWF0Y2ggZGVmYXVsdFZhbHVlcy5kdHlwZVwiKX0obyxhLG4saSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BhcnNlVG9EZW5zZShvLGEsbixpKX0pLHskc3BhcnNlSW5kaWNlczpvLCRzcGFyc2VWYWx1ZXM6YSwkZGVmYXVsdFZhbHVlOml9KX19KTt2YXIgdGg9QW4oe2dhdGhlck5EXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJORFwiLFwiaW50MzJcIikscj1tbih0LFwieFwiLFwiZ2F0aGVyTkRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdhdGhlck5EKHIsbil9KSx7eDpyLGluZGljZXM6bn0sbnVsbCxcIkdhdGhlck5kXCIpfX0pO3ZhciBlaD1Bbih7ZGlhZ186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImRpYWdcIikuZmxhdHRlbigpLG49dC5zaGFwZS5jb25jYXQodC5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRpYWcoZSl9KSx7JHg6ZX0pLnJlc2hhcGUobil9fSk7dmFyIG5oPUFuKHtkcm9wb3V0XzpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1tbih0LFwieFwiLFwiZHJvcG91dFwiKTtpZihDKFwiZmxvYXQzMlwiPT09by5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cInggaGFzIHRvIGJlIGEgZmxvYXRpbmcgcG9pbnQgdGVuc29yIHNpbmNlIGl0J3MgZ29pbmcgdG8gYmUgc2NhbGVkLCBidXQgZ290IGEgXCIrby5kdHlwZStcIiB0ZW5zb3IgaW5zdGVhZC5cIn0pKSxDKGU+PTAmJmU8MSwoZnVuY3Rpb24oKXtyZXR1cm5cInJhdGUgbXVzdCBiZSBhIGZsb2F0IGluIHRoZSByYW5nZSBbMCwgMSksIGJ1dCBnb3QgXCIrZStcIi5cIn0pKSwwPT09ZSlyZXR1cm4gdCBpbnN0YW5jZW9mIHd0P28uY2xvbmUoKTpvO3ZhciBhPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09ZSlyZXR1cm4gdC5zaGFwZS5zbGljZSgpO2lmKFModC5zaGFwZSxlKSlyZXR1cm4gZTtpZih0LnNoYXBlLmxlbmd0aD09PWUubGVuZ3RoKXtmb3IodmFyIG49W10scj0wO3I8dC5zaGFwZS5sZW5ndGg7cisrKW51bGw9PWVbcl0mJm51bGwhPXQuc2hhcGVbcl0/bi5wdXNoKHQuc2hhcGVbcl0pOm4ucHVzaChlW3JdKTtyZXR1cm4gbn1yZXR1cm4gZX0obyxuKSxpPTEtZSxzPV9yKGEsMCwxLFwiZmxvYXQzMlwiLHIpLmFkZChpKS5mbG9vcigpLmRpdihpKTtyZXR1cm4gby5tdWwocyl9fSk7ZnVuY3Rpb24gcmgodCxlLG4pe2Zvcih2YXIgcj0xLXQlMixvPW5ldyBGbG9hdDMyQXJyYXkodCksYT0wO2E8dDsrK2Epe3ZhciBpPTIqTWF0aC5QSSphLyh0K3ItMSk7b1thXT1lLW4qTWF0aC5jb3MoaSl9cmV0dXJuIE1uKG8sXCJmbG9hdDMyXCIpfXZhciBvaD1Bbih7aGFubldpbmRvd186ZnVuY3Rpb24odCl7cmV0dXJuIHJoKHQsLjUsLjUpfX0pLGFoPUFuKHtoYW1taW5nV2luZG93XzpmdW5jdGlvbih0KXtyZXR1cm4gcmgodCwuNTQsLjQ2KX19KSxpaD1Bbih7ZnJhbWVfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9ITEpLHZvaWQgMD09PW8mJihvPTApO2Zvcih2YXIgYT0wLGk9W107YStlPD10LnNpemU7KWkucHVzaChtbCh0LGEsZSkpLGErPW47aWYocilmb3IoO2E8dC5zaXplOyl7dmFyIHM9YStlLXQuc2l6ZSx1PVluKFttbCh0LGEsZS1zKSxIbihbc10sbyldKTtpLnB1c2godSksYSs9bn1yZXR1cm4gMD09PWkubGVuZ3RoP0JuKFtdLFswLGVdKTpZbihpKS5hczJEKGkubGVuZ3RoLGUpfX0pLHNoPUFuKHtzdGZ0XzpmdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhO3ZvaWQgMD09PW8mJihvPW9oKSxudWxsPT1yJiYoYT1lLHI9TWF0aC5mbG9vcihNYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhhKS9NYXRoLmxvZygyKSkpKSk7Zm9yKHZhciBpPWloKHQsZSxuKSxzPWdjKGksbyhlKSksdT1bXSxjPTA7YzxpLnNoYXBlWzBdO2MrKyl1LnB1c2goJGwocy5zbGljZShbYywwXSxbMSxlXSkscikpO3JldHVybiBZbih1KX19KSx1aD1PYmplY3QuZnJlZXplKHtoYW5uV2luZG93Om9oLGhhbW1pbmdXaW5kb3c6YWgsZnJhbWU6aWgsc3RmdDpzaH0pO3ZhciBjaCxsaD1mdW5jdGlvbih0LGUsbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPTEpLG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGEsaSxzLHUsYyxsLGgsZixkLHAsdixtLGc7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1tbih0LFwicHJlZGljdGlvbnNcIixcImluVG9wS1wiKSxhPW1uKGUsXCJ0YXJnZXRzXCIsXCJpblRvcEtcIiksQyhuLnJhbms+MSwoZnVuY3Rpb24oKXtyZXR1cm5cImluVG9wSygpIGV4cGVjdHMgdGhlIHByZWRpY3Rpb25zIHRvIGJlIG9mIHJhbmsgMiBvciBoaWdoZXIsIGJ1dCBnb3QgXCIrbi5yYW5rfSkpLEMobi5yYW5rLTE9PT1hLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJwcmVkaWN0aW9ucyByYW5rIHNob3VsZCBiZSAxIGxhcmdlciB0aGFuIHRhcmdldHMgcmFuaywgYnV0IGdvdCBwcmVkaWN0aW9ucyByYW5rIFwiK24ucmFuaytcIiBhbmQgdGFyZ2V0cyByYW5rIFwiK2EucmFua30pKSxFKG4uc2hhcGUuc2xpY2UoMCxuLnNoYXBlLmxlbmd0aC0xKSxhLnNoYXBlLFwicHJlZGljdGlvbnMncyBzaGFwZSBzaG91bGQgYmUgYWxpZ24gd2l0aCB0aGUgdGFyZ2V0cycgc2hhcGUsIGV4Y2VwdCB0aGUgbGFzdCBkaW1lbnNpb24uXCIpLGk9bi5zaGFwZVtuLnNoYXBlLmxlbmd0aC0xXSxDKG8+MCYmbzw9aSwoZnVuY3Rpb24oKXtyZXR1cm5cIidrJyBwYXNzZWQgdG8gaW5Ub3BLKCkgbXVzdCBiZSA+IDAgJiYgPD0gdGhlIHByZWRpY3Rpb25zIGxhc3QgZGltZW5zaW9uIChcIitpK1wiKSwgYnV0IGdvdCBcIitvfSkpLFs0LG4uZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHM9ci5zZW50KCksWzQsYS5kYXRhKCldO2Nhc2UgMjpmb3IodT1yLnNlbnQoKSxjPVtzLmxlbmd0aC9pLGldLGg9Y1sxXSxmPUIoXCJib29sXCIsbD1jWzBdKSxkPTA7ZDxsO2QrKyl7Zm9yKHA9ZCpoLHY9cy5zdWJhcnJheShwLHAraCksbT1bXSxnPTA7Zzx2Lmxlbmd0aDtnKyspbS5wdXNoKHt2YWx1ZTp2W2ddLGluZGV4Omd9KTtmb3IobS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBlLnZhbHVlLXQudmFsdWV9KSksZltkXT0wLGc9MDtnPG87ZysrKWlmKG1bZ10uaW5kZXg9PT11W2RdKXtmW2RdPTE7YnJlYWt9fXJldHVybiB0IT09biYmbi5kaXNwb3NlKCksZSE9PWEmJmEuZGlzcG9zZSgpLFsyLEZuKGYsYS5zaGFwZSxcImJvb2xcIildfX0pKX0pKX07IWZ1bmN0aW9uKHQpe3RbdC5OT05FPTBdPVwiTk9ORVwiLHRbdC5NRUFOPTFdPVwiTUVBTlwiLHRbdC5TVU09Ml09XCJTVU1cIix0W3QuU1VNX0JZX05PTlpFUk9fV0VJR0hUUz0zXT1cIlNVTV9CWV9OT05aRVJPX1dFSUdIVFNcIn0oY2h8fChjaD17fSkpO3ZhciBoaD1Bbih7YWJzb2x1dGVEaWZmZXJlbmNlXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbz1tbih0LFwibGFiZWxzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIiksYT1tbihlLFwicHJlZGljdGlvbnNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxpPW51bGw7bnVsbCE9biYmKGk9bW4obixcIndlaWdodHNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSksRShvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBhYnNvbHV0ZURpZmZlcmVuY2U6IFwiKTt2YXIgcz1vLnN1YihhKS5hYnMoKTtyZXR1cm4gZmgocyxpLHIpfX0pLGZoPUFuKHtjb21wdXRlV2VpZ2h0ZWRMb3NzXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIHI9bW4odCxcImxvc3Nlc1wiLFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiKSxvPW51bGw7bnVsbCE9ZSYmKG89bW4oZSxcIndlaWdodHNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIikpO3ZhciBhPW51bGw9PW8/cjpyLm11bChvKTtpZihuPT09Y2guTk9ORSlyZXR1cm4gYTtpZihuPT09Y2guU1VNKXJldHVybiBhLnN1bSgpO2lmKG49PT1jaC5NRUFOKXtpZihudWxsPT1vKXJldHVybiBhLm1lYW4oKTt2YXIgaT1yLnNpemUvby5zaXplLHM9YS5zdW0oKS5kaXYoby5zdW0oKSk7cmV0dXJuIGk+MT9zLmRpdihPbihpKSk6c31pZihuPT09Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7aWYobnVsbD09bylyZXR1cm4gYS5zdW0oKS5kaXYoT24oci5zaXplKSk7dmFyIHU9by5tdWwoem4oci5zaGFwZSkpLm5vdEVxdWFsKE9uKDApKS5zdW0oKS50b0Zsb2F0KCk7cmV0dXJuIGEuc3VtKCkuZGl2KHUpfXRocm93IEVycm9yKFwiVW5rbm93biByZWR1Y3Rpb246IFwiK24pfX0pLGRoPUFuKHtjb3NpbmVEaXN0YW5jZV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1tbih0LFwibGFiZWxzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxpPW1uKGUsXCJwcmVkaWN0aW9uc1wiLFwiY29zaW5lRGlzdGFuY2VcIikscz1udWxsO251bGwhPXImJihzPW1uKHIsXCJ3ZWlnaHRzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBjb3NpbmVEaXN0YW5jZTogXCIpO3ZhciB1PU9uKDEpLnN1YihhLm11bChpKS5zdW0obiwhMCkpO3JldHVybiBmaCh1LHMsbyl9fSkscGg9QW4oe2hpbmdlTG9zc186ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89bW4odCxcImxhYmVsc1wiLFwiaGluZ2VMb3NzXCIpLGE9bW4oZSxcInByZWRpY3Rpb25zXCIsXCJoaW5nZUxvc3NcIiksaT1udWxsO251bGwhPW4mJihpPW1uKG4sXCJ3ZWlnaHRzXCIsXCJoaW5nZUxvc3NcIikpLEUoby5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gaGluZ2VMb3NzOiBcIik7dmFyIHM9T24oMSk7bz1PbigyKS5tdWwobykuc3ViKHMpO3ZhciB1PXMuc3ViKG8ubXVsKGEpKS5yZWx1KCk7cmV0dXJuIGZoKHUsaSxyKX19KSx2aD1Bbih7aHViZXJMb3NzXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW8mJihvPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPW1uKHQsXCJsYWJlbHNcIixcImh1YmVyTG9zc1wiKSxpPW1uKGUsXCJwcmVkaWN0aW9uc1wiLFwiaHViZXJMb3NzXCIpLHM9bnVsbDtudWxsIT1uJiYocz1tbihuLFwid2VpZ2h0c1wiLFwiaHViZXJMb3NzXCIpKSxFKGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGh1YmVyTG9zczogXCIpO3ZhciB1PU9uKHIpLGM9aS5zdWIoYSkuYWJzKCksbD1kYyhjLHUpLGg9Yy5zdWIobCksZj1PbiguNSkubXVsKGwuc3F1YXJlKCkpLmFkZCh1Lm11bChoKSk7cmV0dXJuIGZoKGYscyxvKX19KSxtaD1Bbih7bG9nTG9zc186ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0xZS03KSx2b2lkIDA9PT1vJiYobz1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1tbih0LFwibGFiZWxzXCIsXCJsb2dMb3NzXCIpLGk9bW4oZSxcInByZWRpY3Rpb25zXCIsXCJsb2dMb3NzXCIpLHM9bnVsbDtudWxsIT1uJiYocz1tbihuLFwid2VpZ2h0c1wiLFwibG9nTG9zc1wiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBsb2dMb3NzOiBcIik7dmFyIHU9T24oMSksYz1PbihyKSxsPWEubXVsKGkuYWRkKGMpLmxvZygpKS5uZWcoKS5zdWIodS5zdWIoYSkubXVsKHUuc3ViKGkpLmFkZChjKS5sb2coKSkpO3JldHVybiBmaChsLHMsbyl9fSksZ2g9QW4oe21lYW5TcXVhcmVkRXJyb3JfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPW1uKHQsXCJsYWJlbHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksYT1tbihlLFwicHJlZGljdGlvbnNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksaT1udWxsO251bGwhPW4mJihpPW1uKG4sXCJ3ZWlnaHRzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpKSxFKG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIG1lYW5TcXVhcmVkRXJyb3I6IFwiKTt2YXIgcz1vLnNxdWFyZWREaWZmZXJlbmNlKGEpO3JldHVybiBmaChzLGkscil9fSkseWg9QW4oe3NpZ21vaWRDcm9zc0VudHJvcHlfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9bW4odCxcIm11bHRpQ2xhc3NMYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIiksaT1tbihlLFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLHM9bnVsbDtpZihudWxsIT1uJiYocz1tbihuLFwid2VpZ2h0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5OiBcIikscj4wKXt2YXIgdT1PbihyKSxjPU9uKDEpLGw9T24oLjUpO2E9YS5tdWwoYy5zdWIodSkpLmFkZChsLm11bCh1KSl9dmFyIGg9ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwibGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKSxyPW1uKGUsXCJsb2dpdHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpO0Uobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHM6IFwiKTt2YXIgbz1yLnJlbHUoKSxhPXIubXVsKG4pLGk9ci5hYnMoKS5uZWcoKS5leHAoKS5sb2cxcCgpO3JldHVybiBvLnN1YihhKS5hZGQoaSl9KGEsaSk7cmV0dXJuIGZoKGgscyxvKX19KSx4aD1Bbih7c29mdG1heENyb3NzRW50cm9weV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1tbih0LFwib25laG90TGFiZWxzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLGk9bW4oZSxcImxvZ2l0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxzPW51bGw7aWYobnVsbCE9biYmKHM9bW4obixcIndlaWdodHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIikpLEUoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc29mdG1heENyb3NzRW50cm9weTogXCIpLHI+MCl7dmFyIHU9T24ociksYz1PbigxKSxsPU9uKGEuc2hhcGVbMV0pO2E9YS5tdWwoYy5zdWIodSkpLmFkZCh1LmRpdihsKSl9dmFyIGg9ZnVuY3Rpb24odCxlLG4pe2lmKHZvaWQgMD09PW4mJihuPS0xKSwtMT09PW4mJihuPWUucmFuay0xKSxuIT09ZS5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGNyb3NzIGVudHJvcHkgYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExhYmVscyAvIGxvZ2l0cyB3YXMgcmFuayBcIitlLnJhbmsrXCIgYW5kIGRpbSB3YXMgXCIrbik7cmV0dXJuIHZvKChmdW5jdGlvbih0LGUscil7dmFyIG89ZS5sb2dTdW1FeHAoW25dLCEwKSxhPWUudG9GbG9hdCgpLnN1YihvKTtyKFt0LGFdKTtyZXR1cm57dmFsdWU6YS5tdWwodCkubmVnKCkuc3VtKFtuXSksZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgcj1lWzBdLG89ZVsxXSxhPXduKHQuc2hhcGUsW25dKTtyZXR1cm5bdC5yZXNoYXBlKGEpLm11bChyLnRvRmxvYXQoKS5zdWIoby5leHAoKSkpLHQucmVzaGFwZShhKS5tdWwoby5leHAoKS5zdWIoci50b0Zsb2F0KCkpKV19fX0pKSh0LGUpfShhLGkpO3JldHVybiBmaChoLHMsbyl9fSksYmg9T2JqZWN0LmZyZWV6ZSh7Z2V0IFJlZHVjdGlvbigpe3JldHVybiBjaH0sYWJzb2x1dGVEaWZmZXJlbmNlOmhoLGNvbXB1dGVXZWlnaHRlZExvc3M6ZmgsY29zaW5lRGlzdGFuY2U6ZGgsaGluZ2VMb3NzOnBoLGh1YmVyTG9zczp2aCxsb2dMb3NzOm1oLG1lYW5TcXVhcmVkRXJyb3I6Z2gsc2lnbW9pZENyb3NzRW50cm9weTp5aCxzb2Z0bWF4Q3Jvc3NFbnRyb3B5OnhofSk7ZnVuY3Rpb24gd2godCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLEx0LnRpZHkoKGZ1bmN0aW9uKCl7aWYoMiE9PXQuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInFyMmQoKSByZXF1aXJlcyBhIDJEIFRlbnNvciwgYnV0IGdvdCBhIFwiK3Quc2hhcGUubGVuZ3RoK1wiRCBUZW5zb3IuXCIpO2Zvcih2YXIgbj10LnNoYXBlWzBdLHI9dC5zaGFwZVsxXSxvPUNyKG4pLGE9dC5jbG9uZSgpLGk9Qm4oW1sxXV0sWzEsMV0pLHM9aS5jbG9uZSgpLHU9bj49cj9yOm4sYz1mdW5jdGlvbih0KXt2YXIgZSx1PWEsYz1zLGw9bztlPUx0LnRpZHkoKGZ1bmN0aW9uKCl7dmFyIGU9YS5zbGljZShbdCx0XSxbbi10LDFdKSx1PWUubm9ybSgpLGM9YS5zbGljZShbdCx0XSxbMSwxXSksbD1CbihbWy0xXV0pLndoZXJlKGMuZ3JlYXRlcigwKSxCbihbWzFdXSkpLGg9Yy5zdWIobC5tdWwodSkpLGY9ZS5kaXYoaCk7cz0xPT09Zi5zaGFwZVswXT9pLmNsb25lKCk6aS5jb25jYXQoZi5zbGljZShbMSwwXSxbZi5zaGFwZVswXS0xLGYuc2hhcGVbMV1dKSwwKTt2YXIgZD1sLm1hdE11bChoKS5kaXYodSkubmVnKCkscD1hLnNsaWNlKFt0LDBdLFtuLXQscl0pLHY9ZC5tdWwocyk7aWYoMD09PXQpYT1wLnN1Yih2Lm1hdE11bChzLnRyYW5zcG9zZSgpLm1hdE11bChwKSkpO2Vsc2V7dmFyIG09cC5zdWIodi5tYXRNdWwocy50cmFuc3Bvc2UoKS5tYXRNdWwocCkpKTthPWEuc2xpY2UoWzAsMF0sW3Qscl0pLmNvbmNhdChtLDApfXZhciBnPW8uc2xpY2UoWzAsdF0sW24sby5zaGFwZVsxXS10XSk7aWYoMD09PXQpbz1nLnN1YihnLm1hdE11bChzKS5tYXRNdWwodi50cmFuc3Bvc2UoKSkpO2Vsc2V7dmFyIHk9Zy5zdWIoZy5tYXRNdWwocykubWF0TXVsKHYudHJhbnNwb3NlKCkpKTtvPW8uc2xpY2UoWzAsMF0sW24sdF0pLmNvbmNhdCh5LDEpfXJldHVybltzLGEsb119KSkscz1lWzBdLGE9ZVsxXSxvPWVbMl0sdG4oW3UsYyxsXSl9LGw9MDtsPHU7KytsKWMobCk7cmV0dXJuIWUmJm4+ciYmKG89by5zbGljZShbMCwwXSxbbixyXSksYT1hLnNsaWNlKFswLDBdLFtyLHJdKSksW28sYV19KSl9dmFyIENoPUFuKHtiYW5kUGFydF86ZnVuY3Rpb24odCxlLG4pe2lmKGUlMSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJiYW5kUGFydCgpOiBudW1Mb3dlciBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCBcIitlK1wiLlwiKTtpZihuJTEhPTApdGhyb3cgbmV3IEVycm9yKFwiYmFuZFBhcnQoKTogbnVtVXBwZXIgbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgXCIrbitcIi5cIik7dmFyIHI9bW4odCxcImFcIixcImJhbmRQYXJ0XCIpO2lmKHIucmFuazwyKXRocm93IG5ldyBFcnJvcihcImJhbmRQYXJ0KCk6IFJhbmsgbXVzdCBiZSBhdCBsZWFzdCAyLCBnb3QgXCIrci5yYW5rK1wiLlwiKTt2YXIgbz1yLnNoYXBlLGE9ci5zaGFwZS5zbGljZSgtMiksaT1hWzBdLHM9YVsxXTtpZighKGU8PWkpKXRocm93IG5ldyBFcnJvcihcImJhbmRQYXJ0KCk6IG51bUxvd2VyIChcIitlK1wiKSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiByb3dzIChcIitpK1wiKS5cIik7aWYoIShuPD1zKSl0aHJvdyBuZXcgRXJyb3IoXCJiYW5kUGFydCgpOiBudW1VcHBlciAoXCIrbitcIikgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgY29sdW1ucyAoXCIrcytcIikuXCIpO2U8MCYmKGU9aSksbjwwJiYobj1zKTt2YXIgdT1LbigwLGksMSxcImludDMyXCIpLnJlc2hhcGUoWy0xLDFdKSxjPUtuKDAscywxLFwiaW50MzJcIiksbD1DYyh1LGMpLGg9UXUobC5sZXNzRXF1YWwoT24oK2UsXCJpbnQzMlwiKSksbC5ncmVhdGVyRXF1YWwoT24oLW4sXCJpbnQzMlwiKSkpLGY9R24oW2ksc10sci5kdHlwZSk7cmV0dXJuIFByKFVyKHIucmVzaGFwZShbLTEsaSxzXSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGVjKGgsdCxmKX0pKSkucmVzaGFwZShvKX19KSxFaD1Bbih7Z3JhbVNjaG1pZHRfOmZ1bmN0aW9uKHQpe3ZhciBlO2lmKEFycmF5LmlzQXJyYXkodCkpe2U9ITEsQyhudWxsIT10JiZ0Lmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwiR3JhbS1TY2htaWR0IHByb2Nlc3M6IGlucHV0IG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHlcIn0pKTtmb3IodmFyIG49dFswXS5zaGFwZVswXSxyPWZ1bmN0aW9uKGUpe0ModFtlXS5zaGFwZVswXT09PW4sKGZ1bmN0aW9uKCl7cmV0dXJuXCJHcmFtLVNjaG1pZHQ6IE5vbi11bmlxdWUgbGVuZ3RocyBmb3VuZCBpbiB0aGUgaW5wdXQgdmVjdG9yczogKFwiK3RbZV0uc2hhcGVbMF0rXCIgdnMuIFwiK24rXCIpXCJ9KSl9LG89MTtvPHQubGVuZ3RoOysrbylyKG8pfWVsc2UgZT0hMCx0PXRyKHQsdC5zaGFwZVswXSwwKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBCcih0LFswXSl9KSk7Qyh0Lmxlbmd0aDw9dFswXS5zaGFwZVswXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkdyYW0tU2NobWlkdDogTnVtYmVyIG9mIHZlY3RvcnMgKFwiK3QubGVuZ3RoK1wiKSBleGNlZWRzIG51bWJlciBvZiBkaW1lbnNpb25zIChcIit0WzBdLnNoYXBlWzBdK1wiKS5cIn0pKTt2YXIgYT1bXSxpPXQscz1mdW5jdGlvbih0KXthLnB1c2goTHQudGlkeSgoZnVuY3Rpb24oKXt2YXIgZT1pW3RdO2lmKHQ+MClmb3IodmFyIG49MDtuPHQ7KytuKXt2YXIgcj1ObChhW25dLm11bFN0cmljdChlKSkubXVsKGFbbl0pO2U9ZS5zdWIocil9cmV0dXJuIGUuZGl2KFZsKGUsXCJldWNsaWRlYW5cIikpfSkpKX07Zm9yKG89MDtvPHQubGVuZ3RoOysrbylzKG8pO3JldHVybiBlP1ByKGEsMCk6YX19KSxSaD1Bbih7cXJfOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9ITEpLHQucmFuazwyKXRocm93IG5ldyBFcnJvcihcInFyKCkgcmVxdWlyZXMgaW5wdXQgdGVuc29yIHRvIGhhdmUgYSByYW5rID49IDIsIGJ1dCBnb3QgcmFuayBcIit0LnJhbmspO2lmKDI9PT10LnJhbmspcmV0dXJuIHdoKHQsZSk7dmFyIG49dC5zaGFwZS5zbGljZSgwLHQuc2hhcGUubGVuZ3RoLTIpLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpLHI9VXIodC5yZXNoYXBlKFtuLHQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMl0sdC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXV0pLDApLG89W10sYT1bXTtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj13aCh0LGUpLHI9blswXSxpPW5bMV07by5wdXNoKHIpLGEucHVzaChpKX0pKSxbUHIobywwKS5yZXNoYXBlKHQuc2hhcGUpLFByKGEsMCkucmVzaGFwZSh0LnNoYXBlKV19fSksSWg9T2JqZWN0LmZyZWV6ZSh7YmFuZFBhcnQ6Q2gsZ3JhbVNjaG1pZHQ6RWgscXI6Umh9KTtmdW5jdGlvbiBraCh0LGUsbixyLG8sYSl7bnVsbD09ciYmKHI9LjUpLG51bGw9PW8mJihvPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSksbnVsbD09YSYmKGE9MCk7dmFyIGk9dC5zaGFwZVswXTtyZXR1cm4gbj1NYXRoLm1pbihuLGkpLEMoMDw9ciYmcjw9MSwoZnVuY3Rpb24oKXtyZXR1cm5cImlvdVRocmVzaG9sZCBtdXN0IGJlIGluIFswLCAxXSwgYnV0IHdhcyAnXCIrcitcIidcIn0pKSxDKDI9PT10LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJib3hlcyBtdXN0IGJlIGEgMkQgdGVuc29yLCBidXQgd2FzIG9mIHJhbmsgJ1wiK3QucmFuaytcIidcIn0pKSxDKDQ9PT10LnNoYXBlWzFdLChmdW5jdGlvbigpe3JldHVyblwiYm94ZXMgbXVzdCBoYXZlIDQgY29sdW1ucywgYnV0IDJuZCBkaW1lbnNpb24gd2FzIFwiK3Quc2hhcGVbMV19KSksQygxPT09ZS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwic2NvcmVzIG11c3QgYmUgYSAxRCB0ZW5zb3JcIn0pKSxDKGUuc2hhcGVbMF09PT1pLChmdW5jdGlvbigpe3JldHVyblwic2NvcmVzIGhhcyBpbmNvbXBhdGlibGUgc2hhcGUgd2l0aCBib3hlcy4gRXhwZWN0ZWQgXCIraStcIiwgYnV0IHdhcyBcIitlLnNoYXBlWzBdfSkpLEMoMDw9YSYmYTw9MSwoZnVuY3Rpb24oKXtyZXR1cm5cInNvZnRObXNTaWdtYSBtdXN0IGJlIGluIFswLCAxXSwgYnV0IHdhcyAnXCIrYStcIidcIn0pKSx7bWF4T3V0cHV0U2l6ZTpuLGlvdVRocmVzaG9sZDpyLHNjb3JlVGhyZXNob2xkOm8sc29mdE5tc1NpZ21hOmF9fXZhciBTaD1Bbih7cmVzaXplQmlsaW5lYXJfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcImltYWdlc1wiLFwicmVzaXplQmlsaW5lYXJcIik7QygzPT09ci5yYW5rfHw0PT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rIFwiK3IucmFuaytcIi5cIn0pKSxDKDI9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIitlK1wiLlwifSkpO3ZhciBvPXIsYT0hMTszPT09ci5yYW5rJiYoYT0hMCxvPXIuYXM0RCgxLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdKSk7dmFyIGk9ZVswXSxzPWVbMV0sdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3JldHVybiBlKFtvXSksdC5yZXNpemVCaWxpbmVhcihvLGkscyxuKX0pLHt4Om99LChmdW5jdGlvbih0LGUpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHIpe3JldHVybiByLnJlc2l6ZUJpbGluZWFyQmFja3Byb3AodCxlWzBdLG4pfSkse30pfX19KSxcIlJlc2l6ZUJpbGluZWFyXCIse2FsaWduQ29ybmVyczpuLG5ld0hlaWdodDppLG5ld1dpZHRoOnN9KTtyZXR1cm4gYT91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9fSksQWg9QW4oe3Jlc2l6ZU5lYXJlc3ROZWlnaGJvcl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwiaW1hZ2VzXCIsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7QygzPT09ci5yYW5rfHw0PT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayBcIityLnJhbmsrXCIuXCJ9KSksQygyPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiK2UrXCIuXCJ9KSksQyhcImZsb2F0MzJcIj09PXIuZHR5cGV8fFwiaW50MzJcIj09PXIuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJgaW1hZ2VzYCBtdXN0IGhhdmUgYGludDMyYCBvciBgZmxvYXQzMmAgYXMgZHR5cGVcIn0pKTt2YXIgbz1yLGE9ITE7Mz09PXIucmFuayYmKGE9ITAsbz1yLmFzNEQoMSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSkpO3ZhciBpPWVbMF0scz1lWzFdLHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXtyZXR1cm4gZShbb10pLHQucmVzaXplTmVhcmVzdE5laWdoYm9yKG8saSxzLG4pfSkse2JhdGNoSW1hZ2VzOm99LChmdW5jdGlvbih0LGUpe3JldHVybntiYXRjaEltYWdlczpmdW5jdGlvbigpe3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihyKXtyZXR1cm4gci5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcCh0LGVbMF0sbil9KSx7fSl9fX0pKTtyZXR1cm4gYT91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9fSksRGg9QW4oe25vbk1heFN1cHByZXNzaW9uXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPS41KSx2b2lkIDA9PT1vJiYobz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO3ZhciBhPW1uKHQsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIiksaT1tbihlLFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxzPWtoKGEsaSxuLHIsbyk7bj1zLm1heE91dHB1dFNpemUscj1zLmlvdVRocmVzaG9sZCxvPXMuc2NvcmVUaHJlc2hvbGQ7dmFyIHU9e21heE91dHB1dFNpemU6bixpb3VUaHJlc2hvbGQ6cixzY29yZVRocmVzaG9sZDpvfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubm9uTWF4U3VwcHJlc3Npb24oYSxpLG4scixvKX0pLHtib3hlczphLHNjb3JlczppfSxudWxsLFwiTm9uTWF4U3VwcHJlc3Npb25WM1wiLHUpfX0pLFRoPWZ1bmN0aW9uKHQsZSxvLGEsaSl7cmV0dXJuIHZvaWQgMD09PWEmJihhPS41KSx2b2lkIDA9PT1pJiYoaT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49bW4odCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLHM9bW4oZSxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSx1PWtoKG4scyxvLGEsaSksbz11Lm1heE91dHB1dFNpemUsYT11LmlvdVRocmVzaG9sZCxpPXUuc2NvcmVUaHJlc2hvbGQsWzQsUHJvbWlzZS5hbGwoW24uZGF0YSgpLHMuZGF0YSgpXSldO2Nhc2UgMTpyZXR1cm4gYz1yLnNlbnQoKSxsPWNbMF0saD1jWzFdLGY9am8obCxoLG8sYSxpKSxuIT09dCYmbi5kaXNwb3NlKCkscyE9PWUmJnMuZGlzcG9zZSgpLFsyLGZdfX0pKX0pKX0sTmg9QW4oe25vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dm9pZCAwPT09ciYmKHI9LjUpLHZvaWQgMD09PW8mJihvPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSksdm9pZCAwPT09YSYmKGE9MCk7dmFyIGk9bW4odCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxzPW1uKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLHU9a2goaSxzLG4scixvLGEpLGM9e21heE91dHB1dFNpemU6bj11Lm1heE91dHB1dFNpemUsaW91VGhyZXNob2xkOnI9dS5pb3VUaHJlc2hvbGQsc2NvcmVUaHJlc2hvbGQ6bz11LnNjb3JlVGhyZXNob2xkLHNvZnRObXNTaWdtYTphPXUuc29mdE5tc1NpZ21hfSxsPUx0LnJ1bktlcm5lbChcIk5vbk1heFN1cHByZXNzaW9uVjVcIix7Ym94ZXM6aSxzY29yZXM6c30sYyk7cmV0dXJue3NlbGVjdGVkSW5kaWNlczpsWzBdLHNlbGVjdGVkU2NvcmVzOmxbMV19fX0pLEZoPWZ1bmN0aW9uKHQsZSxvLGEsaSxzKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9LjUpLHZvaWQgMD09PWkmJihpPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSksdm9pZCAwPT09cyYmKHM9MCksbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sdSxjLGwsaCxmLGQ7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1tbih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksdT1tbihlLFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLGM9a2gobix1LG8sYSxpLHMpLG89Yy5tYXhPdXRwdXRTaXplLGE9Yy5pb3VUaHJlc2hvbGQsaT1jLnNjb3JlVGhyZXNob2xkLHM9Yy5zb2Z0Tm1zU2lnbWEsWzQsUHJvbWlzZS5hbGwoW24uZGF0YSgpLHUuZGF0YSgpXSldO2Nhc2UgMTpyZXR1cm4gbD1yLnNlbnQoKSxoPWxbMF0sZj1sWzFdLGQ9WG8oaCxmLG8sYSxpLHMpLG4hPT10JiZuLmRpc3Bvc2UoKSx1IT09ZSYmdS5kaXNwb3NlKCksWzIsZF19fSkpfSkpfSxfaD1Bbih7Y3JvcEFuZFJlc2l6ZV86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW1uKHQsXCJpbWFnZVwiLFwiY3JvcEFuZFJlc2l6ZVwiKSxzPW1uKGUsXCJib3hlc1wiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiZmxvYXQzMlwiKSx1PW1uKG4sXCJib3hJbmRcIixcImNyb3BBbmRSZXNpemVcIixcImludDMyXCIpO289b3x8XCJiaWxpbmVhclwiLGE9YXx8MDt2YXIgYz1zLnNoYXBlWzBdO3JldHVybiBDKDQ9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBpbWFnZSBtdXN0IGJlIHJhbmsgNCxidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSkpLEMoMj09PXMucmFuayYmND09PXMuc2hhcGVbMV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hlcyBtdXN0IGJlIGhhdmUgc2l6ZSBbXCIrYytcIiw0XSBidXQgaGFkIHNoYXBlIFwiK3Muc2hhcGUrXCIuXCJ9KSksQygxPT09dS5yYW5rJiZ1LnNoYXBlWzBdPT09YywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveEluZCBtdXN0IGJlIGhhdmUgc2l6ZSBbXCIrYytcIl0gYnV0IGhhZCBzaGFwZSBcIitzLnNoYXBlK1wiLlwifSkpLEMoMj09PXIubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogY3JvcFNpemUgbXVzdCBiZSBvZiBsZW5ndGggMiwgYnV0IGdvdCBsZW5ndGggXCIrci5sZW5ndGgrXCIuXCJ9KSksQyhyWzBdPj0xJiZyWzFdPj0xLChmdW5jdGlvbigpe3JldHVyblwiY3JvcFNpemUgbXVzdCBiZSBhdGxlYXN0IFsxLDFdLCBidXQgd2FzIFwiK3J9KSksQyhcImJpbGluZWFyXCI9PT1vfHxcIm5lYXJlc3RcIj09PW8sKGZ1bmN0aW9uKCl7cmV0dXJuXCJtZXRob2QgbXVzdCBiZSBiaWxpbmVhciBvciBuZWFyZXN0LCBidXQgd2FzIFwiK299KSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jcm9wQW5kUmVzaXplKGkscyx1LHIsbyxhKX0pLHtpbWFnZXM6aSxib3hlczpzLGJveEluZDp1fSxudWxsLFwiQ3JvcEFuZFJlc2l6ZVwiLHttZXRob2Q6byxleHRyYXBvbGF0aW9uVmFsdWU6YSxjcm9wU2l6ZTpyfSl9fSksT2g9T2JqZWN0LmZyZWV6ZSh7cmVzaXplQmlsaW5lYXI6U2gscmVzaXplTmVhcmVzdE5laWdoYm9yOkFoLG5vbk1heFN1cHByZXNzaW9uOkRoLG5vbk1heFN1cHByZXNzaW9uQXN5bmM6VGgsbm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmU6Tmgsbm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVBc3luYzpGaCxjcm9wQW5kUmVzaXplOl9ofSksTWg9ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHQ+MCl8fFwibGluZWFyXCI9PT1lfSxCaD1mdW5jdGlvbih0LGUsbil7aWYobnVsbD09bnx8XCJsaW5lYXJcIj09PW4pcmV0dXJuIHQ7aWYoXCJyZWx1XCI9PT1uKXJldHVybiB0Lm11bChlLnN0ZXAoKSk7dGhyb3cgbmV3IEVycm9yKFwiR3JhZGllbnQgZm9yIGFjdGl2YXRpb24gXCIrbitcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlwiKX0sUGg9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLHI9RW8odC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gci5sZW5ndGg+MCYmKG49bi5zdW0ocikpLG4ucmVzaGFwZSh0LnNoYXBlKX0sTGg9ZnVuY3Rpb24odCxlLG4pe2lmKFwibGluZWFyXCI9PT1lKXJldHVybiB0O2lmKFwicmVsdVwiPT09ZSlyZXR1cm4gQmwodCk7aWYoXCJlbHVcIj09PWUpcmV0dXJuIF9sKHQpO2lmKFwicmVsdTZcIj09PWUpcmV0dXJuIFBsKHQpO2lmKFwicHJlbHVcIj09PWUpcmV0dXJuIE1sKHQsbik7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmdXNlZCBhY3RpdmF0aW9uIFwiK2UrXCIuXCIpfTt2YXIgV2g9QW4oe2Z1c2VkTWF0TXVsXzpmdW5jdGlvbih0KXt2YXIgZSxuPXQuYSxyPXQuYixvPXQudHJhbnNwb3NlQSxhPXZvaWQgMCE9PW8mJm8saT10LnRyYW5zcG9zZUIscz12b2lkIDAhPT1pJiZpLHU9dC5iaWFzLGM9dC5hY3RpdmF0aW9uLGw9dm9pZCAwPT09Yz9cImxpbmVhclwiOmMsaD10LnByZWx1QWN0aXZhdGlvbldlaWdodHM7aWYoITE9PT1NaChMdC5zdGF0ZS5ncmFkaWVudERlcHRoLGwpKXt2YXIgZj1lbChuLHIsYSxzKTtyZXR1cm4gbnVsbCE9dSYmKGY9cmMoZix1KSksTGgoZixsLGgpfXZhciBkPW1uKG4sXCJhXCIsXCJmdXNlZCBtYXRNdWxcIikscD1tbihyLFwiYlwiLFwiZnVzZWQgbWF0TXVsXCIpO2U9TnQoZCxwKSxkPWVbMF0scD1lWzFdO3ZhciB2PWE/ZC5zaGFwZVtkLnJhbmstMl06ZC5zaGFwZVtkLnJhbmstMV0sbT1zP3Auc2hhcGVbcC5yYW5rLTFdOnAuc2hhcGVbcC5yYW5rLTJdLGc9YT9kLnNoYXBlW2QucmFuay0xXTpkLnNoYXBlW2QucmFuay0yXSx5PXM/cC5zaGFwZVtwLnJhbmstMl06cC5zaGFwZVtwLnJhbmstMV0seD1kLnNoYXBlLnNsaWNlKDAsLTIpLGI9cC5zaGFwZS5zbGljZSgwLC0yKSx3PWsoeCksRT1rKGIpO0MoZC5yYW5rPj0yJiZwLnJhbms+PTImJmQucmFuaz09PXAucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIG1hdE11bDogaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIG9mIGF0IGxlYXN0IDIsIGdvdCByYW5rcyBcIitkLnJhbmsrXCIgYW5kIFwiK3AucmFuaytcIi5cIn0pKSxDKFMoeCxiKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIG1hdE11bDogb3V0ZXIgZGltZW5zaW9ucyAoXCIreCtcIikgYW5kIChcIitiK1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK2Quc2hhcGUrXCIgYW5kIFwiK3Auc2hhcGUrXCIgbXVzdCBtYXRjaC5cIn0pKSxDKHY9PT1tLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBpbm5lciBzaGFwZXMgKFwiK3YrXCIpIGFuZCAoXCIrbStcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIitkLnNoYXBlK1wiIGFuZCBcIitwLnNoYXBlK1wiIGFuZCB0cmFuc3Bvc2VBPVwiK2ErXCIgYW5kIHRyYW5zcG9zZUI9XCIrcytcIiBtdXN0IG1hdGNoLlwifSkpO3ZhciBSLEksQT1kLnNoYXBlLnNsaWNlKDAsLTIpLmNvbmNhdChbZyx5XSksRD1hP2QuYXMzRCh3LHYsZyk6ZC5hczNEKHcsZyx2KSxUPXM/cC5hczNEKEUseSxtKTpwLmFzM0QoRSxtLHkpO251bGwhPXUmJlJvKEEsKFI9TnQoUj1tbih1LFwiYmlhc1wiLFwiZnVzZWQgbWF0TXVsXCIpLGQpWzBdKS5zaGFwZSksbnVsbCE9aCYmKEk9bW4oaCxcInByZWx1IHdlaWdodHNcIixcImZ1c2VkIG1hdE11bFwiKSk7dmFyIE49e2E6RCxiOlR9O251bGwhPXUmJihOLmJpYXM9UiksbnVsbCE9aCYmKE4ucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz1JKTt2YXIgRj1bRCxUXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmZ1c2VkQmF0Y2hNYXRNdWwoe2E6RCxiOlQsdHJhbnNwb3NlQTphLHRyYW5zcG9zZUI6cyxiaWFzOlIsYWN0aXZhdGlvbjpsLHByZWx1QWN0aXZhdGlvbldlaWdodHM6SX0pO3JldHVybiBlKFtELFQsbl0pLG59KSxOLChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89ZVsyXSxpPUJoKHQsbyxsKSxjPXt9O3JldHVybiBudWxsIT11JiYoYz17YmlhczpmdW5jdGlvbigpe3JldHVybiBQaChSLGkpfX0pLGF8fHM/IWEmJnM/T2JqZWN0LmFzc2lnbih7YTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bChyLCExLCExKX0sYjpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bChuLCEwLCExKX19LGMpOmEmJiFzP09iamVjdC5hc3NpZ24oe2E6ZnVuY3Rpb24oKXtyZXR1cm4gci5tYXRNdWwoaSwhMSwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gbi5tYXRNdWwoaSwhMSwhMSl9fSxjKTpPYmplY3QuYXNzaWduKHthOmZ1bmN0aW9uKCl7cmV0dXJuIHIubWF0TXVsKGksITAsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKG4sITAsITApfX0sYyk6T2JqZWN0LmFzc2lnbih7YTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bChyLCExLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiBuLm1hdE11bChpLCEwLCExKX19LGMpfSksXCJfRnVzZWRNYXRNdWxcIix7dHJhbnNwb3NlQTphLHRyYW5zcG9zZUI6cyxhY3RpdmF0aW9uOmx9LEYsWyEwXSkucmVzaGFwZShBKX19KSxVaD1Bbih7ZnVzZWRDb252MmRfOmZ1bmN0aW9uKHQpe3ZhciBlPXQueCxuPXQuZmlsdGVyLHI9dC5zdHJpZGVzLG89dC5wYWQsYT10LmRhdGFGb3JtYXQsaT12b2lkIDA9PT1hP1wiTkhXQ1wiOmEscz10LmRpbGF0aW9ucyx1PXZvaWQgMD09PXM/WzEsMV06cyxjPXQuZGltUm91bmRpbmdNb2RlLGw9dC5iaWFzLGg9dC5hY3RpdmF0aW9uLGY9dm9pZCAwPT09aD9cImxpbmVhclwiOmgsZD10LnByZWx1QWN0aXZhdGlvbldlaWdodHM7aWYoZj1mfHxcImxpbmVhclwiLCExPT09TWgoTHQuc3RhdGUuZ3JhZGllbnREZXB0aCxmKSl7dmFyIHA9cWMoZSxuLHIsbyxpLHUsYyk7cmV0dXJuIG51bGwhPWwmJihwPXJjKHAsbCkpLExoKHAsZixkKX12YXIgdj1tbihlLFwieFwiLFwiY29udjJkXCIpLG09bW4obixcImZpbHRlclwiLFwiY29udjJkXCIpLGc9dix5PSExOzM9PT12LnJhbmsmJih5PSEwLGc9di5hczREKDEsdi5zaGFwZVswXSx2LnNoYXBlWzFdLHYuc2hhcGVbMl0pKSxDKDQ9PT1nLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrZy5yYW5rK1wiLlwifSkpLEMoND09PW0ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbS5yYW5rK1wiLlwifSkpLG51bGwhPWMmJkMoQShvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYytcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpLEMoZy5zaGFwZVszXT09PW0uc2hhcGVbMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0IChcIitnLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbS5zaGFwZVsyXStcIi5cIn0pKSxDKE1vKHIsdSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MkQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrdStcIidcIn0pKSxDKFwiTkhXQ1wiPT09aSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZ290IGRhdGFGb3JtYXQgb2YgXCIraStcIiBidXQgb25seSBOSFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJ9KSk7dmFyIHgsYix3PVNvKGcuc2hhcGUsbS5zaGFwZSxyLHUsbyxjKTtudWxsIT1sJiYoeD1OdCh4PW1uKGwsXCJiaWFzXCIsXCJmdXNlZCBjb252MmRcIiksdilbMF0sUm8ody5vdXRTaGFwZSx4LnNoYXBlKSksbnVsbCE9ZCYmKGI9bW4oZCxcInByZWx1IHdlaWdodHNcIixcImZ1c2VkIGNvbnYyZFwiKSk7dmFyIEU9e3g6ZyxmaWx0ZXI6bX07bnVsbCE9bCYmKEUuYmlhcz14KSxudWxsIT1kJiYoRS5wcmVsdUFjdGl2YXRpb25XZWlnaHRzPWIpO3ZhciBSPVttLGddLEk9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmZ1c2VkQ29udjJkKHtpbnB1dDpnLGZpbHRlcjptLGNvbnZJbmZvOncsYmlhczp4LGFjdGl2YXRpb246ZixwcmVsdUFjdGl2YXRpb25XZWlnaHRzOmJ9KTtyZXR1cm4gZShbbSxnLG5dKSxufSksRSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lLGE9blswXSxpPW5bMV0scz1uWzJdLGM9QmgodCxzLGYpO0MoT28odSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJ1wiK3UrXCInXCJ9KSk7dmFyIGg9e307cmV0dXJuIG51bGwhPWwmJihoPXtiaWFzOmZ1bmN0aW9uKCl7cmV0dXJuIFBoKHgsYyl9fSksT2JqZWN0LmFzc2lnbih7eDpmdW5jdGlvbigpe3JldHVybiBYYyhpLnNoYXBlLGMsYSxyLG8pfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gamMoaSxjLGEuc2hhcGUscixvKX19LGgpfSksXCJGdXNlZENvbnYyRFwiLHtjb252SW5mbzp3LGFjdGl2YXRpb246Zn0sUixbITBdKTtyZXR1cm4geT9JLmFzM0QoSS5zaGFwZVsxXSxJLnNoYXBlWzJdLEkuc2hhcGVbM10pOkl9fSksVmg9QW4oe2Z1c2VkRGVwdGh3aXNlQ29udjJkXzpmdW5jdGlvbih0KXt2YXIgZT10Lngsbj10LmZpbHRlcixyPXQuc3RyaWRlcyxvPXQucGFkLGE9dC5kYXRhRm9ybWF0LGk9dm9pZCAwPT09YT9cIk5IV0NcIjphLHM9dC5kaWxhdGlvbnMsdT12b2lkIDA9PT1zP1sxLDFdOnMsYz10LmRpbVJvdW5kaW5nTW9kZSxsPXQuYmlhcyxoPXQuYWN0aXZhdGlvbixmPXZvaWQgMD09PWg/XCJsaW5lYXJcIjpoLGQ9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO2lmKCExPT09TWgoTHQuc3RhdGUuZ3JhZGllbnREZXB0aCxmKSl7dmFyIHA9WWMoZSxuLHIsbyxpLHUsYyk7cmV0dXJuIG51bGwhPWwmJihwPXJjKHAsbCkpLExoKHAsZixkKX12YXIgdj1tbihlLFwieFwiLFwiZGVwdGh3aXNlQ29udjJkXCIpLG09bW4obixcImZpbHRlclwiLFwiZGVwdGh3aXNlQ29udjJkXCIpLGc9dix5PSExOzM9PT12LnJhbmsmJih5PSEwLGc9di5hczREKDEsdi5zaGFwZVswXSx2LnNoYXBlWzFdLHYuc2hhcGVbMl0pKSxDKDQ9PT1nLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrZy5yYW5rK1wiLlwifSkpLEMoND09PW0ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbS5yYW5rK1wiLlwifSkpLEMoZy5zaGFwZVszXT09PW0uc2hhcGVbMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IG51bWJlciBvZiBpbnB1dCBjaGFubmVscyAoXCIrZy5zaGFwZVszXStcIikgbXVzdCBtYXRjaCB0aGUgaW5DaGFubmVscyBkaW1lbnNpb24gaW4gZmlsdGVyIFwiK20uc2hhcGVbMl0rXCIuXCJ9KSksbnVsbD09dSYmKHU9WzEsMV0pLEMoTW8ocix1KSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIit1K1wiJ1wifSkpLG51bGwhPWMmJkMoQShvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nIGRpbVJvdW5kaW5nTW9kZSBcIitjK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KSk7dmFyIHgsYix3PVNvKGcuc2hhcGUsbS5zaGFwZSxyLHUsbyxjLCEwKTtudWxsIT1sJiYoeD1OdCh4PW1uKGwsXCJiaWFzXCIsXCJmdXNlZCBjb252MmRcIiksdilbMF0sUm8ody5vdXRTaGFwZSx4LnNoYXBlKSksbnVsbCE9ZCYmKGI9bW4oZCxcInByZWx1IHdlaWdodHNcIixcImZ1c2VkIGRlcHRod2lzZUNvbnYyZFwiKSk7dmFyIEU9e3g6ZyxmaWx0ZXI6bX07bnVsbCE9bCYmKEUuYmlhcz14KSxudWxsIT1kJiYoRS5wcmVsdUFjdGl2YXRpb25XZWlnaHRzPWIpO3ZhciBSPVttLGddLEk9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmZ1c2VkRGVwdGh3aXNlQ29udjJEKHtpbnB1dDpnLGZpbHRlcjptLGNvbnZJbmZvOncsYmlhczp4LGFjdGl2YXRpb246ZixwcmVsdUFjdGl2YXRpb25XZWlnaHRzOmJ9KTtyZXR1cm4gZShbbSxnLG5dKSxufSksRSwoZnVuY3Rpb24odCxlKXtDKE9vKHUpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQuIEdvdCBkaWxhdGlvbnMgJ1wiK3UrXCInXCJ9KSk7dmFyIG49ZVswXSxyPWVbMV0sbz1lWzJdLGE9QmgodCxvLGYpLGk9e307cmV0dXJuIG51bGwhPWwmJihpPXtiaWFzOmZ1bmN0aW9uKCl7cmV0dXJuIFBoKHgsYSl9fSksT2JqZWN0LmFzc2lnbih7eDpmdW5jdGlvbigpe3JldHVybiAkYyhyLnNoYXBlLGEsbix3KX0sZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIFFjKHIsYSxuLnNoYXBlLHcpfX0saSl9KSxcIkZ1c2VkRGVwdGh3aXNlQ29udjJEXCIse2NvbnZJbmZvOncsYWN0aXZhdGlvbjpmfSxSLFshMF0pO3JldHVybiB5P0kuYXMzRChJLnNoYXBlWzFdLEkuc2hhcGVbMl0sSS5zaGFwZVszXSk6SX19KSx6aD1PYmplY3QuZnJlZXplKHttYXRNdWw6V2gsY29udjJkOlVoLGRlcHRod2lzZUNvbnYyZDpWaH0pLEdoPU9iamVjdC5mcmVlemUoe2ltYWdlOk9oLGxpbmFsZzpJaCxsb3NzZXM6Ymgsc3BlY3RyYWw6SmwsZnVzZWQ6emgsc2lnbmFsOnVoLHNxdWFyZTp0dSxzcXVhcmVkRGlmZmVyZW5jZTpudSxjb252MWQ6SGMsY29udjJkOnFjLGNvbnYzZDpLYyxkZXB0aHdpc2VDb252MmQ6WWMsc2VwYXJhYmxlQ29udjJkOkpjLGNvbnYyZFRyYW5zcG9zZTpaYyxjb252M2RUcmFuc3Bvc2U6dGwsb3A6QW4sYmF0Y2hOb3JtYWxpemF0aW9uMmQ6R3UsYmF0Y2hOb3JtYWxpemF0aW9uM2Q6SHUsYmF0Y2hOb3JtYWxpemF0aW9uNGQ6cXUsYmF0Y2hOb3JtYWxpemF0aW9uOkt1LGJhdGNoTm9ybTpqdSxiYXRjaE5vcm0yZDpYdSxiYXRjaE5vcm0zZDpZdSxiYXRjaE5vcm00ZDokdSxib29sZWFuTWFza0FzeW5jOlVjLGNvbXBsZXg6RG4scmVhbDpUbixpbWFnOk5uLGNvbmNhdDpZbixjb25jYXQxZDokbixjb25jYXQyZDpRbixjb25jYXQzZDpKbixjb25jYXQ0ZDpabixzcGxpdDp0cixtYXRNdWw6ZWwsZG90Om5sLG91dGVyUHJvZHVjdDpybCxyZXZlcnNlOm9sLHJldmVyc2UxZDphbCxyZXZlcnNlMmQ6aWwscmV2ZXJzZTNkOnNsLHJldmVyc2U0ZDp1bCxtYXhQb29sOmhsLGF2Z1Bvb2w6ZmwscG9vbDpkbCxtYXhQb29sM2Q6cGwsYXZnUG9vbDNkOnZsLHNsaWNlOm1sLHNsaWNlMWQ6Z2wsc2xpY2UyZDp5bCxzbGljZTNkOnhsLHNsaWNlNGQ6YmwsYWJzOnJ1LGFjb3M6b3UsYWNvc2g6YXUsYXNpbjppdSxhc2luaDpzdSxhdGFuOnV1LGF0YW5oOmN1LGNlaWw6bHUsY2xpcEJ5VmFsdWU6aHUsY29zOmZ1LGNvc2g6ZHUsZXJmOnB1LGV4cDp2dSxleHBtMTptdSxmbG9vcjpndSxsb2c6eXUsbG9nMXA6eHUsbG9nU2lnbW9pZDpidSxuZWc6d3UscmVjaXByb2NhbDpDdSxyb3VuZDpFdSxyc3FydDpSdSxzaWdtb2lkOkl1LHNpZ246a3UsaXNOYU46U3UsaXNJbmY6QXUsaXNGaW5pdGU6RHUsc2luOlR1LHNpbmg6TnUsc29mdHBsdXM6RnUsc3FydDpfdSxzdGVwOk91LHRhbjpNdSx0YW5oOkJ1LGFsbDpDbCxhbnk6RWwsYXJnTWF4OlJsLGFyZ01pbjpJbCxsb2dTdW1FeHA6a2wsbWF4OlNsLG1lYW46QWwsbWluOkRsLG1vbWVudHM6VGwsc3VtOk5sLHByb2Q6RmwsZXF1YWw6UmMsZXF1YWxTdHJpY3Q6SWMsZ3JlYXRlcjprYyxncmVhdGVyRXF1YWw6U2MsZ3JlYXRlckVxdWFsU3RyaWN0OkFjLGdyZWF0ZXJTdHJpY3Q6RGMsbGVzczpUYyxsZXNzRXF1YWw6TmMsbGVzc0VxdWFsU3RyaWN0OkZjLGxlc3NTdHJpY3Q6X2Msbm90RXF1YWw6T2Msbm90RXF1YWxTdHJpY3Q6TWMsYWRkOnJjLGFkZE46b2MsYWRkU3RyaWN0OmFjLGF0YW4yOmljLGRpdjpzYyxkaXZOb05hbjp1YyxkaXZTdHJpY3Q6Y2MsZmxvb3JEaXY6bGMsbWF4aW11bTpoYyxtYXhpbXVtU3RyaWN0OmZjLG1pbmltdW06ZGMsbWluaW11bVN0cmljdDpwYyxtb2Q6dmMsbW9kU3RyaWN0Om1jLG11bDpnYyxtdWxTdHJpY3Q6eWMscG93OnhjLHBvd1N0cmljdDpiYyxzcXVhcmVkRGlmZmVyZW5jZVN0cmljdDp3YyxzdWI6Q2Msc3ViU3RyaWN0OkVjLGVsdTpfbCxsZWFreVJlbHU6T2wscHJlbHU6TWwscmVsdTpCbCxyZWx1NjpQbCxzZWx1OkxsLGxvZ2ljYWxBbmQ6UXUsbG9naWNhbE5vdDpKdSxsb2dpY2FsT3I6WnUsbG9naWNhbFhvcjp0Yyx3aGVyZTplYyx3aGVyZUFzeW5jOm5jLGJ1ZmZlcjpkcixwcmludDpwcixiYXRjaFRvU3BhY2VORDp2cixicm9hZGNhc3RUbzptcixjYXN0OmdyLGNsb25lOnlyLGN1bXN1bTp4cixkZXB0aFRvU3BhY2U6YnIsZXhwYW5kRGltczp3cixleWU6Q3IsbXVsdGlub21pYWw6RXIsb25lSG90OlJyLHBhZDpJcixwYWQxZDprcixwYWQyZDpTcixwYWQzZDpBcixwYWQ0ZDpEcixyYW5kOlRyLHJhbmRvbU5vcm1hbDpOcixyYW5kb21HYW1tYTpGcixyYW5kb21Vbmlmb3JtOl9yLHJlc2hhcGU6T3Isc3BhY2VUb0JhdGNoTkQ6TXIsc3F1ZWV6ZTpCcixzdGFjazpQcix0aWxlOkxyLHRydW5jYXRlZE5vcm1hbDpXcix1bnN0YWNrOlVyLHNldGRpZmYxZEFzeW5jOlZyLGZpbGw6SG4sbGluc3BhY2U6cW4sb25lczp6bixyYW5nZTpLbixzY2FsYXI6T24sdGVuc29yOkZuLHRlbnNvcjFkOk1uLHRlbnNvcjJkOkJuLHRlbnNvcjNkOlBuLHRlbnNvcjRkOkxuLHRlbnNvcjVkOlduLHRlbnNvcjZkOlVuLHZhcmlhYmxlOlZuLHplcm9zOkduLG9uZXNMaWtlOmpuLHplcm9zTGlrZTpYbix0cmFuc3Bvc2U6V2wsc29mdG1heDpnbyxsb2dTb2Z0bWF4OnlvLGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOlVsLG5vcm06VmwsZ2F0aGVyOkxjLHVuc29ydGVkU2VnbWVudFN1bTpXYyxiYXNpY0xTVE1DZWxsOnpsLG11bHRpUk5OQ2VsbDpHbCxtb3ZpbmdBdmVyYWdlOkhsLHN0cmlkZWRTbGljZTpxbCx0b3BrOktsLHNjYXR0ZXJORDpqbCxmZnQ6WGwsaWZmdDpZbCxyZmZ0OiRsLGlyZmZ0OlFsLHNwYXJzZVRvRGVuc2U6WmwsZ2F0aGVyTkQ6dGgsZGlhZzplaCxkcm9wb3V0Om5oLGhhbm5XaW5kb3c6b2gsaGFtbWluZ1dpbmRvdzphaCxmcmFtZTppaCxzdGZ0OnNoLGluVG9wS0FzeW5jOmxofSk7ZnVuY3Rpb24gSGgodCxlKXtBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7bnVsbCE9dCYmQyhcImNvbXBsZXg2NFwiIT09dC5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm4gZStcIiBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCB0ZW5zb3JzLlwifSkpfSkpfWZ1bmN0aW9uIHFoKHQsZSxuLHIpe2lmKFwibGluZWFyXCI9PT1uKXJldHVybiB0LmxpbmVhcihlKTtpZihcInJlbHVcIj09PW4pcmV0dXJuIHQucmVsdShlKTtpZihcImVsdVwiPT09bilyZXR1cm4gdC5lbHUoZSk7aWYoXCJyZWx1NlwiPT09bilyZXR1cm4gdC5yZWx1NihlKTtpZihcInByZWx1XCI9PT1uKXJldHVybiB0LnByZWx1KGUscik7dGhyb3cgbmV3IEVycm9yKFwiQWN0aXZhdGlvbiBcIituK1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIENQVSBiYWNrZW5kLlwiKX12YXIgS2g9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbygpe3ZhciBlPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gZS5ibG9ja1NpemU9NDgsZS5maXJzdFVzZT0hMCxlLmRhdGE9bmV3IHhvKGUsTHQpLGV9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUsbil7dGhpcy5maXJzdFVzZSYmKHRoaXMuZmlyc3RVc2U9ITEsaSgpLmdldChcIklTX05PREVcIikmJmRuKFwiXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbkhpIHRoZXJlIPCfkYsuIExvb2tzIGxpa2UgeW91IGFyZSBydW5uaW5nIFRlbnNvckZsb3cuanMgaW4gTm9kZS5qcy4gVG8gc3BlZWQgdGhpbmdzIHVwIGRyYW1hdGljYWxseSwgaW5zdGFsbCBvdXIgbm9kZSBiYWNrZW5kLCB3aGljaCBiaW5kcyB0byBUZW5zb3JGbG93IEMrKywgYnkgcnVubmluZyBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUsIG9yIG5wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZS1ncHUgaWYgeW91IGhhdmUgQ1VEQS4gVGhlbiBjYWxsIHJlcXVpcmUoJ0B0ZW5zb3JmbG93L3RmanMtbm9kZScpOyAoLWdwdSBzdWZmaXggZm9yIENVREEpIGF0IHRoZSBzdGFydCBvZiB5b3VyIHByb2dyYW0uIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtbm9kZSBmb3IgbW9yZSBkZXRhaWxzLlxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIikpO3ZhciByPXt9O3JldHVybiB0aGlzLmRhdGEuc2V0KHIse3ZhbHVlczp0LGR0eXBlOm59KSxyfSxvLnByb3RvdHlwZS5tb3ZlPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuZGF0YS5zZXQodCx7dmFsdWVzOmUsZHR5cGU6cn0pfSxvLnByb3RvdHlwZS5udW1EYXRhSWRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YS5udW1EYXRhSWRzKCl9LG8ucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3JldHVyblsyLHRoaXMucmVhZFN5bmModCldfSkpfSkpfSxvLnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmRhdGEuZ2V0KHQpLG49ZS5kdHlwZSxyPWUuY29tcGxleFRlbnNvcnM7cmV0dXJuXCJjb21wbGV4NjRcIj09PW4/Vm8odGhpcy5yZWFkU3luYyhyLnJlYWwuZGF0YUlkKSx0aGlzLnJlYWRTeW5jKHIuaW1hZy5kYXRhSWQpKTp0aGlzLmRhdGEuZ2V0KHQpLnZhbHVlc30sby5wcm90b3R5cGUuYnVmZmVyU3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPWU7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpdHJ5e249ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBvdCh0KX0pKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIGVuY29kZWQgc3RyaW5nIGJ5dGVzIGludG8gdXRmLThcIil9cmV0dXJuIGRyKHQuc2hhcGUsdC5kdHlwZSxuKX0sby5wcm90b3R5cGUubWFrZU91dHB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy53cml0ZSh0LGUsbik7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKHIsZSxuLHRoaXMpfSxvLnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbih0KXtpZih0aGlzLmRhdGEuaGFzKHQpKXt2YXIgZT10aGlzLmRhdGEuZ2V0KHQpLmNvbXBsZXhUZW5zb3JzO251bGwhPWUmJihlLnJlYWwuZGlzcG9zZSgpLGUuaW1hZy5kaXNwb3NlKCkpLHRoaXMuZGF0YS5kZWxldGUodCl9fSxvLnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4gZT1ldCgpLHQoKSxbMix7a2VybmVsTXM6ZXQoKS1lfV19KSl9KSl9LG8ucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3JldHVybnt1bnJlbGlhYmxlOiEwLHJlYXNvbnM6W1wiVGhlIHJlcG9ydGVkIG1lbW9yeSBpcyBhbiB1cHBlciBib3VuZC4gRHVlIHRvIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb24sIHRoZSB0cnVlIGFsbG9jYXRlZCBtZW1vcnkgbWF5IGJlIGxlc3MuXCJdfX0sby5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubWFrZU91dHB1dChudWxsLHQuc2hhcGUsXCJjb21wbGV4NjRcIik7cmV0dXJuIHRoaXMuZGF0YS5nZXQobi5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzPXtyZWFsOkx0LmtlZXAodC5jbG9uZSgpKSxpbWFnOkx0LmtlZXAoZS5jbG9uZSgpKX0sbn0sby5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5jbG9uZSgpfSxvLnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5pbWFnLmNsb25lKCl9LG8ucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXtpZihIaCh0LFwic2xpY2VcIiksaW8odC5zaGFwZSxlLG4pKXt2YXIgcj1zbyhlLHQuc3RyaWRlcyksbz1rKG4pO3JldHVybiBGbih0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKS5zdWJhcnJheShyLHIrbyksbix0LmR0eXBlKX1mb3IodmFyIGE9ZHIobix0LmR0eXBlKSxpPXRoaXMuYnVmZmVyU3luYyh0KSxzPTA7czxhLnNpemU7KytzKXt2YXIgdT1hLmluZGV4VG9Mb2MocykubWFwKChmdW5jdGlvbih0LG4pe3JldHVybiB0K2Vbbl19KSk7YS52YWx1ZXNbc109aS5nZXQuYXBwbHkoaSx1KX1yZXR1cm4gYS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scil7SGgodCxcInN0cmlkZWRTbGljZVwiKTt2YXIgbz1ybyhlLG4scik7aWYoby5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gMD09PXR9KSkpcmV0dXJuIEZuKFtdLG8pO2Zvcih2YXIgYT1kcihvLHQuZHR5cGUpLGk9dGhpcy5idWZmZXJTeW5jKHQpLHM9MDtzPGEuc2l6ZTtzKyspe2Zvcih2YXIgdT1hLmluZGV4VG9Mb2MocyksYz1uZXcgQXJyYXkodS5sZW5ndGgpLGw9MDtsPGMubGVuZ3RoO2wrKyljW2xdPXVbbF0qcltsXStlW2xdO2Euc2V0LmFwcGx5KGEsW2kuZ2V0LmFwcGx5KGksYyldLmNvbmNhdCh1KSl9cmV0dXJuIGEudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZGlhZz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1kcihbdC5zaXplLHQuc2l6ZV0sdC5kdHlwZSkscj1uLnZhbHVlcyxvPTA7bzxlLmxlbmd0aDtvKyspcltvKnQuc2l6ZStvXT1lW29dO3JldHVybiBuLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5zaGFwZVtlXSxyPW5ldyBBcnJheSh0LnJhbmstMSksbz0wLGE9MDthPHQucmFuazthKyspYSE9PWUmJihyW28rK109dC5zaGFwZVthXSk7dmFyIGk9bmV3IEFycmF5KHQucmFuaykuZmlsbCgwKSxzPXQuc2hhcGUuc2xpY2UoKTtzW2VdPTE7dmFyIHU9bmV3IEFycmF5KG4pO2ZvcihhPTA7YTx1Lmxlbmd0aDthKyspaVtlXT1hLHVbYV09dGhpcy5zbGljZSh0LGkscykucmVzaGFwZShyKTtyZXR1cm4gdX0sby5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0LGUpe0hoKHQsXCJyZXZlcnNlXCIpO2Zvcih2YXIgbj1kcih0LnNoYXBlLHQuZHR5cGUpLHI9dGhpcy5idWZmZXJTeW5jKHQpLG89ZnVuY3Rpb24obyl7dmFyIGE9bi5pbmRleFRvTG9jKG8pLGk9YS5zbGljZSgpO2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGlbZV09dC5zaGFwZVtlXS0xLWlbZV19KSksbi5zZXQuYXBwbHkobixbci5nZXQuYXBwbHkocixpKV0uY29uY2F0KGEpKX0sYT0wO2E8bi5zaXplO2ErKylvKGEpO3JldHVybiBuLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7aWYoXCJjb21wbGV4NjRcIj09PXRbMF0uZHR5cGUpe3ZhciByPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gVG4odCl9KSksbz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIE5uKHQpfSkpO3JldHVybiBEbih0aGlzLmNvbmNhdChyLGUpLHRoaXMuY29uY2F0KG8sZSkpfXZhciBhPXQubWFwKChmdW5jdGlvbih0KXt2YXIgbj1rKHQuc2hhcGUuc2xpY2UoZSkpO3JldHVybiB0LmFzMkQoLTEsbil9KSksaT1TbihhLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksMSkscz1kcihpLHRbMF0uZHR5cGUpLnZhbHVlcztpZigxPT09YVswXS5zaGFwZVswXSl7dmFyIHU9MDthLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Muc2V0KG4ucmVhZFN5bmModC5kYXRhSWQpLHUpLHUrPXQuc2l6ZX0pKX1lbHNle3ZhciBjPTA7YS5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGU9bi5yZWFkU3luYyh0LmRhdGFJZCkscj0wLG89MDtvPHQuc2hhcGVbMF07KytvKWZvcih2YXIgYT1vKmlbMV0rYyx1PTA7dTx0LnNoYXBlWzFdOysrdSlzW2ErdV09ZVtyKytdO2MrPXQuc2hhcGVbMV19KSl9dmFyIGw9U24odC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLGUpO3JldHVybiBGbihzLGwsdFswXS5kdHlwZSl9LG8ucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXtyZXR1cm4gSGgodCxcIm5lZ1wiKSx0aGlzLm11bHRpcGx5KE9uKC0xKSx0KX0sby5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSwoZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dCtuLGltYWc6ZStyfX0pKTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLER0KHQuZHR5cGUsZS5kdHlwZSksKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0pKX0sby5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXt2YXIgZT10aGlzO0hoKHQsXCJhZGROXCIpO2Zvcih2YXIgbj10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUucmVhZFN5bmModC5kYXRhSWQpfSkpLHI9ZHIodFswXS5zaGFwZSx0WzBdLmR0eXBlKSxvPXIudmFsdWVzLGE9MDthPHQubGVuZ3RoO2ErKylmb3IodmFyIGk9blthXSxzPTA7czxvLmxlbmd0aDtzKyspb1tzXSs9aVtzXTtyZXR1cm4gci50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQsZSl7dmFyIG49TyhbZV0sdC5zaGFwZSkscj10aGlzLm1heCh0LG4pLG89d24oci5zaGFwZSxuKSxhPXRoaXMuc3VidHJhY3QodCxyLnJlc2hhcGUobykpLGk9dGhpcy5leHAoYSkscz10aGlzLnN1bShpLG4pLnJlc2hhcGUobyk7cmV0dXJuIHRoaXMucmVhbERpdmlkZShpLHMpfSxvLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVyblwiY29tcGxleDY0XCI9PT10LmR0eXBlfHxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKHQuY2FzdChcImNvbXBsZXg2NFwiKSxlLmNhc3QoXCJjb21wbGV4NjRcIiksKGZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybntyZWFsOnQtbixpbWFnOmUtcn19KSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxEdCh0LmR0eXBlLGUuZHR5cGUpLChmdW5jdGlvbih0LGUpe3JldHVybiB0LWV9KSl9LG8ucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcInBvd1wiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGgucG93KHQsZSl9KSl9LG8ucHJvdG90eXBlLmJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIpe0hoKFt0LGVdLFwibWF0TXVsXCIpO2Zvcih2YXIgbz1uP3Quc2hhcGVbMV06dC5zaGFwZVsyXSxhPW4/dC5zaGFwZVsyXTp0LnNoYXBlWzFdLGk9cj9lLnNoYXBlWzFdOmUuc2hhcGVbMl0scz10LnNoYXBlWzBdLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxsPW4/W3Quc3RyaWRlc1swXSwxLHQuc3RyaWRlc1sxXV06W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV0sMV0saD1sWzBdLGY9bFsxXSxkPWxbMl0scD1yP1sxLGUuc3RyaWRlc1sxXSxlLnN0cmlkZXNbMF1dOltlLnN0cmlkZXNbMV0sMSxlLnN0cmlkZXNbMF1dLHY9cFswXSxtPXBbMV0sZz1wWzJdLHk9YSppLHg9ZHIoW3MsYSxpXSx0LmR0eXBlKSxiPXgudmFsdWVzLHc9dGhpcy5ibG9ja1NpemUsQz0wO0M8cztDKyspZm9yKHZhciBFPTA7RTxhO0UrPXcpZm9yKHZhciBSPTA7UjxpO1IrPXcpZm9yKHZhciBJPTA7STxvO0krPXcpZm9yKHZhciBrPU1hdGgubWluKEUrdyxhKSxTPU1hdGgubWluKFIrdyxpKSxBPU1hdGgubWluKEkrdyxvKSxEPUU7RDxrO0QrKylmb3IodmFyIFQ9UjtUPFM7VCsrKXtmb3IodmFyIE49MCxGPUk7RjxBO0YrKylOKz11W0MqaCtEKmYrRipkXSpjW0YqditUKm0rQypnXTtiW0MqeSsoRCppK1QpXSs9Tn1yZXR1cm4geC50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5mdXNlZEJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQpe3ZhciBlPXQuYSxuPXQuYixyPXQudHJhbnNwb3NlQSxvPXQudHJhbnNwb3NlQixhPXQuYmlhcyxpPXQuYWN0aXZhdGlvbixzPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyx1PXRoaXMuYmF0Y2hNYXRNdWwoZSxuLHIsbyk7cmV0dXJuIGEmJih1PXRoaXMuYWRkKHUsYSkpLGkmJih1PXFoKHRoaXMsdSxpLHMpKSx1fSxvLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0LGUpe3JldHVyblwiY29tcGxleDY0XCI9PT10LmR0eXBlfHxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKHQuY2FzdChcImNvbXBsZXg2NFwiKSxlLmNhc3QoXCJjb21wbGV4NjRcIiksKGZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybntyZWFsOnQqbi1lKnIsaW1hZzp0KnIrZSpufX0pKTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLER0KHQuZHR5cGUsZS5kdHlwZSksKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKX0sby5wcm90b3R5cGUucmVhbERpdmlkZT1mdW5jdGlvbih0LGUpe0hoKFt0LGVdLFwicmVhbERpdmlkZVwiKTtyZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImZsb2F0MzJcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC9lfSkpfSxvLnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0LGUpe0hoKFt0LGVdLFwiZmxvb3JEaXZcIik7cmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJpbnQzMlwiLChmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLmZsb29yKHQvZSl9KSl9LG8ucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe0hoKHQsXCJzdW1cIiksQ24oXCJzdW1cIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsRHQodC5kdHlwZSxcImludDMyXCIpKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPTAsZj0wO2Y8aTsrK2YpaCs9dVtsK2ZdO3NbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe0hoKHQsXCJzdW1cIik7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsRHQodC5kdHlwZSxcImludDMyXCIpKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPTEsZj0wO2Y8aTsrK2YpaCo9dVtsK2ZdO3NbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXtIaCh0LFwidW5zb3J0ZWRTZWdtZW50U3VtXCIpO2Zvcih2YXIgcj1bXSxvPXQucmFuay1lLnJhbmssYT0wO2E8bzsrK2EpZT1lLmV4cGFuZERpbXMoYSsxKTtmb3IoYT0wO2E8bjsrK2Epe3ZhciBpPU9uKGEsXCJpbnQzMlwiKSxzPVJjKGksZSkuYXNUeXBlKFwiZmxvYXQzMlwiKS5tdWwodCkuc3VtKDApO3IucHVzaChzKX1yZXR1cm4gUHIocil9LG8ucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe0hoKHQsXCJhcmdNaW5cIik7dmFyIG49W2VdO0NuKFwiYXJnTWluXCIsbix0LnJhbmspO2Zvcih2YXIgcj1ibih0LnNoYXBlLG4pLG89clswXSxhPXJbMV0saT1HbihvLFwiaW50MzJcIikscz1rKGEpLHU9dGhpcy5yZWFkU3luYyhpLmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxsPTA7bDx1Lmxlbmd0aDsrK2wpe2Zvcih2YXIgaD1sKnMsZj1jW2hdLGQ9MCxwPTA7cDxzOysrcCl7dmFyIHY9Y1toK3BdO3Y8ZiYmKGY9dixkPXApfXVbbF09ZH1yZXR1cm4gaX0sby5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7SGgodCxcImFyZ01heFwiKTt2YXIgbj1bZV07Q24oXCJhcmdNYXhcIixuLHQucmFuayk7Zm9yKHZhciByPWJuKHQuc2hhcGUsbiksbz1yWzBdLGE9clsxXSxpPUduKG8sXCJpbnQzMlwiKSxzPWsoYSksdT10aGlzLnJlYWRTeW5jKGkuZGF0YUlkKSxjPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGw9MDtsPHUubGVuZ3RoOysrbCl7Zm9yKHZhciBoPWwqcyxmPWNbaF0sZD0wLHA9MDtwPHM7KytwKXt2YXIgdj1jW2grcF07dj5mJiYoZj12LGQ9cCl9dVtsXT1kfXJldHVybiBpfSxvLnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7aWYoSGgodCxcImN1bXN1bVwiKSxlIT09dC5yYW5rLTEpdGhyb3cgbmV3IEVycm9yKFwiYmFja2VuZC5jdW1zdW0gaW4gQ1BVIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiKyh0LnJhbmstMSkrXCIgYnV0IGdvdCBheGlzPVwiK2UpO2Zvcih2YXIgbz1EdCh0LmR0eXBlLFwiaW50MzJcIiksYT1Hbih0LnNoYXBlLG8pLGk9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCkscz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx1PXQuc2hhcGVbdC5yYW5rLTFdLGM9cj9mdW5jdGlvbih0LGUpe3JldHVybiB0K3UtZS0xfTpmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9LGw9MDtsPHMubGVuZ3RoO2wrPXUpZm9yKHZhciBoPTA7aDx1O2grKyl7dmFyIGY9YyhsLGgpO2lmKDA9PT1oKWlbZl09bj8wOnNbZl07ZWxzZXt2YXIgZD1jKGwsaC0xKTtpW2ZdPW4/c1tkXStpW2RdOnNbZl0raVtkXX19cmV0dXJuIGF9LG8ucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwiZXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWU/MTowfSkpfSxvLnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcIm5vdEVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQhPT1lPzE6MH0pKX0sby5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImxlc3NcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdDxlPzE6MH0pKX0sby5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibGVzc0VxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8PWU/MTowfSkpfSxvLnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwiZ3JlYXRlclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0PmU/MTowfSkpfSxvLnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJncmVhdGVyRXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD49ZT8xOjB9KSl9LG8ucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7SGgodCxcImxvZ2ljYWxOb3RcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPWVbcl0/MDoxO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImxvZ2ljYWxBbmRcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmZX0pKX0sby5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibG9naWNhbE9yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR8fGV9KSl9LG8ucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZSxuXSxcInNlbGVjdFwiKTtmb3IodmFyIHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxhPXRoaXMucmVhZFN5bmMobi5kYXRhSWQpLGk9R24oZS5zaGFwZSxEdChlLmR0eXBlLG4uZHR5cGUpKSxzPXRoaXMucmVhZFN5bmMoaS5kYXRhSWQpLHU9MCxjPTA9PT10LnJhbmt8fHQucmFuaz4xfHwxPT09ZS5yYW5rPzE6ayhlLnNoYXBlLnNsaWNlKDEpKSxsPTA7bDxyLmxlbmd0aDtsKyspZm9yKHZhciBoPTA7aDxjO2grKykxPT09cltsXT9zW3UrK109b1tsXTpzW3UrK109YVtsXTtyZXR1cm4gaX0sby5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7SGgoW3RdLFwid2hlcmVcIik7dmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCk7cmV0dXJuIG5hKHQuc2hhcGUsZSl9LG8ucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBIaCh0LFwidG9wa1wiKSxlYSh0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx0LnNoYXBlLHQuZHR5cGUsZSl9LG8ucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe0hoKHQsXCJtaW5cIiksQ24oXCJtaW5cIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsdC5kdHlwZSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD11W2xdLGY9MDtmPGk7KytmKXt2YXIgZD11W2wrZl07ZDxoJiYoaD1kKX1zW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJtaW5pbXVtXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5taW4odCxlKX0pKX0sby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibW9kXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXt2YXIgbj10JWU7cmV0dXJuIHQ8MCYmZTwwfHx0Pj0wJiZlPj0wP246KG4rZSklZX0pKX0sby5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7SGgodCxcIm1heFwiKSxDbihcIm1heFwiLGUsdC5yYW5rKTtmb3IodmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9R24ocix0LmR0eXBlKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPXVbbF0sZj0wO2Y8aTsrK2Ype3ZhciBkPXVbbCtmXTtkPmgmJihoPWQpfXNbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcIm1heGltdW1cIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLm1heCh0LGUpfSkpfSxvLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtIaCh0LFwiYWxsXCIpLENuKFwiYWxsXCIsZSx0LnJhbmspO2Zvcih2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1HbihyLHQuZHR5cGUpLGk9ayhvKSxzPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz0wO2M8cy5sZW5ndGg7KytjKXtmb3IodmFyIGw9YyppLGg9dVtsXSxmPTA7ZjxpOysrZil7dmFyIGQ9dVtsK2ZdO2g9aCYmZH1zW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe0hoKHQsXCJhbnlcIiksQ24oXCJhbnlcIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsdC5kdHlwZSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD11W2xdLGY9MDtmPGk7KytmKXt2YXIgZD11W2wrZl07aD1ofHxkfXNbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJzcXVhcmVkRGlmZmVyZW5jZVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC1lO3JldHVybiBuKm59KSl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24odCl7SGgodCxcImNlaWxcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5jZWlsKGVbcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24odCl7SGgodCxcImZsb29yXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZmxvb3IoZVtyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe0hoKHQsXCJ4XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcillW3JdPDA/bltyXT0tMTplW3JdPjA/bltyXT0xOm5bcl09MDtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKHQpe0hoKHQsXCJ4XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTnVtYmVyLmlzTmFOKGVbcl0pJiYobltyXT0xKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe0hoKHQsXCJ4XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTWF0aC5hYnMoZVtyXSk9PT0xLzAmJihuW3JdPTEpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24odCl7SGgodCxcInhcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcilOdW1iZXIuaXNGaW5pdGUoZVtyXSkmJihuW3JdPTEpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiYm9vbFwiKX0sby5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7SGgodCxcInJvdW5kXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89TWF0aC5mbG9vcihlW3JdKTtlW3JdLW88LjU/bltyXT1NYXRoLmZsb29yKGVbcl0pOmVbcl0tbz4uNT9uW3JdPU1hdGguY2VpbChlW3JdKTpuW3JdPW8lMj09MD9vOm8rMX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXtIaCh0LFwiZXhwXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZXhwKGVbcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24odCl7SGgodCxcImV4cG0xXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZXhwbTEoZVtyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24odCl7SGgodCxcImxvZ1wiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLmxvZyhvKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe0hoKHQsXCJsb2cxcFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLmxvZzFwKG8pfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc3FydD1mdW5jdGlvbih0KXtIaCh0LFwic3FydFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLnNxcnQobyl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXtIaCh0LFwicnNxcnRcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09MS9NYXRoLnNxcnQobyl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe0hoKHQsXCJyZWNpcHJvY2FsXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPTEvZVtyXTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmxpbmVhcj1mdW5jdGlvbih0KXtyZXR1cm4gdH0sby5wcm90b3R5cGUucmVsdT1mdW5jdGlvbih0KXtIaCh0LFwicmVsdVwiKTtmb3IodmFyIGU9R24odC5zaGFwZSx0LmR0eXBlKSxuPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz0wO288ci5sZW5ndGg7KytvKW5bb109TWF0aC5tYXgoMCxyW29dKTtyZXR1cm4gZX0sby5wcm90b3R5cGUucmVsdTY9ZnVuY3Rpb24odCl7SGgodCxcInJlbHVcIik7Zm9yKHZhciBlPUduKHQuc2hhcGUsdC5kdHlwZSksbj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxyPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89MDtvPHIubGVuZ3RoOysrbyluW29dPU1hdGgubWluKE1hdGgubWF4KDAscltvXSksNik7cmV0dXJuIGV9LG8ucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwicHJlbHVcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3JldHVybiB0PDA/ZSp0OnR9KSl9LG8ucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXtIaCh0LFwiZWx1XCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3Ipe3ZhciBvPW5bcl07ZVtyXT1vPj0wP286TWF0aC5leHAobyktMX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe0hoKFt0LGVdLFwiZWx1RGVyXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxvPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGE9MDthPHIubGVuZ3RoOysrYSl7dmFyIGk9clthXTtuW2FdPWk+PTE/b1thXTpvW2FdKihpKzEpfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobixlLnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXtIaCh0LFwic2VsdVwiKTtmb3IodmFyIGU9YnMsbj13cyxyPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxvPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGk9b1thXTtyW2FdPWk+PTA/bippOmUqKE1hdGguZXhwKGkpLTEpfXJldHVybiB0aGlzLm1ha2VPdXRwdXQocix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbih0LGUsbil7SGgodCxcImNsaXBcIik7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxvPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGk9b1thXTtyW2FdPWk+bj9uOmk8ZT9lOml9cmV0dXJuIHRoaXMubWFrZU91dHB1dChyLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYWJzKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8dC5zaXplOysrcil7dmFyIG89blsyKnJdLGE9blsyKnIrMV07ZVtyXT1NYXRoLmh5cG90KG8sYSl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7SGgodCxcImludFwiKTtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPW5bcl07cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJpbnQzMlwiKX0sby5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXtIaCh0LFwic2lnbW9pZFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09MS8oMStNYXRoLmV4cCgtbltyXSkpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7SGgodCxcInNvZnRwbHVzXCIpO2Zvcih2YXIgZT1NYXRoLmxvZygxLjE5MjA5Mjg5NTUwNzgxMjVlLTcpKzIsbj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSkscj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPTA7bzxyLmxlbmd0aDsrK28pe3ZhciBhPXJbb10+LWUsaT1yW29dPGUscz1NYXRoLmV4cChyW29dKSx1PXZvaWQgMDt1PWk/czphP3Jbb106TWF0aC5sb2coMStzKSxuW29dPXV9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zaW49ZnVuY3Rpb24odCl7SGgodCxcInNpblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5zaW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24odCl7SGgodCxcImNvc1wiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5jb3MobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS50YW49ZnVuY3Rpb24odCl7SGgodCxcInRhblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC50YW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe0hoKHQsXCJhc2luXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFzaW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKHQpe0hoKHQsXCJhY29zXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFjb3MobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe0hoKHQsXCJhdGFuXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmF0YW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImF0YW4yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5hdGFuMih0LGUpfSkpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe0hoKHQsXCJzaW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLnNpbmgobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe0hoKHQsXCJjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmNvc2gobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe0hoKHQsXCJ0YW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1EKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7SGgodCxcImFzaW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFzaW5oKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24odCl7SGgodCxcImFjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFjb3NoKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7SGgodCxcImF0YW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmF0YW5oKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe0hoKHQsXCJlcmZcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcil7dmFyIG89TWF0aC5zaWduKG5bcl0pLGE9TWF0aC5hYnMobltyXSksaT0xLygxKy4zMjc1OTExKmEpO2Vbcl09byooMS0oKCgoMS4wNjE0MDU0MjkqaS0xLjQ1MzE1MjAyNykqaSsxLjQyMTQxMzc0MSkqaS0uMjg0NDk2NzM2KSppKy4yNTQ4Mjk1OTIpKmkqTWF0aC5leHAoLWEqYSkpfXJldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLEhoKHQsXCJzdGVwXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSkscj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPTA7bzxyLmxlbmd0aDsrK28pe3ZhciBhPXJbb107aXNOYU4oYSk/bltvXT1OYU46bltvXT1hPjA/MTplfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZnVzZWRDb252MmQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dCxuPXQuZmlsdGVyLHI9dC5jb252SW5mbyxvPXQuYmlhcyxhPXQuYWN0aXZhdGlvbixpPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxzPXRoaXMuY29udjJkKGUsbixyKTtyZXR1cm4gbyYmKHM9dGhpcy5hZGQocyxvKSksYSYmKHM9cWgodGhpcyxzLGEsaSkpLHN9LG8ucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJjb252MmRcIik7Zm9yKHZhciByPW4uZmlsdGVySGVpZ2h0LG89bi5maWx0ZXJXaWR0aCxhPW4uZGlsYXRpb25IZWlnaHQsaT1uLmRpbGF0aW9uV2lkdGgscz1uLnBhZEluZm8ubGVmdCx1PW4ucGFkSW5mby50b3AsYz1cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0LGw9ZHIobi5vdXRTaGFwZSx0LmR0eXBlKSxoPXQuc3RyaWRlc1swXSxmPWM/dC5zdHJpZGVzWzFdOnQuc3RyaWRlc1syXSxkPWM/dC5zdHJpZGVzWzJdOjEscD1jPzE6dC5zdHJpZGVzWzFdLHY9bC5zdHJpZGVzWzBdLG09Yz9sLnN0cmlkZXNbMV06bC5zdHJpZGVzWzJdLGc9Yz9sLnN0cmlkZXNbMl06MSx5PWM/MTpsLnN0cmlkZXNbMV0seD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxiPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHc9bC52YWx1ZXMsQz0wO0M8bi5iYXRjaFNpemU7KytDKWZvcih2YXIgRT1DKmgsUj1DKnYsST0wO0k8bi5vdXRIZWlnaHQ7KytJKWZvcih2YXIgaz1SK0kqbSxTPUkqbi5zdHJpZGVIZWlnaHQtdSxBPTA7QTxyO0ErKyl7dmFyIEQ9UytBKmE7aWYoIShEPDB8fEQ+PW4uaW5IZWlnaHQpKWZvcih2YXIgVD1BKmUuc3RyaWRlc1swXSxOPUUrRCpmLEY9MDtGPG4ub3V0V2lkdGg7KytGKWZvcih2YXIgXz1rK0YqZyxPPUYqbi5zdHJpZGVXaWR0aC1zLE09MDtNPG87TSsrKXt2YXIgQj1PK00qaTtpZighKEI8MHx8Qj49bi5pbldpZHRoKSlmb3IodmFyIFA9TitCKmQsTD1UK00qZS5zdHJpZGVzWzFdLFc9MDtXPG4uaW5DaGFubmVsczsrK1cpe2Zvcih2YXIgVT14W1ArVypwXSxWPTA7VjxuLm91dENoYW5uZWxzOysrVil3W18rVip5XSs9VSpiW0wrVl07TCs9bi5vdXRDaGFubmVsc319fXJldHVybiBsLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYzZD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPW4uZmlsdGVyRGVwdGgsbz1uLmZpbHRlckhlaWdodCxhPW4uZmlsdGVyV2lkdGgsaT1uLmRpbGF0aW9uRGVwdGgscz1uLmRpbGF0aW9uSGVpZ2h0LHU9bi5kaWxhdGlvbldpZHRoLGM9bi5wYWRJbmZvLmZyb250LGw9bi5wYWRJbmZvLmxlZnQsaD1uLnBhZEluZm8udG9wLGY9ZHIobi5vdXRTaGFwZSx0LmR0eXBlKSxkPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHA9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdj1mLnZhbHVlcyxtPTA7bTxuLmJhdGNoU2l6ZTsrK20pZm9yKHZhciBnPW0qdC5zdHJpZGVzWzBdLHk9bSpmLnN0cmlkZXNbMF0seD0wO3g8bi5vdXREZXB0aDsrK3gpZm9yKHZhciBiPXkreCpmLnN0cmlkZXNbMV0sdz14Km4uc3RyaWRlRGVwdGgtYyxDPTA7QzxyO0MrKyl7dmFyIEU9dytDKmk7aWYoIShFPDB8fEU+PW4uaW5EZXB0aCkpZm9yKHZhciBSPUMqZS5zdHJpZGVzWzBdLEk9ZytFKnQuc3RyaWRlc1sxXSxrPTA7azxuLm91dEhlaWdodDsrK2spZm9yKHZhciBTPWIraypmLnN0cmlkZXNbMl0sQT1rKm4uc3RyaWRlSGVpZ2h0LWgsRD0wO0Q8bztEKyspe3ZhciBUPUErRCpzO2lmKCEoVDwwfHxUPj1uLmluSGVpZ2h0KSlmb3IodmFyIE49UitEKmUuc3RyaWRlc1sxXSxGPUkrVCp0LnN0cmlkZXNbMl0sXz0wO188bi5vdXRXaWR0aDsrK18pZm9yKHZhciBPPVMrXypuLm91dENoYW5uZWxzLE09XypuLnN0cmlkZVdpZHRoLWwsQj0wO0I8YTtCKyspe3ZhciBQPU0rQip1O2lmKCEoUDwwfHxQPj1uLmluV2lkdGgpKWZvcih2YXIgTD1OK0IqZS5zdHJpZGVzWzJdLFc9RitQKm4uaW5DaGFubmVscyxVPUwsVj0wO1Y8bi5pbkNoYW5uZWxzOysrVil7Zm9yKHZhciB6PWRbVytWXSxHPTA7RzxuLm91dENoYW5uZWxzOysrRyl2W08rR10rPXoqcFtVK0ddO1UrPW4ub3V0Q2hhbm5lbHN9fX19cmV0dXJuIGYudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiY29udjJkRGVySW5wdXRcIik7Zm9yKHZhciByPWRyKG4uaW5TaGFwZSxcImZsb2F0MzJcIiksbz1yLnZhbHVlcyxhPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGk9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCkscz1lLnN0cmlkZXMsdT1zWzBdLGM9c1sxXSxsPXNbMl0saD1uLmJhdGNoU2l6ZSxmPW4uZmlsdGVySGVpZ2h0LGQ9bi5maWx0ZXJXaWR0aCxwPW4uaW5DaGFubmVscyx2PW4uaW5IZWlnaHQsbT1uLmluV2lkdGgsZz1uLm91dENoYW5uZWxzLHk9bi5vdXRIZWlnaHQseD1uLm91dFdpZHRoLGI9bi5zdHJpZGVIZWlnaHQsdz1uLnN0cmlkZVdpZHRoLEM9bi5kYXRhRm9ybWF0LEU9Zi0xLW4ucGFkSW5mby50b3AsUj1kLTEtbi5wYWRJbmZvLmxlZnQsST1cImNoYW5uZWxzTGFzdFwiPT09QyxrPXIuc3RyaWRlc1swXSxTPUk/ci5zdHJpZGVzWzFdOnIuc3RyaWRlc1syXSxBPUk/ci5zdHJpZGVzWzJdOjEsRD1JPzE6ci5zdHJpZGVzWzFdLFQ9dC5zdHJpZGVzWzBdLE49ST90LnN0cmlkZXNbMV06dC5zdHJpZGVzWzJdLEY9ST90LnN0cmlkZXNbMl06MSxfPUk/MTp0LnN0cmlkZXNbMV0sTz0wO088aDsrK08pZm9yKHZhciBNPTA7TTxwOysrTSlmb3IodmFyIEI9MDtCPHY7KytCKWZvcih2YXIgUD1CLUUsTD1NYXRoLm1heCgwLE1hdGguY2VpbChQL2IpKSxXPU1hdGgubWluKHksKGYrUCkvYiksVT0wO1U8bTsrK1Upe2Zvcih2YXIgVj1VLVIsej1NYXRoLm1heCgwLE1hdGguY2VpbChWL3cpKSxHPU1hdGgubWluKHgsKGQrVikvdyksSD0wLHE9TDtxPFc7KytxKWZvcih2YXIgSz1xKmItUCxqPXo7ajxHOysrailmb3IodmFyIFg9VCpPK04qcStGKmosWT11KihmLTEtSykrYyooZC0xLShqKnctVikpK2wqTSwkPTA7JDxnOysrJCl7SCs9YVtYK18qJF0qaVtZKyRdfW9baypPK1MqQitBKlUrRCpNXT1IfXJldHVybiByLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYzZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9ZHIobi5pblNoYXBlLFwiZmxvYXQzMlwiKSxvPXIudmFsdWVzLGE9ci5zdHJpZGVzLGk9YVswXSxzPWFbMV0sdT1hWzJdLGM9YVszXSxsPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGg9dC5zdHJpZGVzLGY9aFswXSxkPWhbMV0scD1oWzJdLHY9aFszXSxtPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGc9ZS5zdHJpZGVzLHk9Z1swXSx4PWdbMV0sYj1nWzJdLHc9Z1szXSxDPW4uYmF0Y2hTaXplLEU9bi5maWx0ZXJEZXB0aCxSPW4uZmlsdGVySGVpZ2h0LEk9bi5maWx0ZXJXaWR0aCxrPW4uaW5DaGFubmVscyxTPW4uaW5EZXB0aCxBPW4uaW5IZWlnaHQsRD1uLmluV2lkdGgsVD1uLm91dENoYW5uZWxzLE49bi5vdXREZXB0aCxGPW4ub3V0SGVpZ2h0LF89bi5vdXRXaWR0aCxPPW4uc3RyaWRlRGVwdGgsTT1uLnN0cmlkZUhlaWdodCxCPW4uc3RyaWRlV2lkdGgsUD1FLTEtbi5wYWRJbmZvLmZyb250LEw9Ui0xLW4ucGFkSW5mby50b3AsVz1JLTEtbi5wYWRJbmZvLmxlZnQsVT0wO1U8QzsrK1UpZm9yKHZhciBWPTA7VjxrOysrVilmb3IodmFyIHo9MDt6PFM7Kyt6KWZvcih2YXIgRz16LVAsSD1NYXRoLm1heCgwLE1hdGguY2VpbChHL08pKSxxPU1hdGgubWluKE4sKEUrRykvTyksSz0wO0s8QTsrK0spZm9yKHZhciBqPUstTCxYPU1hdGgubWF4KDAsTWF0aC5jZWlsKGovTSkpLFk9TWF0aC5taW4oRiwoUitqKS9NKSwkPTA7JDxEOysrJCl7Zm9yKHZhciBRPSQtVyxKPU1hdGgubWF4KDAsTWF0aC5jZWlsKFEvQikpLFo9TWF0aC5taW4oXywoSStRKS9CKSx0dD0wLGV0PUg7ZXQ8cTsrK2V0KWZvcih2YXIgbnQ9ZXQqTy1HLHJ0PVg7cnQ8WTsrK3J0KWZvcih2YXIgb3Q9cnQqTS1qLGF0PUo7YXQ8WjsrK2F0KWZvcih2YXIgaXQ9ZipVK2QqZXQrcCpydCt2KmF0LHN0PXkqKEUtMS1udCkreCooUi0xLW90KStiKihJLTEtKGF0KkItUSkpK3cqVix1dD0wO3V0PFQ7Kyt1dCl7dHQrPWxbaXQrdXRdKm1bc3QrdXRdfW9baSpVK3Mqeit1KksrYyokK1ZdPXR0fXJldHVybiByLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJjb252MmREZXJGaWx0ZXJcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPVwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQsdT1kcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSxjPW4ucGFkSW5mby5sZWZ0LGw9bi5wYWRJbmZvLnRvcCxoPXRoaXMuYnVmZmVyU3luYyh0KSxmPXRoaXMuYnVmZmVyU3luYyhlKSxkPTA7ZDxhOysrZClmb3IodmFyIHA9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGwtZCkvcikpLHY9TWF0aC5taW4obi5vdXRIZWlnaHQsKG4uaW5IZWlnaHQrbC1kKS9yKSxtPTA7bTxpOysrbSlmb3IodmFyIGc9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGMtbSkvbykpLHk9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK2MtbSkvbykseD0wO3g8bi5pbkNoYW5uZWxzOysreClmb3IodmFyIGI9MDtiPG4ub3V0Q2hhbm5lbHM7KytiKXtmb3IodmFyIHc9MCxDPTA7QzxuLmJhdGNoU2l6ZTsrK0MpZm9yKHZhciBFPXA7RTx2OysrRSlmb3IodmFyIFI9ZCtFKnItbCxJPWc7STx5OysrSSl7dmFyIGs9bStJKm8tYzt3Kz1zP2guZ2V0KEMsUixrLHgpKmYuZ2V0KEMsRSxJLGIpOmguZ2V0KEMseCxSLGspKmYuZ2V0KEMsYixFLEkpfXUuc2V0KHcsZCxtLHgsYil9cmV0dXJuIHUudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29udjNkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9bi5zdHJpZGVEZXB0aCxvPW4uc3RyaWRlSGVpZ2h0LGE9bi5zdHJpZGVXaWR0aCxpPW4uZmlsdGVyRGVwdGgscz1uLmZpbHRlckhlaWdodCx1PW4uZmlsdGVyV2lkdGgsYz1kcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSxsPWMudmFsdWVzLGg9Yy5zdHJpZGVzLGY9aFswXSxkPWhbMV0scD1oWzJdLHY9aFszXSxtPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGc9ZS5zdHJpZGVzLHk9Z1swXSx4PWdbMV0sYj1nWzJdLHc9Z1szXSxDPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLEU9dC5zdHJpZGVzLFI9RVswXSxJPUVbMV0saz1FWzJdLFM9RVszXSxBPW4ucGFkSW5mby5mcm9udCxEPW4ucGFkSW5mby5sZWZ0LFQ9bi5wYWRJbmZvLnRvcCxOPTA7TjxpOysrTilmb3IodmFyIEY9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKEEtTikvcikpLF89TWF0aC5taW4obi5vdXREZXB0aCwobi5pbkRlcHRoK0EtTikvciksTz1OKmYsTT0wO008czsrK00pZm9yKHZhciBCPU1hdGgubWF4KDAsTWF0aC5jZWlsKChULU0pL28pKSxQPU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K1QtTSkvbyksTD1NKmQrTyxXPTA7Vzx1OysrVylmb3IodmFyIFU9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKEQtVykvYSkpLFY9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK0QtVykvYSksej1XKnArTCxHPTA7RzxuLmluQ2hhbm5lbHM7KytHKWZvcih2YXIgSD1HKnYreixxPTA7cTxuLm91dENoYW5uZWxzOysrcSl7Zm9yKHZhciBLPTAsaj0wO2o8bi5iYXRjaFNpemU7KytqKWZvcih2YXIgWD1qKlIsWT1qKnksJD1GOyQ8XzsrKyQpZm9yKHZhciBRPShOKyQqci1BKSpJK1gsSj0kKngrWSxaPUI7WjxQOysrWilmb3IodmFyIHR0PShNK1oqby1UKSprK1EsZXQ9WipiK0osbnQ9VTtudDxWOysrbnQpe3ZhciBydD1udCp3K2V0O0srPUNbKFcrbnQqYS1EKSpTK3R0K0ddKm1bcnQrcV19bFtIK3FdPUt9cmV0dXJuIGMudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZnVzZWREZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dCxuPXQuZmlsdGVyLHI9dC5jb252SW5mbyxvPXQuYmlhcyxhPXQuYWN0aXZhdGlvbixpPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxzPXRoaXMuZGVwdGh3aXNlQ29udjJEKGUsbixyKTtyZXR1cm4gbyYmKHM9dGhpcy5hZGQocyxvKSksYSYmKHM9cWgodGhpcyxzLGEsaSkpLHN9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJkZXB0aHdpc2VDb252MkRcIik7Zm9yKHZhciByPW4uZmlsdGVySGVpZ2h0LG89bi5maWx0ZXJXaWR0aCxhPW4uZGlsYXRpb25IZWlnaHQsaT1uLmRpbGF0aW9uV2lkdGgscz1uLnBhZEluZm8ubGVmdCx1PW4ucGFkSW5mby50b3AsYz1uLm91dENoYW5uZWxzL24uaW5DaGFubmVscyxsPWRyKG4ub3V0U2hhcGUsdC5kdHlwZSksaD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxmPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGQ9bC52YWx1ZXMscD0wO3A8bi5iYXRjaFNpemU7KytwKWZvcih2YXIgdj1wKnQuc3RyaWRlc1swXSxtPXAqbC5zdHJpZGVzWzBdLGc9MDtnPG4ub3V0SGVpZ2h0OysrZylmb3IodmFyIHk9bStnKmwuc3RyaWRlc1sxXSx4PWcqbi5zdHJpZGVIZWlnaHQtcyxiPTA7YjxyOysrYil7dmFyIHc9eCtiKmE7aWYoISh3PDB8fHc+PW4uaW5IZWlnaHQpKWZvcih2YXIgQz1iKmUuc3RyaWRlc1swXSxFPXYrdyp0LnN0cmlkZXNbMV0sUj0wO1I8bi5vdXRXaWR0aDsrK1IpZm9yKHZhciBJPXkrUipsLnN0cmlkZXNbMl0saz1SKm4uc3RyaWRlV2lkdGgtdSxTPTA7UzxvOysrUyl7dmFyIEE9aytTKmk7aWYoIShBPDB8fEE+PW4uaW5XaWR0aCkpZm9yKHZhciBEPUMrUyplLnN0cmlkZXNbMV0sVD1FK0Eqbi5pbkNoYW5uZWxzLE49SSxGPUQsXz0wO188bi5pbkNoYW5uZWxzOysrXyl7Zm9yKHZhciBPPWhbVCtfXSxNPTA7TTxjOysrTSlkW04rTV0rPU8qZltGK01dO04rPWMsRis9Y319fXJldHVybiBsLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImRlcHRod2lzZUNvbnYyRERlcklucHV0XCIpO2Zvcih2YXIgcj1kcihuLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89ci52YWx1ZXMsYT1yLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sYz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxsPXQuc3RyaWRlcyxoPWxbMF0sZj1sWzFdLGQ9bFsyXSxwPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHY9ZS5zdHJpZGVzLG09dlswXSxnPXZbMV0seT12WzJdLHg9bi5iYXRjaFNpemUsYj1uLmZpbHRlckhlaWdodCx3PW4uZmlsdGVyV2lkdGgsQz1uLmluQ2hhbm5lbHMsRT1uLmluSGVpZ2h0LFI9bi5pbldpZHRoLEk9bi5vdXRDaGFubmVscyxrPW4ub3V0SGVpZ2h0LFM9bi5vdXRXaWR0aCxBPW4uc3RyaWRlSGVpZ2h0LEQ9bi5zdHJpZGVXaWR0aCxUPWItMS1uLnBhZEluZm8udG9wLE49dy0xLW4ucGFkSW5mby5sZWZ0LEY9SS9DLF89MDtfPHg7KytfKWZvcih2YXIgTz0wO088QzsrK08pZm9yKHZhciBNPTA7TTxFOysrTSlmb3IodmFyIEI9TS1ULFA9TWF0aC5tYXgoMCxNYXRoLmNlaWwoQi9BKSksTD1NYXRoLm1pbihrLChiK0IpL0EpLFc9MDtXPFI7KytXKXtmb3IodmFyIFU9Vy1OLFY9TWF0aC5tYXgoMCxNYXRoLmNlaWwoVS9EKSksej1NYXRoLm1pbihTLCh3K1UpL0QpLEc9MCxIPVA7SDxMOysrSClmb3IodmFyIHE9SCpBLUIsSz1WO0s8ejsrK0spZm9yKHZhciBqPWgqXytmKkgrZCpLLFg9bSooYi0xLXEpK2cqKHctMS0oSypELVUpKSt5Kk8sWT0wO1k8RjsrK1kpe0crPWNbaisoTypGK1kpXSpwW1grWV19b1tpKl8rcypNK3UqVytPXT1HfXJldHVybiByLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJkZXB0aHdpc2VDb252MkREZXJGaWx0ZXJcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPWRyKG4uZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLHU9bi5wYWRJbmZvLmxlZnQsYz1uLnBhZEluZm8udG9wLGw9bi5vdXRDaGFubmVscy9uLmluQ2hhbm5lbHMsaD10aGlzLmJ1ZmZlclN5bmModCksZj10aGlzLmJ1ZmZlclN5bmMoZSksZD0wO2Q8YTsrK2QpZm9yKHZhciBwPU1hdGgubWF4KDAsTWF0aC5jZWlsKChjLWQpL3IpKSx2PU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K2MtZCkvciksbT0wO208aTsrK20pZm9yKHZhciBnPU1hdGgubWF4KDAsTWF0aC5jZWlsKCh1LW0pL28pKSx5PU1hdGgubWluKG4ub3V0V2lkdGgsKG4uaW5XaWR0aCt1LW0pL28pLHg9MDt4PG4ub3V0Q2hhbm5lbHM7Kyt4KXtmb3IodmFyIGI9TWF0aC50cnVuYyh4L2wpLHc9eCVsLEM9MCxFPTA7RTxuLmJhdGNoU2l6ZTsrK0UpZm9yKHZhciBSPXA7Ujx2OysrUilmb3IodmFyIEk9ZCtSKnItYyxrPWc7azx5Oysrayl7dmFyIFM9bStrKm8tdTtDKz1oLmdldChFLEksUyxiKSpmLmdldChFLFIsayx4KX1zLnNldChDLGQsbSxiLHcpfXJldHVybiBzLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgodCxcInRpbGVcIiksdGEodGhpcy5idWZmZXJTeW5jKHQpLGUpfSxvLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlLG4pe0hoKHQsXCJwYWRcIik7dmFyIHI9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdC5zaGFwZVtuXStlWzFdfSkpLG89ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpLGE9dGhpcy5idWZmZXJTeW5jKHQpLGk9ZHIocix0LmR0eXBlKTswIT09biYmaS52YWx1ZXMuZmlsbChuKTtmb3IodmFyIHM9MDtzPHQuc2l6ZTtzKyspe3ZhciB1PWEuaW5kZXhUb0xvYyhzKSxjPXUubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiB0K29bZV19KSk7aS5zZXQuYXBwbHkoaSxbYS5nZXQuYXBwbHkoYSx1KV0uY29uY2F0KGMpKX1yZXR1cm4gaS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCxlKXtIaCh0LFwidHJhbnNwb3NlXCIpO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5yYW5rKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10LnNoYXBlW2Vbcl1dO3ZhciBvPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGE9ZHIobix0LmR0eXBlKSxpPXRoaXMuYnVmZmVyU3luYyh0KTtmb3Iocj0wO3I8dC5zaXplOysrcil7Zm9yKHZhciBzPWkuaW5kZXhUb0xvYyhyKSx1PW5ldyBBcnJheShzLmxlbmd0aCksYz0wO2M8dS5sZW5ndGg7YysrKXVbY109c1tlW2NdXTt2YXIgbD1hLmxvY1RvSW5kZXgodSk7YS52YWx1ZXNbbF09b1tyXX1yZXR1cm4gYS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiZ2F0aGVyXCIpO3ZhciByPXQuc2hhcGUuc2xpY2UoKSxvPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpO3Jbbl09by5sZW5ndGg7Zm9yKHZhciBhPWRyKHIsdC5kdHlwZSksaT10aGlzLmJ1ZmZlclN5bmModCkscz0wO3M8YS5zaXplOysrcyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLGM9dS5zbGljZSgpO2Nbbl09b1t1W25dXTt2YXIgbD1pLmxvY1RvSW5kZXgoYyk7YS52YWx1ZXNbc109aS52YWx1ZXNbbF19cmV0dXJuIGEudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe0hoKFt0XSxcImJhdGNoVG9TcGFjZU5EXCIpO3ZhciByPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksbz16cih0LnNoYXBlLGUsciksYT1HcihvLmxlbmd0aCxlLmxlbmd0aCksaT1Icih0LnNoYXBlLGUscikscz1xcihuLGUubGVuZ3RoKSx1PUtyKGksbixlLmxlbmd0aCk7cmV0dXJuIHQucmVzaGFwZShvKS50cmFuc3Bvc2UoYSkucmVzaGFwZShpKS5zbGljZShzLHUpfSxvLnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7SGgoW3RdLFwic3BhY2VUb0JhdGNoTkRcIik7dmFyIHI9ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKSxvPVtbMCwwXV07by5wdXNoLmFwcGx5KG8sbik7Zm9yKHZhciBhPTErZS5sZW5ndGg7YTx0LnNoYXBlLmxlbmd0aDsrK2Epby5wdXNoKFswLDBdKTt2YXIgaT10LnBhZChvKSxzPXpyKGkuc2hhcGUsZSxyLCExKSx1PUdyKHMubGVuZ3RoLGUubGVuZ3RoLCExKSxjPUhyKGkuc2hhcGUsZSxyLCExKTtyZXR1cm4gaS5yZXNoYXBlKHMpLnRyYW5zcG9zZSh1KS5yZXNoYXBlKGMpfSxvLnByb3RvdHlwZS5wb29sPWZ1bmN0aW9uKHQsZSxuKXtIaCh0LFwicG9vbFwiKTtmb3IodmFyIHI9ZS5zdHJpZGVIZWlnaHQsbz1lLnN0cmlkZVdpZHRoLGE9ZS5kaWxhdGlvbkhlaWdodCxpPWUuZGlsYXRpb25XaWR0aCxzPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxjPWUucGFkSW5mby50b3AsbD1lLnBhZEluZm8ubGVmdCxoPVwibWF4XCI9PT1uP051bWJlci5ORUdBVElWRV9JTkZJTklUWTpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksZj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxkPWRyKGUub3V0U2hhcGUsdC5kdHlwZSkscD1kLnZhbHVlcyx2PWUub3V0U2hhcGVbMV0qZS5vdXRTaGFwZVsyXSplLm91dFNoYXBlWzNdLG09ZS5vdXRTaGFwZVsyXSplLm91dFNoYXBlWzNdLGc9ZS5vdXRTaGFwZVszXSx5PTA7eTxlLmJhdGNoU2l6ZTsrK3kpZm9yKHZhciB4PXkqdixiPXkqdC5zdHJpZGVzWzBdLHc9MDt3PGUuaW5DaGFubmVsczsrK3cpZm9yKHZhciBDPTA7QzxlLm91dEhlaWdodDsrK0MpZm9yKHZhciBFPUMqci1jLFI9TWF0aC5tYXgoMCxFKSxJPU1hdGgubWluKGUuaW5IZWlnaHQscytFKSxrPXgrQyptLFM9MDtTPGUub3V0V2lkdGg7KytTKXtmb3IodmFyIEE9UypvLWwsRD1NYXRoLm1heCgwLEEpLFQ9TWF0aC5taW4oZS5pbldpZHRoLHUrQSksTj1oLEY9MCxfPTAsTz1SO088STtPKz1hKXtmb3IodmFyIE09YitPKnQuc3RyaWRlc1sxXSxCPUQ7QjxUO0IrPWkpe3ZhciBQPWZbTStCKnQuc3RyaWRlc1syXSt3XTtcIm1heFwiPT09biYmUD5OP049UDpcImF2Z1wiPT09biYmKEYrPVAsXysrKX1pZihpc05hTihOKSlicmVha31wW2srUypnK3ddPVwiYXZnXCI9PT1uP0YvXzpOfXJldHVybiBkLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5wb29sKHQsZSxcIm1heFwiKX0sby5wcm90b3R5cGUubWF4UG9vbFBvc2l0aW9ucz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1kcihlLm91dFNoYXBlLFwiaW50MzJcIikscj1lLnN0cmlkZUhlaWdodCxvPWUuc3RyaWRlV2lkdGgsYT1lLmRpbGF0aW9uSGVpZ2h0LGk9ZS5kaWxhdGlvbldpZHRoLHM9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9ZS5wYWRJbmZvLnRvcCxsPWUucGFkSW5mby5sZWZ0LGg9dGhpcy5idWZmZXJTeW5jKHQpLGY9MDtmPGUuYmF0Y2hTaXplOysrZilmb3IodmFyIGQ9MDtkPGUuaW5DaGFubmVsczsrK2QpZm9yKHZhciBwPTA7cDxlLm91dEhlaWdodDsrK3Ape2Zvcih2YXIgdj1wKnItYyxtPXY7bTwwOyltKz1hO2Zvcih2YXIgZz1NYXRoLm1pbihlLmluSGVpZ2h0LHMrdikseT0wO3k8ZS5vdXRXaWR0aDsrK3kpe2Zvcih2YXIgeD15Km8tbCxiPXg7YjwwOyliKz1pO2Zvcih2YXIgdz1NYXRoLm1pbihlLmluV2lkdGgsdSt4KSxDPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxFPS0xLFI9bTtSPGc7Uis9YSlmb3IodmFyIEk9Ui12LGs9YjtrPHc7ays9aSl7dmFyIFM9ay14LEE9aC5nZXQoZixSLGssZCk7QT5DJiYoQz1BLEU9SSp1K1MpfW4uc2V0KEUsZixwLHksZCl9fXJldHVybiBuLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXtIaChbZSxuXSxcIm1heFBvb2xCYWNrcHJvcFwiKTtmb3IodmFyIG89dGhpcy5tYXhQb29sUG9zaXRpb25zKGUsciksYT1yLnN0cmlkZUhlaWdodCxpPXIuc3RyaWRlV2lkdGgscz1yLmRpbGF0aW9uSGVpZ2h0LHU9ci5kaWxhdGlvbldpZHRoLGM9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbD1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGg9bC0xLXIucGFkSW5mby5sZWZ0LGY9Yy0xLXIucGFkSW5mby50b3AsZD1kcihlLnNoYXBlLFwiZmxvYXQzMlwiKSxwPXRoaXMuYnVmZmVyU3luYyhvKSx2PXRoaXMuYnVmZmVyU3luYyh0KSxtPTA7bTxyLmJhdGNoU2l6ZTsrK20pZm9yKHZhciBnPTA7ZzxyLmluQ2hhbm5lbHM7KytnKWZvcih2YXIgeT0wO3k8ci5pbkhlaWdodDsrK3kpZm9yKHZhciB4PTA7eDxyLmluV2lkdGg7Kyt4KXtmb3IodmFyIGI9eS1mLHc9eC1oLEM9MCxFPTA7RTxjO0UrPXMpe3ZhciBSPShiK0UpL2E7aWYoIShSPDB8fFI+PXIub3V0SGVpZ2h0fHxNYXRoLmZsb29yKFIpIT09UikpZm9yKHZhciBJPTA7STxsO0krPXUpe3ZhciBrPSh3K0kpL2k7aWYoIShrPDB8fGs+PXIub3V0V2lkdGh8fE1hdGguZmxvb3IoaykhPT1rKSl7dmFyIFM9YypsLTEtcC5nZXQobSxSLGssZyk9PT1FKmwrST8xOjA7aWYoMCE9PVMpQys9di5nZXQobSxSLGssZykqU319fWQuc2V0KEMsbSx5LHgsZyl9cmV0dXJuIGQudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImF2Z1Bvb2xCYWNrcHJvcFwiKTtmb3IodmFyIHI9bi5zdHJpZGVIZWlnaHQsbz1uLnN0cmlkZVdpZHRoLGE9bi5maWx0ZXJIZWlnaHQsaT1uLmZpbHRlcldpZHRoLHM9bi5kaWxhdGlvbkhlaWdodCx1PW4uZGlsYXRpb25XaWR0aCxjPW4uZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGw9bi5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxoPWwtMS1uLnBhZEluZm8ubGVmdCxmPWMtMS1uLnBhZEluZm8udG9wLGQ9ZHIoZS5zaGFwZSxcImZsb2F0MzJcIikscD0xLyhhKmkpLHY9dGhpcy5idWZmZXJTeW5jKHQpLG09MDttPG4uYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9MDtnPG4uaW5DaGFubmVsczsrK2cpZm9yKHZhciB5PTA7eTxuLmluSGVpZ2h0OysreSlmb3IodmFyIHg9MDt4PG4uaW5XaWR0aDsrK3gpe2Zvcih2YXIgYj15LWYsdz14LWgsQz0wLEU9MDtFPGM7RSs9cyl7dmFyIFI9KGIrRSkvcjtpZighKFI8MHx8Uj49bi5vdXRIZWlnaHR8fE1hdGguZmxvb3IoUikhPT1SKSlmb3IodmFyIEk9MDtJPGw7SSs9dSl7dmFyIGs9KHcrSSkvbztpZighKGs8MHx8az49bi5vdXRXaWR0aHx8TWF0aC5mbG9vcihrKSE9PWspKUMrPXYuZ2V0KG0sUixrLGcpfX1kLnNldChDKnAsbSx5LHgsZyl9cmV0dXJuIGQudG9UZW5zb3IoKX0sby5wcm90b3R5cGUucG9vbDNkPWZ1bmN0aW9uKHQsZSxuKXtIaCh0LFwicG9vbDNkXCIpO2Zvcih2YXIgcj1lLnN0cmlkZURlcHRoLG89ZS5zdHJpZGVIZWlnaHQsYT1lLnN0cmlkZVdpZHRoLGk9ZS5kaWxhdGlvbkRlcHRoLHM9ZS5kaWxhdGlvbkhlaWdodCx1PWUuZGlsYXRpb25XaWR0aCxjPWUuZWZmZWN0aXZlRmlsdGVyRGVwdGgsbD1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxoPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsZj1lLnBhZEluZm8uZnJvbnQsZD1lLnBhZEluZm8udG9wLHA9ZS5wYWRJbmZvLmxlZnQsdj1cIm1heFwiPT09bj9OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG09dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksZz1kcihlLm91dFNoYXBlLHQuZHR5cGUpLHk9Zy52YWx1ZXMseD1lLm91dFNoYXBlWzFdKmUub3V0U2hhcGVbMl0qZS5vdXRTaGFwZVszXSplLm91dFNoYXBlWzRdLGI9ZS5vdXRTaGFwZVsyXSplLm91dFNoYXBlWzNdKmUub3V0U2hhcGVbNF0sdz1lLm91dFNoYXBlWzNdKmUub3V0U2hhcGVbNF0sQz1lLm91dFNoYXBlWzRdLEU9MDtFPGUuYmF0Y2hTaXplOysrRSlmb3IodmFyIFI9RSp4LEk9RSp0LnN0cmlkZXNbMF0saz0wO2s8ZS5pbkNoYW5uZWxzOysraylmb3IodmFyIFM9MDtTPGUub3V0RGVwdGg7KytTKXtmb3IodmFyIEE9UypyLWYsRD1BO0Q8MDspRCs9aTtmb3IodmFyIFQ9TWF0aC5taW4oZS5pbkRlcHRoLGMrQSksTj1SK1MqYixGPTA7RjxlLm91dEhlaWdodDsrK0Ype2Zvcih2YXIgXz1GKm8tZCxPPV87TzwwOylPKz1zO2Zvcih2YXIgTT1NYXRoLm1pbihlLmluSGVpZ2h0LGwrXyksQj1OK0YqdyxQPTA7UDxlLm91dFdpZHRoOysrUCl7Zm9yKHZhciBMPVAqYS1wLFc9TDtXPDA7KVcrPXU7Zm9yKHZhciBVPU1hdGgubWluKGUuaW5XaWR0aCxoK0wpLFY9QitQKkMsej12LEc9MCxIPTAscT1EO3E8VDtxKz1pKXtmb3IodmFyIEs9SStxKnQuc3RyaWRlc1sxXSxqPU87ajxNO2orPXMpe2Zvcih2YXIgWD1LK2oqdC5zdHJpZGVzWzJdLFk9VztZPFU7WSs9dSl7dmFyICQ9bVtYK1kqdC5zdHJpZGVzWzNdK2tdO2lmKFwibWF4XCI9PT1uJiYkPno/ej0kOlwiYXZnXCI9PT1uJiYoRys9JCxIKyspLGlzTmFOKHopKWJyZWFrfWlmKGlzTmFOKHopKWJyZWFrfWlmKGlzTmFOKHopKWJyZWFrfXlbVitrXT1cImF2Z1wiPT09bj9HL0g6en19fXJldHVybiBnLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmF2Z1Bvb2wzZD1mdW5jdGlvbih0LGUpe3JldHVybiBIaCh0LFwiYXZnUG9vbDNkXCIpLHRoaXMucG9vbDNkKHQsZSxcImF2Z1wiKS50b0Zsb2F0KCl9LG8ucHJvdG90eXBlLmF2Z1Bvb2wzZEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImF2Z1Bvb2wzZEJhY2twcm9wXCIpO2Zvcih2YXIgcj1uLnN0cmlkZURlcHRoLG89bi5zdHJpZGVIZWlnaHQsYT1uLnN0cmlkZVdpZHRoLGk9bi5maWx0ZXJEZXB0aCxzPW4uZmlsdGVySGVpZ2h0LHU9bi5maWx0ZXJXaWR0aCxjPW4uZGlsYXRpb25EZXB0aCxsPW4uZGlsYXRpb25IZWlnaHQsaD1uLmRpbGF0aW9uV2lkdGgsZj1uLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGQ9bi5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQscD1uLmVmZmVjdGl2ZUZpbHRlcldpZHRoLHY9Zi0xLW4ucGFkSW5mby5mcm9udCxtPXAtMS1uLnBhZEluZm8ubGVmdCxnPWQtMS1uLnBhZEluZm8udG9wLHk9ZHIoZS5zaGFwZSxcImZsb2F0MzJcIikseD0xLyhpKnMqdSksYj10aGlzLmJ1ZmZlclN5bmModCksdz0wO3c8bi5iYXRjaFNpemU7Kyt3KWZvcih2YXIgQz0wO0M8bi5pbkNoYW5uZWxzOysrQylmb3IodmFyIEU9MDtFPG4uaW5EZXB0aDsrK0UpZm9yKHZhciBSPTA7UjxuLmluSGVpZ2h0OysrUilmb3IodmFyIEk9MDtJPG4uaW5XaWR0aDsrK0kpe2Zvcih2YXIgaz1FLXYsUz1SLWcsQT1JLW0sRD0wLFQ9MDtUPGY7VCs9Yyl7dmFyIE49KGsrVCkvcjtpZighKE48MHx8Tj49bi5vdXREZXB0aHx8TWF0aC5mbG9vcihOKSE9PU4pKWZvcih2YXIgRj0wO0Y8ZDtGKz1sKXt2YXIgXz0oUytGKS9vO2lmKCEoXzwwfHxfPj1uLm91dEhlaWdodHx8TWF0aC5mbG9vcihfKSE9PV8pKWZvcih2YXIgTz0wO088cDtPKz1oKXt2YXIgTT0oQStPKS9hO2lmKCEoTTwwfHxNPj1uLm91dFdpZHRofHxNYXRoLmZsb29yKE0pIT09TSkpRCs9Yi5nZXQodyxOLF8sTSxDKX19fXkuc2V0KEQqeCx3LEUsUixJLEMpfXJldHVybiB5LnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLm1heFBvb2wzZD1mdW5jdGlvbih0LGUpe3JldHVybiBIaCh0LFwibWF4UG9vbDNkXCIpLHRoaXMucG9vbDNkKHQsZSxcIm1heFwiKS50b0Zsb2F0KCl9LG8ucHJvdG90eXBlLm1heFBvb2wzZFBvc2l0aW9ucz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1kcihlLm91dFNoYXBlLFwiaW50MzJcIikscj1lLnN0cmlkZURlcHRoLG89ZS5zdHJpZGVIZWlnaHQsYT1lLnN0cmlkZVdpZHRoLGk9ZS5kaWxhdGlvbkRlcHRoLHM9ZS5kaWxhdGlvbkhlaWdodCx1PWUuZGlsYXRpb25XaWR0aCxjPWUuZWZmZWN0aXZlRmlsdGVyRGVwdGgsbD1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxoPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsZj1lLnBhZEluZm8uZnJvbnQsZD1lLnBhZEluZm8udG9wLHA9ZS5wYWRJbmZvLmxlZnQsdj10aGlzLmJ1ZmZlclN5bmModCksbT0wO208ZS5iYXRjaFNpemU7KyttKWZvcih2YXIgZz0wO2c8ZS5pbkNoYW5uZWxzOysrZylmb3IodmFyIHk9MDt5PGUub3V0RGVwdGg7Kyt5KXtmb3IodmFyIHg9eSpyLWYsYj14O2I8MDspYis9aTtmb3IodmFyIHc9TWF0aC5taW4oZS5pbkRlcHRoLGMreCksQz0wO0M8ZS5vdXRIZWlnaHQ7KytDKXtmb3IodmFyIEU9QypvLWQsUj1FO1I8MDspUis9cztmb3IodmFyIEk9TWF0aC5taW4oZS5pbkhlaWdodCxsK0UpLGs9MDtrPGUub3V0V2lkdGg7KytrKXtmb3IodmFyIFM9ayphLXAsQT1TO0E8MDspQSs9dTtmb3IodmFyIEQ9TWF0aC5taW4oZS5pbldpZHRoLGgrUyksVD1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksTj0tMSxGPWI7Rjx3O0YrPWkpZm9yKHZhciBfPUYteCxPPVI7TzxJO08rPXMpZm9yKHZhciBNPU8tRSxCPUE7QjxEO0IrPXUpe3ZhciBQPUItUyxMPXYuZ2V0KG0sRixPLEIsZyk7TD49VCYmKFQ9TCxOPV8qbCpoK00qbCtQKX1uLnNldChOLG0seSxDLGssZyl9fX1yZXR1cm4gbi50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5tYXhQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXtIaChbZSxuXSxcIm1heFBvb2wzZEJhY2twcm9wXCIpO2Zvcih2YXIgbz10aGlzLm1heFBvb2wzZFBvc2l0aW9ucyhlLHIpLGE9ci5zdHJpZGVEZXB0aCxpPXIuc3RyaWRlSGVpZ2h0LHM9ci5zdHJpZGVXaWR0aCx1PXIuZGlsYXRpb25EZXB0aCxjPXIuZGlsYXRpb25IZWlnaHQsbD1yLmRpbGF0aW9uV2lkdGgsaD1yLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGY9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsZD1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLHA9aC0xLXIucGFkSW5mby5mcm9udCx2PWQtMS1yLnBhZEluZm8ubGVmdCxtPWYtMS1yLnBhZEluZm8udG9wLGc9ZHIoZS5zaGFwZSxcImZsb2F0MzJcIikseT10aGlzLmJ1ZmZlclN5bmMobykseD10aGlzLmJ1ZmZlclN5bmModCksYj0wO2I8ci5iYXRjaFNpemU7KytiKWZvcih2YXIgdz0wO3c8ci5pbkNoYW5uZWxzOysrdylmb3IodmFyIEM9MDtDPHIuaW5EZXB0aDsrK0MpZm9yKHZhciBFPTA7RTxyLmluSGVpZ2h0OysrRSlmb3IodmFyIFI9MDtSPHIuaW5XaWR0aDsrK1Ipe2Zvcih2YXIgST1DLXAsaz1FLW0sUz1SLXYsQT0wLEQ9MDtEPGg7RCs9dSl7dmFyIFQ9KEkrRCkvYTtpZighKFQ8MHx8VD49ci5vdXREZXB0aHx8TWF0aC5mbG9vcihUKSE9PVQpKWZvcih2YXIgTj0wO048ZjtOKz1jKXt2YXIgRj0oaytOKS9pO2lmKCEoRjwwfHxGPj1yLm91dEhlaWdodHx8TWF0aC5mbG9vcihGKSE9PUYpKWZvcih2YXIgXz0wO188ZDtfKz1sKXt2YXIgTz0oUytfKS9zO2lmKCEoTzwwfHxPPj1yLm91dFdpZHRofHxNYXRoLmZsb29yKE8pIT09Tykpe3ZhciBNPWgqZipkLTEteS5nZXQoYixULEYsTyx3KT09PUQqZipkK04qZCtfPzE6MDtpZigwIT09TSlBKz14LmdldChiLFQsRixPLHcpKk19fX19Zy5zZXQoQSxiLEMsRSxSLHcpfXJldHVybiBnLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gUG8odCxlLHRoaXMpfSxvLnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIExvKHQsZSl9LG8ucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgodCxcImF2Z1Bvb2xcIiksdGhpcy5wb29sKHQsZSxcImF2Z1wiKS50b0Zsb2F0KCl9LG8ucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSxuLHIpe0hoKHQsXCJyZXNpemVCaWxpbmVhclwiKTtmb3IodmFyIG89dC5zaGFwZSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM10sYz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxsPW5ldyBGbG9hdDMyQXJyYXkoayhbYSxlLG4sdV0pKSxoPVtyJiZlPjE/aS0xOmksciYmbj4xP3MtMTpzXSxmPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXSxkPTAscD1oWzBdL2ZbMF0sdj1oWzFdL2ZbMV0sbT0wO208YTttKyspZm9yKHZhciBnPTA7ZzxlO2crKylmb3IodmFyIHk9cCpnLHg9TWF0aC5mbG9vcih5KSxiPXkteCx3PU1hdGgubWluKGktMSxNYXRoLmNlaWwoeSkpLEM9bSp0LnN0cmlkZXNbMF0reCp0LnN0cmlkZXNbMV0sRT1tKnQuc3RyaWRlc1swXSt3KnQuc3RyaWRlc1sxXSxSPTA7UjxuO1IrKylmb3IodmFyIEk9dipSLFM9TWF0aC5mbG9vcihJKSxBPUktUyxEPU1hdGgubWluKHMtMSxNYXRoLmNlaWwoSSkpLFQ9QytTKnQuc3RyaWRlc1syXSxOPUUrUyp0LnN0cmlkZXNbMl0sRj1DK0QqdC5zdHJpZGVzWzJdLF89RStEKnQuc3RyaWRlc1syXSxPPTA7Tzx1O08rKyl7dmFyIE09Y1tUK09dLEI9Y1tOK09dLFA9TSsoY1tGK09dLU0pKkEsTD1QKyhCKyhjW18rT10tQikqQS1QKSpiO2xbZCsrXT1MfXJldHVybiBGbihsLFthLGUsbix1XSl9LG8ucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwicmVzaXplQmlsaW5lYXJCYWNrcHJvcFwiKTtmb3IodmFyIHI9ZS5zaGFwZSxvPXJbMF0sYT1yWzFdLGk9clsyXSxzPXJbM10sdT10LnNoYXBlLGM9dVsxXSxsPXVbMl0saD1uZXcgRmxvYXQzMkFycmF5KG8qYSppKnMpLGY9W24mJmM+MT9hLTE6YSxuJiZsPjE/aS0xOmldLGQ9W24mJmM+MT9jLTE6YyxuJiZsPjE/bC0xOmxdLHA9ZlswXS9kWzBdLHY9ZlsxXS9kWzFdLG09dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksZz0wLHk9MDt5PG87eSsrKWZvcih2YXIgeD15KmUuc3RyaWRlc1swXSxiPTA7YjxjO2IrKylmb3IodmFyIHc9YipwLEM9TWF0aC5mbG9vcih3KSxFPU1hdGgubWluKE1hdGguY2VpbCh3KSxhLTEpLFI9eCtDKmUuc3RyaWRlc1sxXSxJPXgrRSplLnN0cmlkZXNbMV0saz13LUMsUz0xLWssQT0wO0E8bDtBKyspZm9yKHZhciBEPUEqdixUPU1hdGguZmxvb3IoRCksTj1NYXRoLm1pbihNYXRoLmNlaWwoRCksaS0xKSxGPUQtVCxfPTEtRixPPVIrVCplLnN0cmlkZXNbMl0sTT1SK04qZS5zdHJpZGVzWzJdLEI9SStUKmUuc3RyaWRlc1syXSxQPUkrTiplLnN0cmlkZXNbMl0sTD1TKl8sVz1TKkYsVT1rKl8sVj1rKkYsej0wO3o8czt6Kyspe3ZhciBHPW1bZysrXTtoW08rel0rPUcqTCxoW00rel0rPUcqVyxoW0Irel0rPUcqVSxoW1Arel0rPUcqVn1yZXR1cm4gTG4oaCxbbyxpLGEsc10sZS5kdHlwZSl9LG8ucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUsbixyKXtIaCh0LFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpO2Zvcih2YXIgbz10LnNoYXBlLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxjPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGw9bmV3IEZsb2F0MzJBcnJheShhKmUqbip1KSxoPVtyJiZlPjE/aS0xOmksciYmbj4xP3MtMTpzXSxmPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXSxkPWhbMF0vZlswXSxwPWhbMV0vZlsxXSx2PTAsbT0wO208YTttKyspZm9yKHZhciBnPW0qdC5zdHJpZGVzWzBdLHk9MDt5PGU7eSsrKWZvcih2YXIgeD1kKnksYj1nK01hdGgubWluKGktMSxyP01hdGgucm91bmQoeCk6TWF0aC5mbG9vcih4KSkqdC5zdHJpZGVzWzFdLHc9MDt3PG47dysrKWZvcih2YXIgQz1wKncsRT1iK01hdGgubWluKHMtMSxyP01hdGgucm91bmQoQyk6TWF0aC5mbG9vcihDKSkqdC5zdHJpZGVzWzJdLFI9MDtSPHU7UisrKXt2YXIgST1jW0UrUl07bFt2KytdPUl9cmV0dXJuIEZuKGwsW2EsZSxuLHVdLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcFwiKTtmb3IodmFyIHI9ZS5zaGFwZSxvPXJbMF0sYT1yWzFdLGk9clsyXSxzPXJbM10sdT10LnNoYXBlLGM9dVsxXSxsPXVbMl0saD1uZXcgRmxvYXQzMkFycmF5KG8qYSppKnMpLGY9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksZD1bbiYmYz4xP2EtMTphLG4mJmw+MT9pLTE6aV0scD1bbiYmYz4xP2MtMTpjLG4mJmw+MT9sLTE6bF0sdj1kWzBdL3BbMF0sbT1kWzFdL3BbMV0sZz0xL3YseT0xL20seD0yKk1hdGguY2VpbChnKSsyLGI9MipNYXRoLmNlaWwoeSkrMix3PTA7dzxvO3crKylmb3IodmFyIEM9dyplLnN0cmlkZXNbMF0sRT0wO0U8YTtFKyspZm9yKHZhciBSPUMrRSplLnN0cmlkZXNbMV0sST1NYXRoLmZsb29yKEUqZyksaz1NYXRoLmZsb29yKEkteC8yKSxTPTA7UzxpO1MrKylmb3IodmFyIEE9UitTKmUuc3RyaWRlc1syXSxEPU1hdGguZmxvb3IoUyp5KSxUPU1hdGguZmxvb3IoRC1iLzIpLE49MDtOPHM7TisrKXtmb3IodmFyIEY9MCxfPTA7Xzx4O18rKyl7dmFyIE89XytrO2lmKCEoTzwwfHxPPj1jKSl7dmFyIE09QytPKnQuc3RyaWRlc1sxXSxCPU8qdjtpZihFPT09TWF0aC5taW4oYS0xLG4/TWF0aC5yb3VuZChCKTpNYXRoLmZsb29yKEIpKSlmb3IodmFyIFA9MDtQPGI7UCsrKXt2YXIgTD1QK1Q7aWYoIShMPDB8fEw+PWwpKXt2YXIgVz1NK0wqdC5zdHJpZGVzWzJdLFU9TCptO1M9PT1NYXRoLm1pbihpLTEsbj9NYXRoLnJvdW5kKFUpOk1hdGguZmxvb3IoVSkpJiYoRis9ZltXK05dKX19fX1oW0ErTl09Rn1yZXR1cm4gTG4oaCxlLnNoYXBlLGUuZHR5cGUpfSxvLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvLGEpe0hoKFt0LGUsbixvLGFdLFwiYmF0Y2hOb3JtXCIpO2Zvcih2YXIgaT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxzPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyhuLmRhdGFJZCksYz1vP3RoaXMucmVhZFN5bmMoby5kYXRhSWQpOm5ldyBGbG9hdDMyQXJyYXkoWzFdKSxsPWE/dGhpcy5yZWFkU3luYyhhLmRhdGFJZCk6bmV3IEZsb2F0MzJBcnJheShbMF0pLGg9bmV3IEZsb2F0MzJBcnJheShpLmxlbmd0aCksZj1sLmxlbmd0aCxkPWMubGVuZ3RoLHA9dS5sZW5ndGgsdj1zLmxlbmd0aCxtPTAsZz0wLHk9MCx4PTAsYj0wO2I8aS5sZW5ndGg7KytiKWhbYl09bFttKytdKyhpW2JdLXNbZysrXSkqY1t5KytdL01hdGguc3FydCh1W3grK10rciksbT49ZiYmKG09MCksZz49diYmKGc9MCkseT49ZCYmKHk9MCkseD49cCYmKHg9MCk7cmV0dXJuIExuKGgsdC5zaGFwZSl9LG8ucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ9ZnVuY3Rpb24odCxlLG4scixvKXtIaCh0LFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RFwiKTt2YXIgYT10LnNoYXBlWzNdLGk9YS0xLHM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksdT10LnNpemUsYz1uZXcgRmxvYXQzMkFycmF5KHUpO2Z1bmN0aW9uIGwodCl7Zm9yKHZhciBuPXQlYSxyPXQtbitNYXRoLm1heCgwLG4tZSksbz10LW4rTWF0aC5taW4obitlLGkpLHU9MDtyPD1vO3IrKyl7dmFyIGM9c1tyXTt1Kz1jKmN9cmV0dXJuIHV9Zm9yKHZhciBoPTA7aDx1O2grKyl7dmFyIGY9bChoKSxkPXNbaF0qTWF0aC5wb3cobityKmYsLW8pO2NbaF09ZH1yZXR1cm4gTG4oYyx0LnNoYXBlKX0sby5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXtIaCh0LFwiTFJOR3JhZFwiKTtmb3IodmFyIHM9dC5zaGFwZVszXSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksbD10aGlzLnJlYWRTeW5jKG4uZGF0YUlkKSxoPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxmPXQuc2l6ZSxkPTA7ZDxmO2QrKyl7Zm9yKHZhciBwPWQlcyx2PWQtcCtNYXRoLm1heCgwLHAtciksbT1kLXArTWF0aC5taW4ocyxwK3IrMSksZz0wLHk9djt5PG07eSsrKWcrPU1hdGgucG93KGNbeV0sMik7Zz1hKmcrbztmb3IoeT12O3k8bTt5Kyspe3ZhciB4PS0yKmEqaSpjW3ldKmxbZF0vZztkPT09eSYmKHgrPU1hdGgucG93KGcsLWkpKSx4Kj11W2RdLGhbeV0rPXh9fXJldHVybiBMbihoLHQuc2hhcGUpfSxvLnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbih0LGUsbixyKXtIaCh0LFwibXVsdGlub21pYWxcIik7Zm9yKHZhciBvPWU/dDpnbyh0KSxhPW8uc2hhcGVbMF0saT1vLnNoYXBlWzFdLHM9R24oW2Esbl0sXCJpbnQzMlwiKSx1PXRoaXMucmVhZFN5bmMocy5kYXRhSWQpLGM9dGhpcy5yZWFkU3luYyhvLmRhdGFJZCksbD0wO2w8YTsrK2wpe3ZhciBoPWwqaSxmPW5ldyBGbG9hdDMyQXJyYXkoaS0xKTtmWzBdPWNbaF07Zm9yKHZhciBkPTE7ZDxmLmxlbmd0aDsrK2QpZltkXT1mW2QtMV0rY1toK2RdO2Zvcih2YXIgcD1jcihyLnRvU3RyaW5nKCkpLHY9bCpuLG09MDttPG47KyttKXt2YXIgZz1wKCk7dVt2K21dPWYubGVuZ3RoO2Zvcih2YXIgeT0wO3k8Zi5sZW5ndGg7eSsrKWlmKGc8Zlt5XSl7dVt2K21dPXk7YnJlYWt9fX1yZXR1cm4gc30sby5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuLHIpe0hoKHQsXCJvbmVIb3RcIik7dmFyIG89bmV3IEZsb2F0MzJBcnJheSh0LnNpemUqZSk7by5maWxsKHIpO2Zvcih2YXIgYT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxpPTA7aTx0LnNpemU7KytpKWFbaV0+PTAmJmFbaV08ZSYmKG9baSplK2FbaV1dPW4pO3JldHVybiBCbihvLFt0LnNpemUsZV0sXCJpbnQzMlwiKX0sby5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gSGgodCxcIm5vbk1heFN1cHByZXNzaW9uXCIpLGpvKHRoaXMucmVhZFN5bmModC5kYXRhSWQpLHRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLG4scixvKX0sby5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEJhdGNoKHQsITEpfSxvLnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEJhdGNoKHQsITApfSxvLnByb3RvdHlwZS5mZnRCYXRjaD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LnNoYXBlWzBdLHI9dC5zaGFwZVsxXSxvPWRyKHQuc2hhcGUsXCJmbG9hdDMyXCIpLGE9ZHIodC5zaGFwZSxcImZsb2F0MzJcIiksaT1Ubih0KS5hczJEKG4scikscz1Obih0KS5hczJEKG4sciksdT0wO3U8bjt1KyspZm9yKHZhciBjPWkuc2xpY2UoW3UsMF0sWzEscl0pLGw9cy5zbGljZShbdSwwXSxbMSxyXSksaD1EbihjLGwpLGY9dGhpcy5yZWFkU3luYyh0aGlzLmZmdEltcGwoaCxlKS5kYXRhSWQpLGQ9MDtkPHI7ZCsrKXt2YXIgcD16byhmLGQpO28udmFsdWVzW3UqcitkXT1wLnJlYWwsYS52YWx1ZXNbdSpyK2RdPXAuaW1hZ31yZXR1cm4gRG4oby50b1RlbnNvcigpLGEudG9UZW5zb3IoKSkuYXMyRChuLHIpfSxvLnByb3RvdHlwZS5mZnRJbXBsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5hczFEKCkscj1uLnNpemU7aWYodGhpcy5pc0V4cG9uZW50T2YyKHIpKXt2YXIgbz10aGlzLmZmdFJhZGl4MihuLHIsZSkuYXMyRCh0LnNoYXBlWzBdLHQuc2hhcGVbMV0pO3JldHVybiBlJiYobz1EbihUbihvKS5kaXYoT24ocikpLE5uKG8pLmRpdihPbihyKSkpKSxvfXZhciBhPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgvMiksbj1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoLzIpLHI9MDtyPHQubGVuZ3RoO3IrPTIpZVtyLzJdPXRbcl0sbltyLzJdPXRbcisxXTtyZXR1cm57cmVhbDplLGltYWc6bn19KHRoaXMuZm91cmllclRyYW5zZm9ybUJ5TWF0bXVsKGEscixlKSk7cmV0dXJuIERuKGkucmVhbCxpLmltYWcpLmFzMkQodC5zaGFwZVswXSx0LnNoYXBlWzFdKX0sby5wcm90b3R5cGUuaXNFeHBvbmVudE9mMj1mdW5jdGlvbih0KXtyZXR1cm4gMD09KHQmdC0xKX0sby5wcm90b3R5cGUuZmZ0UmFkaXgyPWZ1bmN0aW9uKHQsZSxuKXtpZigxPT09ZSlyZXR1cm4gdDt2YXIgcj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPWUvMixhPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1NYXRoLmNlaWwodC5sZW5ndGgvNCksbj1uZXcgRmxvYXQzMkFycmF5KGUpLHI9bmV3IEZsb2F0MzJBcnJheShlKSxvPTA7bzx0Lmxlbmd0aDtvKz00KW5bTWF0aC5mbG9vcihvLzQpXT10W29dLHJbTWF0aC5mbG9vcihvLzQpXT10W28rMV07cmV0dXJue3JlYWw6bixpbWFnOnJ9fShyKSxpPURuKGEucmVhbCxhLmltYWcpLmFzMUQoKSxzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1NYXRoLmZsb29yKHQubGVuZ3RoLzQpLG49bmV3IEZsb2F0MzJBcnJheShlKSxyPW5ldyBGbG9hdDMyQXJyYXkoZSksbz0yO288dC5sZW5ndGg7bys9NCluW01hdGguZmxvb3Ioby80KV09dFtvXSxyW01hdGguZmxvb3Ioby80KV09dFtvKzFdO3JldHVybntyZWFsOm4saW1hZzpyfX0ociksdT1EbihzLnJlYWwscy5pbWFnKS5hczFEKCk7aT10aGlzLmZmdFJhZGl4MihpLG8sbiksdT10aGlzLmZmdFJhZGl4Mih1LG8sbik7dmFyIGM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSh0LzIpLHI9bmV3IEZsb2F0MzJBcnJheSh0LzIpLG89MDtvPE1hdGguY2VpbCh0LzIpO28rKyl7dmFyIGE9KGU/MjotMikqTWF0aC5QSSooby90KTtuW29dPU1hdGguY29zKGEpLHJbb109TWF0aC5zaW4oYSl9cmV0dXJue3JlYWw6bixpbWFnOnJ9fShlLG4pLGw9RG4oYy5yZWFsLGMuaW1hZykubXVsKHUpLGg9aS5hZGQobCksZj1pLnN1YihsKSxkPVRuKGgpLmNvbmNhdChUbihmKSkscD1ObihoKS5jb25jYXQoTm4oZikpO3JldHVybiBEbihkLHApLmFzMUQoKX0sby5wcm90b3R5cGUuZm91cmllclRyYW5zZm9ybUJ5TWF0bXVsPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9bmV3IEZsb2F0MzJBcnJheSgyKmUpLG89MDtvPGU7bysrKXtmb3IodmFyIGE9MCxpPTAscz0wO3M8ZTtzKyspe3ZhciB1PUhvKG8qcyxlLG4pLGM9em8odCxzKTthKz1jLnJlYWwqdS5yZWFsLWMuaW1hZyp1LmltYWcsaSs9Yy5yZWFsKnUuaW1hZytjLmltYWcqdS5yZWFsfW4mJihhLz1lLGkvPWUpLEdvKHIsYSxpLG8pfXJldHVybiByfSxvLnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlLG4pe0MoXCJOSFdDXCI9PT1uLChmdW5jdGlvbigpe3JldHVyblwiT25seSBOSFdDIGRhdGFGb3JtYXQgc3VwcG9ydGVkIG9uIENQVSBmb3IgZGVwdGhUb1NwYWNlLiBHb3QgXCIrbn0pKSxDKGU+MSwoZnVuY3Rpb24oKXtyZXR1cm5cImJsb2NrU2l6ZSBzaG91bGQgYmUgPiAxIGZvciBkZXB0aFRvU3BhY2UsIGJ1dCB3YXM6IFwiK2V9KSk7Zm9yKHZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdLGE9dC5zaGFwZVsyXSxpPXQuc2hhcGVbM10scz1vKmUsdT1hKmUsYz1pLyhlKmUpLGw9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksaD1uZXcgRmxvYXQzMkFycmF5KHIqcyp1KmMpLGY9MCxkPTA7ZDxyOysrZClmb3IodmFyIHA9MDtwPHM7KytwKWZvcih2YXIgdj1NYXRoLmZsb29yKHAvZSksbT1wJWUsZz0wO2c8dTsrK2cpZm9yKHZhciB5PU1hdGguZmxvb3IoZy9lKSx4PShtKmUrZyVlKSpjLGI9MDtiPGM7KytiKXt2YXIgdz1iK3graSooeSthKih2K28qZCkpO2hbZisrXT1sW3ddfXJldHVybiBMbihoLFtyLHMsdSxjXSl9LG8ucHJvdG90eXBlLmJyb2FkY2FzdGVkQmluYXJ5T3A9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89Um8odC5zaGFwZSxlLnNoYXBlKSxhPWRyKG8sbiksaT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxzPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHU9Q28odC5zaGFwZSxvKSxjPUNvKGUuc2hhcGUsbyksbD1hLnZhbHVlcztpZih1Lmxlbmd0aCtjLmxlbmd0aD09PTApZm9yKHZhciBoPTA7aDxsLmxlbmd0aDsrK2gpbFtoXT1yKGlbaCVpLmxlbmd0aF0sc1toJXMubGVuZ3RoXSk7ZWxzZXt2YXIgZj10aGlzLmJ1ZmZlclN5bmModCksZD10aGlzLmJ1ZmZlclN5bmMoZSkscD1mdW5jdGlvbihuKXt2YXIgbz1hLmluZGV4VG9Mb2MobiksaD1vLnNsaWNlKC10LnJhbmspO3UuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGhbdF09MH0pKTt2YXIgcD1mLmxvY1RvSW5kZXgoaCksdj1vLnNsaWNlKC1lLnJhbmspO2MuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHZbdF09MH0pKTt2YXIgbT1kLmxvY1RvSW5kZXgodik7bFtuXT1yKGlbcF0sc1ttXSl9O2ZvcihoPTA7aDxsLmxlbmd0aDsrK2gpcChoKX1yZXR1cm4gYS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9Um8odC5zaGFwZSxlLnNoYXBlKSxvPWRyKHIsXCJmbG9hdDMyXCIpLGE9ZHIocixcImZsb2F0MzJcIiksaT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxzPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHU9Q28odC5zaGFwZSxyKSxjPUNvKGUuc2hhcGUsciksbD1vLnZhbHVlcyxoPWEudmFsdWVzO2lmKHUubGVuZ3RoK2MubGVuZ3RoPT09MClmb3IodmFyIGY9MDtmPGwubGVuZ3RoO2YrKyl7dmFyIGQ9ZiVpLmxlbmd0aCxwPWYlcy5sZW5ndGgsdj1uKGlbMipkXSxpWzIqZCsxXSxzWzIqcF0sc1syKnArMV0pO2xbZl09di5yZWFsLGhbZl09di5pbWFnfWVsc2V7dmFyIG09dGhpcy5idWZmZXJTeW5jKHRoaXMuZGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwpLGc9dGhpcy5idWZmZXJTeW5jKHRoaXMuZGF0YS5nZXQoZS5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHk9ZnVuY3Rpb24ocil7dmFyIGE9by5pbmRleFRvTG9jKHIpLGY9YS5zbGljZSgtdC5yYW5rKTt1LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBmW3RdPTB9KSk7dmFyIGQ9bS5sb2NUb0luZGV4KGYpLHA9YS5zbGljZSgtZS5yYW5rKTtjLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBwW3RdPTB9KSk7dmFyIHY9Zy5sb2NUb0luZGV4KHApLHk9bihpWzIqZF0saVsyKmQrMV0sc1syKnZdLHNbMip2KzFdKTtsW3JdPXkucmVhbCxoW3JdPXkuaW1hZ307Zm9yKGY9MDtmPGwubGVuZ3RoO2YrKyl5KGYpfXJldHVybiB0aGlzLmNvbXBsZXgoby50b1RlbnNvcigpLGEudG9UZW5zb3IoKSl9LG8ucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gWm8odCxlLG4pfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7fSxvLnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiAzMn0sby5wcm90b3R5cGUuZXBzaWxvbj1mdW5jdGlvbigpe3JldHVybiAxZS03fSxvLnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtmb3IodmFyIGk9dC5zaGFwZSxzPWlbMF0sdT1pWzFdLGM9aVsyXSxsPWlbM10saD1lLnNoYXBlWzBdLGY9clswXSxkPXJbMV0scD1kcihbaCxmLGQsbF0sXCJmbG9hdDMyXCIpLHY9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksbT10aGlzLnJlYWRTeW5jKG4uZGF0YUlkKSxnPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHk9dC5zdHJpZGVzLHg9cC5zdHJpZGVzLGI9MDtiPGg7YisrKXt2YXIgdz00KmIsQz12W3ddLEU9dlt3KzFdLFI9dlt3KzJdLEk9dlt3KzNdLGs9bVtiXTtpZighKGs+PXMpKWZvcih2YXIgUz1mPjE/KFItQykqKHUtMSkvKGYtMSk6MCxBPWQ+MT8oSS1FKSooYy0xKS8oZC0xKTowLEQ9MDtEPGY7RCsrKXt2YXIgVD1mPjE/QyoodS0xKStEKlM6LjUqKEMrUikqKHUtMSk7aWYoVDwwfHxUPnUtMSlmb3IodmFyIE49MDtOPGQ7TisrKWZvcih2YXIgRj0wO0Y8bDtGKyspe3ZhciBfPUYrTip4WzJdK0QqeFsxXStiKnhbMF07cC52YWx1ZXNbX109YX1lbHNlIGlmKFwiYmlsaW5lYXJcIj09PW8pe3ZhciBPPU1hdGguZmxvb3IoVCksTT1NYXRoLmNlaWwoVCksQj1ULU87Zm9yKE49MDtOPGQ7TisrKXtpZigocT1kPjE/RSooYy0xKStOKkE6LjUqKEUrSSkqKGMtMSkpPDB8fHE+Yy0xKWZvcihGPTA7RjxsO0YrKyl7Xz1GK04qeFsyXStEKnhbMV0rYip4WzBdO3AudmFsdWVzW19dPWF9ZWxzZXt2YXIgUD1NYXRoLmZsb29yKHEpLEw9TWF0aC5jZWlsKHEpLFc9cS1QO2ZvcihGPTA7RjxsO0YrKyl7dmFyIFU9Z1tfPUYrUCp5WzJdK08qeVsxXStrKnlbMF1dLFY9Z1tfPUYrTCp5WzJdK08qeVsxXStrKnlbMF1dLHo9Z1tfPUYrUCp5WzJdK00qeVsxXStrKnlbMF1dLEc9VSsoVi1VKSpXLEg9eisoZ1tfPUYrTCp5WzJdK00qeVsxXStrKnlbMF1dLXopKlc7Xz1GK04qeFsyXStEKnhbMV0rYip4WzBdLHAudmFsdWVzW19dPUcrKEgtRykqQn19fX1lbHNlIGZvcihOPTA7TjxkOysrTil7dmFyIHE7aWYoKHE9ZD4xP0UqKGMtMSkrTipBOi41KihFK0kpKihjLTEpKTwwfHxxPmMtMSlmb3IoRj0wO0Y8bDtGKyspe189RitOKnhbMl0rRCp4WzFdK2IqeFswXTtwLnZhbHVlc1tfXT1hfWVsc2V7dmFyIEs9TWF0aC5yb3VuZChxKSxqPU1hdGgucm91bmQoVCk7Zm9yKEY9MDtGPGw7RisrKXt2YXIgWD1GK0sqeVsyXStqKnlbMV0rayp5WzBdLFk9RitOKnhbMl0rRCp4WzFdK2IqeFswXTtwLnZhbHVlc1tZXT1nW1hdfX19fX1yZXR1cm4gcC50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPVpyKDAsdCxuKSxhPW8uc2xpY2VSYW5rLGk9by5udW1VcGRhdGVzLHM9by5zbGljZVNpemUsdT1vLnN0cmlkZXMsYz1vLm91dHB1dFNpemU7cmV0dXJuIHRoaXMuc2NhdHRlcih0LGUsbixjLHMsaSxhLHUsciwhMSl9LG8ucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zaGFwZSxyPW5bbi5sZW5ndGgtMV0sbz1qcih0LGUpLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXTtpZigwPT09aSlyZXR1cm4gRm4oW10sYSx0LmR0eXBlKTtmb3IodmFyIGM9bmV3IGd0KFtpLHNdLHQuZHR5cGUpLGw9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksaD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxmPTA7ZjxpO2YrKyl7Zm9yKHZhciBkPVtdLHA9MCx2PTA7djxyO3YrKyl7dmFyIG09bFtmKnIrdl07cCs9bSp1W3ZdLGQucHVzaChtKX1pZihwPDB8fHA+PXQuc2l6ZS9zKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kaWNlczogXCIrZCtcIiBkb2VzIG5vdCBpbmRleCBpbnRvIFwiK3Quc2hhcGUpO2Zvcih2YXIgZz0wO2c8cztnKyspYy52YWx1ZXNbZipzK2ddPWhbcCpzK2ddfXJldHVybiBjLnRvVGVuc29yKCkucmVzaGFwZShhKX0sby5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1acigwLHQsbiksbz1yLnNsaWNlUmFuayxhPXIubnVtVXBkYXRlcyxpPXIuc2xpY2VTaXplLHM9ci5zdHJpZGVzLHU9ci5vdXRwdXRTaXplLGM9T24oMCk7cmV0dXJuIHRoaXMuc2NhdHRlcih0LGUsbix1LGksYSxvLHMsYywhMCl9LG8ucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVAobj1ufHxqKGUpLGsodCkpO3JldHVybiByLmZpbGwoZSksTHQubWFrZVRlbnNvcihyLHQsbix0aGlzKX0sby5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwib25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCBmb3Igc3RyaW5nIHRlbnNvcnNcIik7cmV0dXJuIHRoaXMuZmlsbCh0LnNoYXBlLDEsdC5kdHlwZSl9LG8ucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbih0KXt2YXIgZT1QKHQuZHR5cGUsayh0LnNoYXBlKSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsdC5kdHlwZSl9LG8ucHJvdG90eXBlLmxpbnNwYWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gV28odCxlLG4pfSxvLnByb3RvdHlwZS5zY2F0dGVyPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1LGMpe3ZhciBsPVtyL28sb10saD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxmPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpO2lmKDA9PT1yKXJldHVybiBGbihbXSxuLGUuZHR5cGUpO3ZhciBkPW5ldyBndChsLGUuZHR5cGUpO2QudmFsdWVzLmZpbGwodGhpcy5yZWFkU3luYyh1LmRhdGFJZClbMF0pO2Zvcih2YXIgcD0wO3A8YTtwKyspe2Zvcih2YXIgdj1bXSxtPTAsZz0wO2c8aTtnKyspe3ZhciB5PWhbcCppK2ddO3YucHVzaCh5KSxtKz15KnNbZ119aWYobTwwfHxtPj1yL28pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiBcIit2K1wiIGRvZXMgbm90IGluZGV4IGludG8gXCIrbik7Zm9yKHZhciB4PTA7eDxvO3grKyljP2QudmFsdWVzW20qbyt4XSs9ZltwKm8reF06ZC52YWx1ZXNbbSpvK3hdPTA9PT1lLnJhbms/ZlswXTpmW3Aqbyt4XX1yZXR1cm4gZC50b1RlbnNvcigpLnJlc2hhcGUobil9LG99KGJvKTtMdC5yZWdpc3RlckJhY2tlbmQoXCJjcHVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEtofSksMSk7Zm9yKHZhciBqaD0wLFhoPVt7a2VybmVsTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjVcIixiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dHMsbj10LmJhY2tlbmQscj10LmF0dHJzLG89ZSxhPW8uYm94ZXMsaT1vLnNjb3JlcyxzPXIsdT1zLm1heE91dHB1dFNpemUsYz1zLmlvdVRocmVzaG9sZCxsPXMuc2NvcmVUaHJlc2hvbGQsaD1zLnNvZnRObXNTaWdtYSxmPW47SGgoYSxcIk5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlXCIpO3ZhciBkPVhvKGYuZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxmLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMsdSxjLGwsaCk7cmV0dXJuW2Quc2VsZWN0ZWRJbmRpY2VzLGQuc2VsZWN0ZWRTY29yZXNdfX0se2tlcm5lbE5hbWU6XCJTcXVhcmVcIixiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dHMsbj10LmJhY2tlbmQscj1lLngsbz1uO0hoKHIsXCJzcXVhcmVcIik7Zm9yKHZhciBhPW8uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxpPW5ldyBGbG9hdDMyQXJyYXkoYS5sZW5ndGgpLHM9MDtzPGEubGVuZ3RoOysrcyl7dmFyIHU9YVtzXTtpW3NdPXUqdX1yZXR1cm57ZGF0YUlkOm8ud3JpdGUoaSxyLnNoYXBlLHIuZHR5cGUpLHNoYXBlOnIuc2hhcGUsZHR5cGU6ci5kdHlwZX19fSx7a2VybmVsTmFtZTpldSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dHMsbj10LmJhY2tlbmQscj1lLG89ci5hLGE9ci5iLGk9bjtIaChbbyxhXSxldSk7dmFyIHM9aS5kYXRhLmdldChvLmRhdGFJZCkudmFsdWVzLHU9aS5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGM9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPVJvKHQsZSkscz1pLmxlbmd0aCx1PSQoaSksYz1CKG8sayhpKSksbD10Lmxlbmd0aCxoPWUubGVuZ3RoLGY9JCh0KSxkPSQoZSkscD1Dbyh0LGkpLHY9Q28oZSxpKTtpZihwLmxlbmd0aCt2Lmxlbmd0aD09PTApZm9yKHZhciBtPTA7bTxjLmxlbmd0aDsrK20pY1ttXT1hKG5bbSVuLmxlbmd0aF0sclttJXIubGVuZ3RoXSk7ZWxzZXt2YXIgZz1mdW5jdGlvbih0KXt2YXIgZT1pdCh0LHMsdSksbz1lLnNsaWNlKC1sKTtwLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBvW3RdPTB9KSk7dmFyIGk9YXQobyxsLGYpLG09ZS5zbGljZSgtaCk7di5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gbVt0XT0wfSkpO3ZhciBnPWF0KG0saCxkKTtjW3RdPWEobltpXSxyW2ddKX07Zm9yKG09MDttPGMubGVuZ3RoOysrbSlnKG0pfXJldHVybltjLGldfShvLnNoYXBlLGEuc2hhcGUscyx1LG8uZHR5cGUsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC1lO3JldHVybiBuKm59KSksbD1jWzBdLGg9Y1sxXTtyZXR1cm57ZGF0YUlkOmkud3JpdGUobCxoLG8uZHR5cGUpLHNoYXBlOmgsZHR5cGU6by5kdHlwZX19fV07amg8WGgubGVuZ3RoO2poKyspe2QoWGhbamhdKX12YXIgWWgsJGg9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIGU9dWEoKSxuPXRbMF0scj10WzFdO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgdGV4UiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB0ZXhDID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGRlcHRoID0gY29vcmRzWzJdO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIrcitcIi4wLCBcIituK1wiLjApO1xcblxcbiAgICAgICAgdmVjNCB2YWx1ZXMgPSBcIitlLnRleHR1cmUyRCtcIihBLCB1dik7XFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFFoPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSExLHRoaXMucGFja2VkT3V0cHV0PSEwO3ZhciBlPXVhKCksbj10WzBdLHI9dFsxXTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBmb3IoaW50IHJvdz0wOyByb3c8PTE7IHJvdysrKSB7XFxuICAgICAgICAgIGZvcihpbnQgY29sPTA7IGNvbDw9MTsgY29sKyspIHtcXG4gICAgICAgICAgICB0ZXhDID0gY29vcmRzWzFdICsgcm93O1xcbiAgICAgICAgICAgIGRlcHRoID0gY29vcmRzWzJdICsgY29sO1xcblxcbiAgICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIityK1wiLjAsIFwiK24rXCIuMCk7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSBcIitlLnRleHR1cmUyRCtcIihBLCB1dik7XFxuICAgICAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDMpIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJlc3VsdFtyb3cgKiAyICsgY29sXSA9IGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIitlLm91dHB1dCtcIiA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifTtmb3IodmFyIEpoPTAsWmg9W3trZXJuZWxOYW1lOlwiRnJvbVBpeGVsc1wiLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9dC5hdHRycyxvPWUucGl4ZWxzLGE9ci5udW1DaGFubmVscyxzPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MVmlkZW9FbGVtZW50JiZvIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCx1PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50JiZvIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCxjPXM/W28udmlkZW9XaWR0aCxvLnZpZGVvSGVpZ2h0XTpbby53aWR0aCxvLmhlaWdodF0sbD1jWzBdLGg9Y1sxXSxmPVtoLGxdLGQ9W2gsbCxhXTsodXx8cykmJihudWxsPT1ZaCYmKFloPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpKSxZaC5jYW52YXMud2lkdGg9bCxZaC5jYW52YXMuaGVpZ2h0PWgsWWguZHJhd0ltYWdlKG8sMCwwLGwsaCksbz1ZaC5jYW52YXMpO3ZhciBwPW4ubWFrZVRlbnNvckluZm8oZixcImludDMyXCIpO24udGV4RGF0YS5nZXQocC5kYXRhSWQpLnVzYWdlPXp0LlBJWEVMUyxuLmdwZ3B1LnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShuLmdldFRleHR1cmUocC5kYXRhSWQpLG8pO3ZhciB2PWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgUWgoZCk6bmV3ICRoKGQpLG09bi5ydW5XZWJHTFByb2dyYW0odixbcF0sXCJpbnQzMlwiKTtyZXR1cm4gbi5kaXNwb3NlRGF0YShwLmRhdGFJZCksbX19LHtrZXJuZWxOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9dC5hdHRycztkbihcInRmLm5vbk1heFN1cHByZXNzaW9uKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKCkgaW5zdGVhZFwiKTt2YXIgbz1lLGE9by5ib3hlcyxpPW8uc2NvcmVzLHM9cix1PXMubWF4T3V0cHV0U2l6ZSxjPXMuaW91VGhyZXNob2xkLGw9cy5zY29yZVRocmVzaG9sZCxoPXMuc29mdE5tc1NpZ21hLGY9bixkPVhvKGYucmVhZFN5bmMoYS5kYXRhSWQpLGYucmVhZFN5bmMoaS5kYXRhSWQpLHUsYyxsLGgpO3JldHVybltkLnNlbGVjdGVkSW5kaWNlcyxkLnNlbGVjdGVkU2NvcmVzXX19LHtrZXJuZWxOYW1lOlwiU3F1YXJlXCIsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dHMsbj10LmJhY2tlbmQscj1lLngsbz1uLGE9bmV3IENzKHIuc2hhcGUsXCJyZXR1cm4geCAqIHg7XCIpO3JldHVybiBvLnJ1bldlYkdMUHJvZ3JhbShhLFtyXSxyLmR0eXBlKX19LHtrZXJuZWxOYW1lOmV1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9ZSxvPXIuYSxhPXIuYixzPW4sdT1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFwicmV0dXJuIChhIC0gYikgKiAoYSAtIGIpO1wiLG8uc2hhcGUsYS5zaGFwZSk6bmV3IEJhKFwicmV0dXJuIChhIC0gYikgKiAoYSAtIGIpO1wiLG8uc2hhcGUsYS5zaGFwZSk7cmV0dXJuIHMuY29tcGlsZUFuZFJ1bih1LFtvLGFdKX19XTtKaDxaaC5sZW5ndGg7SmgrKyl7ZChaaFtKaF0pfWZvcih2YXIgdGY9MCxlZj1be2tlcm5lbE5hbWU6XCJTcXVhcmVcIixncmFkRnVuYzpmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi50b0Zsb2F0KCkubXVsKDIpKX19fX0se2tlcm5lbE5hbWU6ZXUsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPU9uKDIpO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIGdjKHQsZ2MobyxDYyhuLHIpKSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gZ2ModCxnYyhvLENjKHIsbikpKX19fX1dO3RmPGVmLmxlbmd0aDt0ZisrKXtwKGVmW3RmXSl9dmFyIG5mPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuZmV0Y2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZmV0Y2godCxlKX0sdC5wcm90b3R5cGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfSx0LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihcInV0Zi04XCIhPT1lJiZcInV0ZjhcIiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIGVuY29kZXIgb25seSBzdXBwb3J0cyB1dGYtOCwgYnV0IGdvdCBcIitlKTtyZXR1cm4gbnVsbD09dGhpcy50ZXh0RW5jb2RlciYmKHRoaXMudGV4dEVuY29kZXI9bmV3IFRleHRFbmNvZGVyKSx0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh0KX0sdC5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlKS5kZWNvZGUodCl9LHR9KCk7aSgpLmdldChcIklTX0JST1dTRVJcIikmJmkoKS5zZXRQbGF0Zm9ybShcImJyb3dzZXJcIixuZXcgbmYpO3ZhciByZixvZj1mdW5jdGlvbigpe3JldHVybiByZXF1aXJlKFwibm9kZS1mZXRjaFwiKX0sYWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy51dGlsPXJlcXVpcmUoXCJ1dGlsXCIpLHRoaXMudGV4dEVuY29kZXI9bmV3IHRoaXMudXRpbC5UZXh0RW5jb2Rlcn1yZXR1cm4gdC5wcm90b3R5cGUuZmV0Y2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9aSgpLmdsb2JhbC5mZXRjaD9pKCkuZ2xvYmFsLmZldGNoKHQsZSk6KG51bGw9PXJmJiYocmY9b2YoKSkscmYodCxlKSl9LHQucHJvdG90eXBlLm5vdz1mdW5jdGlvbigpe3ZhciB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyp0WzBdK3RbMV0vMWU2fSx0LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihcInV0Zi04XCIhPT1lJiZcInV0ZjhcIiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBidWlsdC1pbiBlbmNvZGVyIG9ubHkgc3VwcG9ydHMgdXRmLTgsIGJ1dCBnb3QgXCIrZSk7cmV0dXJuIHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHQpfSx0LnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09PXQubGVuZ3RoP1wiXCI6bmV3IHRoaXMudXRpbC5UZXh0RGVjb2RlcihlKS5kZWNvZGUodCl9LHR9KCk7aSgpLmdldChcIklTX05PREVcIikmJmkoKS5zZXRQbGF0Zm9ybShcIm5vZGVcIixuZXcgYWYpO3ZhciBzZj17ZmxvYXQzMjo0LGludDMyOjQsdWludDE2OjIsdWludDg6MSxib29sOjF9LHVmPTQ7ZnVuY3Rpb24gY2YodCxlKXtmb3IodmFyIG49e30scj0wLG89ZnVuY3Rpb24oZSl7dmFyIG89ZS5uYW1lLGE9ZS5kdHlwZSxpPWUuc2hhcGUscz1rKGkpLHU9dm9pZCAwO2lmKFwicXVhbnRpemF0aW9uXCJpbiBlKXt2YXIgYz1lLnF1YW50aXphdGlvbjtpZihcInVpbnQ4XCIhPT1jLmR0eXBlJiZcInVpbnQxNlwiIT09Yy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgXCIrZS5uYW1lK1wiIGhhcyB1bmtub3duIHF1YW50aXphdGlvbiBkdHlwZSBcIitjLmR0eXBlK1wiLiBTdXBwb3J0ZWQgcXVhbnRpemF0aW9uIGR0eXBlcyBhcmU6ICd1aW50OCcgYW5kICd1aW50MTYnLlwiKTt2YXIgbD1zZltjLmR0eXBlXSxoPXQuc2xpY2UocixyK3MqbCksZj1cInVpbnQ4XCI9PT1jLmR0eXBlP25ldyBVaW50OEFycmF5KGgpOm5ldyBVaW50MTZBcnJheShoKTtpZihcImZsb2F0MzJcIj09PWEpdT1GbG9hdDMyQXJyYXkuZnJvbShmLChmdW5jdGlvbih0KXtyZXR1cm4gdCpjLnNjYWxlK2MubWlufSkpO2Vsc2V7aWYoXCJpbnQzMlwiIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK28rXCInOiBcIithKTt1PUludDMyQXJyYXkuZnJvbShmLChmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KmMuc2NhbGUrYy5taW4pfSkpfXIrPXMqbH1lbHNlIGlmKFwic3RyaW5nXCI9PT1hKXt2YXIgZD1rKGUuc2hhcGUpO3U9W107Zm9yKHZhciBwPTA7cDxkO3ArKyl7dmFyIHY9bmV3IFVpbnQzMkFycmF5KHQuc2xpY2UocixyK3VmKSlbMF07cis9dWY7dmFyIG09bmV3IFVpbnQ4QXJyYXkodC5zbGljZShyLHIrdikpO3UucHVzaChtKSxyKz12fX1lbHNle3ZhciBnPXNmW2FdO2g9dC5zbGljZShyLHIrcypnKTtpZihcImZsb2F0MzJcIj09PWEpdT1uZXcgRmxvYXQzMkFycmF5KGgpO2Vsc2UgaWYoXCJpbnQzMlwiPT09YSl1PW5ldyBJbnQzMkFycmF5KGgpO2Vsc2V7aWYoXCJib29sXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO3U9bmV3IFVpbnQ4QXJyYXkoaCl9cis9cypnfW5bb109Rm4odSxpLGEpfSxhPTAsaT1lO2E8aS5sZW5ndGg7YSsrKXtvKGlbYV0pfXJldHVybiBufWZ1bmN0aW9uIGxmKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdmFsdWU6IFwiK0pTT04uc3RyaW5naWZ5KHQpKTt2YXIgZT0wLG49W107dC5mb3JFYWNoKChmdW5jdGlvbih0KXtpZihlKz10LmJ5dGVMZW5ndGgsbi5wdXNoKHQuYnl0ZUxlbmd0aD09PXQuYnVmZmVyLmJ5dGVMZW5ndGg/dDpuZXcgdC5jb25zdHJ1Y3Rvcih0KSksISh0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFR5cGVkQXJyYXkgc3VidHlwZTogXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKX0pKTt2YXIgcj1uZXcgVWludDhBcnJheShlKSxvPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5zZXQobmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLG8pLG8rPXQuYnl0ZUxlbmd0aH0pKSxyLmJ1ZmZlcn12YXIgaGY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlciYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBCbG9ifHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYXRvYnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGJ0b2EpO2Z1bmN0aW9uIGZmKHQpe3JldHVybiBoZj9CdWZmZXIuYnl0ZUxlbmd0aCh0KTpuZXcgQmxvYihbdF0pLnNpemV9ZnVuY3Rpb24gZGYodCl7dmFyIGU9MDt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2UrPXQuYnl0ZUxlbmd0aH0pKTt2YXIgbj1uZXcgVWludDhBcnJheShlKSxyPTA7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5zZXQobmV3IFVpbnQ4QXJyYXkodCkscikscis9dC5ieXRlTGVuZ3RofSkpLG4uYnVmZmVyfWZ1bmN0aW9uIHBmKHQpe2Zvcih0PXQudHJpbSgpO3QuZW5kc1dpdGgoXCIvXCIpOyl0PXQuc2xpY2UoMCx0Lmxlbmd0aC0xKTt2YXIgZT10LnNwbGl0KFwiL1wiKTtyZXR1cm4gZVtlLmxlbmd0aC0xXX1mdW5jdGlvbiB2Zih0KXtpZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBKU09OIG1vZGVsIHRvcG9sb2d5LCByZWNlaXZlZCBBcnJheUJ1ZmZlci5cIik7cmV0dXJue2RhdGVTYXZlZDpuZXcgRGF0ZSxtb2RlbFRvcG9sb2d5VHlwZTpcIkpTT05cIixtb2RlbFRvcG9sb2d5Qnl0ZXM6bnVsbD09dC5tb2RlbFRvcG9sb2d5PzA6ZmYoSlNPTi5zdHJpbmdpZnkodC5tb2RlbFRvcG9sb2d5KSksd2VpZ2h0U3BlY3NCeXRlczpudWxsPT10LndlaWdodFNwZWNzPzA6ZmYoSlNPTi5zdHJpbmdpZnkodC53ZWlnaHRTcGVjcykpLHdlaWdodERhdGFCeXRlczpudWxsPT10LndlaWdodERhdGE/MDp0LndlaWdodERhdGEuYnl0ZUxlbmd0aH19dmFyIG1mPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuc2F2ZVJvdXRlcnM9W10sdGhpcy5sb2FkUm91dGVycz1bXX1yZXR1cm4gdC5nZXRJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3RlclNhdmVSb3V0ZXI9ZnVuY3Rpb24oZSl7dC5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzLnB1c2goZSl9LHQucmVnaXN0ZXJMb2FkUm91dGVyPWZ1bmN0aW9uKGUpe3QuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVycy5wdXNoKGUpfSx0LmdldFNhdmVIYW5kbGVycz1mdW5jdGlvbihlKXtyZXR1cm4gdC5nZXRIYW5kbGVycyhlLFwic2F2ZVwiKX0sdC5nZXRMb2FkSGFuZGxlcnM9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5nZXRIYW5kbGVycyhlLFwibG9hZFwiLG4pfSx0LmdldEhhbmRsZXJzPWZ1bmN0aW9uKGUsbixyKXt2YXIgbz1bXTtyZXR1cm4oXCJsb2FkXCI9PT1uP3QuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVyczp0LmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnMpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPXQoZSxyKTtudWxsIT09biYmby5wdXNoKG4pfSkpLG99LHR9KCksZ2Y9XCI6Ly9cIix5Zj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLm1hbmFnZXJzPXt9fXJldHVybiB0LmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXQuaW5zdGFuY2UmJih0Lmluc3RhbmNlPW5ldyB0KSx0Lmluc3RhbmNlfSx0LnJlZ2lzdGVyTWFuYWdlcj1mdW5jdGlvbihlLG4pe0MobnVsbCE9ZSwoZnVuY3Rpb24oKXtyZXR1cm5cInNjaGVtZSBtdXN0IG5vdCBiZSB1bmRlZmluZWQgb3IgbnVsbC5cIn0pKSxlLmVuZHNXaXRoKGdmKSYmKGU9ZS5zbGljZSgwLGUuaW5kZXhPZihnZikpKSxDKGUubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzY2hlbWUgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nLlwifSkpO3ZhciByPXQuZ2V0SW5zdGFuY2UoKTtDKG51bGw9PXIubWFuYWdlcnNbZV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJBIG1vZGVsIHN0b3JlIG1hbmFnZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBzY2hlbWUgJ1wiK2UrXCInLlwifSkpLHIubWFuYWdlcnNbZV09bn0sdC5nZXRNYW5hZ2VyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vyc1t0XTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIG1hbmFnZXIgZm9yIHNjaGVtZSAnXCIrdCtcIidcIik7cmV0dXJuIGV9LHQuZ2V0U2NoZW1lcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEluc3RhbmNlKCkubWFuYWdlcnMpfSx0fSgpO2Z1bmN0aW9uIHhmKHQpe2lmKC0xPT09dC5pbmRleE9mKGdmKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdXJsIHN0cmluZyBwcm92aWRlZCBkb2VzIG5vdCBjb250YWluIGEgc2NoZW1lLiBTdXBwb3J0ZWQgc2NoZW1lcyBhcmU6IFwiK3lmLmdldFNjaGVtZXMoKS5qb2luKFwiLFwiKSk7cmV0dXJue3NjaGVtZTp0LnNwbGl0KGdmKVswXSxwYXRoOnQuc3BsaXQoZ2YpWzFdfX1mdW5jdGlvbiBiZih0LGUsbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPSExKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixhLGkscyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gQyh0IT09ZSwoZnVuY3Rpb24oKXtyZXR1cm5cIk9sZCBwYXRoIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWU6ICdcIit0K1wiJ1wifSkpLEMoKG49bWYuZ2V0TG9hZEhhbmRsZXJzKHQpKS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2Ugbm8gbG9hZCBoYW5kbGVyIGlzIGZvdW5kIGZvciBzb3VyY2UgVVJMIFwiK3QrXCIuXCJ9KSksQyhuLmxlbmd0aDwyLChmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgbG9hZCBoYW5kbGVycyBmb3Igc291cmNlIFVSTCBcIit0K1wiLlwifSkpLGE9blswXSxDKChpPW1mLmdldFNhdmVIYW5kbGVycyhlKSkubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIHNhdmUgaGFuZGxlciBpcyBmb3VuZCBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCJ9KSksQyhpLmxlbmd0aDwyLChmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgc2F2ZSBoYW5kbGVycyBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCJ9KSkscz1pWzBdLHU9eGYodCkuc2NoZW1lLGM9eGYodCkucGF0aCxsPXU9PT14Zih0KS5zY2hlbWUsWzQsYS5sb2FkKCldO2Nhc2UgMTpyZXR1cm4gaD1yLnNlbnQoKSxvJiZsP1s0LHlmLmdldE1hbmFnZXIodSkucmVtb3ZlTW9kZWwoYyldOlszLDNdO2Nhc2UgMjpyLnNlbnQoKSxyLmxhYmVsPTM7Y2FzZSAzOnJldHVybls0LHMuc2F2ZShoKV07Y2FzZSA0OnJldHVybiBmPXIuc2VudCgpLCFvfHxsP1szLDZdOls0LHlmLmdldE1hbmFnZXIodSkucmVtb3ZlTW9kZWwoYyldO2Nhc2UgNTpyLnNlbnQoKSxyLmxhYmVsPTY7Y2FzZSA2OnJldHVyblsyLGYubW9kZWxBcnRpZmFjdHNJbmZvXX19KSl9KSl9dmFyIHdmPVwibW9kZWxzX3N0b3JlXCIsQ2Y9XCJtb2RlbF9pbmZvX3N0b3JlXCI7ZnVuY3Rpb24gRWYoKXtpZighaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBvYnRhaW4gSW5kZXhlZERCIGZhY3RvcnkgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudGlzIG5vdCBhIHdlYiBicm93c2VyLlwiKTt2YXIgdD13aW5kb3d8fHNlbGYsZT10LmluZGV4ZWREQnx8dC5tb3pJbmRleGVkREJ8fHQud2Via2l0SW5kZXhlZERCfHx0Lm1zSW5kZXhlZERCfHx0LnNoaW1JbmRleGVkREI7aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IEluZGV4ZWREQi5cIik7cmV0dXJuIGV9ZnVuY3Rpb24gUmYodCl7dmFyIGU9dC5yZXN1bHQ7ZS5jcmVhdGVPYmplY3RTdG9yZSh3Zix7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSksZS5jcmVhdGVPYmplY3RTdG9yZShDZix7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSl9dmFyIElmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmluZGV4ZWREQj1FZigpLG51bGw9PXR8fCF0KXRocm93IG5ldyBFcnJvcihcIkZvciBJbmRleGVkREIsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPXR9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCx0KV19KSl9KSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCldfSkpfSkpfSx0LnByb3RvdHlwZS5kYXRhYmFzZUFjdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LHIpe3ZhciBvPW4uaW5kZXhlZERCLm9wZW4oXCJ0ZW5zb3JmbG93anNcIiwxKTtvLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBSZihvKX0sby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgYT1vLnJlc3VsdDtpZihudWxsPT1lKXt2YXIgaT1hLnRyYW5zYWN0aW9uKHdmLFwicmVhZG9ubHlcIikscz1pLm9iamVjdFN0b3JlKHdmKS5nZXQobi5tb2RlbFBhdGgpO3Mub25zdWNjZXNzPWZ1bmN0aW9uKCl7aWYobnVsbD09cy5yZXN1bHQpcmV0dXJuIGEuY2xvc2UoKSxyKG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIrbi5tb2RlbFBhdGgrXCInIGluIEluZGV4ZWREQi5cIikpO3Qocy5yZXN1bHQubW9kZWxBcnRpZmFjdHMpfSxzLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKHMuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX1lbHNle3ZhciB1LGM9dmYoZSksbD1hLnRyYW5zYWN0aW9uKENmLFwicmVhZHdyaXRlXCIpLGg9bC5vYmplY3RTdG9yZShDZiksZj1oLnB1dCh7bW9kZWxQYXRoOm4ubW9kZWxQYXRoLG1vZGVsQXJ0aWZhY3RzSW5mbzpjfSk7Zi5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgbz0odT1hLnRyYW5zYWN0aW9uKHdmLFwicmVhZHdyaXRlXCIpKS5vYmplY3RTdG9yZSh3ZikucHV0KHttb2RlbFBhdGg6bi5tb2RlbFBhdGgsbW9kZWxBcnRpZmFjdHM6ZSxtb2RlbEFydGlmYWN0c0luZm86Y30pO28ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHQoe21vZGVsQXJ0aWZhY3RzSW5mbzpjfSl9LG8ub25lcnJvcj1mdW5jdGlvbih0KXt2YXIgZT0oaD1sLm9iamVjdFN0b3JlKENmKSkuZGVsZXRlKG4ubW9kZWxQYXRoKTtlLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCkscihvLmVycm9yKX0sZS5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscihvLmVycm9yKX19fSxmLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKGYuZXJyb3IpfSxsLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT11P2EuY2xvc2UoKTp1Lm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX19fSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIoby5lcnJvcil9fSkpfSx0LlVSTF9TQ0hFTUU9XCJpbmRleGVkZGI6Ly9cIix0fSgpLGtmPWZ1bmN0aW9uKHQpe3JldHVybiBpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoSWYuVVJMX1NDSEVNRSk/KGU9dC5zbGljZShJZi5VUkxfU0NIRU1FLmxlbmd0aCksbmV3IElmKGUpKTpudWxsO3ZhciBlfTttZi5yZWdpc3RlclNhdmVSb3V0ZXIoa2YpLG1mLnJlZ2lzdGVyTG9hZFJvdXRlcihrZik7dmFyIFNmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuaW5kZXhlZERCPUVmKCl9cmV0dXJuIHQucHJvdG90eXBlLmxpc3RNb2RlbHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtyZXR1cm5bMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSxuKXt2YXIgcj10LmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7ci5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gUmYocil9LHIub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIHQ9ci5yZXN1bHQsbz10LnRyYW5zYWN0aW9uKENmLFwicmVhZG9ubHlcIiksYT1vLm9iamVjdFN0b3JlKENmKS5nZXRBbGwoKTthLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2Zvcih2YXIgdD17fSxuPTAscj1hLnJlc3VsdDtuPHIubGVuZ3RoO24rKyl7dmFyIG89cltuXTt0W28ubW9kZWxQYXRoXT1vLm1vZGVsQXJ0aWZhY3RzSW5mb31lKHQpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY2xvc2UoKSxuKGEuZXJyb3IpfSxvLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9zZSgpfX0sci5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBuKHIuZXJyb3IpfX0pKV19KSl9KSl9LHQucHJvdG90eXBlLnJlbW92ZU1vZGVsPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiB0PShyPXQpLnN0YXJ0c1dpdGgoSWYuVVJMX1NDSEVNRSk/ci5zbGljZShJZi5VUkxfU0NIRU1FLmxlbmd0aCk6cixbMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24obixyKXt2YXIgbz1lLmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7by5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gUmYobyl9LG8ub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGUsYT1vLnJlc3VsdCxpPWEudHJhbnNhY3Rpb24oQ2YsXCJyZWFkd3JpdGVcIikscz1pLm9iamVjdFN0b3JlKENmKSx1PXMuZ2V0KHQpO3Uub25zdWNjZXNzPWZ1bmN0aW9uKCl7aWYobnVsbD09dS5yZXN1bHQpcmV0dXJuIGEuY2xvc2UoKSxyKG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIrdCtcIicgaW4gSW5kZXhlZERCLlwiKSk7dmFyIG89cy5kZWxldGUodCksaT1mdW5jdGlvbigpe3ZhciBvPShlPWEudHJhbnNhY3Rpb24od2YsXCJyZWFkd3JpdGVcIikpLm9iamVjdFN0b3JlKHdmKS5kZWxldGUodCk7by5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gbih1LnJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8pfSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIodS5lcnJvcil9fTtvLm9uc3VjY2Vzcz1pLG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gaSgpLGEuY2xvc2UoKSxyKHUuZXJyb3IpfX0sdS5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscih1LmVycm9yKX0saS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7bnVsbD09ZT9hLmNsb3NlKCk6ZS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKX19fSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIoby5lcnJvcil9fSkpXX0pKX0pKX0sdH0oKTtpZihpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdHJ5e3lmLnJlZ2lzdGVyTWFuYWdlcihJZi5VUkxfU0NIRU1FLG5ldyBTZil9Y2F0Y2godCl7fXZhciBBZj1cIi9cIixEZj1cInRlbnNvcmZsb3dqc19tb2RlbHNcIixUZj1cImluZm9cIixOZj1cIm1vZGVsX3RvcG9sb2d5XCIsRmY9XCJ3ZWlnaHRfc3BlY3NcIixfZj1cIndlaWdodF9kYXRhXCIsT2Y9XCJtb2RlbF9tZXRhZGF0YVwiO2Z1bmN0aW9uIE1mKHQpe3JldHVybntpbmZvOltEZix0LFRmXS5qb2luKEFmKSx0b3BvbG9neTpbRGYsdCxOZl0uam9pbihBZiksd2VpZ2h0U3BlY3M6W0RmLHQsRmZdLmpvaW4oQWYpLHdlaWdodERhdGE6W0RmLHQsX2ZdLmpvaW4oQWYpLG1vZGVsTWV0YWRhdGE6W0RmLHQsT2ZdLmpvaW4oQWYpfX1mdW5jdGlvbiBCZih0KXt2YXIgZT10LnNwbGl0KEFmKTtpZihlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5IGZvcm1hdDogXCIrdCk7cmV0dXJuIGUuc2xpY2UoMSxlLmxlbmd0aC0xKS5qb2luKEFmKX12YXIgUGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKCFpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIil8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3d8fHZvaWQgMD09PXdpbmRvdy5sb2NhbFN0b3JhZ2UpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBsb2NhbCBzdG9yYWdlLlwiKTtpZih0aGlzLkxTPXdpbmRvdy5sb2NhbFN0b3JhZ2UsbnVsbD09dHx8IXQpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGxvY2FsIHN0b3JhZ2UsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPXQsdGhpcy5rZXlzPU1mKHRoaXMubW9kZWxQYXRoKX1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7ZT1KU09OLnN0cmluZ2lmeSh0Lm1vZGVsVG9wb2xvZ3kpLG49SlNPTi5zdHJpbmdpZnkodC53ZWlnaHRTcGVjcyksbz12Zih0KTt0cnl7cmV0dXJuIHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMuaW5mbyxKU09OLnN0cmluZ2lmeShvKSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy50b3BvbG9neSxlKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzLG4pLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSxmdW5jdGlvbih0KXtpZihoZilyZXR1cm4gQnVmZmVyLmZyb20odCkudG9TdHJpbmcoXCJiYXNlNjRcIik7Zm9yKHZhciBlPW5ldyBVaW50OEFycmF5KHQpLG49XCJcIixyPTAsbz1lLmxlbmd0aDtyPG87cisrKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtyXSk7cmV0dXJuIGJ0b2Eobil9KHQud2VpZ2h0RGF0YSkpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMubW9kZWxNZXRhZGF0YSxKU09OLnN0cmluZ2lmeSh7Zm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeSx1c2VyRGVmaW5lZE1ldGFkYXRhOnQudXNlckRlZmluZWRNZXRhZGF0YX0pKSxbMix7bW9kZWxBcnRpZmFjdHNJbmZvOm99XX1jYXRjaCh0KXt0aHJvdyB0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLmluZm8pLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIHRvIGxvY2FsIHN0b3JhZ2U6IHNpemUgcXVvdGEgYmVpbmcgZXhjZWVkZWQgaXMgYSBwb3NzaWJsZSBjYXVzZSBvZiB0aGlzIGZhaWx1cmU6IG1vZGVsVG9wb2xvZ3lCeXRlcz1cIitvLm1vZGVsVG9wb2xvZ3lCeXRlcytcIiwgd2VpZ2h0U3BlY3NCeXRlcz1cIitvLndlaWdodFNwZWNzQnl0ZXMrXCIsIHdlaWdodERhdGFCeXRlcz1cIitvLndlaWdodERhdGFCeXRlcytcIi5cIil9cmV0dXJuWzJdfSkpfSkpfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUsbixvLGEsaSxzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe2lmKG51bGw9PSh0PUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5pbmZvKSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZXJlIGlzIG5vIG1vZGVsIHdpdGggbmFtZSAnXCIrdGhpcy5tb2RlbFBhdGgrXCInXCIpO2lmKFwiSlNPTlwiIT09dC5tb2RlbFRvcG9sb2d5VHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlIGRvZXMgbm90IHN1cHBvcnQgbG9hZGluZyBub24tSlNPTiBtb2RlbCB0b3BvbG9neSB5ZXQuXCIpO2lmKGU9e30sbnVsbD09KG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5KSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB0b3BvbG9neSBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGlzIG1pc3NpbmcuXCIpO2lmKGUubW9kZWxUb3BvbG9neT1uLG51bGw9PShvPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcykpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgd2VpZ2h0IHNwZWNzIG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgYXJlIG1pc3NpbmcuXCIpO2lmKGUud2VpZ2h0U3BlY3M9byxudWxsIT0oYT10aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEpKSYmKGk9SlNPTi5wYXJzZShhKSxlLmZvcm1hdD1pLmZvcm1hdCxlLmdlbmVyYXRlZEJ5PWkuZ2VuZXJhdGVkQnksZS5jb252ZXJ0ZWRCeT1pLmNvbnZlcnRlZEJ5LGUudXNlckRlZmluZWRNZXRhZGF0YT1pLnVzZXJEZWZpbmVkTWV0YWRhdGEpLG51bGw9PShzPXRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSBiaW5hcnkgd2VpZ2h0IHZhbHVlcyBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGFyZSBtaXNzaW5nLlwiKTtyZXR1cm4gZS53ZWlnaHREYXRhPWZ1bmN0aW9uKHQpe2lmKGhmKXt2YXIgZT1CdWZmZXIuZnJvbSh0LFwiYmFzZTY0XCIpO3JldHVybiBlLmJ1ZmZlci5zbGljZShlLmJ5dGVPZmZzZXQsZS5ieXRlT2Zmc2V0K2UuYnl0ZUxlbmd0aCl9Zm9yKHZhciBuPWF0b2IodCkscj1uZXcgVWludDhBcnJheShuLmxlbmd0aCksbz0wO288bi5sZW5ndGg7KytvKXIuc2V0KFtuLmNoYXJDb2RlQXQobyldLG8pO3JldHVybiByLmJ1ZmZlcn0ocyksWzIsZV19KSl9KSl9LHQuVVJMX1NDSEVNRT1cImxvY2Fsc3RvcmFnZTovL1wiLHR9KCksTGY9ZnVuY3Rpb24odCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aChQZi5VUkxfU0NIRU1FKT8oZT10LnNsaWNlKFBmLlVSTF9TQ0hFTUUubGVuZ3RoKSxuZXcgUGYoZSkpOm51bGw7dmFyIGV9O21mLnJlZ2lzdGVyU2F2ZVJvdXRlcihMZiksbWYucmVnaXN0ZXJMb2FkUm91dGVyKExmKTt2YXIgV2Y9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7QyhpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJDdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIHdlYiBicm93c2VyXCJ9KSksQyhcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93fHx2b2lkIDAhPT13aW5kb3cubG9jYWxTdG9yYWdlLChmdW5jdGlvbigpe3JldHVyblwiQ3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IGxvY2FsU3RvcmFnZVwifSkpLHRoaXMuTFM9d2luZG93LmxvY2FsU3RvcmFnZX1yZXR1cm4gdC5wcm90b3R5cGUubGlzdE1vZGVscz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG4sbyxhLGk7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7Zm9yKHQ9e30sZT1EZitBZixuPUFmK1RmLG89MDtvPHRoaXMuTFMubGVuZ3RoOysrbykoYT10aGlzLkxTLmtleShvKSkuc3RhcnRzV2l0aChlKSYmYS5lbmRzV2l0aChuKSYmKGk9QmYoYSksdFtpXT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShhKSkpO3JldHVyblsyLHRdfSkpfSkpfSx0LnByb3RvdHlwZS5yZW1vdmVNb2RlbD1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXt2YXIgbztpZih0PShvPXQpLnN0YXJ0c1dpdGgoUGYuVVJMX1NDSEVNRSk/by5zbGljZShQZi5VUkxfU0NIRU1FLmxlbmd0aCk6byxlPU1mKHQpLG51bGw9PXRoaXMuTFMuZ2V0SXRlbShlLmluZm8pKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIGF0IHBhdGggJ1wiK3QrXCInXCIpO3JldHVybiBuPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKGUuaW5mbykpLHRoaXMuTFMucmVtb3ZlSXRlbShlLmluZm8pLHRoaXMuTFMucmVtb3ZlSXRlbShlLnRvcG9sb2d5KSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS53ZWlnaHRTcGVjcyksdGhpcy5MUy5yZW1vdmVJdGVtKGUud2VpZ2h0RGF0YSksWzIsbl19KSl9KSl9LHR9KCk7aWYoaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRyeXt5Zi5yZWdpc3Rlck1hbmFnZXIoUGYuVVJMX1NDSEVNRSxuZXcgV2YpfWNhdGNoKHQpe312YXIgVWY9XCJtb2RlbFwiLFZmPVwiLmpzb25cIix6Zj1cIi53ZWlnaHRzLmJpblwiO2Z1bmN0aW9uIEdmKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIHNldFRpbWVvdXQodCl9KSkudGhlbih0KX12YXIgSGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2lmKCFpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlckRvd25sb2FkcygpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgYnJvd3Nlci5cIik7ZS5zdGFydHNXaXRoKHQuVVJMX1NDSEVNRSkmJihlPWUuc2xpY2UodC5VUkxfU0NIRU1FLmxlbmd0aCkpLG51bGwhPWUmJjAhPT1lLmxlbmd0aHx8KGU9VWYpLHRoaXMubW9kZWxUb3BvbG9neUZpbGVOYW1lPWUrVmYsdGhpcy53ZWlnaHREYXRhRmlsZU5hbWU9ZSt6Zn1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGEsaSxzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGRvY3VtZW50KXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgZG93bmxvYWRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgc2luY2UgYGRvY3VtZW50YCBpcyBub3QgcHJlc2VudFwiKTtpZihlPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt0LndlaWdodERhdGFdLHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSksISh0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpcmV0dXJuWzMsMV07dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckRvd25sb2Fkcy5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtjYXNlIDE6cmV0dXJuIG49W3twYXRoczpbXCIuL1wiK3RoaXMud2VpZ2h0RGF0YUZpbGVOYW1lXSx3ZWlnaHRzOnQud2VpZ2h0U3BlY3N9XSxvPXttb2RlbFRvcG9sb2d5OnQubW9kZWxUb3BvbG9neSxmb3JtYXQ6dC5mb3JtYXQsZ2VuZXJhdGVkQnk6dC5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTp0LmNvbnZlcnRlZEJ5LHdlaWdodHNNYW5pZmVzdDpufSxhPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShvKV0se3R5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSksKGk9bnVsbD09dGhpcy5qc29uQW5jaG9yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMuanNvbkFuY2hvcikuZG93bmxvYWQ9dGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWUsaS5ocmVmPWEsWzQsR2YoKGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChcImNsaWNrXCIpKX0pKV07Y2FzZSAyOnJldHVybiByLnNlbnQoKSxudWxsPT10LndlaWdodERhdGE/WzMsNF06KChzPW51bGw9PXRoaXMud2VpZ2h0RGF0YUFuY2hvcj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTp0aGlzLndlaWdodERhdGFBbmNob3IpLmRvd25sb2FkPXRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lLHMuaHJlZj1lLFs0LEdmKChmdW5jdGlvbigpe3JldHVybiBzLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9KSldKTtjYXNlIDM6ci5zZW50KCksci5sYWJlbD00O2Nhc2UgNDpyZXR1cm5bMix7bW9kZWxBcnRpZmFjdHNJbmZvOnZmKHQpfV19fSkpfSkpfSx0LlVSTF9TQ0hFTUU9XCJkb3dubG9hZHM6Ly9cIix0fSgpLHFmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZihudWxsPT10fHx0Lmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBicm93c2VyRmlsZXMsIGF0IGxlYXN0IDEgZmlsZSBpcyByZXF1aXJlZCwgYnV0IHJlY2VpdmVkIFwiK3QpO3RoaXMuZmlsZXM9dH1yZXR1cm4gdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG49dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtyZXR1cm4gdD10aGlzLmZpbGVzWzBdLGU9dGhpcy5maWxlcy5zbGljZSgxKSxbMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixvKXt2YXIgYT1uZXcgRmlsZVJlYWRlcjthLm9ubG9hZD1mdW5jdGlvbihhKXt2YXIgaT1KU09OLnBhcnNlKGEudGFyZ2V0LnJlc3VsdCkscz1pLm1vZGVsVG9wb2xvZ3k7aWYobnVsbCE9cyl7MD09PWUubGVuZ3RoJiZyKHttb2RlbFRvcG9sb2d5OnN9KTt2YXIgdT1pLndlaWdodHNNYW5pZmVzdDtpZihudWxsIT11KXt2YXIgYzt0cnl7Yz1uLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcyh1LGUpfWNhdGNoKHQpe3JldHVybiB2b2lkIG8odCl9dmFyIGw9W10saD1bXSxmPVtdO3UuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5wYXRocy5mb3JFYWNoKChmdW5jdGlvbih0KXtoLnB1c2godCksZi5wdXNoKG51bGwpfSkpLGwucHVzaC5hcHBseShsLHQud2VpZ2h0cyl9KSksdS5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBGaWxlUmVhZGVyO2Uub25sb2FkPWZ1bmN0aW9uKGUpe3ZhciBuPWUudGFyZ2V0LnJlc3VsdCxvPWguaW5kZXhPZih0KTtmW29dPW4sLTE9PT1mLmluZGV4T2YobnVsbCkmJnIoe21vZGVsVG9wb2xvZ3k6cyx3ZWlnaHRTcGVjczpsLHdlaWdodERhdGE6ZGYoZiksZm9ybWF0OmkuZm9ybWF0LGdlbmVyYXRlZEJ5OmkuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6aS5jb252ZXJ0ZWRCeSx1c2VyRGVmaW5lZE1ldGFkYXRhOmkudXNlckRlZmluZWRNZXRhZGF0YX0pfSxlLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG8oXCJGYWlsZWQgdG8gd2VpZ2h0cyBkYXRhIGZyb20gZmlsZSBvZiBwYXRoICdcIit0K1wiJy5cIil9LGUucmVhZEFzQXJyYXlCdWZmZXIoY1t0XSl9KSl9KSl9ZWxzZSBvKG5ldyBFcnJvcihcIndlaWdodE1hbmlmZXN0IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlIFwiK3QubmFtZSkpfWVsc2UgbyhuZXcgRXJyb3IoXCJtb2RlbFRvcG9sb2d5IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlIFwiK3QubmFtZSkpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG8oXCJGYWlsZWQgdG8gcmVhZCBtb2RlbCB0b3BvbG9neSBhbmQgd2VpZ2h0cyBtYW5pZmVzdCBKU09OIGZyb20gZmlsZSAnXCIrdC5uYW1lK1wiJy4gQnJvd3NlckZpbGVzIHN1cHBvcnRzIGxvYWRpbmcgS2VyYXMtc3R5bGUgdGYuTW9kZWwgYXJ0aWZhY3RzIG9ubHkuXCIpfSxhLnJlYWRBc1RleHQodCl9KSldfSkpfSkpfSx0LnByb3RvdHlwZS5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W10scj1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHBmKHQubmFtZSl9KSksbz17fSxhPTAsaT10O2E8aS5sZW5ndGg7YSsrKXtpW2FdLnBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPXBmKHQpO2lmKC0xIT09bi5pbmRleE9mKGEpKXRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBmaWxlIGJhc2VuYW1lIGZvdW5kIGluIHdlaWdodHMgbWFuaWZlc3Q6ICdcIithK1wiJ1wiKTtpZihuLnB1c2goYSksLTE9PT1yLmluZGV4T2YoYSkpdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IGZpbGUgd2l0aCBiYXNlbmFtZSAnXCIrYStcIicgaXMgbm90IHByb3ZpZGVkLlwiKTtvW3RdPWVbci5pbmRleE9mKGEpXX0pKX1pZihuLmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZmlsZXMgaW4gd2VpZ2h0cyBtYW5pZmVzdCAoXCIrbi5sZW5ndGgrXCIpIGFuZCB0aGUgbnVtYmVyIG9mIHdlaWdodCBmaWxlcyBwcm92aWRlZCAoXCIrZS5sZW5ndGgrXCIpLlwiKTtyZXR1cm4gb30sdH0oKTtmdW5jdGlvbiBLZih0LGUsbixyKXshZnVuY3Rpb24odCl7QyhudWxsIT10JiZBcnJheS5pc0FycmF5KHQpJiZ0Lmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwicHJvbWlzZXMgbXVzdCBiZSBhIG5vbmUgZW1wdHkgYXJyYXlcIn0pKX0odCksZnVuY3Rpb24odCxlKXtDKHQ+PTAmJnQ8PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQcm9ncmVzcyBmcmFjdGlvbiBtdXN0IGJlIGluIHJhbmdlIFswLCAxXSwgYnV0IGdvdCBzdGFydEZyYWN0aW9uIFwiK3R9KSksQyhlPj0wJiZlPD0xLChmdW5jdGlvbigpe3JldHVyblwiUHJvZ3Jlc3MgZnJhY3Rpb24gbXVzdCBiZSBpbiByYW5nZSBbMCwgMV0sIGJ1dCBnb3QgZW5kRnJhY3Rpb24gXCIrZX0pKSxDKGU+PXQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzdGFydEZyYWN0aW9uIG11c3QgYmUgbm8gbW9yZSB0aGFuIGVuZEZyYWN0aW9uLCBidXQgZ290IHN0YXJ0RnJhY3Rpb24gXCIrdCtcIiBhbmQgZW5kRnJhY3Rpb24gXCIrZX0pKX0obj1udWxsPT1uPzA6bixyPW51bGw9PXI/MTpyKTt2YXIgbz0wO3JldHVybiBQcm9taXNlLmFsbCh0Lm1hcCgoZnVuY3Rpb24oYSl7cmV0dXJuIGEudGhlbigoZnVuY3Rpb24oYSl7dmFyIGk9bisgKytvL3QubGVuZ3RoKihyLW4pO3JldHVybiBlKGkpLGF9KSksYX0pKSl9ZnVuY3Rpb24gamYodCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sbyxhLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PWUmJihlPXt9KSxuPW51bGw9PWUuZmV0Y2hGdW5jP2koKS5wbGF0Zm9ybS5mZXRjaDplLmZldGNoRnVuYyxvPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUucmVxdWVzdEluaXQse2lzQmluYXJ5OiEwfSl9KSksYT0wLHM9LjUsbnVsbCE9ZS5vblByb2dyZXNzP1szLDJdOls0LFByb21pc2UuYWxsKG8pXTtjYXNlIDE6cmV0dXJuIHU9ci5zZW50KCksWzMsNF07Y2FzZSAyOnJldHVybls0LEtmKG8sZS5vblByb2dyZXNzLGEscyldO2Nhc2UgMzp1PXIuc2VudCgpLHIubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIGM9dS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSksbD0uNSxoPTEsbnVsbCE9ZS5vblByb2dyZXNzP1szLDZdOls0LFByb21pc2UuYWxsKGMpXTtjYXNlIDU6cmV0dXJuIGY9ci5zZW50KCksWzMsOF07Y2FzZSA2OnJldHVybls0LEtmKGMsZS5vblByb2dyZXNzLGwsaCldO2Nhc2UgNzpmPXIuc2VudCgpLHIubGFiZWw9ODtjYXNlIDg6cmV0dXJuWzIsZl19fSkpfSkpfWZ1bmN0aW9uIFhmKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKG8sYSxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9XCJcIiksbihlLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixzLHUsYyxsLGgsZixkLHA7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihlPW8ubWFwKChmdW5jdGlvbigpe3JldHVybiExfSkpLG49e30scz1udWxsIT1pP2kubWFwKChmdW5jdGlvbigpe3JldHVybiExfSkpOltdLHU9W10sby5mb3JFYWNoKChmdW5jdGlvbih0LHIpe3ZhciBvPTA7dC53ZWlnaHRzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPVwicXVhbnRpemF0aW9uXCJpbiB0P3QucXVhbnRpemF0aW9uLmR0eXBlOnQuZHR5cGUsYz1zZlthXSprKHQuc2hhcGUpLGw9ZnVuY3Rpb24oKXtlW3JdPSEwLG51bGw9PW5bcl0mJihuW3JdPVtdKSxuW3JdLnB1c2goe21hbmlmZXN0RW50cnk6dCxncm91cE9mZnNldDpvLHNpemVCeXRlczpjfSl9O251bGwhPWk/aS5mb3JFYWNoKChmdW5jdGlvbihlLG4pe2U9PT10Lm5hbWUmJihsKCksc1tuXT0hMCl9KSk6bCgpLHUucHVzaCh0Lm5hbWUpLG8rPWN9KSl9KSksIXMuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpKXRocm93IGM9aS5maWx0ZXIoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIXNbZV19KSksbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2VpZ2h0cyBpbiBtYW5pZmVzdCB3aXRoIG5hbWVzOiBcIitjLmpvaW4oXCIsIFwiKStcIi4gXFxuTWFuaWZlc3QgSlNPTiBoYXMgd2VpZ2h0cyB3aXRoIG5hbWVzOiBcIit1LmpvaW4oXCIsIFwiKStcIi5cIik7cmV0dXJuIGw9ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZSYmdC5wdXNoKG4pLHR9KSxbXSksaD1bXSxsLmZvckVhY2goKGZ1bmN0aW9uKHQpe29bdF0ucGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9YSsoYS5lbmRzV2l0aChcIi9cIik/XCJcIjpcIi9cIikrdDtoLnB1c2goZSl9KSl9KSksWzQsdChoKV07Y2FzZSAxOnJldHVybiBmPXIuc2VudCgpLGQ9e30scD0wLGwuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBlPW9bdF0ucGF0aHMubGVuZ3RoLHI9MCxhPTA7YTxlO2ErKylyKz1mW3ArYV0uYnl0ZUxlbmd0aDtmb3IodmFyIGk9bmV3IEFycmF5QnVmZmVyKHIpLHM9bmV3IFVpbnQ4QXJyYXkoaSksdT0wLGM9MDtjPGU7YysrKXt2YXIgbD1uZXcgVWludDhBcnJheShmW3ArY10pO3Muc2V0KGwsdSksdSs9bC5ieXRlTGVuZ3RofW5bdF0uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9Y2YoaS5zbGljZSh0Lmdyb3VwT2Zmc2V0LHQuZ3JvdXBPZmZzZXQrdC5zaXplQnl0ZXMpLFt0Lm1hbmlmZXN0RW50cnldKTtmb3IodmFyIG4gaW4gZSlkW25dPWVbbl19KSkscCs9ZX0pKSxbMixkXX19KSl9KSl9fW1mLnJlZ2lzdGVyU2F2ZVJvdXRlcigoZnVuY3Rpb24odCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aChIZi5VUkxfU0NIRU1FKT9mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD1cIm1vZGVsXCIpO3JldHVybiBuZXcgSGYodCl9KHQuc2xpY2UoSGYuVVJMX1NDSEVNRS5sZW5ndGgpKTpudWxsfSkpO3ZhciBZZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtpZih0aGlzLkRFRkFVTFRfTUVUSE9EPVwiUE9TVFwiLG51bGw9PWUmJihlPXt9KSx0aGlzLndlaWdodFBhdGhQcmVmaXg9ZS53ZWlnaHRQYXRoUHJlZml4LHRoaXMub25Qcm9ncmVzcz1lLm9uUHJvZ3Jlc3MsbnVsbCE9ZS5mZXRjaEZ1bmM/KEMoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5mZXRjaEZ1bmMsKGZ1bmN0aW9uKCl7cmV0dXJuXCJNdXN0IHBhc3MgYSBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHNpZ25hdHVyZSBvZiBgZmV0Y2hgIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSSlcIn0pKSx0aGlzLmZldGNoPWUuZmV0Y2hGdW5jKTp0aGlzLmZldGNoPWkoKS5wbGF0Zm9ybS5mZXRjaCxDKG51bGwhPXQmJnQubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJVUkwgcGF0aCBmb3IgaHR0cCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCJ9KSksQXJyYXkuaXNBcnJheSh0KSYmQygyPT09dC5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJVUkwgcGF0aHMgZm9yIGh0dHAgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDIsIChhY3R1YWwgbGVuZ3RoIGlzIFwiK3QubGVuZ3RoK1wiKS5cIn0pKSx0aGlzLnBhdGg9dCxudWxsIT1lLnJlcXVlc3RJbml0JiZudWxsIT1lLnJlcXVlc3RJbml0LmJvZHkpdGhyb3cgbmV3IEVycm9yKFwicmVxdWVzdEluaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBubyBwcmUtZXhpc3RpbmcgYm9keSwgYnV0IGhhcyBvbmUuXCIpO3RoaXMucmVxdWVzdEluaXQ9ZS5yZXF1ZXN0SW5pdHx8e319cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVybihlPU9iamVjdC5hc3NpZ24oe21ldGhvZDp0aGlzLkRFRkFVTFRfTUVUSE9EfSx0aGlzLnJlcXVlc3RJbml0KSkuYm9keT1uZXcgRm9ybURhdGEsbj1be3BhdGhzOltcIi4vbW9kZWwud2VpZ2h0cy5iaW5cIl0sd2VpZ2h0czp0LndlaWdodFNwZWNzfV0sbz17bW9kZWxUb3BvbG9neTp0Lm1vZGVsVG9wb2xvZ3ksZm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeSx1c2VyRGVmaW5lZE1ldGFkYXRhOnQudXNlckRlZmluZWRNZXRhZGF0YSx3ZWlnaHRzTWFuaWZlc3Q6bn0sZS5ib2R5LmFwcGVuZChcIm1vZGVsLmpzb25cIixuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobyldLHt0eXBlOlwiYXBwbGljYXRpb24vanNvblwifSksXCJtb2RlbC5qc29uXCIpLG51bGwhPXQud2VpZ2h0RGF0YSYmZS5ib2R5LmFwcGVuZChcIm1vZGVsLndlaWdodHMuYmluXCIsbmV3IEJsb2IoW3Qud2VpZ2h0RGF0YV0se3R5cGU6XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pLFwibW9kZWwud2VpZ2h0cy5iaW5cIiksWzQsdGhpcy5mZXRjaCh0aGlzLnBhdGgsZSldO2Nhc2UgMTppZigoYT1yLnNlbnQoKSkub2spcmV0dXJuWzIse21vZGVsQXJ0aWZhY3RzSW5mbzp2Zih0KSxyZXNwb25zZXM6W2FdfV07dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIFwiK2Euc3RhdHVzK1wiLlwiKX19KSl9KSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuLG8sYSxpLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5mZXRjaCh0aGlzLnBhdGgsdGhpcy5yZXF1ZXN0SW5pdCldO2Nhc2UgMTppZighKHQ9ci5zZW50KCkpLm9rKXRocm93IG5ldyBFcnJvcihcIlJlcXVlc3QgdG8gXCIrdGhpcy5wYXRoK1wiIGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlIFwiK3Quc3RhdHVzK1wiLiBQbGVhc2UgdmVyaWZ5IHRoaXMgVVJMIHBvaW50cyB0byB0aGUgbW9kZWwgSlNPTiBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cIik7ci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gci50cnlzLnB1c2goWzIsNCwsNV0pLFs0LHQuanNvbigpXTtjYXNlIDM6cmV0dXJuIGU9ci5zZW50KCksWzMsNV07Y2FzZSA0OnRocm93IHIuc2VudCgpLG49XCJGYWlsZWQgdG8gcGFyc2UgbW9kZWwgSlNPTiBvZiByZXNwb25zZSBmcm9tIFwiK3RoaXMucGF0aCtcIi5cIix0aGlzLnBhdGguZW5kc1dpdGgoXCIucGJcIik/bis9XCIgWW91ciBwYXRoIGNvbnRhaW5zIGEgLnBiIGZpbGUgZXh0ZW5zaW9uLiBTdXBwb3J0IGZvciAucGIgbW9kZWxzIGhhdmUgYmVlbiByZW1vdmVkIGluIFRlbnNvckZsb3cuanMgMS4wIGluIGZhdm9yIG9mIC5qc29uIG1vZGVscy4gWW91IGNhbiByZS1jb252ZXJ0IHlvdXIgUHl0aG9uIFRlbnNvckZsb3cgbW9kZWwgdXNpbmcgdGhlIFRlbnNvckZsb3cuanMgMS4wIGNvbnZlcnNpb24gc2NyaXB0cyBvciB5b3UgY2FuIGNvbnZlcnQgeW91ci5wYiBtb2RlbHMgd2l0aCB0aGUgJ3BiMmpzb24nTlBNIHNjcmlwdCBpbiB0aGUgdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlciByZXBvc2l0b3J5LlwiOm4rPVwiIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHNlcnZlciBpcyBzZXJ2aW5nIHZhbGlkIEpTT04gZm9yIHRoaXMgcmVxdWVzdC5cIixuZXcgRXJyb3Iobik7Y2FzZSA1OmlmKG89ZS5tb2RlbFRvcG9sb2d5LGE9ZS53ZWlnaHRzTWFuaWZlc3QsaT1lLmdlbmVyYXRlZEJ5LHM9ZS5jb252ZXJ0ZWRCeSx1PWUuZm9ybWF0LGM9ZS51c2VyRGVmaW5lZE1ldGFkYXRhLG51bGw9PW8mJm51bGw9PWEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIEpTT04gZnJvbSBIVFRQIHBhdGggXCIrdGhpcy5wYXRoK1wiIGNvbnRhaW5zIG5laXRoZXIgbW9kZWwgdG9wb2xvZ3kgb3IgbWFuaWZlc3QgZm9yIHdlaWdodHMuXCIpO3JldHVybiBudWxsPT1hP1szLDddOls0LHRoaXMubG9hZFdlaWdodHMoYSldO2Nhc2UgNjpmPXIuc2VudCgpLGw9ZlswXSxoPWZbMV0sci5sYWJlbD03O2Nhc2UgNzpyZXR1cm5bMix7bW9kZWxUb3BvbG9neTpvLHdlaWdodFNwZWNzOmwsd2VpZ2h0RGF0YTpoLHVzZXJEZWZpbmVkTWV0YWRhdGE6YyxnZW5lcmF0ZWRCeTppLGNvbnZlcnRlZEJ5OnMsZm9ybWF0OnV9XX19KSl9KSl9LHQucHJvdG90eXBlLmxvYWRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYSxpLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6Zm9yKGU9QXJyYXkuaXNBcnJheSh0aGlzLnBhdGgpP3RoaXMucGF0aFsxXTp0aGlzLnBhdGgsbj1mdW5jdGlvbih0KXt2YXIgZT10Lmxhc3RJbmRleE9mKFwiL1wiKSxuPXQubGFzdEluZGV4T2YoXCI/XCIpLHI9dC5zdWJzdHJpbmcoMCxlKSxvPW4+ZT90LnN1YnN0cmluZyhuKTpcIlwiO3JldHVybltyK1wiL1wiLG9dfShlKSxvPW5bMF0sYT1uWzFdLGk9dGhpcy53ZWlnaHRQYXRoUHJlZml4fHxvLHM9W10sdT0wLGM9dDt1PGMubGVuZ3RoO3UrKylsPWNbdV0scy5wdXNoLmFwcGx5KHMsbC53ZWlnaHRzKTtyZXR1cm4gaD1bXSx0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7aC5wdXNoKGkrdCthKX0pKX0pKSxbNCxqZihoLHtyZXF1ZXN0SW5pdDp0aGlzLnJlcXVlc3RJbml0LGZldGNoRnVuYzp0aGlzLmZldGNoLG9uUHJvZ3Jlc3M6dGhpcy5vblByb2dyZXNzfSldO2Nhc2UgMTpyZXR1cm4gZj1yLnNlbnQoKSxbMixbcyxkZihmKV1dfX0pKX0pKX0sdC5VUkxfU0NIRU1FX1JFR0VYPS9eaHR0cHM/OlxcL1xcLy8sdH0oKTtmdW5jdGlvbiAkZih0KXtyZXR1cm4gbnVsbCE9dC5tYXRjaChZZi5VUkxfU0NIRU1FX1JFR0VYKX12YXIgUWY9ZnVuY3Rpb24odCxlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZmV0Y2gpcmV0dXJuIG51bGw7cmV0dXJuKEFycmF5LmlzQXJyYXkodCk/dC5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuICRmKHQpfSkpOiRmKHQpKT9KZih0LHtvblByb2dyZXNzOmV9KTpudWxsfTtmdW5jdGlvbiBKZih0LGUpe3JldHVybiBuZXcgWWYodCxlKX1tZi5yZWdpc3RlclNhdmVSb3V0ZXIoUWYpLG1mLnJlZ2lzdGVyTG9hZFJvdXRlcihRZik7dmFyIFpmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLm1vZGVsQXJ0aWZhY3RzPXR9cmV0dXJuIHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy5tb2RlbEFydGlmYWN0c119KSl9KSl9LHR9KCksdGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuc2F2ZUhhbmRsZXI9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5zYXZlSGFuZGxlcih0KV19KSl9KSl9LHR9KCk7dmFyIGVkPU9iamVjdC5mcmVlemUoe2Jyb3dzZXJGaWxlczpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHFmKHQpfSxicm93c2VySFRUUFJlcXVlc3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gSmYodCxlKX0sY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnM6ZGYsZGVjb2RlV2VpZ2h0czpjZixlbmNvZGVXZWlnaHRzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBvLGEsaSxzLHUsYz10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGwpe3N3aXRjaChsLmxhYmVsKXtjYXNlIDA6Zm9yKG89W10sYT1bXSxpPUFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkscz1mdW5jdGlvbihzKXt2YXIgdT1pW3NdLGw9QXJyYXkuaXNBcnJheSh0KT90W3NdLnRlbnNvcjp0W3VdO2lmKFwiZmxvYXQzMlwiIT09bC5kdHlwZSYmXCJpbnQzMlwiIT09bC5kdHlwZSYmXCJib29sXCIhPT1sLmR0eXBlJiZcInN0cmluZ1wiIT09bC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK3UrXCInOiBcIitsLmR0eXBlKTt2YXIgaD17bmFtZTp1LHNoYXBlOmwuc2hhcGUsZHR5cGU6bC5kdHlwZX07aWYoXCJzdHJpbmdcIj09PWwuZHR5cGUpe3ZhciBmPW5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gbihjLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGEsaSxzLHU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxsLmJ5dGVzKCldO2Nhc2UgMTpmb3IoZT1yLnNlbnQoKSxuPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2UubGVuZ3RofSksMCkrdWYqZS5sZW5ndGgsbz1uZXcgVWludDhBcnJheShuKSxhPTAsaT0wO2k8ZS5sZW5ndGg7aSsrKXM9ZVtpXSx1PW5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbcy5sZW5ndGhdKS5idWZmZXIpLG8uc2V0KHUsYSksYSs9dWYsby5zZXQocyxhKSxhKz1zLmxlbmd0aDtyZXR1cm4gdChvKSxbMl19fSkpfSkpfSkpO2EucHVzaChmKX1lbHNlIGEucHVzaChsLmRhdGEoKSk7bnVsbCE9ZSYmKGguZ3JvdXA9ZSksby5wdXNoKGgpfSx1PTA7dTxpLmxlbmd0aDsrK3Upcyh1KTtyZXR1cm5bNCxQcm9taXNlLmFsbChhKV07Y2FzZSAxOnJldHVyblsyLHtkYXRhOmxmKGwuc2VudCgpKSxzcGVjczpvfV19fSkpfSkpfSxmcm9tTWVtb3J5OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD9udWxsIT10Lm1vZGVsVG9wb2xvZ3l8fG51bGwhPXQud2VpZ2h0U3BlY3M/bmV3IFpmKHQpOihjb25zb2xlLndhcm4oXCJQbGVhc2UgY2FsbCB0Zi5pby5mcm9tTWVtb3J5KCkgd2l0aCBvbmx5IG9uZSBhcmd1bWVudC4gVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBvZiB0eXBlIE1vZGVsQXJ0aWZhY3RzLiBUaGUgbXVsdGktYXJndW1lbnQgc2lnbmF0dXJlIG9mIHRmLmlvLmZyb21NZW1vcnkoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIiksbmV3IFpmKHttb2RlbFRvcG9sb2d5OnR9KSk6KGNvbnNvbGUud2FybihcIlBsZWFzZSBjYWxsIHRmLmlvLmZyb21NZW1vcnkoKSB3aXRoIG9ubHkgb25lIGFyZ3VtZW50LiBUaGUgYXJndW1lbnQgc2hvdWxkIGJlIG9mIHR5cGUgTW9kZWxBcnRpZmFjdHMuIFRoZSBtdWx0aS1hcmd1bWVudCBzaWduYXR1cmUgb2YgdGYuaW8uZnJvbU1lbW9yeSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiKSxuZXcgWmYoe21vZGVsVG9wb2xvZ3k6dCx3ZWlnaHRTcGVjczplLHdlaWdodERhdGE6bix0cmFpbmluZ0NvbmZpZzpyfSkpfSxnZXRMb2FkSGFuZGxlcnM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbWYuZ2V0TG9hZEhhbmRsZXJzKHQsZSl9LGdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT046dmYsZ2V0U2F2ZUhhbmRsZXJzOmZ1bmN0aW9uKHQpe3JldHVybiBtZi5nZXRTYXZlSGFuZGxlcnModCl9LGh0dHA6SmYsaXNIVFRQU2NoZW1lOiRmLGxvYWRXZWlnaHRzOmZ1bmN0aW9uKHQsZSxvLGEpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cIlwiKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm5bMixYZigoZnVuY3Rpb24odCl7cmV0dXJuIGpmKHQse3JlcXVlc3RJbml0OmF9KX0pKSh0LGUsbyldfSkpfSkpfSxyZWdpc3RlckxvYWRSb3V0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG1mLnJlZ2lzdGVyTG9hZFJvdXRlcih0KX0scmVnaXN0ZXJTYXZlUm91dGVyOmZ1bmN0aW9uKHQpe3JldHVybiBtZi5yZWdpc3RlclNhdmVSb3V0ZXIodCl9LHdlaWdodHNMb2FkZXJGYWN0b3J5OlhmLHdpdGhTYXZlSGFuZGxlcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHRkKHQpfSxjb3B5TW9kZWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7cmV0dXJuITEsWzIsYmYodCxlLCExKV19KSl9KSl9LGxpc3RNb2RlbHM6ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuLG8sYSxpLHM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0PXlmLmdldFNjaGVtZXMoKSxlPXt9LG49MCxvPXQsci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxvLmxlbmd0aD8oYT1vW25dLFs0LHlmLmdldE1hbmFnZXIoYSkubGlzdE1vZGVscygpXSk6WzMsNF07Y2FzZSAyOmZvcihzIGluIGk9ci5zZW50KCkpZVthK2dmK3NdPWlbc107ci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMixlXX19KSl9KSl9LG1vdmVNb2RlbDpmdW5jdGlvbih0LGUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4hMCxbMixiZih0LGUsITApXX0pKX0pKX0scmVtb3ZlTW9kZWw6ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVybiBlPXhmKHQpLFsyLHlmLmdldE1hbmFnZXIoZS5zY2hlbWUpLnJlbW92ZU1vZGVsKGUucGF0aCldfSkpfSkpfX0pO3ZhciBuZCxyZD1Bbih7Y29uZnVzaW9uTWF0cml4XzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcImxhYmVsc1wiLFwiY29uZnVzaW9uTWF0cml4XCIpLG89bW4oZSxcInByZWRpY3Rpb25zXCIsXCJjb25mdXNpb25NYXRyaXhcIik7QyhudWxsPT1ufHxuPjAmJk51bWJlci5pc0ludGVnZXIobiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJJZiBwcm92aWRlZCwgbnVtQ2xhc3NlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitufSkpLEMoMT09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkV4cGVjdGVkIHRoZSByYW5rIG9mIGxhYmVscyB0byBiZSAxLCBidXQgZ290IFwiK3IucmFua30pKSxDKDE9PT1vLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFeHBlY3RlZCB0aGUgcmFuayBvZiBwcmVkaWN0aW9ucyB0byBiZSAxLCBidXQgZ290IFwiK28ucmFua30pKSxDKHIuc2hhcGVbMF09PT1vLnNoYXBlWzBdLChmdW5jdGlvbigpe3JldHVyblwiTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBleGFtcGxlczogXCIrci5zaGFwZVswXStcIiB2cy4gXCIrby5zaGFwZVswXStcIi4gTGFiZWxzIGFuZCBwcmVkaWN0aW9ucyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCJ9KSksQyhuPjAmJk51bWJlci5pc0ludGVnZXIobiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJudW1DbGFzc2VzIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitufSkpO3ZhciBhPVJyKHIuYXNUeXBlKFwiaW50MzJcIiksbiksaT1ScihvLmFzVHlwZShcImludDMyXCIpLG4pO3JldHVybiBhLnRyYW5zcG9zZSgpLm1hdE11bChpKS5hc1R5cGUoXCJpbnQzMlwiKX19KSxvZD1PYmplY3QuZnJlZXplKHtjb25mdXNpb25NYXRyaXg6cmR9KTt2YXIgYWQ9QW4oe2Zyb21QaXhlbHNfOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9MyksZT40KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgVGVuc29yIHdpdGggbW9yZSB0aGFuIDQgY2hhbm5lbHMgZnJvbSBwaXhlbHMuXCIpO2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBjYW4gbm90IGJlIG51bGxcIik7dmFyIG49ITEscj0hMSxvPSExLGE9ITEsaT0hMTtpZih0LmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KW49ITA7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgSW1hZ2VEYXRhJiZ0IGluc3RhbmNlb2YgSW1hZ2VEYXRhKXI9ITA7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTFZpZGVvRWxlbWVudCYmdCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpbz0hMDtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50JiZ0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClhPSEwO2Vsc2V7aWYobnVsbD09dC5nZXRDb250ZXh0KXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgbXVzdCBiZSBlaXRoZXIgYW4gSFRNTFZpZGVvRWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQsIEltYWdlRGF0YSBpbiBicm93c2VyLCBvciBPZmZzY3JlZW5DYW52YXMsIEltYWdlRGF0YSBpbiB3ZWJ3b3JrZXIgb3Ige2RhdGE6IFVpbnQzMkFycmF5LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIGJ1dCB3YXMgXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKTtpPSEwfWlmKG8pe2lmKG8mJnQucmVhZHlTdGF0ZTwyKXRocm93IG5ldyBFcnJvcihcIlRoZSB2aWRlbyBlbGVtZW50IGhhcyBub3QgbG9hZGVkIGRhdGEgeWV0LiBQbGVhc2Ugd2FpdCBmb3IgYGxvYWRlZGRhdGFgIGV2ZW50IG9uIHRoZSA8dmlkZW8+IGVsZW1lbnQuXCIpfWlmKG51bGwhPWwoXCJGcm9tUGl4ZWxzXCIsTHQuYmFja2VuZE5hbWUpKXJldHVybiBMdC5ydW5LZXJuZWwoXCJGcm9tUGl4ZWxzXCIse3BpeGVsczp0fSx7bnVtQ2hhbm5lbHM6ZX0pO3ZhciBzLHUsYz1vP1t0LnZpZGVvV2lkdGgsdC52aWRlb0hlaWdodF06W3Qud2lkdGgsdC5oZWlnaHRdLGg9Y1swXSxmPWNbMV07aWYoaT9zPXQuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAsaCxmKS5kYXRhOnJ8fG4/cz10LmRhdGE6KGF8fG8pJiYobnVsbD09bmQmJihuZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSksbmQuY2FudmFzLndpZHRoPWgsbmQuY2FudmFzLmhlaWdodD1mLG5kLmRyYXdJbWFnZSh0LDAsMCxoLGYpLHM9bmQuZ2V0SW1hZ2VEYXRhKDAsMCxoLGYpLmRhdGEpLDQ9PT1lKXU9bmV3IEludDMyQXJyYXkocyk7ZWxzZXt2YXIgZD1oKmY7dT1uZXcgSW50MzJBcnJheShkKmUpO2Zvcih2YXIgcD0wO3A8ZDtwKyspZm9yKHZhciB2PTA7djxlOysrdil1W3AqZSt2XT1zWzQqcCt2XX1yZXR1cm4gUG4odSxbZixoLGVdLFwiaW50MzJcIil9fSksaWQ9T2JqZWN0LmZyZWV6ZSh7dG9QaXhlbHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sbyxhLGkscyx1LGMsbCxoLGYsZCxwLHYsbSxnLHkseCxiLHcsQyxFLFIsSTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKG49bW4odCxcImltZ1wiLFwidG9QaXhlbHNcIiksdCBpbnN0YW5jZW9mIHd0fHwobj1uLnRvSW50KCkpLDIhPT1uLnJhbmsmJjMhPT1uLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyByYW5rIDIgb3IgMyB0ZW5zb3JzLCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCIpO2lmKG89bi5zaGFwZS5zbGljZSgwLDIpLGE9b1swXSxpPW9bMV0sKHM9Mj09PW4ucmFuaz8xOm4uc2hhcGVbMl0pPjR8fDI9PT1zKXRocm93IG5ldyBFcnJvcihcInRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgZGVwdGggb2Ygc2l6ZSAxLCAzIG9yIDQgYnV0IGdvdCBcIitzKTtyZXR1cm5bNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiB1PXIuc2VudCgpLGM9bi5taW4oKSxsPW4ubWF4KCksWzQsUHJvbWlzZS5hbGwoW2MuZGF0YSgpLGwuZGF0YSgpXSldO2Nhc2UgMjppZihoPXIuc2VudCgpLGY9aFswXSxkPWhbMV0scD1mWzBdLHY9ZFswXSxjLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKSxcImZsb2F0MzJcIj09PW4uZHR5cGUpe2lmKHA8MHx8dj4xKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgZmxvYXQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSBidXQgZ290IHJhbmdlIFtcIitwK1wiIC0gXCIrditcIl0uXCIpfWVsc2V7aWYoXCJpbnQzMlwiIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIGZvciB0b1BpeGVsczogXCIrbi5kdHlwZStcIi4gUGxlYXNlIHVzZSBmbG9hdDMyIG9yIGludDMyIHRlbnNvcnMuXCIpO2lmKHA8MHx8dj4yNTUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIHZhbHVlcyBmb3IgYSBpbnQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAyNTVdIGJ1dCBnb3QgcmFuZ2UgW1wiK3ArXCIgLSBcIit2K1wiXS5cIil9Zm9yKG09XCJmbG9hdDMyXCI9PT1uLmR0eXBlPzI1NToxLGc9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGkqYSo0KSx5PTA7eTxhKmk7Kyt5KXg9dm9pZCAwLGI9dm9pZCAwLHc9dm9pZCAwLEM9dm9pZCAwLDE9PT1zPyh4PXVbeV0qbSxiPXVbeV0qbSx3PXVbeV0qbSxDPTI1NSk6Mz09PXM/KHg9dVszKnldKm0sYj11WzMqeSsxXSptLHc9dVszKnkrMl0qbSxDPTI1NSk6ND09PXMmJih4PXVbNCp5XSptLGI9dVs0KnkrMV0qbSx3PXVbNCp5KzJdKm0sQz11WzQqeSszXSptKSxnWyhFPTQqeSkrMF09TWF0aC5yb3VuZCh4KSxnW0UrMV09TWF0aC5yb3VuZChiKSxnW0UrMl09TWF0aC5yb3VuZCh3KSxnW0UrM109TWF0aC5yb3VuZChDKTtyZXR1cm4gbnVsbCE9ZSYmKGUud2lkdGg9aSxlLmhlaWdodD1hLFI9ZS5nZXRDb250ZXh0KFwiMmRcIiksST1uZXcgSW1hZ2VEYXRhKGcsaSxhKSxSLnB1dEltYWdlRGF0YShJLDAsMCkpLG4hPT10JiZuLmRpc3Bvc2UoKSxbMixnXX19KSl9KSl9LGZyb21QaXhlbHM6YWR9KSxzZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUpfSx0fSgpLHVkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuY2xhc3NOYW1lTWFwPXt9fXJldHVybiB0LmdldE1hcD1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3Rlcj1mdW5jdGlvbihlKXt0LmdldE1hcCgpLmNsYXNzTmFtZU1hcFtlLmNsYXNzTmFtZV09W2UsZS5mcm9tQ29uZmlnXX0sdH0oKTtmdW5jdGlvbiBjZCh0KXtDKG51bGwhPXQuY2xhc3NOYW1lLChmdW5jdGlvbigpe3JldHVyblwiQ2xhc3MgYmVpbmcgcmVnaXN0ZXJlZCBkb2VzIG5vdCBoYXZlIHRoZSBzdGF0aWMgY2xhc3NOYW1lIHByb3BlcnR5IGRlZmluZWQuXCJ9KSksQyhcInN0cmluZ1wiPT10eXBlb2YgdC5jbGFzc05hbWUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJjbGFzc05hbWUgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgdHlwZSBcIit0eXBlb2YgdC5jbGFzc05hbWV9KSksQyh0LmNsYXNzTmFtZS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkNsYXNzIGJlaW5nIHJlZ2lzdGVyZWQgaGFzIGFuIGVtcHR5LXN0cmluZyBhcyBpdHMgY2xhc3NOYW1lLCB3aGljaCBpcyBkaXNhbGxvd2VkLlwifSkpLHVkLnJlZ2lzdGVyKHQpfXZhciBsZD1PYmplY3QuZnJlZXplKHtTZXJpYWxpemFibGU6c2QsU2VyaWFsaXphdGlvbk1hcDp1ZCxyZWdpc3RlckNsYXNzOmNkfSksaGQ9LjAwMSxmZD0uMTtmdW5jdGlvbiBkZCgpe3JldHVybiAzMj09PUx0LmJhY2tlbmQuZmxvYXRQcmVjaXNpb24oKT9oZDpmZH1mdW5jdGlvbiBwZCh0LGUsbil7dmFyIHI9ITA7aWYoKFYodCl8fFYoZSkpJiYocj0hMSksVih0KSYmVihlKSYmKHI9ITApLHIpe3ZhciBvPXQuY29uc3RydWN0b3IubmFtZSxhPWUuY29uc3RydWN0b3IubmFtZTtpZihvIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlLiBBY3R1YWw6IFwiK28rXCIuIEV4cGVjdGVkOiBcIithKX1pZihBcnJheS5pc0FycmF5KHQpJiZBcnJheS5pc0FycmF5KGUpKXt2YXIgaT1wbih0KSxzPXBuKGUpO2lmKCFTKGkscykpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IHNoYXBlcy4gQWN0dWFsOiBbXCIraStcIl0uIEV4cGVjdGVkOiBbXCIrcytcIl1cIil9dmFyIHU9Vih0KT90OkkodCksYz1WKGUpP2U6SShlKTtpZih1Lmxlbmd0aCE9PWMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzIGFjdHVhbDogXCIrdS5sZW5ndGgrXCIgdnMgZXhwZWN0ZWQ6IFwiK2MubGVuZ3RoK1wiLlxcbkFjdHVhbDogICBcIit1K1wiLlxcbkV4cGVjdGVkOiBcIitjK1wiLlwiKTtmb3IodmFyIGw9MDtsPGMubGVuZ3RoOysrbCl7dmFyIGg9dVtsXSxmPWNbbF07aWYoIW4oaCxmKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgZGlmZmVyOiBhY3R1YWxbXCIrbCtcIl0gPSBcIitoK1wiLCBleHBlY3RlZFtcIitsK1wiXSA9IFwiK2YrXCIuXFxuQWN0dWFsOiAgIFwiK3UrXCIuXFxuRXhwZWN0ZWQ6IFwiK2MrXCIuXCIpfX1mdW5jdGlvbiB2ZCh0LGUsbil7cmV0dXJuIWlzRmluaXRlKHQpJiYhaXNGaW5pdGUoZSl8fCEoaXNOYU4odCl8fGlzTmFOKGUpfHxNYXRoLmFicyh0LWUpPm4pfXZhciBtZD1PYmplY3QuZnJlZXplKHtURVNUX0VQU0lMT05fRkxPQVQxNjpmZCxleHBlY3RBcnJheXNDbG9zZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIG51bGw9PW4mJihuPWRkKCkpLHBkKHQsZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdmQodCxlLG4pfSkpfSx0ZXN0RXBzaWxvbjpkZCxleHBlY3RQcm9taXNlVG9GYWlsOmZ1bmN0aW9uKHQsZSl7dCgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZmFpbCgpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIGUoKX0pKX0sZXhwZWN0QXJyYXlzRXF1YWw6ZnVuY3Rpb24odCxlKXt2YXIgbj1cInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9bZV06ZTtyZXR1cm4gSCh0KXx8SCh0WzBdKXx8SChlKXx8SChlWzBdKT9wZCh0LG4sKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PWV9KSk6cGQodCxlLChmdW5jdGlvbih0LGUpe3JldHVybiB2ZCh0LGUsMCl9KSl9LGV4cGVjdE51bWJlcnNDbG9zZTpmdW5jdGlvbih0LGUsbil7aWYobnVsbD09biYmKG49ZGQoKSksIXZkKHQsZSxuKSl0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXJzIGRpZmZlcjogYWN0dWFsID09PSBcIit0K1wiLCBleHBlY3RlZCA9PT0gXCIrZSl9LGV4cGVjdFZhbHVlc0luUmFuZ2U6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKWlmKHRbcl08ZXx8dFtyXT5uKXRocm93IG5ldyBFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZTpcIit0W3JdK1wiIGxvdzogXCIrZStcIiwgaGlnaDogXCIrbil9LGV4cGVjdEFycmF5QnVmZmVyc0VxdWFsOmZ1bmN0aW9uKHQsZSl7ZXhwZWN0KG5ldyBGbG9hdDMyQXJyYXkodCkpLnRvRXF1YWwobmV3IEZsb2F0MzJBcnJheShlKSl9fSksZ2Q9XCIxLjcuMFwiO3ZhciB5ZD1PYmplY3QuZnJlZXplKHtncGdwdV91dGlsOk1pLHdlYmdsX3V0aWw6R2UsZm9yY2VIYWxmRmxvYXQ6ZnVuY3Rpb24oKXtpKCkuc2V0KFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIsITApfSxNYXRoQmFja2VuZFdlYkdMOlpzLHNldFdlYkdMQ29udGV4dDpLdCxHUEdQVUNvbnRleHQ6Qml9KSx4ZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLm1pbmltaXplPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHI9dGhpcy5jb21wdXRlR3JhZGllbnRzKHQsbiksbz1yLnZhbHVlLGE9ci5ncmFkcztpZihudWxsIT1uKXt2YXIgaT1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue25hbWU6dC5uYW1lLHRlbnNvcjphW3QubmFtZV19fSkpO3RoaXMuYXBwbHlHcmFkaWVudHMoaSl9ZWxzZSB0aGlzLmFwcGx5R3JhZGllbnRzKGEpO3JldHVybiB0bihhKSxlP286KG8uZGlzcG9zZSgpLG51bGwpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoby5wcm90b3R5cGUsXCJpdGVyYXRpb25zXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLml0ZXJhdGlvbnNfJiYodGhpcy5pdGVyYXRpb25zXz0wKSx0aGlzLml0ZXJhdGlvbnNffSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLG8ucHJvdG90eXBlLmluY3JlbWVudEl0ZXJhdGlvbnM9ZnVuY3Rpb24oKXt0aGlzLml0ZXJhdGlvbnNfPXRoaXMuaXRlcmF0aW9ucysxfSxvLnByb3RvdHlwZS5jb21wdXRlR3JhZGllbnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHBvKHQsZSl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtudWxsIT10aGlzLml0ZXJhdGlvbnNfJiZ0bih0aGlzLml0ZXJhdGlvbnNfKX0sby5wcm90b3R5cGUuc2F2ZUl0ZXJhdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMuaXRlcmF0aW9uc18mJih0aGlzLml0ZXJhdGlvbnNfPTApLFsyLHtuYW1lOlwiaXRlclwiLHRlbnNvcjpPbih0aGlzLml0ZXJhdGlvbnNfLFwiaW50MzJcIil9XX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJnZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG9wdGltaXplciB5ZXQuXCIpfSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG9wdGltaXplciBjbGFzcyBcIit0aGlzLmdldENsYXNzTmFtZSgpKX0pKX0pKX0sby5wcm90b3R5cGUuZXh0cmFjdEl0ZXJhdGlvbnM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9dGhpcyxbNCx0WzBdLnRlbnNvci5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gZS5pdGVyYXRpb25zXz1uLnNlbnQoKVswXSxbMix0LnNsaWNlKDEpXX19KSl9KSl9LG99KHNkKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeGQsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dC5taW5pbWl6ZSYmbnVsbCE9dC5jb21wdXRlR3JhZGllbnRzJiZudWxsIT10LmFwcGx5R3JhZGllbnRzfX0pO3ZhciBiZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbixyKXt2b2lkIDA9PT1yJiYocj1udWxsKTt2YXIgbz10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG8ubGVhcm5pbmdSYXRlPWUsby5yaG89bixvLmVwc2lsb249cixvLmFjY3VtdWxhdGVkR3JhZHM9W10sby5hY2N1bXVsYXRlZFVwZGF0ZXM9W10sbnVsbD09ciYmKG8uZXBzaWxvbj1MdC5iYWNrZW5kLmVwc2lsb24oKSksb31yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtudWxsPT1lLmFjY3VtdWxhdGVkR3JhZHNbcl0mJihlLmFjY3VtdWxhdGVkR3JhZHNbcl09e29yaWdpbmFsTmFtZTpuK1wiL2FjY3VtX2dyYWRcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfSksbnVsbD09ZS5hY2N1bXVsYXRlZFVwZGF0ZXNbcl0mJihlLmFjY3VtdWxhdGVkVXBkYXRlc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvYWNjdW1fdmFyXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKG8pLnZhcmlhYmxlKCExKX0pKX0pO3ZhciBhPUFycmF5LmlzQXJyYXkodCk/dFtyXS50ZW5zb3I6dFtuXTtpZihudWxsIT1hKXt2YXIgaT1lLmFjY3VtdWxhdGVkR3JhZHNbcl0udmFyaWFibGUscz1lLmFjY3VtdWxhdGVkVXBkYXRlc1tyXS52YXJpYWJsZTtaZSgoZnVuY3Rpb24oKXt2YXIgdD1pLm11bChlLnJobykuYWRkKGEuc3F1YXJlKCkubXVsKDEtZS5yaG8pKSxuPXMuYWRkKGUuZXBzaWxvbikuc3FydCgpLmRpdihpLmFkZChlLmVwc2lsb24pLnNxcnQoKSkubXVsKGEpLHI9cy5tdWwoZS5yaG8pLmFkZChuLnNxdWFyZSgpLm11bCgxLWUucmhvKSk7aS5hc3NpZ24odCkscy5hc3NpZ24ocik7dmFyIHU9bi5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQobyk7by5hc3NpZ24odSl9KSl9fSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMmJih0bih0aGlzLmFjY3VtdWxhdGVkR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksdG4odGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5hY2N1bXVsYXRlZEdyYWRzLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyksWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW2Uuc2VudCgpXS5jb25jYXQodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6cmV0dXJuIHQ9bi5zZW50KCksZT10Lmxlbmd0aC8yLCExLHRoaXMuYWNjdW11bGF0ZWRHcmFkcz10LnNsaWNlKDAsZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzPXQuc2xpY2UoZSwyKmUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLHJobzp0aGlzLnJobyxlcHNpbG9uOnRoaXMuZXBzaWxvbn19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLnJobyxlLmVwc2lsb24pfSxvLmNsYXNzTmFtZT1cIkFkYWRlbHRhXCIsb30oeGQpO2NkKGJkKTt2YXIgd2Q9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4pe3ZvaWQgMD09PW4mJihuPS4xKTt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIubGVhcm5pbmdSYXRlPWUsci5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZT1uLHIuYWNjdW11bGF0ZWRHcmFkcz1bXSxyfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsoQXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSkuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PWUuYWNjdW11bGF0ZWRHcmFkc1tyXSl7ZS5hY2N1bXVsYXRlZEdyYWRzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9hY2N1bXVsYXRvclwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBIbihvLnNoYXBlLGUuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpLnZhcmlhYmxlKCExKX0pKX19dmFyIGE9QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO2lmKG51bGwhPWEpe3ZhciBpPWUuYWNjdW11bGF0ZWRHcmFkc1tyXS52YXJpYWJsZTtaZSgoZnVuY3Rpb24oKXt2YXIgdD1pLmFkZChhLnNxdWFyZSgpKTtpLmFzc2lnbih0KTt2YXIgbj1hLmRpdih0LmFkZChMdC5iYWNrZW5kLmVwc2lsb24oKSkuc3FydCgpKS5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQobyk7by5hc3NpZ24obil9KSl9fSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZEdyYWRzJiZ0bih0aGlzLmFjY3VtdWxhdGVkR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbdC5zZW50KCldLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX19KSkpXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLCExLHRoaXMuYWNjdW11bGF0ZWRHcmFkcz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGluaXRpYWxBY2N1bXVsYXRvclZhbHVlOnRoaXMuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWV9fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSl9LG8uY2xhc3NOYW1lPVwiQWRhZ3JhZFwiLG99KHhkKTtjZCh3ZCk7dmFyIENkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuLHIsbyl7dm9pZCAwPT09byYmKG89bnVsbCk7dmFyIGE9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBhLmxlYXJuaW5nUmF0ZT1lLGEuYmV0YTE9bixhLmJldGEyPXIsYS5lcHNpbG9uPW8sYS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PVtdLGEuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQ9W10sWmUoKGZ1bmN0aW9uKCl7YS5hY2NCZXRhMT1PbihuKS52YXJpYWJsZSgpLGEuYWNjQmV0YTI9T24ocikudmFyaWFibGUoKX0pKSxudWxsPT1vJiYoYS5lcHNpbG9uPUx0LmJhY2tlbmQuZXBzaWxvbigpKSxhfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPUFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCk7WmUoKGZ1bmN0aW9uKCl7dmFyIHI9Q2MoMSxlLmFjY0JldGExKSxvPUNjKDEsZS5hY2NCZXRhMik7bi5mb3JFYWNoKChmdW5jdGlvbihuLGEpe3ZhciBpPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07bnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdJiYoZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdPXtvcmlnaW5hbE5hbWU6bitcIi9tXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKGkpLnZhcmlhYmxlKCExKX0pKX0pLG51bGw9PWUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbYV0mJihlLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W2FdPXtvcmlnaW5hbE5hbWU6bitcIi92XCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKGkpLnZhcmlhYmxlKCExKX0pKX0pO3ZhciBzPUFycmF5LmlzQXJyYXkodCk/dFthXS50ZW5zb3I6dFtuXTtpZihudWxsIT1zKXt2YXIgdT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbYV0udmFyaWFibGUsYz1lLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W2FdLnZhcmlhYmxlLGw9dS5tdWwoZS5iZXRhMSkuYWRkKHMubXVsKDEtZS5iZXRhMSkpLGg9Yy5tdWwoZS5iZXRhMikuYWRkKHMuc3F1YXJlKCkubXVsKDEtZS5iZXRhMikpLGY9bC5kaXYociksZD1oLmRpdihvKTt1LmFzc2lnbihsKSxjLmFzc2lnbihoKTt2YXIgcD1mLmRpdihkLnNxcnQoKS5hZGQoZS5lcHNpbG9uKSkubXVsKC1lLmxlYXJuaW5nUmF0ZSkuYWRkKGkpO2kuYXNzaWduKHApfX0pKSxlLmFjY0JldGExLmFzc2lnbihlLmFjY0JldGExLm11bChlLmJldGExKSksZS5hY2NCZXRhMi5hc3NpZ24oZS5hY2NCZXRhMi5tdWwoZS5iZXRhMikpfSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5hY2NCZXRhMi5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50JiZ0bih0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCYmdG4odGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudC5jb25jYXQodGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCksWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW2Uuc2VudCgpXS5jb25jYXQodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbj10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PXIuc2VudCgpLFplKChmdW5jdGlvbigpe24uYWNjQmV0YTEuYXNzaWduKHhjKG4uYmV0YTEsbi5pdGVyYXRpb25zXysxKSksbi5hY2NCZXRhMi5hc3NpZ24oeGMobi5iZXRhMixuLml0ZXJhdGlvbnNfKzEpKX0pKSxlPXQubGVuZ3RoLzIsITEsdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PXQuc2xpY2UoMCxlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudD10LnNsaWNlKGUsMiplKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxiZXRhMTp0aGlzLmJldGExLGJldGEyOnRoaXMuYmV0YTIsZXBzaWxvbjp0aGlzLmVwc2lsb259fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5iZXRhMSxlLmJldGEyLGUuZXBzaWxvbil9LG8uY2xhc3NOYW1lPVwiQWRhbVwiLG99KHhkKTtjZChDZCk7dmFyIEVkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuLHIsbyxhKXt2b2lkIDA9PT1vJiYobz1udWxsKSx2b2lkIDA9PT1hJiYoYT0wKTt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkubGVhcm5pbmdSYXRlPWUsaS5iZXRhMT1uLGkuYmV0YTI9cixpLmVwc2lsb249byxpLmRlY2F5PWEsaS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PVtdLGkuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm09W10sWmUoKGZ1bmN0aW9uKCl7aS5pdGVyYXRpb249T24oMCkudmFyaWFibGUoKSxpLmFjY0JldGExPU9uKG4pLnZhcmlhYmxlKCl9KSksbnVsbD09byYmKGkuZXBzaWxvbj1MdC5iYWNrZW5kLmVwc2lsb24oKSksaX1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1BcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpO1plKChmdW5jdGlvbigpe3ZhciByPUNjKDEsZS5hY2NCZXRhMSksbz1zYygtZS5sZWFybmluZ1JhdGUsZS5pdGVyYXRpb24ubXVsKGUuZGVjYXkpLmFkZCgxKSk7bi5mb3JFYWNoKChmdW5jdGlvbihuLGEpe3ZhciBpPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07bnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdJiYoZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdPXtvcmlnaW5hbE5hbWU6bitcIi9tXCIsdmFyaWFibGU6WG4oaSkudmFyaWFibGUoITEpfSksbnVsbD09ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVthXSYmKGUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bYV09e29yaWdpbmFsTmFtZTpuK1wiL3ZcIix2YXJpYWJsZTpYbihpKS52YXJpYWJsZSghMSl9KTt2YXIgcz1BcnJheS5pc0FycmF5KHQpP3RbYV0udGVuc29yOnRbbl07aWYobnVsbCE9cyl7dmFyIHU9ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdLnZhcmlhYmxlLGM9ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVthXS52YXJpYWJsZSxsPXUubXVsKGUuYmV0YTEpLmFkZChzLm11bCgxLWUuYmV0YTEpKSxoPWMubXVsKGUuYmV0YTIpLGY9cy5hYnMoKSxkPWgubWF4aW11bShmKTt1LmFzc2lnbihsKSxjLmFzc2lnbihkKTt2YXIgcD1vLmRpdihyKS5tdWwobC5kaXYoZC5hZGQoZS5lcHNpbG9uKSkpLmFkZChpKTtpLmFzc2lnbihwKX19KSksZS5pdGVyYXRpb24uYXNzaWduKGUuaXRlcmF0aW9uLmFkZCgxKSksZS5hY2NCZXRhMS5hc3NpZ24oZS5hY2NCZXRhMS5tdWwoZS5iZXRhMSkpfSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5pdGVyYXRpb24uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCYmdG4odGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0mJnRuKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiZ2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQWRhbWF4IHlldC5cIil9KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcInNldFdlaWdodHMoKSBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEFkYW1heCB5ZXQuXCIpfSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbixkZWNheTp0aGlzLmRlY2F5fX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuYmV0YTEsZS5iZXRhMixlLmVwc2lsb24sZS5kZWNheSl9LG8uY2xhc3NOYW1lPVwiQWRhbWF4XCIsb30oeGQpO2NkKEVkKTt2YXIgUmQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4ubGVhcm5pbmdSYXRlPWUsbi5zZXRMZWFybmluZ1JhdGUoZSksbn1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO2lmKG51bGwhPW8pe3ZhciBhPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07WmUoKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5jLm11bChvKS5hZGQoYSk7YS5hc3NpZ24odCl9KSl9fSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5zZXRMZWFybmluZ1JhdGU9ZnVuY3Rpb24odCl7dGhpcy5sZWFybmluZ1JhdGU9dCxudWxsIT10aGlzLmMmJnRoaXMuYy5kaXNwb3NlKCksdGhpcy5jPWVuKE9uKC10KSl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmMuZGlzcG9zZSgpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW3Quc2VudCgpXV19fSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnModCldO2Nhc2UgMTppZigwIT09KHQ9ZS5zZW50KCkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTR0Qgb3B0aW1pemVyIGRvZXMgbm90IGhhdmUgc2V0dGFibGUgd2VpZ2h0cy5cIik7cmV0dXJuWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZX19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSl9LG8uY2xhc3NOYW1lPVwiU0dEXCIsb30oeGQpO2NkKFJkKTt2YXIgSWQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPXQuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiBvLmxlYXJuaW5nUmF0ZT1lLG8ubW9tZW50dW09bixvLnVzZU5lc3Rlcm92PXIsby5hY2N1bXVsYXRpb25zPVtdLG8ubT1PbihvLm1vbWVudHVtKSxvfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsoQXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSkuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PWUuYWNjdW11bGF0aW9uc1tyXSl7ZS5hY2N1bXVsYXRpb25zW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9tb21lbnR1bVwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9fXZhciBhPWUuYWNjdW11bGF0aW9uc1tyXS52YXJpYWJsZSxpPUFycmF5LmlzQXJyYXkodCk/dFtyXS50ZW5zb3I6dFtuXTtudWxsIT1pJiZaZSgoZnVuY3Rpb24oKXt2YXIgdCxuPWUubS5tdWwoYSkuYWRkKGkpO3Q9ZS51c2VOZXN0ZXJvdj9lLmMubXVsKGkuYWRkKG4ubXVsKGUubSkpKS5hZGQobyk6ZS5jLm11bChuKS5hZGQobyksYS5hc3NpZ24obiksby5hc3NpZ24odCl9KSl9KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLm0uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0aW9ucyYmdG4odGhpcy5hY2N1bXVsYXRpb25zLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpfSxvLnByb3RvdHlwZS5zZXRNb21lbnR1bT1mdW5jdGlvbih0KXt0aGlzLm1vbWVudHVtPXR9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbdC5zZW50KCldLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGlvbnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX19KSkpXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLCExLHRoaXMuYWNjdW11bGF0aW9ucz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLG1vbWVudHVtOnRoaXMubW9tZW50dW0sdXNlTmVzdGVyb3Y6dGhpcy51c2VOZXN0ZXJvdn19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLm1vbWVudHVtLGUudXNlTmVzdGVyb3YpfSxvLmNsYXNzTmFtZT1cIk1vbWVudHVtXCIsb30oUmQpO2NkKElkKTt2YXIga2Q9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4scixvLGEpe3ZvaWQgMD09PW4mJihuPS45KSx2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1udWxsKSx2b2lkIDA9PT1hJiYoYT0hMSk7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO2lmKGkubGVhcm5pbmdSYXRlPWUsaS5kZWNheT1uLGkubW9tZW50dW09cixpLmVwc2lsb249byxpLmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9W10saS5hY2N1bXVsYXRlZE1vbWVudHM9W10saS5hY2N1bXVsYXRlZE1lYW5HcmFkcz1bXSxpLmNlbnRlcmVkPWEsbnVsbD09byYmKGkuZXBzaWxvbj1MdC5iYWNrZW5kLmVwc2lsb24oKSksbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJsZWFybmluZ1JhdGUgZm9yIFJNU1Byb3BPcHRpbWl6ZXIgbXVzdCBiZSBkZWZpbmVkLlwiKTtyZXR1cm4gaX1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtudWxsPT1lLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl0mJihlLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl09e29yaWdpbmFsTmFtZTpuK1wiL3Jtc1wiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9KSxudWxsPT1lLmFjY3VtdWxhdGVkTW9tZW50c1tyXSYmKGUuYWNjdW11bGF0ZWRNb21lbnRzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9tb21lbnR1bVwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9KSxudWxsPT1lLmFjY3VtdWxhdGVkTWVhbkdyYWRzW3JdJiZlLmNlbnRlcmVkJiYoZS5hY2N1bXVsYXRlZE1lYW5HcmFkc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvbWdcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfSk7dmFyIGE9QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO2lmKG51bGwhPWEpe3ZhciBpPWUuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tyXS52YXJpYWJsZSxzPWUuYWNjdW11bGF0ZWRNb21lbnRzW3JdLnZhcmlhYmxlO1plKChmdW5jdGlvbigpe3ZhciB0PWkubXVsKGUuZGVjYXkpLmFkZChhLnNxdWFyZSgpLm11bCgxLWUuZGVjYXkpKTtpZihlLmNlbnRlcmVkKXt2YXIgbj1lLmFjY3VtdWxhdGVkTWVhbkdyYWRzW3JdLnZhcmlhYmxlLHU9bi5tdWwoZS5kZWNheSkuYWRkKGEubXVsKDEtZS5kZWNheSkpLGM9cy5tdWwoZS5tb21lbnR1bSkuYWRkKGEubXVsKGUubGVhcm5pbmdSYXRlKS5kaXYodC5zdWIodS5zcXVhcmUoKS5hZGQoZS5lcHNpbG9uKSkuc3FydCgpKSk7aS5hc3NpZ24odCksbi5hc3NpZ24odSkscy5hc3NpZ24oYyk7dmFyIGw9by5zdWIoYyk7by5hc3NpZ24obCl9ZWxzZXt2YXIgaD1pLm11bChlLmRlY2F5KS5hZGQoYS5zcXVhcmUoKS5tdWwoMS1lLmRlY2F5KSk7Yz1zLm11bChlLm1vbWVudHVtKS5hZGQoYS5tdWwoZS5sZWFybmluZ1JhdGUpLmRpdihoLmFkZChlLmVwc2lsb24pLnNxcnQoKSkpO2kuYXNzaWduKGgpLHMuYXNzaWduKGMpO2w9by5zdWIoYyk7by5hc3NpZ24obCl9fSkpfX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe251bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyYmdG4odGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMmJnRoaXMuY2VudGVyZWQmJnRuKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1vbWVudHMmJnRuKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkTW9tZW50cyksdGhpcy5jZW50ZXJlZCYmdC5wdXNoLmFwcGx5KHQsdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyksWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW2Uuc2VudCgpXS5jb25jYXQodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6cmV0dXJuIHQ9bi5zZW50KCksZT10aGlzLmNlbnRlcmVkP3QubGVuZ3RoLzM6dC5sZW5ndGgvMiwhMSx0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9dC5zbGljZSgwLGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSx0aGlzLmFjY3VtdWxhdGVkTW9tZW50cz10LnNsaWNlKGUsMiplKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksdGhpcy5jZW50ZXJlZCYmKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHM9dC5zbGljZSgyKmUsMyplKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSkpLFsyXX19KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsZGVjYXk6dGhpcy5kZWNheSxtb21lbnR1bTp0aGlzLm1vbWVudHVtLGVwc2lsb246dGhpcy5lcHNpbG9uLGNlbnRlcmVkOnRoaXMuY2VudGVyZWR9fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5kZWNheSxlLm1vbWVudHVtLGUuZXBzaWxvbixlLmNlbnRlcmVkKX0sby5jbGFzc05hbWU9XCJSTVNQcm9wXCIsb30oeGQpO2NkKGtkKTt2YXIgU2Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnNnZD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFJkKHQpfSx0Lm1vbWVudHVtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITEpLG5ldyBJZCh0LGUsbil9LHQucm1zcHJvcD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09biYmKG49MCksdm9pZCAwPT09ciYmKHI9bnVsbCksdm9pZCAwPT09byYmKG89ITEpLG5ldyBrZCh0LGUsbixyLG8pfSx0LmFkYW09ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDEpLHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0uOTk5KSx2b2lkIDA9PT1yJiYocj1udWxsKSxuZXcgQ2QodCxlLG4scil9LHQuYWRhZGVsdGE9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0uMDAxKSx2b2lkIDA9PT1lJiYoZT0uOTUpLHZvaWQgMD09PW4mJihuPW51bGwpLG5ldyBiZCh0LGUsbil9LHQuYWRhbWF4PWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDIpLHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0uOTk5KSx2b2lkIDA9PT1yJiYocj1udWxsKSx2b2lkIDA9PT1vJiYobz0wKSxuZXcgRWQodCxlLG4scixvKX0sdC5hZGFncmFkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPS4xKSxuZXcgd2QodCxlKX0sdH0oKSxBZD17c2dkOlNkLnNnZCxtb21lbnR1bTpTZC5tb21lbnR1bSxhZGFkZWx0YTpTZC5hZGFkZWx0YSxhZGFncmFkOlNkLmFkYWdyYWQscm1zcHJvcDpTZC5ybXNwcm9wLGFkYW1heDpTZC5hZGFtYXgsYWRhbTpTZC5hZGFtfSxEZD1cInVuZGVmaW5lZFwiIT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lP3JlcXVlc3RBbmltYXRpb25GcmFtZTpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0SW1tZWRpYXRlP3NldEltbWVkaWF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCgpfTtmdW5jdGlvbiBUZCgpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIERkKChmdW5jdGlvbigpe3JldHVybiB0KCl9KSl9KSl9d3QucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBudSh0aGlzLHQpfSx4dD1HaDtleHBvcnR7YmQgYXMgQWRhZGVsdGFPcHRpbWl6ZXIsd2QgYXMgQWRhZ3JhZE9wdGltaXplcixDZCBhcyBBZGFtT3B0aW1pemVyLEVkIGFzIEFkYW1heE9wdGltaXplcix4byBhcyBEYXRhU3RvcmFnZSxzIGFzIEVOVixvIGFzIEVudmlyb25tZW50LGJvIGFzIEtlcm5lbEJhY2tlbmQsSWQgYXMgTW9tZW50dW1PcHRpbWl6ZXIseGQgYXMgT3B0aW1pemVyLGtkIGFzIFJNU1Byb3BPcHRpbWl6ZXIsQ3QgYXMgUmFuayxjaCBhcyBSZWR1Y3Rpb24sUmQgYXMgU0dET3B0aW1pemVyLHd0IGFzIFRlbnNvcixndCBhcyBUZW5zb3JCdWZmZXIsU3QgYXMgVmFyaWFibGUscnUgYXMgYWJzLG91IGFzIGFjb3MsYXUgYXMgYWNvc2gscmMgYXMgYWRkLG9jIGFzIGFkZE4sYWMgYXMgYWRkU3RyaWN0LENsIGFzIGFsbCxFbCBhcyBhbnksUmwgYXMgYXJnTWF4LElsIGFzIGFyZ01pbixpdSBhcyBhc2luLHN1IGFzIGFzaW5oLHV1IGFzIGF0YW4saWMgYXMgYXRhbjIsY3UgYXMgYXRhbmgsZmwgYXMgYXZnUG9vbCx2bCBhcyBhdmdQb29sM2QsaG4gYXMgYmFja2VuZCxVbyBhcyBiYWNrZW5kX3V0aWwsemwgYXMgYmFzaWNMU1RNQ2VsbCxqdSBhcyBiYXRjaE5vcm0sWHUgYXMgYmF0Y2hOb3JtMmQsWXUgYXMgYmF0Y2hOb3JtM2QsJHUgYXMgYmF0Y2hOb3JtNGQsS3UgYXMgYmF0Y2hOb3JtYWxpemF0aW9uLEd1IGFzIGJhdGNoTm9ybWFsaXphdGlvbjJkLEh1IGFzIGJhdGNoTm9ybWFsaXphdGlvbjNkLHF1IGFzIGJhdGNoTm9ybWFsaXphdGlvbjRkLHZyIGFzIGJhdGNoVG9TcGFjZU5ELFVjIGFzIGJvb2xlYW5NYXNrQXN5bmMsbXIgYXMgYnJvYWRjYXN0VG8saWQgYXMgYnJvd3NlcixkciBhcyBidWZmZXIsZ3IgYXMgY2FzdCxsdSBhcyBjZWlsLGh1IGFzIGNsaXBCeVZhbHVlLHlyIGFzIGNsb25lLERuIGFzIGNvbXBsZXgsWW4gYXMgY29uY2F0LCRuIGFzIGNvbmNhdDFkLFFuIGFzIGNvbmNhdDJkLEpuIGFzIGNvbmNhdDNkLFpuIGFzIGNvbmNhdDRkLEhjIGFzIGNvbnYxZCxxYyBhcyBjb252MmQsWmMgYXMgY29udjJkVHJhbnNwb3NlLEtjIGFzIGNvbnYzZCx0bCBhcyBjb252M2RUcmFuc3Bvc2UsZnUgYXMgY29zLGR1IGFzIGNvc2gseHIgYXMgY3Vtc3VtLHZvIGFzIGN1c3RvbUdyYWQsWGUgYXMgZGVwcmVjYXRpb25XYXJuLGJyIGFzIGRlcHRoVG9TcGFjZSxZYyBhcyBkZXB0aHdpc2VDb252MmQsZWggYXMgZGlhZyxqZSBhcyBkaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5ncyx0biBhcyBkaXNwb3NlLFllIGFzIGRpc3Bvc2VWYXJpYWJsZXMsc2MgYXMgZGl2LHVjIGFzIGRpdk5vTmFuLGNjIGFzIGRpdlN0cmljdCxubCBhcyBkb3QsbmggYXMgZHJvcG91dCxfbCBhcyBlbHUsS2UgYXMgZW5hYmxlRGVidWdNb2RlLHFlIGFzIGVuYWJsZVByb2RNb2RlLCRlIGFzIGVuZ2luZSxpIGFzIGVudixSYyBhcyBlcXVhbCxJYyBhcyBlcXVhbFN0cmljdCxwdSBhcyBlcmYsdnUgYXMgZXhwLHdyIGFzIGV4cGFuZERpbXMsbXUgYXMgZXhwbTEsQ3IgYXMgZXllLFhsIGFzIGZmdCxIbiBhcyBmaWxsLHVuIGFzIGZpbmRCYWNrZW5kLGNuIGFzIGZpbmRCYWNrZW5kRmFjdG9yeSxndSBhcyBmbG9vcixsYyBhcyBmbG9vckRpdixpaCBhcyBmcmFtZSx6aCBhcyBmdXNlZCxMYyBhcyBnYXRoZXIsdGggYXMgZ2F0aGVyTkQsWHIgYXMgZ2F0aGVyX3V0aWwsYW4gYXMgZ2V0QmFja2VuZCxoIGFzIGdldEdyYWRpZW50LGwgYXMgZ2V0S2VybmVsLGYgYXMgZ2V0S2VybmVsc0ZvckJhY2tlbmQsY28gYXMgZ3JhZCxsbyBhcyBncmFkcyxrYyBhcyBncmVhdGVyLFNjIGFzIGdyZWF0ZXJFcXVhbCxBYyBhcyBncmVhdGVyRXF1YWxTdHJpY3QsRGMgYXMgZ3JlYXRlclN0cmljdCxhaCBhcyBoYW1taW5nV2luZG93LG9oIGFzIGhhbm5XaW5kb3csWWwgYXMgaWZmdCxObiBhcyBpbWFnLE9oIGFzIGltYWdlLGxoIGFzIGluVG9wS0FzeW5jLGVkIGFzIGlvLFFsIGFzIGlyZmZ0LER1IGFzIGlzRmluaXRlLEF1IGFzIGlzSW5mLFN1IGFzIGlzTmFOLGVuIGFzIGtlZXAsT2wgYXMgbGVha3lSZWx1LFRjIGFzIGxlc3MsTmMgYXMgbGVzc0VxdWFsLEZjIGFzIGxlc3NFcXVhbFN0cmljdCxfYyBhcyBsZXNzU3RyaWN0LEloIGFzIGxpbmFsZyxxbiBhcyBsaW5zcGFjZSxVbCBhcyBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbix5dSBhcyBsb2cseHUgYXMgbG9nMXAsYnUgYXMgbG9nU2lnbW9pZCx5byBhcyBsb2dTb2Z0bWF4LGtsIGFzIGxvZ1N1bUV4cCxRdSBhcyBsb2dpY2FsQW5kLEp1IGFzIGxvZ2ljYWxOb3QsWnUgYXMgbG9naWNhbE9yLHRjIGFzIGxvZ2ljYWxYb3IsYmggYXMgbG9zc2VzLGVsIGFzIG1hdE11bCxvZCBhcyBtYXRoLFNsIGFzIG1heCxobCBhcyBtYXhQb29sLHBsIGFzIG1heFBvb2wzZCxoYyBhcyBtYXhpbXVtLGZjIGFzIG1heGltdW1TdHJpY3QsQWwgYXMgbWVhbixRZSBhcyBtZW1vcnksRGwgYXMgbWluLGRjIGFzIG1pbmltdW0scGMgYXMgbWluaW11bVN0cmljdCx2YyBhcyBtb2QsbWMgYXMgbW9kU3RyaWN0LFRsIGFzIG1vbWVudHMsSGwgYXMgbW92aW5nQXZlcmFnZSxnYyBhcyBtdWwseWMgYXMgbXVsU3RyaWN0LEdsIGFzIG11bHRpUk5OQ2VsbCxFciBhcyBtdWx0aW5vbWlhbCx3dSBhcyBuZWcsVGQgYXMgbmV4dEZyYW1lLFZsIGFzIG5vcm0sT2MgYXMgbm90RXF1YWwsTWMgYXMgbm90RXF1YWxTdHJpY3QsUnIgYXMgb25lSG90LHpuIGFzIG9uZXMsam4gYXMgb25lc0xpa2UsQW4gYXMgb3AscmwgYXMgb3V0ZXJQcm9kdWN0LElyIGFzIHBhZCxrciBhcyBwYWQxZCxTciBhcyBwYWQyZCxBciBhcyBwYWQzZCxEciBhcyBwYWQ0ZCxkbCBhcyBwb29sLHhjIGFzIHBvdyxiYyBhcyBwb3dTdHJpY3QsTWwgYXMgcHJlbHUscHIgYXMgcHJpbnQsRmwgYXMgcHJvZCxKZSBhcyBwcm9maWxlLFRyIGFzIHJhbmQsRnIgYXMgcmFuZG9tR2FtbWEsTnIgYXMgcmFuZG9tTm9ybWFsLF9yIGFzIHJhbmRvbVVuaWZvcm0sS24gYXMgcmFuZ2Usb24gYXMgcmVhZHksVG4gYXMgcmVhbCxDdSBhcyByZWNpcHJvY2FsLGxuIGFzIHJlZ2lzdGVyQmFja2VuZCxwIGFzIHJlZ2lzdGVyR3JhZGllbnQsZCBhcyByZWdpc3Rlcktlcm5lbCxCbCBhcyByZWx1LFBsIGFzIHJlbHU2LHNuIGFzIHJlbW92ZUJhY2tlbmQsT3IgYXMgcmVzaGFwZSxvbCBhcyByZXZlcnNlLGFsIGFzIHJldmVyc2UxZCxpbCBhcyByZXZlcnNlMmQsc2wgYXMgcmV2ZXJzZTNkLHVsIGFzIHJldmVyc2U0ZCwkbCBhcyByZmZ0LEV1IGFzIHJvdW5kLFJ1IGFzIHJzcXJ0LE9uIGFzIHNjYWxhcixqbCBhcyBzY2F0dGVyTkQsdG8gYXMgc2NhdHRlcl91dGlsLExsIGFzIHNlbHUsSmMgYXMgc2VwYXJhYmxlQ29udjJkLGxkIGFzIHNlcmlhbGl6YXRpb24scm4gYXMgc2V0QmFja2VuZCxmbiBhcyBzZXRQbGF0Zm9ybSxWciBhcyBzZXRkaWZmMWRBc3luYyxJdSBhcyBzaWdtb2lkLGt1IGFzIHNpZ24sdWggYXMgc2lnbmFsLFR1IGFzIHNpbixOdSBhcyBzaW5oLG1sIGFzIHNsaWNlLGdsIGFzIHNsaWNlMWQseWwgYXMgc2xpY2UyZCx4bCBhcyBzbGljZTNkLGJsIGFzIHNsaWNlNGQsdW8gYXMgc2xpY2VfdXRpbCxnbyBhcyBzb2Z0bWF4LEZ1IGFzIHNvZnRwbHVzLE1yIGFzIHNwYWNlVG9CYXRjaE5ELFpsIGFzIHNwYXJzZVRvRGVuc2UsSmwgYXMgc3BlY3RyYWwsdHIgYXMgc3BsaXQsX3UgYXMgc3FydCx0dSBhcyBzcXVhcmUsbnUgYXMgc3F1YXJlZERpZmZlcmVuY2Usd2MgYXMgc3F1YXJlZERpZmZlcmVuY2VTdHJpY3QsQnIgYXMgc3F1ZWV6ZSxQciBhcyBzdGFjayxPdSBhcyBzdGVwLHNoIGFzIHN0ZnQscWwgYXMgc3RyaWRlZFNsaWNlLENjIGFzIHN1YixFYyBhcyBzdWJTdHJpY3QsTmwgYXMgc3VtLFR0IGFzIHN1bU91dFR5cGUsTXUgYXMgdGFuLEJ1IGFzIHRhbmgsRm4gYXMgdGVuc29yLE1uIGFzIHRlbnNvcjFkLEJuIGFzIHRlbnNvcjJkLFBuIGFzIHRlbnNvcjNkLExuIGFzIHRlbnNvcjRkLFduIGFzIHRlbnNvcjVkLFVuIGFzIHRlbnNvcjZkLE10IGFzIHRlbnNvcl91dGlsLG1kIGFzIHRlc3RfdXRpbCxaZSBhcyB0aWR5LExyIGFzIHRpbGUsbm4gYXMgdGltZSxLbCBhcyB0b3BrLEFkIGFzIHRyYWluLFdsIGFzIHRyYW5zcG9zZSxXciBhcyB0cnVuY2F0ZWROb3JtYWwsbSBhcyB1bnJlZ2lzdGVyR3JhZGllbnQsdiBhcyB1bnJlZ2lzdGVyS2VybmVsLFdjIGFzIHVuc29ydGVkU2VnbWVudFN1bSxVciBhcyB1bnN0YWNrLHN0IGFzIHV0aWwsaG8gYXMgdmFsdWVBbmRHcmFkLGZvIGFzIHZhbHVlQW5kR3JhZHMsVm4gYXMgdmFyaWFibGUscG8gYXMgdmFyaWFibGVHcmFkcyxnZCBhcyB2ZXJzaW9uX2NvcmUseWQgYXMgd2ViZ2wsZWMgYXMgd2hlcmUsbmMgYXMgd2hlcmVBc3luYyxHbiBhcyB6ZXJvcyxYbiBhcyB6ZXJvc0xpa2V9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYtY29yZS5lc20uanMubWFwXG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZ2V0TW9kZWxVcmlzIH0gZnJvbSAnLi9jb21tb24vZ2V0TW9kZWxVcmlzJztcclxuaW1wb3J0IHsgbG9hZFdlaWdodE1hcCB9IGZyb20gJy4vZG9tJztcclxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi9lbnYnO1xyXG52YXIgTmV1cmFsTmV0d29yayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5ldXJhbE5ldHdvcmsoX25hbWUpIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXVyYWxOZXR3b3JrLnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyYW1zOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXVyYWxOZXR3b3JrLnByb3RvdHlwZSwgXCJwYXJhbU1hcHBpbmdzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmFtTWFwcGluZ3M7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLCBcImlzTG9hZGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5wYXJhbXM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUuZ2V0UGFyYW1Gcm9tUGF0aCA9IGZ1bmN0aW9uIChwYXJhbVBhdGgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnRyYXZlcnNlUHJvcGVydHlQYXRoKHBhcmFtUGF0aCksIG9iaiA9IF9hLm9iaiwgb2JqUHJvcCA9IF9hLm9ialByb3A7XHJcbiAgICAgICAgcmV0dXJuIG9ialtvYmpQcm9wXTtcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5yZWFzc2lnblBhcmFtRnJvbVBhdGggPSBmdW5jdGlvbiAocGFyYW1QYXRoLCB0ZW5zb3IpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnRyYXZlcnNlUHJvcGVydHlQYXRoKHBhcmFtUGF0aCksIG9iaiA9IF9hLm9iaiwgb2JqUHJvcCA9IF9hLm9ialByb3A7XHJcbiAgICAgICAgb2JqW29ialByb3BdLmRpc3Bvc2UoKTtcclxuICAgICAgICBvYmpbb2JqUHJvcF0gPSB0ZW5zb3I7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUuZ2V0UGFyYW1MaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtTWFwcGluZ3MubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1QYXRoID0gX2EucGFyYW1QYXRoO1xyXG4gICAgICAgICAgICByZXR1cm4gKHtcclxuICAgICAgICAgICAgICAgIHBhdGg6IHBhcmFtUGF0aCxcclxuICAgICAgICAgICAgICAgIHRlbnNvcjogX3RoaXMuZ2V0UGFyYW1Gcm9tUGF0aChwYXJhbVBhdGgpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmdldFRyYWluYWJsZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJhbUxpc3QoKS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS50ZW5zb3IgaW5zdGFuY2VvZiB0Zi5WYXJpYWJsZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUuZ2V0RnJvemVuUGFyYW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmFtTGlzdCgpLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICEocGFyYW0udGVuc29yIGluc3RhbmNlb2YgdGYuVmFyaWFibGUpOyB9KTtcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZ2V0RnJvemVuUGFyYW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSBfYS5wYXRoLCB0ZW5zb3IgPSBfYS50ZW5zb3I7XHJcbiAgICAgICAgICAgIF90aGlzLnJlYXNzaWduUGFyYW1Gcm9tUGF0aChwYXRoLCB0ZW5zb3IudmFyaWFibGUoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5nZXRUcmFpbmFibGVQYXJhbXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IF9hLnBhdGgsIHZhcmlhYmxlID0gX2EudGVuc29yO1xyXG4gICAgICAgICAgICB2YXIgdGVuc29yID0gdGYudGVuc29yKHZhcmlhYmxlLmRhdGFTeW5jKCkpO1xyXG4gICAgICAgICAgICB2YXJpYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlYXNzaWduUGFyYW1Gcm9tUGF0aChwYXRoLCB0ZW5zb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAodGhyb3dPblJlZGlzcG9zZSkge1xyXG4gICAgICAgIGlmICh0aHJvd09uUmVkaXNwb3NlID09PSB2b2lkIDApIHsgdGhyb3dPblJlZGlzcG9zZSA9IHRydWU7IH1cclxuICAgICAgICB0aGlzLmdldFBhcmFtTGlzdCgpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIGlmICh0aHJvd09uUmVkaXNwb3NlICYmIHBhcmFtLnRlbnNvci5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJhbSB0ZW5zb3IgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBmb3IgcGF0aCBcIiArIHBhcmFtLnBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtLnRlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLnNlcmlhbGl6ZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmdldFBhcmFtTGlzdCgpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW5zb3IgPSBfYS50ZW5zb3I7XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRlbnNvci5kYXRhU3luYygpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCBhcnIpIHsgcmV0dXJuIGZsYXQuY29uY2F0KGFycik7IH0pKTtcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHdlaWdodHNPclVybCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlaWdodHNPclVybCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYWN0V2VpZ2h0cyh3ZWlnaHRzT3JVcmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubG9hZEZyb21Vcmkod2VpZ2h0c09yVXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUubG9hZEZyb21VcmkgPSBmdW5jdGlvbiAodXJpKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2VpZ2h0TWFwO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJpICYmIHR5cGVvZiB1cmkgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiLmxvYWRGcm9tVXJpIC0gZXhwZWN0ZWQgbW9kZWwgdXJpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxvYWRXZWlnaHRNYXAodXJpLCB0aGlzLmdldERlZmF1bHRNb2RlbE5hbWUoKSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0TWFwID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRGcm9tV2VpZ2h0TWFwKHdlaWdodE1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUubG9hZEZyb21EaXNrID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVhZEZpbGUsIF9hLCBtYW5pZmVzdFVyaSwgbW9kZWxCYXNlVXJpLCBmZXRjaFdlaWdodHNGcm9tRGlzaywgbG9hZFdlaWdodHMsIG1hbmlmZXN0LCBfYiwgX2MsIHdlaWdodE1hcDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVQYXRoICYmIHR5cGVvZiBmaWxlUGF0aCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIubG9hZEZyb21EaXNrIC0gZXhwZWN0ZWQgbW9kZWwgZmlsZSBwYXRoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRGaWxlID0gZW52LmdldEVudigpLnJlYWRGaWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGdldE1vZGVsVXJpcyhmaWxlUGF0aCwgdGhpcy5nZXREZWZhdWx0TW9kZWxOYW1lKCkpLCBtYW5pZmVzdFVyaSA9IF9hLm1hbmlmZXN0VXJpLCBtb2RlbEJhc2VVcmkgPSBfYS5tb2RlbEJhc2VVcmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoV2VpZ2h0c0Zyb21EaXNrID0gZnVuY3Rpb24gKGZpbGVQYXRocykgeyByZXR1cm4gUHJvbWlzZS5hbGwoZmlsZVBhdGhzLm1hcChmdW5jdGlvbiAoZmlsZVBhdGgpIHsgcmV0dXJuIHJlYWRGaWxlKGZpbGVQYXRoKS50aGVuKGZ1bmN0aW9uIChidWYpIHsgcmV0dXJuIGJ1Zi5idWZmZXI7IH0pOyB9KSk7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRXZWlnaHRzID0gdGYuaW8ud2VpZ2h0c0xvYWRlckZhY3RvcnkoZmV0Y2hXZWlnaHRzRnJvbURpc2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IChfYiA9IEpTT04pLnBhcnNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZWFkRmlsZShtYW5pZmVzdFVyaSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3QgPSBfYy5hcHBseShfYiwgWyhfZC5zZW50KCkpLnRvU3RyaW5nKCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbG9hZFdlaWdodHMobWFuaWZlc3QsIG1vZGVsQmFzZVVyaSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0TWFwID0gX2Quc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRGcm9tV2VpZ2h0TWFwKHdlaWdodE1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUubG9hZEZyb21XZWlnaHRNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXApLCBwYXJhbU1hcHBpbmdzID0gX2EucGFyYW1NYXBwaW5ncywgcGFyYW1zID0gX2EucGFyYW1zO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtTWFwcGluZ3MgPSBwYXJhbU1hcHBpbmdzO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5leHRyYWN0V2VpZ2h0cyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5leHRyYWN0UGFyYW1zKHdlaWdodHMpLCBwYXJhbU1hcHBpbmdzID0gX2EucGFyYW1NYXBwaW5ncywgcGFyYW1zID0gX2EucGFyYW1zO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtTWFwcGluZ3MgPSBwYXJhbU1hcHBpbmdzO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS50cmF2ZXJzZVByb3BlcnR5UGF0aCA9IGZ1bmN0aW9uIChwYXJhbVBhdGgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyYXZlcnNlUHJvcGVydHlQYXRoIC0gbW9kZWwgaGFzIG5vIGxvYWRlZCBwYXJhbXNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJhbVBhdGguc3BsaXQoJy8nKS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgb2JqUHJvcCkge1xyXG4gICAgICAgICAgICBpZiAoIXJlcy5uZXh0T2JqLmhhc093blByb3BlcnR5KG9ialByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmF2ZXJzZVByb3BlcnR5UGF0aCAtIG9iamVjdCBkb2VzIG5vdCBoYXZlIHByb3BlcnR5IFwiICsgb2JqUHJvcCArIFwiLCBmb3IgcGF0aCBcIiArIHBhcmFtUGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgb2JqOiByZXMubmV4dE9iaiwgb2JqUHJvcDogb2JqUHJvcCwgbmV4dE9iajogcmVzLm5leHRPYmpbb2JqUHJvcF0gfTtcclxuICAgICAgICB9LCB7IG5leHRPYmo6IHRoaXMucGFyYW1zIH0pO1xyXG4gICAgICAgIHZhciBvYmogPSByZXN1bHQub2JqLCBvYmpQcm9wID0gcmVzdWx0Lm9ialByb3A7XHJcbiAgICAgICAgaWYgKCFvYmogfHwgIW9ialByb3AgfHwgIShvYmpbb2JqUHJvcF0gaW5zdGFuY2VvZiB0Zi5UZW5zb3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyYXZlcnNlUHJvcGVydHlQYXRoIC0gcGFyYW1ldGVyIGlzIG5vdCBhIHRlbnNvciwgZm9yIHBhdGggXCIgKyBwYXJhbVBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBvYmo6IG9iaiwgb2JqUHJvcDogb2JqUHJvcCB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOZXVyYWxOZXR3b3JrO1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZXVyYWxOZXR3b3JrIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5ldXJhbE5ldHdvcmsuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGZ1bGx5Q29ubmVjdGVkTGF5ZXIgfSBmcm9tICcuLi9jb21tb24vZnVsbHlDb25uZWN0ZWRMYXllcic7XHJcbmltcG9ydCB7IHNlcGVyYXRlV2VpZ2h0TWFwcyB9IGZyb20gJy4uL2ZhY2VQcm9jZXNzb3IvdXRpbCc7XHJcbmltcG9ydCB7IFRpbnlYY2VwdGlvbiB9IGZyb20gJy4uL3hjZXB0aW9uL1RpbnlYY2VwdGlvbic7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXMgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAnO1xyXG5pbXBvcnQgeyBHZW5kZXIgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBOZXRJbnB1dCwgdG9OZXRJbnB1dCB9IGZyb20gJy4uL2RvbSc7XHJcbnZhciBBZ2VHZW5kZXJOZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWdlR2VuZGVyTmV0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWdlR2VuZGVyTmV0KGZhY2VGZWF0dXJlRXh0cmFjdG9yKSB7XHJcbiAgICAgICAgaWYgKGZhY2VGZWF0dXJlRXh0cmFjdG9yID09PSB2b2lkIDApIHsgZmFjZUZlYXR1cmVFeHRyYWN0b3IgPSBuZXcgVGlueVhjZXB0aW9uKDIpOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ0FnZUdlbmRlck5ldCcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yID0gZmFjZUZlYXR1cmVFeHRyYWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFnZUdlbmRlck5ldC5wcm90b3R5cGUsIFwiZmFjZUZlYXR1cmVFeHRyYWN0b3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFjZUZlYXR1cmVFeHRyYWN0b3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLnJ1bk5ldCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJvdHRsZW5lY2tGZWF0dXJlcyA9IGlucHV0IGluc3RhbmNlb2YgTmV0SW5wdXRcclxuICAgICAgICAgICAgICAgID8gX3RoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZm9yd2FyZElucHV0KGlucHV0KVxyXG4gICAgICAgICAgICAgICAgOiBpbnB1dDtcclxuICAgICAgICAgICAgdmFyIHBvb2xlZCA9IHRmLmF2Z1Bvb2woYm90dGxlbmVja0ZlYXR1cmVzLCBbNywgN10sIFsyLCAyXSwgJ3ZhbGlkJykuYXMyRChib3R0bGVuZWNrRmVhdHVyZXMuc2hhcGVbMF0sIC0xKTtcclxuICAgICAgICAgICAgdmFyIGFnZSA9IGZ1bGx5Q29ubmVjdGVkTGF5ZXIocG9vbGVkLCBwYXJhbXMuZmMuYWdlKS5hczFEKCk7XHJcbiAgICAgICAgICAgIHZhciBnZW5kZXIgPSBmdWxseUNvbm5lY3RlZExheWVyKHBvb2xlZCwgcGFyYW1zLmZjLmdlbmRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGFnZTogYWdlLCBnZW5kZXI6IGdlbmRlciB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFnZUdlbmRlck5ldC5wcm90b3R5cGUuZm9yd2FyZElucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnJ1bk5ldChpbnB1dCksIGFnZSA9IF9hLmFnZSwgZ2VuZGVyID0gX2EuZ2VuZGVyO1xyXG4gICAgICAgICAgICByZXR1cm4geyBhZ2U6IGFnZSwgZ2VuZGVyOiB0Zi5zb2Z0bWF4KGdlbmRlcikgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHRoaXMsIFtfYi5zZW50KCldKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFnZUdlbmRlck5ldC5wcm90b3R5cGUucHJlZGljdEFnZUFuZEdlbmRlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ldElucHV0LCBvdXQsIGFnZXMsIGdlbmRlcnMsIGFnZUFuZEdlbmRlclRlbnNvcnMsIHByZWRpY3Rpb25zQnlCYXRjaDtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0SW5wdXQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZm9yd2FyZElucHV0KG5ldElucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZXMgPSB0Zi51bnN0YWNrKG91dC5hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJzID0gdGYudW5zdGFjayhvdXQuZ2VuZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlQW5kR2VuZGVyVGVuc29ycyA9IGFnZXMubWFwKGZ1bmN0aW9uIChhZ2VUZW5zb3IsIGkpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VUZW5zb3I6IGFnZVRlbnNvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlclRlbnNvcjogZ2VuZGVyc1tpXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKGFnZUFuZEdlbmRlclRlbnNvcnMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZ2VUZW5zb3IgPSBfYS5hZ2VUZW5zb3IsIGdlbmRlclRlbnNvciA9IF9hLmdlbmRlclRlbnNvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWdlLCBwcm9iTWFsZSwgaXNNYWxlLCBnZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBhZ2VUZW5zb3IuZGF0YSgpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZSA9IChfYi5zZW50KCkpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZW5kZXJUZW5zb3IuZGF0YSgpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2JNYWxlID0gKF9iLnNlbnQoKSlbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTWFsZSA9IHByb2JNYWxlID4gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXIgPSBpc01hbGUgPyBHZW5kZXIuTUFMRSA6IEdlbmRlci5GRU1BTEU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlclByb2JhYmlsaXR5ID0gaXNNYWxlID8gcHJvYk1hbGUgOiAoMSAtIHByb2JNYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZGVyVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgYWdlOiBhZ2UsIGdlbmRlcjogZ2VuZGVyLCBnZW5kZXJQcm9iYWJpbGl0eTogZ2VuZGVyUHJvYmFiaWxpdHkgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY3Rpb25zQnlCYXRjaCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmFnZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5nZW5kZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0SW5wdXQuaXNCYXRjaElucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmVkaWN0aW9uc0J5QmF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByZWRpY3Rpb25zQnlCYXRjaFswXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFnZUdlbmRlck5ldC5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ2FnZV9nZW5kZXJfbW9kZWwnO1xyXG4gICAgfTtcclxuICAgIEFnZUdlbmRlck5ldC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICh0aHJvd09uUmVkaXNwb3NlKSB7XHJcbiAgICAgICAgaWYgKHRocm93T25SZWRpc3Bvc2UgPT09IHZvaWQgMCkgeyB0aHJvd09uUmVkaXNwb3NlID0gdHJ1ZTsgfVxyXG4gICAgICAgIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZGlzcG9zZSh0aHJvd09uUmVkaXNwb3NlKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLCB0aHJvd09uUmVkaXNwb3NlKTtcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLmxvYWRDbGFzc2lmaWVyUGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLmV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKHdlaWdodHMpLCBwYXJhbXMgPSBfYS5wYXJhbXMsIHBhcmFtTWFwcGluZ3MgPSBfYS5wYXJhbU1hcHBpbmdzO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICB0aGlzLl9wYXJhbU1hcHBpbmdzID0gcGFyYW1NYXBwaW5ncztcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLmV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwID0gZnVuY3Rpb24gKHdlaWdodE1hcCkge1xyXG4gICAgICAgIHZhciBfYSA9IHNlcGVyYXRlV2VpZ2h0TWFwcyh3ZWlnaHRNYXApLCBmZWF0dXJlRXh0cmFjdG9yTWFwID0gX2EuZmVhdHVyZUV4dHJhY3Rvck1hcCwgY2xhc3NpZmllck1hcCA9IF9hLmNsYXNzaWZpZXJNYXA7XHJcbiAgICAgICAgdGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5sb2FkRnJvbVdlaWdodE1hcChmZWF0dXJlRXh0cmFjdG9yTWFwKTtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAoY2xhc3NpZmllck1hcCk7XHJcbiAgICB9O1xyXG4gICAgQWdlR2VuZGVyTmV0LnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICB2YXIgY2xhc3NpZmllcldlaWdodFNpemUgPSAoNTEyICogMSArIDEpICsgKDUxMiAqIDIgKyAyKTtcclxuICAgICAgICB2YXIgZmVhdHVyZUV4dHJhY3RvcldlaWdodHMgPSB3ZWlnaHRzLnNsaWNlKDAsIHdlaWdodHMubGVuZ3RoIC0gY2xhc3NpZmllcldlaWdodFNpemUpO1xyXG4gICAgICAgIHZhciBjbGFzc2lmaWVyV2VpZ2h0cyA9IHdlaWdodHMuc2xpY2Uod2VpZ2h0cy5sZW5ndGggLSBjbGFzc2lmaWVyV2VpZ2h0U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5leHRyYWN0V2VpZ2h0cyhmZWF0dXJlRXh0cmFjdG9yV2VpZ2h0cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdENsYXNzaWZpZXJQYXJhbXMoY2xhc3NpZmllcldlaWdodHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBZ2VHZW5kZXJOZXQ7XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBBZ2VHZW5kZXJOZXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdlR2VuZGVyTmV0LmpzLm1hcCIsImltcG9ydCB7IGV4dHJhY3RGQ1BhcmFtc0ZhY3RvcnksIGV4dHJhY3RXZWlnaHRzRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKHdlaWdodHMpIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0V2VpZ2h0c0ZhY3Rvcnkod2VpZ2h0cyksIGV4dHJhY3RXZWlnaHRzID0gX2EuZXh0cmFjdFdlaWdodHMsIGdldFJlbWFpbmluZ1dlaWdodHMgPSBfYS5nZXRSZW1haW5pbmdXZWlnaHRzO1xyXG4gICAgdmFyIGV4dHJhY3RGQ1BhcmFtcyA9IGV4dHJhY3RGQ1BhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgdmFyIGFnZSA9IGV4dHJhY3RGQ1BhcmFtcyg1MTIsIDEsICdmYy9hZ2UnKTtcclxuICAgIHZhciBnZW5kZXIgPSBleHRyYWN0RkNQYXJhbXMoNTEyLCAyLCAnZmMvZ2VuZGVyJyk7XHJcbiAgICBpZiAoZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiBcIiArIGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzLFxyXG4gICAgICAgIHBhcmFtczogeyBmYzogeyBhZ2U6IGFnZSwgZ2VuZGVyOiBnZW5kZXIgfSB9XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXMuanMubWFwIiwiaW1wb3J0IHsgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMsIGV4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIGV4dHJhY3RXZWlnaHRFbnRyeSA9IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGY1BhcmFtcyhwcmVmaXgpIHtcclxuICAgICAgICB2YXIgd2VpZ2h0cyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi93ZWlnaHRzXCIsIDIpO1xyXG4gICAgICAgIHZhciBiaWFzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2JpYXNcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgd2VpZ2h0czogd2VpZ2h0cywgYmlhczogYmlhcyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICBmYzoge1xyXG4gICAgICAgICAgICBhZ2U6IGV4dHJhY3RGY1BhcmFtcygnZmMvYWdlJyksXHJcbiAgICAgICAgICAgIGdlbmRlcjogZXh0cmFjdEZjUGFyYW1zKCdmYy9nZW5kZXInKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgcmV0dXJuIHsgcGFyYW1zOiBwYXJhbXMsIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL0FnZUdlbmRlck5ldCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgdmFyIEdlbmRlcjtcclxuKGZ1bmN0aW9uIChHZW5kZXIpIHtcclxuICAgIEdlbmRlcltcIkZFTUFMRVwiXSA9IFwiZmVtYWxlXCI7XHJcbiAgICBHZW5kZXJbXCJNQUxFXCJdID0gXCJtYWxlXCI7XHJcbn0pKEdlbmRlciB8fCAoR2VuZGVyID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEJveCB9IGZyb20gJy4vQm94JztcclxudmFyIEJvdW5kaW5nQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJvdW5kaW5nQm94LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQm91bmRpbmdCb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucykge1xyXG4gICAgICAgIGlmIChhbGxvd05lZ2F0aXZlRGltZW5zaW9ucyA9PT0gdm9pZCAwKSB7IGFsbG93TmVnYXRpdmVEaW1lbnNpb25zID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCwgcmlnaHQ6IHJpZ2h0LCBib3R0b206IGJvdHRvbSB9LCBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBCb3VuZGluZ0JveDtcclxufShCb3gpKTtcclxuZXhwb3J0IHsgQm91bmRpbmdCb3ggfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRpbmdCb3guanMubWFwIiwiaW1wb3J0IHsgaXNEaW1lbnNpb25zLCBpc1ZhbGlkTnVtYmVyIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQnO1xyXG52YXIgQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQm94KF9ib3gsIGFsbG93TmVnYXRpdmVEaW1lbnNpb25zKSB7XHJcbiAgICAgICAgaWYgKGFsbG93TmVnYXRpdmVEaW1lbnNpb25zID09PSB2b2lkIDApIHsgYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgdmFyIGJveCA9IChfYm94IHx8IHt9KTtcclxuICAgICAgICB2YXIgaXNCYm94ID0gW2JveC5sZWZ0LCBib3gudG9wLCBib3gucmlnaHQsIGJveC5ib3R0b21dLmV2ZXJ5KGlzVmFsaWROdW1iZXIpO1xyXG4gICAgICAgIHZhciBpc1JlY3QgPSBbYm94LngsIGJveC55LCBib3gud2lkdGgsIGJveC5oZWlnaHRdLmV2ZXJ5KGlzVmFsaWROdW1iZXIpO1xyXG4gICAgICAgIGlmICghaXNSZWN0ICYmICFpc0Jib3gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm94LmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgYm94IHRvIGJlIElCb3VuZGluZ0JveCB8IElSZWN0LCBpbnN0ZWFkIGhhdmUgXCIgKyBKU09OLnN0cmluZ2lmeShib3gpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gaXNSZWN0XHJcbiAgICAgICAgICAgID8gW2JveC54LCBib3gueSwgYm94LndpZHRoLCBib3guaGVpZ2h0XVxyXG4gICAgICAgICAgICA6IFtib3gubGVmdCwgYm94LnRvcCwgYm94LnJpZ2h0IC0gYm94LmxlZnQsIGJveC5ib3R0b20gLSBib3gudG9wXSwgeCA9IF9hWzBdLCB5ID0gX2FbMV0sIHdpZHRoID0gX2FbMl0sIGhlaWdodCA9IF9hWzNdO1xyXG4gICAgICAgIEJveC5hc3NlcnRJc1ZhbGlkQm94KHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9LCAnQm94LmNvbnN0cnVjdG9yJywgYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMpO1xyXG4gICAgICAgIHRoaXMuX3ggPSB4O1xyXG4gICAgICAgIHRoaXMuX3kgPSB5O1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgQm94LmlzUmVjdCA9IGZ1bmN0aW9uIChyZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuICEhcmVjdCAmJiBbcmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0XS5ldmVyeShpc1ZhbGlkTnVtYmVyKTtcclxuICAgIH07XHJcbiAgICBCb3guYXNzZXJ0SXNWYWxpZEJveCA9IGZ1bmN0aW9uIChib3gsIGNhbGxlZSwgYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMpIHtcclxuICAgICAgICBpZiAoYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMgPT09IHZvaWQgMCkgeyBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKCFCb3guaXNSZWN0KGJveCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNhbGxlZSArIFwiIC0gaW52YWxpZCBib3g6IFwiICsgSlNPTi5zdHJpbmdpZnkoYm94KSArIFwiLCBleHBlY3RlZCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHgsIHksIHdpZHRoLCBoZWlnaHRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMgJiYgKGJveC53aWR0aCA8IDAgfHwgYm94LmhlaWdodCA8IDApKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjYWxsZWUgKyBcIiAtIHdpZHRoIChcIiArIGJveC53aWR0aCArIFwiKSBhbmQgaGVpZ2h0IChcIiArIGJveC5oZWlnaHQgKyBcIikgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJ4XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3g7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwieVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl95OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3dpZHRoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcImhlaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oZWlnaHQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwibGVmdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLng7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwidG9wXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJyaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcImJvdHRvbVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJhcmVhXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJ0b3BMZWZ0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJ0b3BSaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy5yaWdodCwgdGhpcy50b3ApOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcImJvdHRvbUxlZnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMubGVmdCwgdGhpcy5ib3R0b20pOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcImJvdHRvbVJpZ2h0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQm94LnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIE1hdGgucm91bmQodmFsKTsgfSksIHggPSBfYVswXSwgeSA9IF9hWzFdLCB3aWR0aCA9IF9hWzJdLCBoZWlnaHQgPSBfYVszXTtcclxuICAgICAgICByZXR1cm4gbmV3IEJveCh7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICB9O1xyXG4gICAgQm94LnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIE1hdGguZmxvb3IodmFsKTsgfSksIHggPSBfYVswXSwgeSA9IF9hWzFdLCB3aWR0aCA9IF9hWzJdLCBoZWlnaHQgPSBfYVszXTtcclxuICAgICAgICByZXR1cm4gbmV3IEJveCh7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICB9O1xyXG4gICAgQm94LnByb3RvdHlwZS50b1NxdWFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLCB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHdpZHRoIC0gaGVpZ2h0KTtcclxuICAgICAgICBpZiAod2lkdGggPCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgeCAtPSAoZGlmZiAvIDIpO1xyXG4gICAgICAgICAgICB3aWR0aCArPSBkaWZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGVpZ2h0IDwgd2lkdGgpIHtcclxuICAgICAgICAgICAgeSAtPSAoZGlmZiAvIDIpO1xyXG4gICAgICAgICAgICBoZWlnaHQgKz0gZGlmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3goeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgfTtcclxuICAgIEJveC5wcm90b3R5cGUucmVzY2FsZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlWCA9IGlzRGltZW5zaW9ucyhzKSA/IHMud2lkdGggOiBzO1xyXG4gICAgICAgIHZhciBzY2FsZVkgPSBpc0RpbWVuc2lvbnMocykgPyBzLmhlaWdodCA6IHM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3goe1xyXG4gICAgICAgICAgICB4OiB0aGlzLnggKiBzY2FsZVgsXHJcbiAgICAgICAgICAgIHk6IHRoaXMueSAqIHNjYWxlWSxcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggKiBzY2FsZVgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgKiBzY2FsZVlcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCb3gucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uIChwYWRYLCBwYWRZKSB7XHJcbiAgICAgICAgdmFyIF9hID0gW1xyXG4gICAgICAgICAgICB0aGlzLnggLSAocGFkWCAvIDIpLFxyXG4gICAgICAgICAgICB0aGlzLnkgLSAocGFkWSAvIDIpLFxyXG4gICAgICAgICAgICB0aGlzLndpZHRoICsgcGFkWCxcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgKyBwYWRZXHJcbiAgICAgICAgXSwgeCA9IF9hWzBdLCB5ID0gX2FbMV0sIHdpZHRoID0gX2FbMl0sIGhlaWdodCA9IF9hWzNdO1xyXG4gICAgICAgIHJldHVybiBuZXcgQm94KHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgIH07XHJcbiAgICBCb3gucHJvdG90eXBlLmNsaXBBdEltYWdlQm9yZGVycyA9IGZ1bmN0aW9uIChpbWdXaWR0aCwgaW1nSGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcywgeCA9IF9hLngsIHkgPSBfYS55LCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b207XHJcbiAgICAgICAgdmFyIGNsaXBwZWRYID0gTWF0aC5tYXgoeCwgMCk7XHJcbiAgICAgICAgdmFyIGNsaXBwZWRZID0gTWF0aC5tYXgoeSwgMCk7XHJcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gcmlnaHQgLSBjbGlwcGVkWDtcclxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gYm90dG9tIC0gY2xpcHBlZFk7XHJcbiAgICAgICAgdmFyIGNsaXBwZWRXaWR0aCA9IE1hdGgubWluKG5ld1dpZHRoLCBpbWdXaWR0aCAtIGNsaXBwZWRYKTtcclxuICAgICAgICB2YXIgY2xpcHBlZEhlaWdodCA9IE1hdGgubWluKG5ld0hlaWdodCwgaW1nSGVpZ2h0IC0gY2xpcHBlZFkpO1xyXG4gICAgICAgIHJldHVybiAobmV3IEJveCh7IHg6IGNsaXBwZWRYLCB5OiBjbGlwcGVkWSwgd2lkdGg6IGNsaXBwZWRXaWR0aCwgaGVpZ2h0OiBjbGlwcGVkSGVpZ2h0IH0pKS5mbG9vcigpO1xyXG4gICAgfTtcclxuICAgIEJveC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoc3gsIHN5KSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcywgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54ICsgc3g7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnkgKyBzeTtcclxuICAgICAgICByZXR1cm4gbmV3IEJveCh7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICB9O1xyXG4gICAgQm94LnByb3RvdHlwZS5wYWRBdEJvcmRlcnMgPSBmdW5jdGlvbiAoaW1hZ2VIZWlnaHQsIGltYWdlV2lkdGgpIHtcclxuICAgICAgICB2YXIgdyA9IHRoaXMud2lkdGggKyAxO1xyXG4gICAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQgKyAxO1xyXG4gICAgICAgIHZhciBkeCA9IDE7XHJcbiAgICAgICAgdmFyIGR5ID0gMTtcclxuICAgICAgICB2YXIgZWR4ID0gdztcclxuICAgICAgICB2YXIgZWR5ID0gaDtcclxuICAgICAgICB2YXIgeCA9IHRoaXMubGVmdDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMudG9wO1xyXG4gICAgICAgIHZhciBleCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgdmFyIGV5ID0gdGhpcy5ib3R0b207XHJcbiAgICAgICAgaWYgKGV4ID4gaW1hZ2VXaWR0aCkge1xyXG4gICAgICAgICAgICBlZHggPSAtZXggKyBpbWFnZVdpZHRoICsgdztcclxuICAgICAgICAgICAgZXggPSBpbWFnZVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXkgPiBpbWFnZUhlaWdodCkge1xyXG4gICAgICAgICAgICBlZHkgPSAtZXkgKyBpbWFnZUhlaWdodCArIGg7XHJcbiAgICAgICAgICAgIGV5ID0gaW1hZ2VIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4IDwgMSkge1xyXG4gICAgICAgICAgICBlZHkgPSAyIC0geDtcclxuICAgICAgICAgICAgeCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5IDwgMSkge1xyXG4gICAgICAgICAgICBlZHkgPSAyIC0geTtcclxuICAgICAgICAgICAgeSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGR5OiBkeSwgZWR5OiBlZHksIGR4OiBkeCwgZWR4OiBlZHgsIHk6IHksIGV5OiBleSwgeDogeCwgZXg6IGV4LCB3OiB3LCBoOiBoIH07XHJcbiAgICB9O1xyXG4gICAgQm94LnByb3RvdHlwZS5jYWxpYnJhdGUgPSBmdW5jdGlvbiAocmVnaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3goe1xyXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQgKyAocmVnaW9uLmxlZnQgKiB0aGlzLndpZHRoKSxcclxuICAgICAgICAgICAgdG9wOiB0aGlzLnRvcCArIChyZWdpb24udG9wICogdGhpcy5oZWlnaHQpLFxyXG4gICAgICAgICAgICByaWdodDogdGhpcy5yaWdodCArIChyZWdpb24ucmlnaHQgKiB0aGlzLndpZHRoKSxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLmJvdHRvbSArIChyZWdpb24uYm90dG9tICogdGhpcy5oZWlnaHQpXHJcbiAgICAgICAgfSkudG9TcXVhcmUoKS5yb3VuZCgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCb3g7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEJveCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3guanMubWFwIiwiaW1wb3J0IHsgaXNWYWxpZE51bWJlciB9IGZyb20gJy4uL3V0aWxzJztcclxudmFyIERpbWVuc2lvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAoIWlzVmFsaWROdW1iZXIod2lkdGgpIHx8ICFpc1ZhbGlkTnVtYmVyKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9ucy5jb25zdHJ1Y3RvciAtIGV4cGVjdGVkIHdpZHRoIGFuZCBoZWlnaHQgdG8gYmUgdmFsaWQgbnVtYmVycywgaW5zdGVhZCBoYXZlIFwiICsgSlNPTi5zdHJpbmdpZnkoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGltZW5zaW9ucy5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fd2lkdGg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpbWVuc2lvbnMucHJvdG90eXBlLCBcImhlaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oZWlnaHQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRGltZW5zaW9ucy5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbnMoMSAvIHRoaXMud2lkdGgsIDEgLyB0aGlzLmhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpbWVuc2lvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IERpbWVuc2lvbnMgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGltZW5zaW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgT2JqZWN0RGV0ZWN0aW9uIH0gZnJvbSAnLi9PYmplY3REZXRlY3Rpb24nO1xyXG52YXIgRmFjZURldGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlRGV0ZWN0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmFjZURldGVjdGlvbihzY29yZSwgcmVsYXRpdmVCb3gsIGltYWdlRGltcykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzY29yZSwgc2NvcmUsICcnLCByZWxhdGl2ZUJveCwgaW1hZ2VEaW1zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmFjZURldGVjdGlvbi5wcm90b3R5cGUuZm9yU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIF9hID0gX3N1cGVyLnByb3RvdHlwZS5mb3JTaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCksIHNjb3JlID0gX2Euc2NvcmUsIHJlbGF0aXZlQm94ID0gX2EucmVsYXRpdmVCb3gsIGltYWdlRGltcyA9IF9hLmltYWdlRGltcztcclxuICAgICAgICByZXR1cm4gbmV3IEZhY2VEZXRlY3Rpb24oc2NvcmUsIHJlbGF0aXZlQm94LCBpbWFnZURpbXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlRGV0ZWN0aW9uO1xyXG59KE9iamVjdERldGVjdGlvbikpO1xyXG5leHBvcnQgeyBGYWNlRGV0ZWN0aW9uIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VEZXRlY3Rpb24uanMubWFwIiwiaW1wb3J0IHsgbWluQmJveCB9IGZyb20gJy4uL29wcyc7XHJcbmltcG9ydCB7IGdldENlbnRlclBvaW50IH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBCb3ggfSBmcm9tICcuL0JveCc7XHJcbmltcG9ydCB7IERpbWVuc2lvbnMgfSBmcm9tICcuL0RpbWVuc2lvbnMnO1xyXG5pbXBvcnQgeyBGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi9GYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vUmVjdCc7XHJcbi8vIGZhY2UgYWxpZ25tZW50IGNvbnN0YW50c1xyXG52YXIgcmVsWCA9IDAuNTtcclxudmFyIHJlbFkgPSAwLjQzO1xyXG52YXIgcmVsU2NhbGUgPSAwLjQ1O1xyXG52YXIgRmFjZUxhbmRtYXJrcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZhY2VMYW5kbWFya3MocmVsYXRpdmVGYWNlTGFuZG1hcmtQb3NpdGlvbnMsIGltZ0RpbXMsIHNoaWZ0KSB7XHJcbiAgICAgICAgaWYgKHNoaWZ0ID09PSB2b2lkIDApIHsgc2hpZnQgPSBuZXcgUG9pbnQoMCwgMCk7IH1cclxuICAgICAgICB2YXIgd2lkdGggPSBpbWdEaW1zLndpZHRoLCBoZWlnaHQgPSBpbWdEaW1zLmhlaWdodDtcclxuICAgICAgICB0aGlzLl9pbWdEaW1zID0gbmV3IERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fc2hpZnQgPSBzaGlmdDtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvbnMgPSByZWxhdGl2ZUZhY2VMYW5kbWFya1Bvc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHB0KSB7IHJldHVybiBwdC5tdWwobmV3IFBvaW50KHdpZHRoLCBoZWlnaHQpKS5hZGQoc2hpZnQpOyB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTGFuZG1hcmtzLnByb3RvdHlwZSwgXCJzaGlmdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy5fc2hpZnQueCwgdGhpcy5fc2hpZnQueSk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VMYW5kbWFya3MucHJvdG90eXBlLCBcImltYWdlV2lkdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW1nRGltcy53aWR0aDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZUxhbmRtYXJrcy5wcm90b3R5cGUsIFwiaW1hZ2VIZWlnaHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW1nRGltcy5oZWlnaHQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VMYW5kbWFya3MucHJvdG90eXBlLCBcInBvc2l0aW9uc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvbnM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VMYW5kbWFya3MucHJvdG90eXBlLCBcInJlbGF0aXZlUG9zaXRpb25zXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHB0KSB7IHJldHVybiBwdC5zdWIoX3RoaXMuX3NoaWZ0KS5kaXYobmV3IFBvaW50KF90aGlzLmltYWdlV2lkdGgsIF90aGlzLmltYWdlSGVpZ2h0KSk7IH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRmFjZUxhbmRtYXJrcy5wcm90b3R5cGUuZm9yU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucmVsYXRpdmVQb3NpdGlvbnMsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzLnByb3RvdHlwZS5zaGlmdEJ5ID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5yZWxhdGl2ZVBvc2l0aW9ucywgdGhpcy5faW1nRGltcywgbmV3IFBvaW50KHgsIHkpKTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzLnByb3RvdHlwZS5zaGlmdEJ5UG9pbnQgPSBmdW5jdGlvbiAocHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdEJ5KHB0LngsIHB0LnkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWxpZ25zIHRoZSBmYWNlIGxhbmRtYXJrcyBhZnRlciBmYWNlIGRldGVjdGlvbiBmcm9tIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgb2YgdGhlIGZhY2VzXHJcbiAgICAgKiBib3VuZGluZyBib3gsIG9yIGl0J3MgY3VycmVudCBzaGlmdC4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCB0byBhbGlnbiB0aGUgZmFjZSBpbWFnZXNcclxuICAgICAqIGFmdGVyIGZhY2UgZGV0ZWN0aW9uIGhhcyBiZWVuIHBlcmZvcm1lZCwgYmVmb3JlIHRoZXkgYXJlIHBhc3NlZCB0byB0aGUgZmFjZSByZWNvZ25pdGlvbiBuZXQuXHJcbiAgICAgKiBUaGlzIHdpbGwgbWFrZSB0aGUgY29tcHV0ZWQgZmFjZSBkZXNjcmlwdG9yIG1vcmUgYWNjdXJhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRldGVjdGlvbiAob3B0aW9uYWwpIFRoZSBib3VuZGluZyBib3ggb2YgdGhlIGZhY2Ugb3IgdGhlIGZhY2UgZGV0ZWN0aW9uIHJlc3VsdC4gSWZcclxuICAgICAqIG5vIGFyZ3VtZW50IHdhcyBwYXNzZWQgdGhlIHBvc2l0aW9uIG9mIHRoZSBmYWNlIGxhbmRtYXJrcyBhcmUgYXNzdW1lZCB0byBiZSByZWxhdGl2ZSB0b1xyXG4gICAgICogaXQncyBjdXJyZW50IHNoaWZ0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgYWxpZ25lZCBmYWNlLlxyXG4gICAgICovXHJcbiAgICBGYWNlTGFuZG1hcmtzLnByb3RvdHlwZS5hbGlnbiA9IGZ1bmN0aW9uIChkZXRlY3Rpb24sIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChkZXRlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGJveCA9IGRldGVjdGlvbiBpbnN0YW5jZW9mIEZhY2VEZXRlY3Rpb25cclxuICAgICAgICAgICAgICAgID8gZGV0ZWN0aW9uLmJveC5mbG9vcigpXHJcbiAgICAgICAgICAgICAgICA6IG5ldyBCb3goZGV0ZWN0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRCeShib3gueCwgYm94LnkpLmFsaWduKG51bGwsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBPYmplY3QuYXNzaWduKHt9LCB7IHVzZURsaWJBbGlnbm1lbnQ6IGZhbHNlLCBtaW5Cb3hQYWRkaW5nOiAwLjIgfSwgb3B0aW9ucyksIHVzZURsaWJBbGlnbm1lbnQgPSBfYS51c2VEbGliQWxpZ25tZW50LCBtaW5Cb3hQYWRkaW5nID0gX2EubWluQm94UGFkZGluZztcclxuICAgICAgICBpZiAodXNlRGxpYkFsaWdubWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbkRsaWIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25NaW5CYm94KG1pbkJveFBhZGRpbmcpO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFya3MucHJvdG90eXBlLmFsaWduRGxpYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2VudGVycyA9IHRoaXMuZ2V0UmVmUG9pbnRzRm9yQWxpZ25tZW50KCk7XHJcbiAgICAgICAgdmFyIGxlZnRFeWVDZW50ZXIgPSBjZW50ZXJzWzBdLCByaWdodEV5ZUNlbnRlciA9IGNlbnRlcnNbMV0sIG1vdXRoQ2VudGVyID0gY2VudGVyc1syXTtcclxuICAgICAgICB2YXIgZGlzdFRvTW91dGggPSBmdW5jdGlvbiAocHQpIHsgcmV0dXJuIG1vdXRoQ2VudGVyLnN1YihwdCkubWFnbml0dWRlKCk7IH07XHJcbiAgICAgICAgdmFyIGV5ZVRvTW91dGhEaXN0ID0gKGRpc3RUb01vdXRoKGxlZnRFeWVDZW50ZXIpICsgZGlzdFRvTW91dGgocmlnaHRFeWVDZW50ZXIpKSAvIDI7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLmZsb29yKGV5ZVRvTW91dGhEaXN0IC8gcmVsU2NhbGUpO1xyXG4gICAgICAgIHZhciByZWZQb2ludCA9IGdldENlbnRlclBvaW50KGNlbnRlcnMpO1xyXG4gICAgICAgIC8vIFRPRE86IHBhZCBpbiBjYXNlIHJlY3RhbmdsZSBpcyBvdXQgb2YgaW1hZ2UgYm91bmRzXHJcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHJlZlBvaW50LnggLSAocmVsWCAqIHNpemUpKSk7XHJcbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHJlZlBvaW50LnkgLSAocmVsWSAqIHNpemUpKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHgsIHksIE1hdGgubWluKHNpemUsIHRoaXMuaW1hZ2VXaWR0aCArIHgpLCBNYXRoLm1pbihzaXplLCB0aGlzLmltYWdlSGVpZ2h0ICsgeSkpO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFya3MucHJvdG90eXBlLmFsaWduTWluQmJveCA9IGZ1bmN0aW9uIChwYWRkaW5nKSB7XHJcbiAgICAgICAgdmFyIGJveCA9IG1pbkJib3godGhpcy5wb3NpdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBib3gucGFkKGJveC53aWR0aCAqIHBhZGRpbmcsIGJveC5oZWlnaHQgKiBwYWRkaW5nKTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzLnByb3RvdHlwZS5nZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQgbm90IGltcGxlbWVudGVkIGJ5IGJhc2UgY2xhc3MnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZUxhbmRtYXJrcztcclxufSgpKTtcclxuZXhwb3J0IHsgRmFjZUxhbmRtYXJrcyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlTGFuZG1hcmtzLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBnZXRDZW50ZXJQb2ludCB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4vRmFjZUxhbmRtYXJrcyc7XHJcbnZhciBGYWNlTGFuZG1hcmtzNSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlTGFuZG1hcmtzNSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VMYW5kbWFya3M1KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZhY2VMYW5kbWFya3M1LnByb3RvdHlwZS5nZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHB0cyA9IHRoaXMucG9zaXRpb25zO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHB0c1swXSxcclxuICAgICAgICAgICAgcHRzWzFdLFxyXG4gICAgICAgICAgICBnZXRDZW50ZXJQb2ludChbcHRzWzNdLCBwdHNbNF1dKVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VMYW5kbWFya3M1O1xyXG59KEZhY2VMYW5kbWFya3MpKTtcclxuZXhwb3J0IHsgRmFjZUxhbmRtYXJrczUgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZUxhbmRtYXJrczUuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGdldENlbnRlclBvaW50IH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBGYWNlTGFuZG1hcmtzIH0gZnJvbSAnLi9GYWNlTGFuZG1hcmtzJztcclxudmFyIEZhY2VMYW5kbWFya3M2OCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlTGFuZG1hcmtzNjgsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlTGFuZG1hcmtzNjgoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmFjZUxhbmRtYXJrczY4LnByb3RvdHlwZS5nZXRKYXdPdXRsaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSgwLCAxNyk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrczY4LnByb3RvdHlwZS5nZXRMZWZ0RXllQnJvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMTcsIDIyKTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzNjgucHJvdG90eXBlLmdldFJpZ2h0RXllQnJvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMjIsIDI3KTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzNjgucHJvdG90eXBlLmdldE5vc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDI3LCAzNik7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrczY4LnByb3RvdHlwZS5nZXRMZWZ0RXllID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSgzNiwgNDIpO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFya3M2OC5wcm90b3R5cGUuZ2V0UmlnaHRFeWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDQyLCA0OCk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrczY4LnByb3RvdHlwZS5nZXRNb3V0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoNDgsIDY4KTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzNjgucHJvdG90eXBlLmdldFJlZlBvaW50c0ZvckFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB0aGlzLmdldExlZnRFeWUoKSxcclxuICAgICAgICAgICAgdGhpcy5nZXRSaWdodEV5ZSgpLFxyXG4gICAgICAgICAgICB0aGlzLmdldE1vdXRoKClcclxuICAgICAgICBdLm1hcChnZXRDZW50ZXJQb2ludCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VMYW5kbWFya3M2ODtcclxufShGYWNlTGFuZG1hcmtzKSk7XHJcbmV4cG9ydCB7IEZhY2VMYW5kbWFya3M2OCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlTGFuZG1hcmtzNjguanMubWFwIiwiaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuLi91dGlscyc7XHJcbnZhciBGYWNlTWF0Y2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGYWNlTWF0Y2gobGFiZWwsIGRpc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VNYXRjaC5wcm90b3R5cGUsIFwibGFiZWxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGFiZWw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VNYXRjaC5wcm90b3R5cGUsIFwiZGlzdGFuY2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzdGFuY2U7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRmFjZU1hdGNoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICh3aXRoRGlzdGFuY2UpIHtcclxuICAgICAgICBpZiAod2l0aERpc3RhbmNlID09PSB2b2lkIDApIHsgd2l0aERpc3RhbmNlID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5sYWJlbCArICh3aXRoRGlzdGFuY2UgPyBcIiAoXCIgKyByb3VuZCh0aGlzLmRpc3RhbmNlKSArIFwiKVwiIDogJycpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlTWF0Y2g7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEZhY2VNYXRjaCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlTWF0Y2guanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGlzVmFsaWROdW1iZXIgfSBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IEJveCB9IGZyb20gJy4vQm94JztcclxudmFyIExhYmVsZWRCb3ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGFiZWxlZEJveCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExhYmVsZWRCb3goYm94LCBsYWJlbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJveCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fbGFiZWwgPSBsYWJlbDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBMYWJlbGVkQm94LmFzc2VydElzVmFsaWRMYWJlbGVkQm94ID0gZnVuY3Rpb24gKGJveCwgY2FsbGVlKSB7XHJcbiAgICAgICAgQm94LmFzc2VydElzVmFsaWRCb3goYm94LCBjYWxsZWUpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcihib3gubGFiZWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjYWxsZWUgKyBcIiAtIGV4cGVjdGVkIHByb3BlcnR5IGxhYmVsIChcIiArIGJveC5sYWJlbCArIFwiKSB0byBiZSBhIG51bWJlclwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhYmVsZWRCb3gucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xhYmVsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBMYWJlbGVkQm94O1xyXG59KEJveCkpO1xyXG5leHBvcnQgeyBMYWJlbGVkQm94IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxhYmVsZWRCb3guanMubWFwIiwidmFyIExhYmVsZWRGYWNlRGVzY3JpcHRvcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMYWJlbGVkRmFjZURlc2NyaXB0b3JzKGxhYmVsLCBkZXNjcmlwdG9ycykge1xyXG4gICAgICAgIGlmICghKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyAtIGNvbnN0cnVjdG9yIGV4cGVjdGVkIGxhYmVsIHRvIGJlIGEgc3RyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZXNjcmlwdG9ycykgfHwgZGVzY3JpcHRvcnMuc29tZShmdW5jdGlvbiAoZGVzYykgeyByZXR1cm4gIShkZXNjIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KTsgfSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYWJlbGVkRmFjZURlc2NyaXB0b3JzIC0gY29uc3RydWN0b3IgZXhwZWN0ZWQgZGVzY3JpcHRvcnMgdG8gYmUgYW4gYXJyYXkgb2YgRmxvYXQzMkFycmF5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRvcnMgPSBkZXNjcmlwdG9ycztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYWJlbGVkRmFjZURlc2NyaXB0b3JzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sYWJlbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGFiZWxlZEZhY2VEZXNjcmlwdG9ycy5wcm90b3R5cGUsIFwiZGVzY3JpcHRvcnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVzY3JpcHRvcnM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxyXG4gICAgICAgICAgICBkZXNjcmlwdG9yczogdGhpcy5kZXNjcmlwdG9ycy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIEFycmF5LmZyb20oZCk7IH0pXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBMYWJlbGVkRmFjZURlc2NyaXB0b3JzLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcclxuICAgICAgICB2YXIgZGVzY3JpcHRvcnMgPSBqc29uLmRlc2NyaXB0b3JzLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IExhYmVsZWRGYWNlRGVzY3JpcHRvcnMoanNvbi5sYWJlbCwgZGVzY3JpcHRvcnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMYWJlbGVkRmFjZURlc2NyaXB0b3JzO1xyXG59KCkpO1xyXG5leHBvcnQgeyBMYWJlbGVkRmFjZURlc2NyaXB0b3JzIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxhYmVsZWRGYWNlRGVzY3JpcHRvcnMuanMubWFwIiwiaW1wb3J0IHsgQm94IH0gZnJvbSAnLi9Cb3gnO1xyXG5pbXBvcnQgeyBEaW1lbnNpb25zIH0gZnJvbSAnLi9EaW1lbnNpb25zJztcclxudmFyIE9iamVjdERldGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9iamVjdERldGVjdGlvbihzY29yZSwgY2xhc3NTY29yZSwgY2xhc3NOYW1lLCByZWxhdGl2ZUJveCwgaW1hZ2VEaW1zKSB7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VEaW1zID0gbmV3IERpbWVuc2lvbnMoaW1hZ2VEaW1zLndpZHRoLCBpbWFnZURpbXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9zY29yZSA9IHNjb3JlO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzU2NvcmUgPSBjbGFzc1Njb3JlO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICB0aGlzLl9ib3ggPSBuZXcgQm94KHJlbGF0aXZlQm94KS5yZXNjYWxlKHRoaXMuX2ltYWdlRGltcyk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0RGV0ZWN0aW9uLnByb3RvdHlwZSwgXCJzY29yZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zY29yZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0RGV0ZWN0aW9uLnByb3RvdHlwZSwgXCJjbGFzc1Njb3JlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NsYXNzU2NvcmU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdERldGVjdGlvbi5wcm90b3R5cGUsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NsYXNzTmFtZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0RGV0ZWN0aW9uLnByb3RvdHlwZSwgXCJib3hcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYm94OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3REZXRlY3Rpb24ucHJvdG90eXBlLCBcImltYWdlRGltc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbWFnZURpbXM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdERldGVjdGlvbi5wcm90b3R5cGUsIFwiaW1hZ2VXaWR0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmltYWdlRGltcy53aWR0aDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0RGV0ZWN0aW9uLnByb3RvdHlwZSwgXCJpbWFnZUhlaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmltYWdlRGltcy5oZWlnaHQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdERldGVjdGlvbi5wcm90b3R5cGUsIFwicmVsYXRpdmVCb3hcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEJveCh0aGlzLl9ib3gpLnJlc2NhbGUodGhpcy5pbWFnZURpbXMucmV2ZXJzZSgpKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3REZXRlY3Rpb24ucHJvdG90eXBlLmZvclNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0RGV0ZWN0aW9uKHRoaXMuc2NvcmUsIHRoaXMuY2xhc3NTY29yZSwgdGhpcy5jbGFzc05hbWUsIHRoaXMucmVsYXRpdmVCb3gsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT2JqZWN0RGV0ZWN0aW9uO1xyXG59KCkpO1xyXG5leHBvcnQgeyBPYmplY3REZXRlY3Rpb24gfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0RGV0ZWN0aW9uLmpzLm1hcCIsInZhciBQb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcclxuICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICB0aGlzLl95ID0geTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludC5wcm90b3R5cGUsIFwieFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl94OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludC5wcm90b3R5cGUsIFwieVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl95OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHB0LngsIHRoaXMueSArIHB0LnkpO1xyXG4gICAgfTtcclxuICAgIFBvaW50LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAocHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHB0LngsIHRoaXMueSAtIHB0LnkpO1xyXG4gICAgfTtcclxuICAgIFBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAocHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHB0LngsIHRoaXMueSAqIHB0LnkpO1xyXG4gICAgfTtcclxuICAgIFBvaW50LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAocHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHB0LngsIHRoaXMueSAvIHB0LnkpO1xyXG4gICAgfTtcclxuICAgIFBvaW50LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLmFicyh0aGlzLngpLCBNYXRoLmFicyh0aGlzLnkpKTtcclxuICAgIH07XHJcbiAgICBQb2ludC5wcm90b3R5cGUubWFnbml0dWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54LCAyKSArIE1hdGgucG93KHRoaXMueSwgMikpO1xyXG4gICAgfTtcclxuICAgIFBvaW50LnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGguZmxvb3IodGhpcy54KSwgTWF0aC5mbG9vcih0aGlzLnkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9pbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFBvaW50IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50LmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBpc1ZhbGlkUHJvYmFibGl0aXkgfSBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IExhYmVsZWRCb3ggfSBmcm9tICcuL0xhYmVsZWRCb3gnO1xyXG52YXIgUHJlZGljdGVkQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RlZEJveCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFByZWRpY3RlZEJveChib3gsIGxhYmVsLCBzY29yZSwgY2xhc3NTY29yZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJveCwgbGFiZWwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX3Njb3JlID0gc2NvcmU7XHJcbiAgICAgICAgX3RoaXMuX2NsYXNzU2NvcmUgPSBjbGFzc1Njb3JlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RlZEJveC5hc3NlcnRJc1ZhbGlkUHJlZGljdGVkQm94ID0gZnVuY3Rpb24gKGJveCwgY2FsbGVlKSB7XHJcbiAgICAgICAgTGFiZWxlZEJveC5hc3NlcnRJc1ZhbGlkTGFiZWxlZEJveChib3gsIGNhbGxlZSk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkUHJvYmFibGl0aXkoYm94LnNjb3JlKVxyXG4gICAgICAgICAgICB8fCAhaXNWYWxpZFByb2JhYmxpdGl5KGJveC5jbGFzc1Njb3JlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2FsbGVlICsgXCIgLSBleHBlY3RlZCBwcm9wZXJ0aWVzIHNjb3JlIChcIiArIGJveC5zY29yZSArIFwiKSBhbmQgKFwiICsgYm94LmNsYXNzU2NvcmUgKyBcIikgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiBbMCwgMV1cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmVkaWN0ZWRCb3gucHJvdG90eXBlLCBcInNjb3JlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Njb3JlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmVkaWN0ZWRCb3gucHJvdG90eXBlLCBcImNsYXNzU2NvcmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2xhc3NTY29yZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gUHJlZGljdGVkQm94O1xyXG59KExhYmVsZWRCb3gpKTtcclxuZXhwb3J0IHsgUHJlZGljdGVkQm94IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByZWRpY3RlZEJveC5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgQm94IH0gZnJvbSAnLi9Cb3gnO1xyXG52YXIgUmVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSZWN0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucykge1xyXG4gICAgICAgIGlmIChhbGxvd05lZ2F0aXZlRGltZW5zaW9ucyA9PT0gdm9pZCAwKSB7IGFsbG93TmVnYXRpdmVEaW1lbnNpb25zID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIGFsbG93TmVnYXRpdmVEaW1lbnNpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlY3Q7XHJcbn0oQm94KSk7XHJcbmV4cG9ydCB7IFJlY3QgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjdC5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL0JvdW5kaW5nQm94JztcclxuZXhwb3J0ICogZnJvbSAnLi9Cb3gnO1xyXG5leHBvcnQgKiBmcm9tICcuL0RpbWVuc2lvbnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VEZXRlY3Rpb24nO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VMYW5kbWFya3MnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VMYW5kbWFya3M1JztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlTGFuZG1hcmtzNjgnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VNYXRjaCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vTGFiZWxlZEJveCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vT2JqZWN0RGV0ZWN0aW9uJztcclxuZXhwb3J0ICogZnJvbSAnLi9Qb2ludCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vUHJlZGljdGVkQm94JztcclxuZXhwb3J0ICogZnJvbSAnLi9SZWN0JztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZMYXllcih4LCBwYXJhbXMsIHBhZGRpbmcsIHdpdGhSZWx1KSB7XHJcbiAgICBpZiAocGFkZGluZyA9PT0gdm9pZCAwKSB7IHBhZGRpbmcgPSAnc2FtZSc7IH1cclxuICAgIGlmICh3aXRoUmVsdSA9PT0gdm9pZCAwKSB7IHdpdGhSZWx1ID0gZmFsc2U7IH1cclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGYuYWRkKHRmLmNvbnYyZCh4LCBwYXJhbXMuZmlsdGVycywgWzEsIDFdLCBwYWRkaW5nKSwgcGFyYW1zLmJpYXMpO1xyXG4gICAgICAgIHJldHVybiB3aXRoUmVsdSA/IHRmLnJlbHUob3V0KSA6IG91dDtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZMYXllci5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gZGVwdGh3aXNlU2VwYXJhYmxlQ29udih4LCBwYXJhbXMsIHN0cmlkZSkge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQgPSB0Zi5zZXBhcmFibGVDb252MmQoeCwgcGFyYW1zLmRlcHRod2lzZV9maWx0ZXIsIHBhcmFtcy5wb2ludHdpc2VfZmlsdGVyLCBzdHJpZGUsICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gdGYuYWRkKG91dCwgcGFyYW1zLmJpYXMpO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXB0aHdpc2VTZXBhcmFibGVDb252LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIE9iamVjdC5rZXlzKHdlaWdodE1hcCkuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIGlmICghcGFyYW1NYXBwaW5ncy5zb21lKGZ1bmN0aW9uIChwbSkgeyByZXR1cm4gcG0ub3JpZ2luYWxQYXRoID09PSBwYXRoOyB9KSkge1xyXG4gICAgICAgICAgICB3ZWlnaHRNYXBbcGF0aF0uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIGZpbHRlclNpemUsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGYudGVuc29yNGQoZXh0cmFjdFdlaWdodHMoY2hhbm5lbHNJbiAqIGNoYW5uZWxzT3V0ICogZmlsdGVyU2l6ZSAqIGZpbHRlclNpemUpLCBbZmlsdGVyU2l6ZSwgZmlsdGVyU2l6ZSwgY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXRdKTtcclxuICAgICAgICB2YXIgYmlhcyA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKGNoYW5uZWxzT3V0KSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9maWx0ZXJzXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2JpYXNcIiB9KTtcclxuICAgICAgICByZXR1cm4geyBmaWx0ZXJzOiBmaWx0ZXJzLCBiaWFzOiBiaWFzIH07XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RDb252UGFyYW1zRmFjdG9yeS5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEZDUGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjaGFubmVsc0luLCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGZjX3dlaWdodHMgPSB0Zi50ZW5zb3IyZChleHRyYWN0V2VpZ2h0cyhjaGFubmVsc0luICogY2hhbm5lbHNPdXQpLCBbY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXRdKTtcclxuICAgICAgICB2YXIgZmNfYmlhcyA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKGNoYW5uZWxzT3V0KSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi93ZWlnaHRzXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2JpYXNcIiB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3ZWlnaHRzOiBmY193ZWlnaHRzLFxyXG4gICAgICAgICAgICBiaWFzOiBmY19iaWFzXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdEZDUGFyYW1zRmFjdG9yeS5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBTZXBhcmFibGVDb252UGFyYW1zIH0gZnJvbSAnLi90eXBlcyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBkZXB0aHdpc2VfZmlsdGVyID0gdGYudGVuc29yNGQoZXh0cmFjdFdlaWdodHMoMyAqIDMgKiBjaGFubmVsc0luKSwgWzMsIDMsIGNoYW5uZWxzSW4sIDFdKTtcclxuICAgICAgICB2YXIgcG9pbnR3aXNlX2ZpbHRlciA9IHRmLnRlbnNvcjRkKGV4dHJhY3RXZWlnaHRzKGNoYW5uZWxzSW4gKiBjaGFubmVsc091dCksIFsxLCAxLCBjaGFubmVsc0luLCBjaGFubmVsc091dF0pO1xyXG4gICAgICAgIHZhciBiaWFzID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMoY2hhbm5lbHNPdXQpKTtcclxuICAgICAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2RlcHRod2lzZV9maWx0ZXJcIiB9LCB7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvcG9pbnR3aXNlX2ZpbHRlclwiIH0sIHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9iaWFzXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXBhcmFibGVDb252UGFyYW1zKGRlcHRod2lzZV9maWx0ZXIsIHBvaW50d2lzZV9maWx0ZXIsIGJpYXMpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbG9hZFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRFbnRyeSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgICAgICB2YXIgZGVwdGh3aXNlX2ZpbHRlciA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9kZXB0aHdpc2VfZmlsdGVyXCIsIDQpO1xyXG4gICAgICAgIHZhciBwb2ludHdpc2VfZmlsdGVyID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL3BvaW50d2lzZV9maWx0ZXJcIiwgNCk7XHJcbiAgICAgICAgdmFyIGJpYXMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvYmlhc1wiLCAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IFNlcGFyYWJsZUNvbnZQYXJhbXMoZGVwdGh3aXNlX2ZpbHRlciwgcG9pbnR3aXNlX2ZpbHRlciwgYmlhcyk7XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeS5qcy5tYXAiLCJpbXBvcnQgeyBpc1RlbnNvciB9IGZyb20gJy4uL3V0aWxzJztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9yaWdpbmFsUGF0aCwgcGFyYW1SYW5rLCBtYXBwZWRQYXRoKSB7XHJcbiAgICAgICAgdmFyIHRlbnNvciA9IHdlaWdodE1hcFtvcmlnaW5hbFBhdGhdO1xyXG4gICAgICAgIGlmICghaXNUZW5zb3IodGVuc29yLCBwYXJhbVJhbmspKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHdlaWdodE1hcFtcIiArIG9yaWdpbmFsUGF0aCArIFwiXSB0byBiZSBhIFRlbnNvclwiICsgcGFyYW1SYW5rICsgXCJELCBpbnN0ZWFkIGhhdmUgXCIgKyB0ZW5zb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBvcmlnaW5hbFBhdGg6IG9yaWdpbmFsUGF0aCwgcGFyYW1QYXRoOiBtYXBwZWRQYXRoIHx8IG9yaWdpbmFsUGF0aCB9KTtcclxuICAgICAgICByZXR1cm4gdGVuc29yO1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBleHRyYWN0V2VpZ2h0c0ZhY3Rvcnkod2VpZ2h0cykge1xyXG4gICAgdmFyIHJlbWFpbmluZ1dlaWdodHMgPSB3ZWlnaHRzO1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFdlaWdodHMobnVtV2VpZ2h0cykge1xyXG4gICAgICAgIHZhciByZXQgPSByZW1haW5pbmdXZWlnaHRzLnNsaWNlKDAsIG51bVdlaWdodHMpO1xyXG4gICAgICAgIHJlbWFpbmluZ1dlaWdodHMgPSByZW1haW5pbmdXZWlnaHRzLnNsaWNlKG51bVdlaWdodHMpO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRSZW1haW5pbmdXZWlnaHRzKCkge1xyXG4gICAgICAgIHJldHVybiByZW1haW5pbmdXZWlnaHRzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0V2VpZ2h0czogZXh0cmFjdFdlaWdodHMsXHJcbiAgICAgICAgZ2V0UmVtYWluaW5nV2VpZ2h0czogZ2V0UmVtYWluaW5nV2VpZ2h0c1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0V2VpZ2h0c0ZhY3RvcnkuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGZ1bGx5Q29ubmVjdGVkTGF5ZXIoeCwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRmLmFkZCh0Zi5tYXRNdWwoeCwgcGFyYW1zLndlaWdodHMpLCBwYXJhbXMuYmlhcyk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdWxseUNvbm5lY3RlZExheWVyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBnZXRNb2RlbFVyaXModXJpLCBkZWZhdWx0TW9kZWxOYW1lKSB7XHJcbiAgICB2YXIgZGVmYXVsdE1hbmlmZXN0RmlsZW5hbWUgPSBkZWZhdWx0TW9kZWxOYW1lICsgXCItd2VpZ2h0c19tYW5pZmVzdC5qc29uXCI7XHJcbiAgICBpZiAoIXVyaSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1vZGVsQmFzZVVyaTogJycsXHJcbiAgICAgICAgICAgIG1hbmlmZXN0VXJpOiBkZWZhdWx0TWFuaWZlc3RGaWxlbmFtZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodXJpID09PSAnLycpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtb2RlbEJhc2VVcmk6ICcvJyxcclxuICAgICAgICAgICAgbWFuaWZlc3RVcmk6IFwiL1wiICsgZGVmYXVsdE1hbmlmZXN0RmlsZW5hbWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3RvY29sID0gdXJpLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSA/ICdodHRwOi8vJyA6IHVyaS5zdGFydHNXaXRoKCdodHRwczovLycpID8gJ2h0dHBzOi8vJyA6ICcnO1xyXG4gICAgdXJpID0gdXJpLnJlcGxhY2UocHJvdG9jb2wsICcnKTtcclxuICAgIHZhciBwYXJ0cyA9IHVyaS5zcGxpdCgnLycpLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gczsgfSk7XHJcbiAgICB2YXIgbWFuaWZlc3RGaWxlID0gdXJpLmVuZHNXaXRoKCcuanNvbicpXHJcbiAgICAgICAgPyBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxyXG4gICAgICAgIDogZGVmYXVsdE1hbmlmZXN0RmlsZW5hbWU7XHJcbiAgICB2YXIgbW9kZWxCYXNlVXJpID0gcHJvdG9jb2wgKyAodXJpLmVuZHNXaXRoKCcuanNvbicpID8gcGFydHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoIC0gMSkgOiBwYXJ0cykuam9pbignLycpO1xyXG4gICAgbW9kZWxCYXNlVXJpID0gdXJpLnN0YXJ0c1dpdGgoJy8nKSA/IFwiL1wiICsgbW9kZWxCYXNlVXJpIDogbW9kZWxCYXNlVXJpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtb2RlbEJhc2VVcmk6IG1vZGVsQmFzZVVyaSxcclxuICAgICAgICBtYW5pZmVzdFVyaTogbW9kZWxCYXNlVXJpID09PSAnLycgPyBcIi9cIiArIG1hbmlmZXN0RmlsZSA6IG1vZGVsQmFzZVVyaSArIFwiL1wiICsgbWFuaWZlc3RGaWxlXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE1vZGVsVXJpcy5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL2NvbnZMYXllcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vZGVwdGh3aXNlU2VwYXJhYmxlQ29udic7XHJcbmV4cG9ydCAqIGZyb20gJy4vZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2V4dHJhY3RDb252UGFyYW1zRmFjdG9yeSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZXh0cmFjdEZDUGFyYW1zRmFjdG9yeSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5JztcclxuZXhwb3J0ICogZnJvbSAnLi9leHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5JztcclxuZXhwb3J0ICogZnJvbSAnLi9leHRyYWN0V2VpZ2h0c0ZhY3RvcnknO1xyXG5leHBvcnQgKiBmcm9tICcuL2dldE1vZGVsVXJpcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gbG9hZENvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRFbnRyeSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9maWx0ZXJzXCIsIDQpO1xyXG4gICAgICAgIHZhciBiaWFzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2JpYXNcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyczogZmlsdGVycywgYmlhczogYmlhcyB9O1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkQ29udlBhcmFtc0ZhY3RvcnkuanMubWFwIiwidmFyIFNlcGFyYWJsZUNvbnZQYXJhbXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXBhcmFibGVDb252UGFyYW1zKGRlcHRod2lzZV9maWx0ZXIsIHBvaW50d2lzZV9maWx0ZXIsIGJpYXMpIHtcclxuICAgICAgICB0aGlzLmRlcHRod2lzZV9maWx0ZXIgPSBkZXB0aHdpc2VfZmlsdGVyO1xyXG4gICAgICAgIHRoaXMucG9pbnR3aXNlX2ZpbHRlciA9IHBvaW50d2lzZV9maWx0ZXI7XHJcbiAgICAgICAgdGhpcy5iaWFzID0gYmlhcztcclxuICAgIH1cclxuICAgIHJldHVybiBTZXBhcmFibGVDb252UGFyYW1zO1xyXG59KCkpO1xyXG5leHBvcnQgeyBTZXBhcmFibGVDb252UGFyYW1zIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmltcG9ydCB7IHBhZFRvU3F1YXJlIH0gZnJvbSAnLi4vb3BzL3BhZFRvU3F1YXJlJztcclxuaW1wb3J0IHsgY29tcHV0ZVJlc2hhcGVkRGltZW5zaW9ucywgaXNUZW5zb3IzRCwgaXNUZW5zb3I0RCwgcmFuZ2UgfSBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IGNyZWF0ZUNhbnZhc0Zyb21NZWRpYSB9IGZyb20gJy4vY3JlYXRlQ2FudmFzJztcclxuaW1wb3J0IHsgaW1hZ2VUb1NxdWFyZSB9IGZyb20gJy4vaW1hZ2VUb1NxdWFyZSc7XHJcbnZhciBOZXRJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5ldElucHV0KGlucHV0cywgdHJlYXRBc0JhdGNoSW5wdXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0cmVhdEFzQmF0Y2hJbnB1dCA9PT0gdm9pZCAwKSB7IHRyZWF0QXNCYXRjaElucHV0ID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLl9pbWFnZVRlbnNvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jYW52YXNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3RyZWF0QXNCYXRjaElucHV0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faW5wdXREaW1lbnNpb25zID0gW107XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0cykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV0SW5wdXQuY29uc3RydWN0b3IgLSBleHBlY3RlZCBpbnB1dHMgdG8gYmUgYW4gQXJyYXkgb2YgVFJlc29sdmVkTmV0SW5wdXQgb3IgdG8gYmUgaW5zdGFuY2VvZiB0Zi5UZW5zb3I0RCwgaW5zdGVhZCBoYXZlIFwiICsgaW5wdXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHJlYXRBc0JhdGNoSW5wdXQgPSB0cmVhdEFzQmF0Y2hJbnB1dDtcclxuICAgICAgICB0aGlzLl9iYXRjaFNpemUgPSBpbnB1dHMubGVuZ3RoO1xyXG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaWR4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RlbnNvcjNEKGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2ltYWdlVGVuc29yc1tpZHhdID0gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5wdXREaW1lbnNpb25zW2lkeF0gPSBpbnB1dC5zaGFwZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNUZW5zb3I0RChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBpbnB1dC5zaGFwZVswXTtcclxuICAgICAgICAgICAgICAgIGlmIChiYXRjaFNpemUgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXRJbnB1dCAtIHRmLlRlbnNvcjREIHdpdGggYmF0Y2hTaXplIFwiICsgYmF0Y2hTaXplICsgXCIgcGFzc2VkLCBidXQgbm90IHN1cHBvcnRlZCBpbiBpbnB1dCBhcnJheVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbWFnZVRlbnNvcnNbaWR4XSA9IGlucHV0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2lucHV0RGltZW5zaW9uc1tpZHhdID0gaW5wdXQuc2hhcGUuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGlucHV0IGluc3RhbmNlb2YgZW52LmdldEVudigpLkNhbnZhcyA/IGlucHV0IDogY3JlYXRlQ2FudmFzRnJvbU1lZGlhKGlucHV0KTtcclxuICAgICAgICAgICAgX3RoaXMuX2NhbnZhc2VzW2lkeF0gPSBjYW52YXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9pbnB1dERpbWVuc2lvbnNbaWR4XSA9IFtjYW52YXMuaGVpZ2h0LCBjYW52YXMud2lkdGgsIDNdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5ldElucHV0LnByb3RvdHlwZSwgXCJpbWFnZVRlbnNvcnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VUZW5zb3JzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5ldElucHV0LnByb3RvdHlwZSwgXCJjYW52YXNlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXRJbnB1dC5wcm90b3R5cGUsIFwiaXNCYXRjaElucHV0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hTaXplID4gMSB8fCB0aGlzLl90cmVhdEFzQmF0Y2hJbnB1dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXRJbnB1dC5wcm90b3R5cGUsIFwiYmF0Y2hTaXplXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoU2l6ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXRJbnB1dC5wcm90b3R5cGUsIFwiaW5wdXREaW1lbnNpb25zXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0RGltZW5zaW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXRJbnB1dC5wcm90b3R5cGUsIFwiaW5wdXRTaXplXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0U2l6ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXRJbnB1dC5wcm90b3R5cGUsIFwicmVzaGFwZWRJbnB1dERpbWVuc2lvbnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UodGhpcy5iYXRjaFNpemUsIDAsIDEpLm1hcChmdW5jdGlvbiAoXywgYmF0Y2hJZHgpIHsgcmV0dXJuIF90aGlzLmdldFJlc2hhcGVkSW5wdXREaW1lbnNpb25zKGJhdGNoSWR4KTsgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZXRJbnB1dC5wcm90b3R5cGUuZ2V0SW5wdXQgPSBmdW5jdGlvbiAoYmF0Y2hJZHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNlc1tiYXRjaElkeF0gfHwgdGhpcy5pbWFnZVRlbnNvcnNbYmF0Y2hJZHhdO1xyXG4gICAgfTtcclxuICAgIE5ldElucHV0LnByb3RvdHlwZS5nZXRJbnB1dERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoYmF0Y2hJZHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXREaW1lbnNpb25zW2JhdGNoSWR4XTtcclxuICAgIH07XHJcbiAgICBOZXRJbnB1dC5wcm90b3R5cGUuZ2V0SW5wdXRIZWlnaHQgPSBmdW5jdGlvbiAoYmF0Y2hJZHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXREaW1lbnNpb25zW2JhdGNoSWR4XVswXTtcclxuICAgIH07XHJcbiAgICBOZXRJbnB1dC5wcm90b3R5cGUuZ2V0SW5wdXRXaWR0aCA9IGZ1bmN0aW9uIChiYXRjaElkeCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dERpbWVuc2lvbnNbYmF0Y2hJZHhdWzFdO1xyXG4gICAgfTtcclxuICAgIE5ldElucHV0LnByb3RvdHlwZS5nZXRSZXNoYXBlZElucHV0RGltZW5zaW9ucyA9IGZ1bmN0aW9uIChiYXRjaElkeCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnB1dFNpemUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0UmVzaGFwZWRJbnB1dERpbWVuc2lvbnMgLSBpbnB1dFNpemUgbm90IHNldCwgdG9CYXRjaFRlbnNvciBoYXMgbm90IGJlZW4gY2FsbGVkIHlldCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldElucHV0V2lkdGgoYmF0Y2hJZHgpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldElucHV0SGVpZ2h0KGJhdGNoSWR4KTtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZVJlc2hhcGVkRGltZW5zaW9ucyh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgdGhpcy5pbnB1dFNpemUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgYmF0Y2ggdGVuc29yIGZyb20gYWxsIGlucHV0IGNhbnZhc2VzIGFuZCB0ZW5zb3JzXHJcbiAgICAgKiB3aXRoIHNpemUgW2JhdGNoU2l6ZSwgaW5wdXRTaXplLCBpbnB1dFNpemUsIDNdLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dFNpemUgSGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgdGVuc29yLlxyXG4gICAgICogQHBhcmFtIGlzQ2VudGVySW1hZ2UgKG9wdGlvbmFsLCBkZWZhdWx0OiBmYWxzZSkgSWYgdHJ1ZSwgYWRkIGFuIGVxdWFsIGFtb3VudCBvZiBwYWRkaW5nIG9uXHJcbiAgICAgKiBib3RoIHNpZGVzIG9mIHRoZSBtaW5vciBkaW1lbnNpb24gb29mIHRoZSBpbWFnZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBiYXRjaCB0ZW5zb3IuXHJcbiAgICAgKi9cclxuICAgIE5ldElucHV0LnByb3RvdHlwZS50b0JhdGNoVGVuc29yID0gZnVuY3Rpb24gKGlucHV0U2l6ZSwgaXNDZW50ZXJJbnB1dHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChpc0NlbnRlcklucHV0cyA9PT0gdm9pZCAwKSB7IGlzQ2VudGVySW5wdXRzID0gdHJ1ZTsgfVxyXG4gICAgICAgIHRoaXMuX2lucHV0U2l6ZSA9IGlucHV0U2l6ZTtcclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dFRlbnNvcnMgPSByYW5nZShfdGhpcy5iYXRjaFNpemUsIDAsIDEpLm1hcChmdW5jdGlvbiAoYmF0Y2hJZHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IF90aGlzLmdldElucHV0KGJhdGNoSWR4KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIHRmLlRlbnNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWdUZW5zb3IgPSBpc1RlbnNvcjREKGlucHV0KSA/IGlucHV0IDogaW5wdXQuZXhwYW5kRGltcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltZ1RlbnNvciA9IHBhZFRvU3F1YXJlKGltZ1RlbnNvciwgaXNDZW50ZXJJbnB1dHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWdUZW5zb3Iuc2hhcGVbMV0gIT09IGlucHV0U2l6ZSB8fCBpbWdUZW5zb3Iuc2hhcGVbMl0gIT09IGlucHV0U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdUZW5zb3IgPSB0Zi5pbWFnZS5yZXNpemVCaWxpbmVhcihpbWdUZW5zb3IsIFtpbnB1dFNpemUsIGlucHV0U2l6ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1nVGVuc29yLmFzM0QoaW5wdXRTaXplLCBpbnB1dFNpemUsIDMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgZW52LmdldEVudigpLkNhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0Zi5icm93c2VyLmZyb21QaXhlbHMoaW1hZ2VUb1NxdWFyZShpbnB1dCwgaW5wdXRTaXplLCBpc0NlbnRlcklucHV0cykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9CYXRjaFRlbnNvciAtIGF0IGJhdGNoSWR4IFwiICsgYmF0Y2hJZHggKyBcIiwgZXhwZWN0ZWQgaW5wdXQgdG8gYmUgaW5zdGFuY2VvZiB0Zi5UZW5zb3Igb3IgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCwgaW5zdGVhZCBoYXZlIFwiICsgaW5wdXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGJhdGNoVGVuc29yID0gdGYuc3RhY2soaW5wdXRUZW5zb3JzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC50b0Zsb2F0KCk7IH0pKS5hczREKF90aGlzLmJhdGNoU2l6ZSwgaW5wdXRTaXplLCBpbnB1dFNpemUsIDMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmF0Y2hUZW5zb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5ldElucHV0O1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZXRJbnB1dCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXRJbnB1dC5qcy5tYXAiLCJpbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5pbXBvcnQgeyBpc01lZGlhTG9hZGVkIH0gZnJvbSAnLi9pc01lZGlhTG9hZGVkJztcclxuZXhwb3J0IGZ1bmN0aW9uIGF3YWl0TWVkaWFMb2FkZWQobWVkaWEpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgaWYgKG1lZGlhIGluc3RhbmNlb2YgZW52LmdldEVudigpLkNhbnZhcyB8fCBpc01lZGlhTG9hZGVkKG1lZGlhKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvbkxvYWQoZSkge1xyXG4gICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xyXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgcmVzb2x2ZShlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlKSB7XHJcbiAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XHJcbiAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xyXG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hd2FpdE1lZGlhTG9hZGVkLmpzLm1hcCIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUb0ltYWdlKGJ1Zikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBpZiAoIShidWYgaW5zdGFuY2VvZiBCbG9iKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KCdidWZmZXJUb0ltYWdlIC0gZXhwZWN0ZWQgYnVmIHRvIGJlIG9mIHR5cGU6IEJsb2InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkZXIucmVzdWx0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnYnVmZmVyVG9JbWFnZSAtIGV4cGVjdGVkIHJlYWRlci5yZXN1bHQgdG8gYmUgYSBzdHJpbmcsIGluIG9ubG9hZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBlbnYuZ2V0RW52KCkuY3JlYXRlSW1hZ2VFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKGltZyk7IH07XHJcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xyXG4gICAgICAgICAgICBpbWcuc3JjID0gcmVhZGVyLnJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xyXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJ1Zik7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJUb0ltYWdlLmpzLm1hcCIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmltcG9ydCB7IGdldENvbnRleHQyZE9yVGhyb3cgfSBmcm9tICcuL2dldENvbnRleHQyZE9yVGhyb3cnO1xyXG5pbXBvcnQgeyBnZXRNZWRpYURpbWVuc2lvbnMgfSBmcm9tICcuL2dldE1lZGlhRGltZW5zaW9ucyc7XHJcbmltcG9ydCB7IGlzTWVkaWFMb2FkZWQgfSBmcm9tICcuL2lzTWVkaWFMb2FkZWQnO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgdmFyIGNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBlbnYuZ2V0RW52KCkuY3JlYXRlQ2FudmFzRWxlbWVudDtcclxuICAgIHZhciBjYW52YXMgPSBjcmVhdGVDYW52YXNFbGVtZW50KCk7XHJcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXNGcm9tTWVkaWEobWVkaWEsIGRpbXMpIHtcclxuICAgIHZhciBJbWFnZURhdGEgPSBlbnYuZ2V0RW52KCkuSW1hZ2VEYXRhO1xyXG4gICAgaWYgKCEobWVkaWEgaW5zdGFuY2VvZiBJbWFnZURhdGEpICYmICFpc01lZGlhTG9hZGVkKG1lZGlhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlQ2FudmFzRnJvbU1lZGlhIC0gbWVkaWEgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nIHlldCcpO1xyXG4gICAgfVxyXG4gICAgdmFyIF9hID0gZGltcyB8fCBnZXRNZWRpYURpbWVuc2lvbnMobWVkaWEpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICB2YXIgY2FudmFzID0gY3JlYXRlQ2FudmFzKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgIGlmIChtZWRpYSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xyXG4gICAgICAgIGdldENvbnRleHQyZE9yVGhyb3coY2FudmFzKS5wdXRJbWFnZURhdGEobWVkaWEsIDAsIDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0Q29udGV4dDJkT3JUaHJvdyhjYW52YXMpLmRyYXdJbWFnZShtZWRpYSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUNhbnZhcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzL0ZhY2VEZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyBpc1RlbnNvcjNELCBpc1RlbnNvcjREIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG4vKipcclxuICogRXh0cmFjdHMgdGhlIHRlbnNvcnMgb2YgdGhlIGltYWdlIHJlZ2lvbnMgY29udGFpbmluZyB0aGUgZGV0ZWN0ZWQgZmFjZXMuXHJcbiAqIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBjb21wdXRlIHRoZSBmYWNlIGRlc2NyaXB0b3JzIGZvciB0aGUgZmFjZSBpbWFnZXMuXHJcbiAqIFVzaW5nIHRoaXMgbWV0aG9kIGlzIGZhc3RlciB0aGVuIGV4dHJhY3RpbmcgYSBjYW52YXMgZm9yIGVhY2ggZmFjZSBhbmRcclxuICogY29udmVydGluZyB0aGVtIHRvIHRlbnNvcnMgaW5kaXZpZHVhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gaW1hZ2VUZW5zb3IgVGhlIGltYWdlIHRlbnNvciB0aGF0IGZhY2UgZGV0ZWN0aW9uIGhhcyBiZWVuIHBlcmZvcm1lZCBvbi5cclxuICogQHBhcmFtIGRldGVjdGlvbnMgVGhlIGZhY2UgZGV0ZWN0aW9uIHJlc3VsdHMgb3IgZmFjZSBib3VuZGluZyBib3hlcyBmb3IgdGhhdCBpbWFnZS5cclxuICogQHJldHVybnMgVGVuc29ycyBvZiB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSByZWdpb24gZm9yIGVhY2ggZGV0ZWN0ZWQgZmFjZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RmFjZVRlbnNvcnMoaW1hZ2VUZW5zb3IsIGRldGVjdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNUZW5zb3IzRChpbWFnZVRlbnNvcikgJiYgIWlzVGVuc29yNEQoaW1hZ2VUZW5zb3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dHJhY3RGYWNlVGVuc29ycyAtIGV4cGVjdGVkIGltYWdlIHRlbnNvciB0byBiZSAzRCBvciA0RCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1RlbnNvcjREKGltYWdlVGVuc29yKSAmJiBpbWFnZVRlbnNvci5zaGFwZVswXSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0cmFjdEZhY2VUZW5zb3JzIC0gYmF0Y2hTaXplID4gMSBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGltYWdlVGVuc29yLnNoYXBlLnNsaWNlKGlzVGVuc29yNEQoaW1hZ2VUZW5zb3IpID8gMSA6IDApLCBpbWdIZWlnaHQgPSBfYVswXSwgaW1nV2lkdGggPSBfYVsxXSwgbnVtQ2hhbm5lbHMgPSBfYVsyXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm94ZXMgPSBkZXRlY3Rpb25zLm1hcChmdW5jdGlvbiAoZGV0KSB7IHJldHVybiBkZXQgaW5zdGFuY2VvZiBGYWNlRGV0ZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGV0LmZvclNpemUoaW1nV2lkdGgsIGltZ0hlaWdodCkuYm94XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGV0OyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChib3gpIHsgcmV0dXJuIGJveC5jbGlwQXRJbWFnZUJvcmRlcnMoaW1nV2lkdGgsIGltZ0hlaWdodCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWNlVGVuc29ycyA9IGJveGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGYuc2xpY2UzZChpbWFnZVRlbnNvci5hczNEKGltZ0hlaWdodCwgaW1nV2lkdGgsIG51bUNoYW5uZWxzKSwgW3ksIHgsIDBdLCBbaGVpZ2h0LCB3aWR0aCwgbnVtQ2hhbm5lbHNdKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFjZVRlbnNvcnM7XHJcbiAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0RmFjZVRlbnNvcnMuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52JztcclxuaW1wb3J0IHsgY3JlYXRlQ2FudmFzIH0gZnJvbSAnLi9jcmVhdGVDYW52YXMnO1xyXG5pbXBvcnQgeyBnZXRDb250ZXh0MmRPclRocm93IH0gZnJvbSAnLi9nZXRDb250ZXh0MmRPclRocm93JztcclxuaW1wb3J0IHsgaW1hZ2VUZW5zb3JUb0NhbnZhcyB9IGZyb20gJy4vaW1hZ2VUZW5zb3JUb0NhbnZhcyc7XHJcbmltcG9ydCB7IHRvTmV0SW5wdXQgfSBmcm9tICcuL3RvTmV0SW5wdXQnO1xyXG4vKipcclxuICogRXh0cmFjdHMgdGhlIGltYWdlIHJlZ2lvbnMgY29udGFpbmluZyB0aGUgZGV0ZWN0ZWQgZmFjZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW1hZ2UgdGhhdCBmYWNlIGRldGVjdGlvbiBoYXMgYmVlbiBwZXJmb3JtZWQgb24uXHJcbiAqIEBwYXJhbSBkZXRlY3Rpb25zIFRoZSBmYWNlIGRldGVjdGlvbiByZXN1bHRzIG9yIGZhY2UgYm91bmRpbmcgYm94ZXMgZm9yIHRoYXQgaW1hZ2UuXHJcbiAqIEByZXR1cm5zIFRoZSBDYW52YXNlcyBvZiB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSByZWdpb24gZm9yIGVhY2ggZGV0ZWN0ZWQgZmFjZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RmFjZXMoaW5wdXQsIGRldGVjdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgQ2FudmFzLCBjYW52YXMsIG5ldElucHV0LCB0ZW5zb3JPckNhbnZhcywgX2EsIGN0eCwgYm94ZXM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2FudmFzID0gZW52LmdldEVudigpLkNhbnZhcztcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMgPSBpbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISEoaW5wdXQgaW5zdGFuY2VvZiBDYW52YXMpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0SW5wdXQgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldElucHV0LmJhdGNoU2l6ZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRyYWN0RmFjZXMgLSBiYXRjaFNpemUgPiAxIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yT3JDYW52YXMgPSBuZXRJbnB1dC5nZXRJbnB1dCgwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ZW5zb3JPckNhbnZhcyBpbnN0YW5jZW9mIENhbnZhcykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gdGVuc29yT3JDYW52YXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIGltYWdlVGVuc29yVG9DYW52YXModGVuc29yT3JDYW52YXMpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGdldENvbnRleHQyZE9yVGhyb3coY2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICBib3hlcyA9IGRldGVjdGlvbnMubWFwKGZ1bmN0aW9uIChkZXQpIHsgcmV0dXJuIGRldCBpbnN0YW5jZW9mIEZhY2VEZXRlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkZXQuZm9yU2l6ZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLmJveC5mbG9vcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGV0OyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChib3gpIHsgcmV0dXJuIGJveC5jbGlwQXRJbWFnZUJvcmRlcnMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJveGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWNlSW1nID0gY3JlYXRlQ2FudmFzKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnRleHQyZE9yVGhyb3coZmFjZUltZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHV0SW1hZ2VEYXRhKGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgd2lkdGgsIGhlaWdodCksIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhY2VJbWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdEZhY2VzLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgYnVmZmVyVG9JbWFnZSB9IGZyb20gJy4vYnVmZmVyVG9JbWFnZSc7XHJcbmltcG9ydCB7IGZldGNoT3JUaHJvdyB9IGZyb20gJy4vZmV0Y2hPclRocm93JztcclxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoSW1hZ2UodXJpKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlcywgYmxvYjtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hPclRocm93KHVyaSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAocmVzKS5ibG9iKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2IgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFibG9iLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmV0Y2hJbWFnZSAtIGV4cGVjdGVkIGJsb2IgdHlwZSB0byBiZSBvZiB0eXBlIGltYWdlLyosIGluc3RlYWQgaGF2ZTogXCIgKyBibG9iLnR5cGUgKyBcIiwgZm9yIHVybDogXCIgKyByZXMudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJ1ZmZlclRvSW1hZ2UoYmxvYildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaEltYWdlLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgZmV0Y2hPclRocm93IH0gZnJvbSAnLi9mZXRjaE9yVGhyb3cnO1xyXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hKc29uKHVyaSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaE9yVGhyb3codXJpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKS5qc29uKCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaEpzb24uanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBmZXRjaE9yVGhyb3cgfSBmcm9tICcuL2ZldGNoT3JUaHJvdyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBmZXRjaE5ldFdlaWdodHModXJpKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gRmxvYXQzMkFycmF5LmJpbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hPclRocm93KHVyaSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCAoX2Iuc2VudCgpKS5hcnJheUJ1ZmZlcigpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyAoX2EuYXBwbHkoRmxvYXQzMkFycmF5LCBbdm9pZCAwLCBfYi5zZW50KCldKSkoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoTmV0V2VpZ2h0cy5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmV4cG9ydCBmdW5jdGlvbiBmZXRjaE9yVGhyb3codXJsLCBpbml0KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZldGNoLCByZXM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2ggPSBlbnYuZ2V0RW52KCkuZmV0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2godXJsLCBpbml0KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlcy5zdGF0dXMgPCA0MDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBmZXRjaDogKFwiICsgcmVzLnN0YXR1cyArIFwiKSBcIiArIHJlcy5zdGF0dXNUZXh0ICsgXCIsIGZyb20gdXJsOiBcIiArIHJlcy51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2hPclRocm93LmpzLm1hcCIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmltcG9ydCB7IHJlc29sdmVJbnB1dCB9IGZyb20gJy4vcmVzb2x2ZUlucHV0JztcclxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQyZE9yVGhyb3coY2FudmFzQXJnKSB7XHJcbiAgICB2YXIgX2EgPSBlbnYuZ2V0RW52KCksIENhbnZhcyA9IF9hLkNhbnZhcywgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gX2EuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gICAgaWYgKGNhbnZhc0FyZyBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAgIHJldHVybiBjYW52YXNBcmc7XHJcbiAgICB9XHJcbiAgICB2YXIgY2FudmFzID0gcmVzb2x2ZUlucHV0KGNhbnZhc0FyZyk7XHJcbiAgICBpZiAoIShjYW52YXMgaW5zdGFuY2VvZiBDYW52YXMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHZlQ29udGV4dDJkIC0gZXhwZWN0ZWQgY2FudmFzIHRvIGJlIG9mIGluc3RhbmNlIG9mIENhbnZhcycpO1xyXG4gICAgfVxyXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgaWYgKCFjdHgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc29sdmVDb250ZXh0MmQgLSBjYW52YXMgMmQgY29udGV4dCBpcyBudWxsJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3R4O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENvbnRleHQyZE9yVGhyb3cuanMubWFwIiwiaW1wb3J0IHsgRGltZW5zaW9ucyB9IGZyb20gJy4uL2NsYXNzZXMvRGltZW5zaW9ucyc7XHJcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNZWRpYURpbWVuc2lvbnMoaW5wdXQpIHtcclxuICAgIHZhciBfYSA9IGVudi5nZXRFbnYoKSwgSW1hZ2UgPSBfYS5JbWFnZSwgVmlkZW8gPSBfYS5WaWRlbztcclxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEltYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb25zKGlucHV0Lm5hdHVyYWxXaWR0aCwgaW5wdXQubmF0dXJhbEhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBWaWRlbykge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9ucyhpbnB1dC52aWRlb1dpZHRoLCBpbnB1dC52aWRlb0hlaWdodCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERpbWVuc2lvbnMoaW5wdXQud2lkdGgsIGlucHV0LmhlaWdodCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0TWVkaWFEaW1lbnNpb25zLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52JztcclxuaW1wb3J0IHsgaXNUZW5zb3I0RCB9IGZyb20gJy4uL3V0aWxzJztcclxuZXhwb3J0IGZ1bmN0aW9uIGltYWdlVGVuc29yVG9DYW52YXMoaW1nVGVuc29yLCBjYW52YXMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0Q2FudmFzLCBfYSwgaGVpZ2h0LCB3aWR0aCwgbnVtQ2hhbm5lbHMsIGltZ1RlbnNvcjNEO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENhbnZhcyA9IGNhbnZhcyB8fCBlbnYuZ2V0RW52KCkuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gaW1nVGVuc29yLnNoYXBlLnNsaWNlKGlzVGVuc29yNEQoaW1nVGVuc29yKSA/IDEgOiAwKSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV0sIG51bUNoYW5uZWxzID0gX2FbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nVGVuc29yM0QgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltZ1RlbnNvci5hczNEKGhlaWdodCwgd2lkdGgsIG51bUNoYW5uZWxzKS50b0ludCgpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0Zi5icm93c2VyLnRvUGl4ZWxzKGltZ1RlbnNvcjNELCB0YXJnZXRDYW52YXMpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nVGVuc29yM0QuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0YXJnZXRDYW52YXNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZVRlbnNvclRvQ2FudmFzLmpzLm1hcCIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmltcG9ydCB7IGNyZWF0ZUNhbnZhcywgY3JlYXRlQ2FudmFzRnJvbU1lZGlhIH0gZnJvbSAnLi9jcmVhdGVDYW52YXMnO1xyXG5pbXBvcnQgeyBnZXRDb250ZXh0MmRPclRocm93IH0gZnJvbSAnLi9nZXRDb250ZXh0MmRPclRocm93JztcclxuaW1wb3J0IHsgZ2V0TWVkaWFEaW1lbnNpb25zIH0gZnJvbSAnLi9nZXRNZWRpYURpbWVuc2lvbnMnO1xyXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VUb1NxdWFyZShpbnB1dCwgaW5wdXRTaXplLCBjZW50ZXJJbWFnZSkge1xyXG4gICAgaWYgKGNlbnRlckltYWdlID09PSB2b2lkIDApIHsgY2VudGVySW1hZ2UgPSBmYWxzZTsgfVxyXG4gICAgdmFyIF9hID0gZW52LmdldEVudigpLCBJbWFnZSA9IF9hLkltYWdlLCBDYW52YXMgPSBfYS5DYW52YXM7XHJcbiAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEltYWdlIHx8IGlucHV0IGluc3RhbmNlb2YgQ2FudmFzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW1hZ2VUb1NxdWFyZSAtIGV4cGVjdGVkIGFyZzAgdG8gYmUgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50Jyk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGltcyA9IGdldE1lZGlhRGltZW5zaW9ucyhpbnB1dCk7XHJcbiAgICB2YXIgc2NhbGUgPSBpbnB1dFNpemUgLyBNYXRoLm1heChkaW1zLmhlaWdodCwgZGltcy53aWR0aCk7XHJcbiAgICB2YXIgd2lkdGggPSBzY2FsZSAqIGRpbXMud2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gc2NhbGUgKiBkaW1zLmhlaWdodDtcclxuICAgIHZhciB0YXJnZXRDYW52YXMgPSBjcmVhdGVDYW52YXMoeyB3aWR0aDogaW5wdXRTaXplLCBoZWlnaHQ6IGlucHV0U2l6ZSB9KTtcclxuICAgIHZhciBpbnB1dENhbnZhcyA9IGlucHV0IGluc3RhbmNlb2YgQ2FudmFzID8gaW5wdXQgOiBjcmVhdGVDYW52YXNGcm9tTWVkaWEoaW5wdXQpO1xyXG4gICAgdmFyIG9mZnNldCA9IE1hdGguYWJzKHdpZHRoIC0gaGVpZ2h0KSAvIDI7XHJcbiAgICB2YXIgZHggPSBjZW50ZXJJbWFnZSAmJiB3aWR0aCA8IGhlaWdodCA/IG9mZnNldCA6IDA7XHJcbiAgICB2YXIgZHkgPSBjZW50ZXJJbWFnZSAmJiBoZWlnaHQgPCB3aWR0aCA/IG9mZnNldCA6IDA7XHJcbiAgICBnZXRDb250ZXh0MmRPclRocm93KHRhcmdldENhbnZhcykuZHJhd0ltYWdlKGlucHV0Q2FudmFzLCBkeCwgZHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgcmV0dXJuIHRhcmdldENhbnZhcztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZVRvU3F1YXJlLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vYXdhaXRNZWRpYUxvYWRlZCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vYnVmZmVyVG9JbWFnZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vY3JlYXRlQ2FudmFzJztcclxuZXhwb3J0ICogZnJvbSAnLi9leHRyYWN0RmFjZXMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2V4dHJhY3RGYWNlVGVuc29ycyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZmV0Y2hJbWFnZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZmV0Y2hKc29uJztcclxuZXhwb3J0ICogZnJvbSAnLi9mZXRjaE5ldFdlaWdodHMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2ZldGNoT3JUaHJvdyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2V0Q29udGV4dDJkT3JUaHJvdyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2V0TWVkaWFEaW1lbnNpb25zJztcclxuZXhwb3J0ICogZnJvbSAnLi9pbWFnZVRlbnNvclRvQ2FudmFzJztcclxuZXhwb3J0ICogZnJvbSAnLi9pbWFnZVRvU3F1YXJlJztcclxuZXhwb3J0ICogZnJvbSAnLi9pc01lZGlhRWxlbWVudCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vaXNNZWRpYUxvYWRlZCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vbG9hZFdlaWdodE1hcCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vbWF0Y2hEaW1lbnNpb25zJztcclxuZXhwb3J0ICogZnJvbSAnLi9OZXRJbnB1dCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vcmVzb2x2ZUlucHV0JztcclxuZXhwb3J0ICogZnJvbSAnLi90b05ldElucHV0JztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52JztcclxuZXhwb3J0IGZ1bmN0aW9uIGlzTWVkaWFFbGVtZW50KGlucHV0KSB7XHJcbiAgICB2YXIgX2EgPSBlbnYuZ2V0RW52KCksIEltYWdlID0gX2EuSW1hZ2UsIENhbnZhcyA9IF9hLkNhbnZhcywgVmlkZW8gPSBfYS5WaWRlbztcclxuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEltYWdlXHJcbiAgICAgICAgfHwgaW5wdXQgaW5zdGFuY2VvZiBDYW52YXNcclxuICAgICAgICB8fCBpbnB1dCBpbnN0YW5jZW9mIFZpZGVvO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTWVkaWFFbGVtZW50LmpzLm1hcCIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmV4cG9ydCBmdW5jdGlvbiBpc01lZGlhTG9hZGVkKG1lZGlhKSB7XHJcbiAgICB2YXIgX2EgPSBlbnYuZ2V0RW52KCksIEltYWdlID0gX2EuSW1hZ2UsIFZpZGVvID0gX2EuVmlkZW87XHJcbiAgICByZXR1cm4gKG1lZGlhIGluc3RhbmNlb2YgSW1hZ2UgJiYgbWVkaWEuY29tcGxldGUpXHJcbiAgICAgICAgfHwgKG1lZGlhIGluc3RhbmNlb2YgVmlkZW8gJiYgbWVkaWEucmVhZHlTdGF0ZSA+PSAzKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01lZGlhTG9hZGVkLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZ2V0TW9kZWxVcmlzIH0gZnJvbSAnLi4vY29tbW9uL2dldE1vZGVsVXJpcyc7XHJcbmltcG9ydCB7IGZldGNoSnNvbiB9IGZyb20gJy4vZmV0Y2hKc29uJztcclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRXZWlnaHRNYXAodXJpLCBkZWZhdWx0TW9kZWxOYW1lKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBtYW5pZmVzdFVyaSwgbW9kZWxCYXNlVXJpLCBtYW5pZmVzdDtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IGdldE1vZGVsVXJpcyh1cmksIGRlZmF1bHRNb2RlbE5hbWUpLCBtYW5pZmVzdFVyaSA9IF9hLm1hbmlmZXN0VXJpLCBtb2RlbEJhc2VVcmkgPSBfYS5tb2RlbEJhc2VVcmk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hKc29uKG1hbmlmZXN0VXJpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3QgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRmLmlvLmxvYWRXZWlnaHRzKG1hbmlmZXN0LCBtb2RlbEJhc2VVcmkpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFdlaWdodE1hcC5qcy5tYXAiLCJpbXBvcnQgeyBnZXRNZWRpYURpbWVuc2lvbnMgfSBmcm9tICcuL2dldE1lZGlhRGltZW5zaW9ucyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBtYXRjaERpbWVuc2lvbnMoaW5wdXQsIHJlZmVyZW5jZSwgdXNlTWVkaWFEaW1lbnNpb25zKSB7XHJcbiAgICBpZiAodXNlTWVkaWFEaW1lbnNpb25zID09PSB2b2lkIDApIHsgdXNlTWVkaWFEaW1lbnNpb25zID0gZmFsc2U7IH1cclxuICAgIHZhciBfYSA9IHVzZU1lZGlhRGltZW5zaW9uc1xyXG4gICAgICAgID8gZ2V0TWVkaWFEaW1lbnNpb25zKHJlZmVyZW5jZSlcclxuICAgICAgICA6IHJlZmVyZW5jZSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgaW5wdXQud2lkdGggPSB3aWR0aDtcclxuICAgIGlucHV0LmhlaWdodCA9IGhlaWdodDtcclxuICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaERpbWVuc2lvbnMuanMubWFwIiwiaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52JztcclxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVJbnB1dChhcmcpIHtcclxuICAgIGlmICghZW52LmlzTm9kZWpzKCkgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXJnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmc7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUlucHV0LmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgaXNUZW5zb3IzRCwgaXNUZW5zb3I0RCB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgYXdhaXRNZWRpYUxvYWRlZCB9IGZyb20gJy4vYXdhaXRNZWRpYUxvYWRlZCc7XHJcbmltcG9ydCB7IGlzTWVkaWFFbGVtZW50IH0gZnJvbSAnLi9pc01lZGlhRWxlbWVudCc7XHJcbmltcG9ydCB7IE5ldElucHV0IH0gZnJvbSAnLi9OZXRJbnB1dCc7XHJcbmltcG9ydCB7IHJlc29sdmVJbnB1dCB9IGZyb20gJy4vcmVzb2x2ZUlucHV0JztcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGUgaW5wdXQgdG8gbWFrZSBzdXJlLCB0aGV5IGFyZSB2YWxpZCBuZXQgaW5wdXRzIGFuZCBhd2FpdHMgYWxsIG1lZGlhIGVsZW1lbnRzXHJcbiAqIHRvIGJlIGZpbmlzaGVkIGxvYWRpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQsIHdoaWNoIGNhbiBiZSBhIG1lZGlhIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgZGlmZmVyZW50IG1lZGlhIGVsZW1lbnRzLlxyXG4gKiBAcmV0dXJucyBBIE5ldElucHV0IGluc3RhbmNlLCB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gb25lIG9mIHRoZSBuZXVyYWwgbmV0d29ya3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9OZXRJbnB1dChpbnB1dHMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5wdXRBcmdBcnJheSwgZ2V0SWR4SGludCwgaW5wdXRBcnJheTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzIGluc3RhbmNlb2YgTmV0SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGlucHV0c107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0QXJnQXJyYXkgPSBBcnJheS5pc0FycmF5KGlucHV0cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbaW5wdXRzXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0QXJnQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9OZXRJbnB1dCAtIGVtcHR5IGFycmF5IHBhc3NlZCBhcyBpbnB1dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBnZXRJZHhIaW50ID0gZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gXCIgYXQgaW5wdXQgaW5kZXggXCIgKyBpZHggKyBcIjpcIiA6ICcnOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0QXJyYXkgPSBpbnB1dEFyZ0FycmF5Lm1hcChyZXNvbHZlSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01lZGlhRWxlbWVudChpbnB1dCkgJiYgIWlzVGVuc29yM0QoaW5wdXQpICYmICFpc1RlbnNvcjREKGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dEFyZ0FycmF5W2ldID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvTmV0SW5wdXQgLVwiICsgZ2V0SWR4SGludChpKSArIFwiIHN0cmluZyBwYXNzZWQsIGJ1dCBjb3VsZCBub3QgcmVzb2x2ZSBIVE1MRWxlbWVudCBmb3IgZWxlbWVudCBpZCBcIiArIGlucHV0QXJnQXJyYXlbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9OZXRJbnB1dCAtXCIgKyBnZXRJZHhIaW50KGkpICsgXCIgZXhwZWN0ZWQgbWVkaWEgdG8gYmUgb2YgdHlwZSBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgdGYuVGVuc29yM0QsIG9yIHRvIGJlIGFuIGVsZW1lbnQgaWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGVuc29yNEQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0Zi5UZW5zb3I0RCBpcyBwYXNzZWQgaW4gdGhlIGlucHV0IGFycmF5LCB0aGUgYmF0Y2ggc2l6ZSBoYXMgdG8gYmUgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGlucHV0LnNoYXBlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoU2l6ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvTmV0SW5wdXQgLVwiICsgZ2V0SWR4SGludChpKSArIFwiIHRmLlRlbnNvcjREIHdpdGggYmF0Y2hTaXplIFwiICsgYmF0Y2hTaXplICsgXCIgcGFzc2VkLCBidXQgbm90IHN1cHBvcnRlZCBpbiBpbnB1dCBhcnJheVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGFsbCBtZWRpYSBlbGVtZW50cyBiZWluZyBsb2FkZWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChpbnB1dEFycmF5Lm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlzTWVkaWFFbGVtZW50KGlucHV0KSAmJiBhd2FpdE1lZGlhTG9hZGVkKGlucHV0KTsgfSkpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBhbGwgbWVkaWEgZWxlbWVudHMgYmVpbmcgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgTmV0SW5wdXQoaW5wdXRBcnJheSwgQXJyYXkuaXNBcnJheShpbnB1dHMpKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvTmV0SW5wdXQuanMubWFwIiwiaW1wb3J0IHsgQm94IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmltcG9ydCB7IGdldENvbnRleHQyZE9yVGhyb3cgfSBmcm9tICcuLi9kb20vZ2V0Q29udGV4dDJkT3JUaHJvdyc7XHJcbmltcG9ydCB7IEFuY2hvclBvc2l0aW9uLCBEcmF3VGV4dEZpZWxkLCBEcmF3VGV4dEZpZWxkT3B0aW9ucyB9IGZyb20gJy4vRHJhd1RleHRGaWVsZCc7XHJcbnZhciBEcmF3Qm94T3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERyYXdCb3hPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHZhciBib3hDb2xvciA9IG9wdGlvbnMuYm94Q29sb3IsIGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLCBsYWJlbCA9IG9wdGlvbnMubGFiZWwsIGRyYXdMYWJlbE9wdGlvbnMgPSBvcHRpb25zLmRyYXdMYWJlbE9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5ib3hDb2xvciA9IGJveENvbG9yIHx8ICdyZ2JhKDAsIDAsIDI1NSwgMSknO1xyXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDI7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgIHZhciBkZWZhdWx0RHJhd0xhYmVsT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgYW5jaG9yUG9zaXRpb246IEFuY2hvclBvc2l0aW9uLkJPVFRPTV9MRUZULFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYm94Q29sb3JcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZHJhd0xhYmVsT3B0aW9ucyA9IG5ldyBEcmF3VGV4dEZpZWxkT3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RHJhd0xhYmVsT3B0aW9ucywgZHJhd0xhYmVsT3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIERyYXdCb3hPcHRpb25zO1xyXG59KCkpO1xyXG5leHBvcnQgeyBEcmF3Qm94T3B0aW9ucyB9O1xyXG52YXIgRHJhd0JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERyYXdCb3goYm94LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB0aGlzLmJveCA9IG5ldyBCb3goYm94KTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXcgRHJhd0JveE9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBEcmF3Qm94LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGNhbnZhc0FyZykge1xyXG4gICAgICAgIHZhciBjdHggPSBnZXRDb250ZXh0MmRPclRocm93KGNhbnZhc0FyZyk7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBib3hDb2xvciA9IF9hLmJveENvbG9yLCBsaW5lV2lkdGggPSBfYS5saW5lV2lkdGg7XHJcbiAgICAgICAgdmFyIF9iID0gdGhpcy5ib3gsIHggPSBfYi54LCB5ID0gX2IueSwgd2lkdGggPSBfYi53aWR0aCwgaGVpZ2h0ID0gX2IuaGVpZ2h0O1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJveENvbG9yO1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5vcHRpb25zLmxhYmVsO1xyXG4gICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICBuZXcgRHJhd1RleHRGaWVsZChbbGFiZWxdLCB7IHg6IHggLSAobGluZVdpZHRoIC8gMiksIHk6IHkgfSwgdGhpcy5vcHRpb25zLmRyYXdMYWJlbE9wdGlvbnMpLmRyYXcoY2FudmFzQXJnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERyYXdCb3g7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IERyYXdCb3ggfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhd0JveC5qcy5tYXAiLCJpbXBvcnQgeyBGYWNlTGFuZG1hcmtzIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlTGFuZG1hcmtzJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrczY4IH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlTGFuZG1hcmtzNjgnO1xyXG5pbXBvcnQgeyBnZXRDb250ZXh0MmRPclRocm93IH0gZnJvbSAnLi4vZG9tL2dldENvbnRleHQyZE9yVGhyb3cnO1xyXG5pbXBvcnQgeyBpc1dpdGhGYWNlTGFuZG1hcmtzIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhGYWNlTGFuZG1hcmtzJztcclxuaW1wb3J0IHsgZHJhd0NvbnRvdXIgfSBmcm9tICcuL2RyYXdDb250b3VyJztcclxudmFyIERyYXdGYWNlTGFuZG1hcmtzT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERyYXdGYWNlTGFuZG1hcmtzT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmRyYXdMaW5lcywgZHJhd0xpbmVzID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYSwgX2IgPSBvcHRpb25zLmRyYXdQb2ludHMsIGRyYXdQb2ludHMgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCwgbGluZUNvbG9yID0gb3B0aW9ucy5saW5lQ29sb3IsIHBvaW50U2l6ZSA9IG9wdGlvbnMucG9pbnRTaXplLCBwb2ludENvbG9yID0gb3B0aW9ucy5wb2ludENvbG9yO1xyXG4gICAgICAgIHRoaXMuZHJhd0xpbmVzID0gZHJhd0xpbmVzO1xyXG4gICAgICAgIHRoaXMuZHJhd1BvaW50cyA9IGRyYXdQb2ludHM7XHJcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcclxuICAgICAgICB0aGlzLnBvaW50U2l6ZSA9IHBvaW50U2l6ZSB8fCAyO1xyXG4gICAgICAgIHRoaXMubGluZUNvbG9yID0gbGluZUNvbG9yIHx8ICdyZ2JhKDAsIDI1NSwgMjU1LCAxKSc7XHJcbiAgICAgICAgdGhpcy5wb2ludENvbG9yID0gcG9pbnRDb2xvciB8fCAncmdiYSgyNTUsIDAsIDI1NSwgMSknO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIERyYXdGYWNlTGFuZG1hcmtzT3B0aW9ucztcclxufSgpKTtcclxuZXhwb3J0IHsgRHJhd0ZhY2VMYW5kbWFya3NPcHRpb25zIH07XHJcbnZhciBEcmF3RmFjZUxhbmRtYXJrcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERyYXdGYWNlTGFuZG1hcmtzKGZhY2VMYW5kbWFya3MsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHRoaXMuZmFjZUxhbmRtYXJrcyA9IGZhY2VMYW5kbWFya3M7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IERyYXdGYWNlTGFuZG1hcmtzT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIH1cclxuICAgIERyYXdGYWNlTGFuZG1hcmtzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGNhbnZhc0FyZykge1xyXG4gICAgICAgIHZhciBjdHggPSBnZXRDb250ZXh0MmRPclRocm93KGNhbnZhc0FyZyk7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBkcmF3TGluZXMgPSBfYS5kcmF3TGluZXMsIGRyYXdQb2ludHMgPSBfYS5kcmF3UG9pbnRzLCBsaW5lV2lkdGggPSBfYS5saW5lV2lkdGgsIGxpbmVDb2xvciA9IF9hLmxpbmVDb2xvciwgcG9pbnRTaXplID0gX2EucG9pbnRTaXplLCBwb2ludENvbG9yID0gX2EucG9pbnRDb2xvcjtcclxuICAgICAgICBpZiAoZHJhd0xpbmVzICYmIHRoaXMuZmFjZUxhbmRtYXJrcyBpbnN0YW5jZW9mIEZhY2VMYW5kbWFya3M2OCkge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgICAgIGRyYXdDb250b3VyKGN0eCwgdGhpcy5mYWNlTGFuZG1hcmtzLmdldEphd091dGxpbmUoKSk7XHJcbiAgICAgICAgICAgIGRyYXdDb250b3VyKGN0eCwgdGhpcy5mYWNlTGFuZG1hcmtzLmdldExlZnRFeWVCcm93KCkpO1xyXG4gICAgICAgICAgICBkcmF3Q29udG91cihjdHgsIHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRSaWdodEV5ZUJyb3coKSk7XHJcbiAgICAgICAgICAgIGRyYXdDb250b3VyKGN0eCwgdGhpcy5mYWNlTGFuZG1hcmtzLmdldE5vc2UoKSk7XHJcbiAgICAgICAgICAgIGRyYXdDb250b3VyKGN0eCwgdGhpcy5mYWNlTGFuZG1hcmtzLmdldExlZnRFeWUoKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGRyYXdDb250b3VyKGN0eCwgdGhpcy5mYWNlTGFuZG1hcmtzLmdldFJpZ2h0RXllKCksIHRydWUpO1xyXG4gICAgICAgICAgICBkcmF3Q29udG91cihjdHgsIHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRNb3V0aCgpLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRyYXdQb2ludHMpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcG9pbnRDb2xvcjtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBvaW50Q29sb3I7XHJcbiAgICAgICAgICAgIHZhciBkcmF3UG9pbnQgPSBmdW5jdGlvbiAocHQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5hcmMocHQueCwgcHQueSwgcG9pbnRTaXplLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VMYW5kbWFya3MucG9zaXRpb25zLmZvckVhY2goZHJhd1BvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERyYXdGYWNlTGFuZG1hcmtzO1xyXG59KCkpO1xyXG5leHBvcnQgeyBEcmF3RmFjZUxhbmRtYXJrcyB9O1xyXG5leHBvcnQgZnVuY3Rpb24gZHJhd0ZhY2VMYW5kbWFya3MoY2FudmFzQXJnLCBmYWNlTGFuZG1hcmtzKSB7XHJcbiAgICB2YXIgZmFjZUxhbmRtYXJrc0FycmF5ID0gQXJyYXkuaXNBcnJheShmYWNlTGFuZG1hcmtzKSA/IGZhY2VMYW5kbWFya3MgOiBbZmFjZUxhbmRtYXJrc107XHJcbiAgICBmYWNlTGFuZG1hcmtzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIHZhciBsYW5kbWFya3MgPSBmIGluc3RhbmNlb2YgRmFjZUxhbmRtYXJrc1xyXG4gICAgICAgICAgICA/IGZcclxuICAgICAgICAgICAgOiAoaXNXaXRoRmFjZUxhbmRtYXJrcyhmKSA/IGYubGFuZG1hcmtzIDogdW5kZWZpbmVkKTtcclxuICAgICAgICBpZiAoIWxhbmRtYXJrcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYXdGYWNlTGFuZG1hcmtzIC0gZXhwZWN0ZWQgZmFjZUV4cHJlc3Npb25zIHRvIGJlIEZhY2VMYW5kbWFya3MgfCBXaXRoRmFjZUxhbmRtYXJrczxXaXRoRmFjZURldGVjdGlvbjx7fT4+IG9yIGFycmF5IHRoZXJlb2YnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3IERyYXdGYWNlTGFuZG1hcmtzKGxhbmRtYXJrcykuZHJhdyhjYW52YXNBcmcpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhd0ZhY2VMYW5kbWFya3MuanMubWFwIiwiaW1wb3J0IHsgZ2V0Q29udGV4dDJkT3JUaHJvdyB9IGZyb20gJy4uL2RvbS9nZXRDb250ZXh0MmRPclRocm93JztcclxuaW1wb3J0IHsgcmVzb2x2ZUlucHV0IH0gZnJvbSAnLi4vZG9tL3Jlc29sdmVJbnB1dCc7XHJcbmV4cG9ydCB2YXIgQW5jaG9yUG9zaXRpb247XHJcbihmdW5jdGlvbiAoQW5jaG9yUG9zaXRpb24pIHtcclxuICAgIEFuY2hvclBvc2l0aW9uW1wiVE9QX0xFRlRcIl0gPSBcIlRPUF9MRUZUXCI7XHJcbiAgICBBbmNob3JQb3NpdGlvbltcIlRPUF9SSUdIVFwiXSA9IFwiVE9QX1JJR0hUXCI7XHJcbiAgICBBbmNob3JQb3NpdGlvbltcIkJPVFRPTV9MRUZUXCJdID0gXCJCT1RUT01fTEVGVFwiO1xyXG4gICAgQW5jaG9yUG9zaXRpb25bXCJCT1RUT01fUklHSFRcIl0gPSBcIkJPVFRPTV9SSUdIVFwiO1xyXG59KShBbmNob3JQb3NpdGlvbiB8fCAoQW5jaG9yUG9zaXRpb24gPSB7fSkpO1xyXG52YXIgRHJhd1RleHRGaWVsZE9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmF3VGV4dEZpZWxkT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB2YXIgYW5jaG9yUG9zaXRpb24gPSBvcHRpb25zLmFuY2hvclBvc2l0aW9uLCBiYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvciwgZm9udENvbG9yID0gb3B0aW9ucy5mb250Q29sb3IsIGZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSwgZm9udFN0eWxlID0gb3B0aW9ucy5mb250U3R5bGUsIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmc7XHJcbiAgICAgICAgdGhpcy5hbmNob3JQb3NpdGlvbiA9IGFuY2hvclBvc2l0aW9uIHx8IEFuY2hvclBvc2l0aW9uLlRPUF9MRUZUO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yIHx8ICdyZ2JhKDAsIDAsIDAsIDAuNSknO1xyXG4gICAgICAgIHRoaXMuZm9udENvbG9yID0gZm9udENvbG9yIHx8ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpJztcclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gZm9udFNpemUgfHwgMTQ7XHJcbiAgICAgICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGUgfHwgJ0dlb3JnaWEnO1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmcgfHwgNDtcclxuICAgIH1cclxuICAgIHJldHVybiBEcmF3VGV4dEZpZWxkT3B0aW9ucztcclxufSgpKTtcclxuZXhwb3J0IHsgRHJhd1RleHRGaWVsZE9wdGlvbnMgfTtcclxudmFyIERyYXdUZXh0RmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmF3VGV4dEZpZWxkKHRleHQsIGFuY2hvciwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdHlwZW9mIHRleHQgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgID8gW3RleHRdXHJcbiAgICAgICAgICAgIDogKHRleHQgaW5zdGFuY2VvZiBEcmF3VGV4dEZpZWxkID8gdGV4dC50ZXh0IDogdGV4dCk7XHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IERyYXdUZXh0RmllbGRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgRHJhd1RleHRGaWVsZC5wcm90b3R5cGUubWVhc3VyZVdpZHRoID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5vcHRpb25zLnBhZGRpbmc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dC5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dChsKS53aWR0aDsgfSkucmVkdWNlKGZ1bmN0aW9uICh3MCwgdzEpIHsgcmV0dXJuIHcwIDwgdzEgPyB3MSA6IHcwOyB9LCAwKSArICgyICogcGFkZGluZyk7XHJcbiAgICB9O1xyXG4gICAgRHJhd1RleHRGaWVsZC5wcm90b3R5cGUubWVhc3VyZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGZvbnRTaXplID0gX2EuZm9udFNpemUsIHBhZGRpbmcgPSBfYS5wYWRkaW5nO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHQubGVuZ3RoICogZm9udFNpemUgKyAoMiAqIHBhZGRpbmcpO1xyXG4gICAgfTtcclxuICAgIERyYXdUZXh0RmllbGQucHJvdG90eXBlLmdldFVwcGVyTGVmdCA9IGZ1bmN0aW9uIChjdHgsIGNhbnZhc0RpbXMpIHtcclxuICAgICAgICB2YXIgYW5jaG9yUG9zaXRpb24gPSB0aGlzLm9wdGlvbnMuYW5jaG9yUG9zaXRpb247XHJcbiAgICAgICAgdmFyIGlzU2hpZnRMZWZ0ID0gYW5jaG9yUG9zaXRpb24gPT09IEFuY2hvclBvc2l0aW9uLkJPVFRPTV9SSUdIVCB8fCBhbmNob3JQb3NpdGlvbiA9PT0gQW5jaG9yUG9zaXRpb24uVE9QX1JJR0hUO1xyXG4gICAgICAgIHZhciBpc1NoaWZ0VG9wID0gYW5jaG9yUG9zaXRpb24gPT09IEFuY2hvclBvc2l0aW9uLkJPVFRPTV9MRUZUIHx8IGFuY2hvclBvc2l0aW9uID09PSBBbmNob3JQb3NpdGlvbi5CT1RUT01fUklHSFQ7XHJcbiAgICAgICAgdmFyIHRleHRGaWVsZFdpZHRoID0gdGhpcy5tZWFzdXJlV2lkdGgoY3R4KTtcclxuICAgICAgICB2YXIgdGV4dEZpZWxkSGVpZ2h0ID0gdGhpcy5tZWFzdXJlSGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIHggPSAoaXNTaGlmdExlZnQgPyB0aGlzLmFuY2hvci54IC0gdGV4dEZpZWxkV2lkdGggOiB0aGlzLmFuY2hvci54KTtcclxuICAgICAgICB2YXIgeSA9IGlzU2hpZnRUb3AgPyB0aGlzLmFuY2hvci55IC0gdGV4dEZpZWxkSGVpZ2h0IDogdGhpcy5hbmNob3IueTtcclxuICAgICAgICAvLyBhZGp1c3QgYW5jaG9yIGlmIHRleHQgYm94IGV4Y2VlZHMgY2FudmFzIGJvcmRlcnNcclxuICAgICAgICBpZiAoY2FudmFzRGltcykge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjYW52YXNEaW1zLndpZHRoLCBoZWlnaHQgPSBjYW52YXNEaW1zLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIG5ld1ggPSBNYXRoLm1heChNYXRoLm1pbih4LCB3aWR0aCAtIHRleHRGaWVsZFdpZHRoKSwgMCk7XHJcbiAgICAgICAgICAgIHZhciBuZXdZID0gTWF0aC5tYXgoTWF0aC5taW4oeSwgaGVpZ2h0IC0gdGV4dEZpZWxkSGVpZ2h0KSwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IG5ld1gsIHk6IG5ld1kgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xyXG4gICAgfTtcclxuICAgIERyYXdUZXh0RmllbGQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY2FudmFzQXJnKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHJlc29sdmVJbnB1dChjYW52YXNBcmcpO1xyXG4gICAgICAgIHZhciBjdHggPSBnZXRDb250ZXh0MmRPclRocm93KGNhbnZhcyk7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBiYWNrZ3JvdW5kQ29sb3IgPSBfYS5iYWNrZ3JvdW5kQ29sb3IsIGZvbnRDb2xvciA9IF9hLmZvbnRDb2xvciwgZm9udFNpemUgPSBfYS5mb250U2l6ZSwgZm9udFN0eWxlID0gX2EuZm9udFN0eWxlLCBwYWRkaW5nID0gX2EucGFkZGluZztcclxuICAgICAgICBjdHguZm9udCA9IGZvbnRTaXplICsgXCJweCBcIiArIGZvbnRTdHlsZTtcclxuICAgICAgICB2YXIgbWF4VGV4dFdpZHRoID0gdGhpcy5tZWFzdXJlV2lkdGgoY3R4KTtcclxuICAgICAgICB2YXIgdGV4dEhlaWdodCA9IHRoaXMubWVhc3VyZUhlaWdodCgpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdmFyIHVwcGVyTGVmdCA9IHRoaXMuZ2V0VXBwZXJMZWZ0KGN0eCwgY2FudmFzKTtcclxuICAgICAgICBjdHguZmlsbFJlY3QodXBwZXJMZWZ0LngsIHVwcGVyTGVmdC55LCBtYXhUZXh0V2lkdGgsIHRleHRIZWlnaHQpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7XHJcbiAgICAgICAgdGhpcy50ZXh0LmZvckVhY2goZnVuY3Rpb24gKHRleHRMaW5lLCBpKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFkZGluZyArIHVwcGVyTGVmdC54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhZGRpbmcgKyB1cHBlckxlZnQueSArICgoaSArIDEpICogZm9udFNpemUpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dExpbmUsIHgsIHkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEcmF3VGV4dEZpZWxkO1xyXG59KCkpO1xyXG5leHBvcnQgeyBEcmF3VGV4dEZpZWxkIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYXdUZXh0RmllbGQuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGRyYXdDb250b3VyKGN0eCwgcG9pbnRzLCBpc0Nsb3NlZCkge1xyXG4gICAgaWYgKGlzQ2xvc2VkID09PSB2b2lkIDApIHsgaXNDbG9zZWQgPSBmYWxzZTsgfVxyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgcG9pbnRzLnNsaWNlKDEpLmZvckVhY2goZnVuY3Rpb24gKF9hLCBwcmV2SWR4KSB7XHJcbiAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueTtcclxuICAgICAgICB2YXIgZnJvbSA9IHBvaW50c1twcmV2SWR4XTtcclxuICAgICAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcclxuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoaXNDbG9zZWQpIHtcclxuICAgICAgICB2YXIgZnJvbSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIHRvID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIGlmICghZnJvbSB8fCAhdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcclxuICAgICAgICBjdHgubGluZVRvKHRvLngsIHRvLnkpO1xyXG4gICAgfVxyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdDb250b3VyLmpzLm1hcCIsImltcG9ydCB7IEJveCB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5pbXBvcnQgeyBGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgaXNXaXRoRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2ZhY3Rvcmllcy9XaXRoRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBEcmF3Qm94IH0gZnJvbSAnLi9EcmF3Qm94JztcclxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdEZXRlY3Rpb25zKGNhbnZhc0FyZywgZGV0ZWN0aW9ucykge1xyXG4gICAgdmFyIGRldGVjdGlvbnNBcnJheSA9IEFycmF5LmlzQXJyYXkoZGV0ZWN0aW9ucykgPyBkZXRlY3Rpb25zIDogW2RldGVjdGlvbnNdO1xyXG4gICAgZGV0ZWN0aW9uc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKGRldCkge1xyXG4gICAgICAgIHZhciBzY29yZSA9IGRldCBpbnN0YW5jZW9mIEZhY2VEZXRlY3Rpb25cclxuICAgICAgICAgICAgPyBkZXQuc2NvcmVcclxuICAgICAgICAgICAgOiAoaXNXaXRoRmFjZURldGVjdGlvbihkZXQpID8gZGV0LmRldGVjdGlvbi5zY29yZSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdmFyIGJveCA9IGRldCBpbnN0YW5jZW9mIEZhY2VEZXRlY3Rpb25cclxuICAgICAgICAgICAgPyBkZXQuYm94XHJcbiAgICAgICAgICAgIDogKGlzV2l0aEZhY2VEZXRlY3Rpb24oZGV0KSA/IGRldC5kZXRlY3Rpb24uYm94IDogbmV3IEJveChkZXQpKTtcclxuICAgICAgICB2YXIgbGFiZWwgPSBzY29yZSA/IFwiXCIgKyByb3VuZChzY29yZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgbmV3IERyYXdCb3goYm94LCB7IGxhYmVsOiBsYWJlbCB9KS5kcmF3KGNhbnZhc0FyZyk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3RGV0ZWN0aW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5pbXBvcnQgeyBGYWNlRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9mYWNlRXhwcmVzc2lvbk5ldCc7XHJcbmltcG9ydCB7IGlzV2l0aEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9mYWN0b3JpZXMvV2l0aEZhY2VEZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyBpc1dpdGhGYWNlRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9mYWN0b3JpZXMvV2l0aEZhY2VFeHByZXNzaW9ucyc7XHJcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBEcmF3VGV4dEZpZWxkIH0gZnJvbSAnLi9EcmF3VGV4dEZpZWxkJztcclxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdGYWNlRXhwcmVzc2lvbnMoY2FudmFzQXJnLCBmYWNlRXhwcmVzc2lvbnMsIG1pbkNvbmZpZGVuY2UsIHRleHRGaWVsZEFuY2hvcikge1xyXG4gICAgaWYgKG1pbkNvbmZpZGVuY2UgPT09IHZvaWQgMCkgeyBtaW5Db25maWRlbmNlID0gMC4xOyB9XHJcbiAgICB2YXIgZmFjZUV4cHJlc3Npb25zQXJyYXkgPSBBcnJheS5pc0FycmF5KGZhY2VFeHByZXNzaW9ucykgPyBmYWNlRXhwcmVzc2lvbnMgOiBbZmFjZUV4cHJlc3Npb25zXTtcclxuICAgIGZhY2VFeHByZXNzaW9uc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgZXhwciA9IGUgaW5zdGFuY2VvZiBGYWNlRXhwcmVzc2lvbnNcclxuICAgICAgICAgICAgPyBlXHJcbiAgICAgICAgICAgIDogKGlzV2l0aEZhY2VFeHByZXNzaW9ucyhlKSA/IGUuZXhwcmVzc2lvbnMgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmICghZXhwcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYXdGYWNlRXhwcmVzc2lvbnMgLSBleHBlY3RlZCBmYWNlRXhwcmVzc2lvbnMgdG8gYmUgRmFjZUV4cHJlc3Npb25zIHwgV2l0aEZhY2VFeHByZXNzaW9uczx7fT4gb3IgYXJyYXkgdGhlcmVvZicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc29ydGVkID0gZXhwci5hc1NvcnRlZEFycmF5KCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdHNUb0Rpc3BsYXkgPSBzb3J0ZWQuZmlsdGVyKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiBleHByLnByb2JhYmlsaXR5ID4gbWluQ29uZmlkZW5jZTsgfSk7XHJcbiAgICAgICAgdmFyIGFuY2hvciA9IGlzV2l0aEZhY2VEZXRlY3Rpb24oZSlcclxuICAgICAgICAgICAgPyBlLmRldGVjdGlvbi5ib3guYm90dG9tTGVmdFxyXG4gICAgICAgICAgICA6ICh0ZXh0RmllbGRBbmNob3IgfHwgbmV3IFBvaW50KDAsIDApKTtcclxuICAgICAgICB2YXIgZHJhd1RleHRGaWVsZCA9IG5ldyBEcmF3VGV4dEZpZWxkKHJlc3VsdHNUb0Rpc3BsYXkubWFwKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiBleHByLmV4cHJlc3Npb24gKyBcIiAoXCIgKyByb3VuZChleHByLnByb2JhYmlsaXR5KSArIFwiKVwiOyB9KSwgYW5jaG9yKTtcclxuICAgICAgICBkcmF3VGV4dEZpZWxkLmRyYXcoY2FudmFzQXJnKTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdGYWNlRXhwcmVzc2lvbnMuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9kcmF3Q29udG91cic7XHJcbmV4cG9ydCAqIGZyb20gJy4vZHJhd0RldGVjdGlvbnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2RyYXdGYWNlRXhwcmVzc2lvbnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL0RyYXdCb3gnO1xyXG5leHBvcnQgKiBmcm9tICcuL0RyYXdGYWNlTGFuZG1hcmtzJztcclxuZXhwb3J0ICogZnJvbSAnLi9EcmF3VGV4dEZpZWxkJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJFbnYoKSB7XHJcbiAgICB2YXIgZmV0Y2ggPSB3aW5kb3dbJ2ZldGNoJ10gfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmV0Y2ggLSBtaXNzaW5nIGZldGNoIGltcGxlbWVudGF0aW9uIGZvciBicm93c2VyIGVudmlyb25tZW50Jyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlYWRGaWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhZEZpbGUgLSBmaWxlc3lzdGVtIG5vdCBhdmFpbGFibGUgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnQnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIENhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXHJcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXHJcbiAgICAgICAgSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQsXHJcbiAgICAgICAgSW1hZ2VEYXRhOiBJbWFnZURhdGEsXHJcbiAgICAgICAgVmlkZW86IEhUTUxWaWRlb0VsZW1lbnQsXHJcbiAgICAgICAgY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IH0sXHJcbiAgICAgICAgY3JlYXRlSW1hZ2VFbGVtZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTsgfSxcclxuICAgICAgICBmZXRjaDogZmV0Y2gsXHJcbiAgICAgICAgcmVhZEZpbGU6IHJlYWRGaWxlXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUJyb3dzZXJFbnYuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpbGVTeXN0ZW0oZnMpIHtcclxuICAgIHZhciByZXF1aXJlRnNFcnJvciA9ICcnO1xyXG4gICAgaWYgKCFmcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZzID0gcmVxdWlyZSgnZnMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICByZXF1aXJlRnNFcnJvciA9IGVyci50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciByZWFkRmlsZSA9IGZzXHJcbiAgICAgICAgPyBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xyXG4gICAgICAgICAgICAgICAgZnMucmVhZEZpbGUoZmlsZVBhdGgsIGZ1bmN0aW9uIChlcnIsIGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIgPyByZWooZXJyKSA6IHJlcyhidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZEZpbGUgLSBmYWlsZWQgdG8gcmVxdWlyZSBmcyBpbiBub2RlanMgZW52aXJvbm1lbnQgd2l0aCBlcnJvcjogXCIgKyByZXF1aXJlRnNFcnJvcik7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVhZEZpbGU6IHJlYWRGaWxlXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUZpbGVTeXN0ZW0uanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgY3JlYXRlRmlsZVN5c3RlbSB9IGZyb20gJy4vY3JlYXRlRmlsZVN5c3RlbSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb2RlanNFbnYoKSB7XHJcbiAgICB2YXIgQ2FudmFzID0gZ2xvYmFsWydDYW52YXMnXSB8fCBnbG9iYWxbJ0hUTUxDYW52YXNFbGVtZW50J107XHJcbiAgICB2YXIgSW1hZ2UgPSBnbG9iYWxbJ0ltYWdlJ10gfHwgZ2xvYmFsWydIVE1MSW1hZ2VFbGVtZW50J107XHJcbiAgICB2YXIgY3JlYXRlQ2FudmFzRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoQ2FudmFzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlQ2FudmFzRWxlbWVudCAtIG1pc3NpbmcgQ2FudmFzIGltcGxlbWVudGF0aW9uIGZvciBub2RlanMgZW52aXJvbm1lbnQnKTtcclxuICAgIH07XHJcbiAgICB2YXIgY3JlYXRlSW1hZ2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChJbWFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlSW1hZ2VFbGVtZW50IC0gbWlzc2luZyBJbWFnZSBpbXBsZW1lbnRhdGlvbiBmb3Igbm9kZWpzIGVudmlyb25tZW50Jyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGZldGNoID0gZ2xvYmFsWydmZXRjaCddIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoIC0gbWlzc2luZyBmZXRjaCBpbXBsZW1lbnRhdGlvbiBmb3Igbm9kZWpzIGVudmlyb25tZW50Jyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGZpbGVTeXN0ZW0gPSBjcmVhdGVGaWxlU3lzdGVtKCk7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oeyBDYW52YXM6IENhbnZhcyB8fCAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENhbnZhcygpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2FudmFzO1xyXG4gICAgICAgIH0oKSksIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDogZ2xvYmFsWydDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQnXSB8fCAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICAgICAgfSgpKSwgSW1hZ2U6IEltYWdlIHx8IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSW1hZ2UoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEltYWdlO1xyXG4gICAgICAgIH0oKSksIEltYWdlRGF0YTogZ2xvYmFsWydJbWFnZURhdGEnXSB8fCAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzIoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzI7XHJcbiAgICAgICAgfSgpKSwgVmlkZW86IGdsb2JhbFsnSFRNTFZpZGVvRWxlbWVudCddIHx8IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMygpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMztcclxuICAgICAgICB9KCkpLCBjcmVhdGVDYW52YXNFbGVtZW50OiBjcmVhdGVDYW52YXNFbGVtZW50LFxyXG4gICAgICAgIGNyZWF0ZUltYWdlRWxlbWVudDogY3JlYXRlSW1hZ2VFbGVtZW50LFxyXG4gICAgICAgIGZldGNoOiBmZXRjaCB9LCBmaWxlU3lzdGVtKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVOb2RlanNFbnYuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQnJvd3NlckVudiB9IGZyb20gJy4vY3JlYXRlQnJvd3NlckVudic7XHJcbmltcG9ydCB7IGNyZWF0ZUZpbGVTeXN0ZW0gfSBmcm9tICcuL2NyZWF0ZUZpbGVTeXN0ZW0nO1xyXG5pbXBvcnQgeyBjcmVhdGVOb2RlanNFbnYgfSBmcm9tICcuL2NyZWF0ZU5vZGVqc0Vudic7XHJcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vaXNCcm93c2VyJztcclxuaW1wb3J0IHsgaXNOb2RlanMgfSBmcm9tICcuL2lzTm9kZWpzJztcclxudmFyIGVudmlyb25tZW50O1xyXG5mdW5jdGlvbiBnZXRFbnYoKSB7XHJcbiAgICBpZiAoIWVudmlyb25tZW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRFbnYgLSBlbnZpcm9ubWVudCBpcyBub3QgZGVmaW5lZCwgY2hlY2sgaXNOb2RlanMoKSBhbmQgaXNCcm93c2VyKCknKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnZpcm9ubWVudDtcclxufVxyXG5mdW5jdGlvbiBzZXRFbnYoZW52KSB7XHJcbiAgICBlbnZpcm9ubWVudCA9IGVudjtcclxufVxyXG5mdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gICAgLy8gY2hlY2sgZm9yIGlzQnJvd3NlcigpIGZpcnN0IHRvIHByZXZlbnQgZWxlY3Ryb24gcmVuZGVyZXIgcHJvY2Vzc1xyXG4gICAgLy8gdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aCB3cm9uZyBlbnZpcm9ubWVudCBkdWUgdG8gaXNOb2RlanMoKSByZXR1cm5pbmcgdHJ1ZVxyXG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XHJcbiAgICAgICAgc2V0RW52KGNyZWF0ZUJyb3dzZXJFbnYoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOb2RlanMoKSkge1xyXG4gICAgICAgIHNldEVudihjcmVhdGVOb2RlanNFbnYoKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbW9ua2V5UGF0Y2goZW52KSB7XHJcbiAgICBpZiAoIWVudmlyb25tZW50KSB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9ua2V5UGF0Y2ggLSBlbnZpcm9ubWVudCBpcyBub3QgZGVmaW5lZCwgY2hlY2sgaXNOb2RlanMoKSBhbmQgaXNCcm93c2VyKCknKTtcclxuICAgIH1cclxuICAgIHZhciBfYSA9IGVudi5DYW52YXMsIENhbnZhcyA9IF9hID09PSB2b2lkIDAgPyBlbnZpcm9ubWVudC5DYW52YXMgOiBfYSwgX2IgPSBlbnYuSW1hZ2UsIEltYWdlID0gX2IgPT09IHZvaWQgMCA/IGVudmlyb25tZW50LkltYWdlIDogX2I7XHJcbiAgICBlbnZpcm9ubWVudC5DYW52YXMgPSBDYW52YXM7XHJcbiAgICBlbnZpcm9ubWVudC5JbWFnZSA9IEltYWdlO1xyXG4gICAgZW52aXJvbm1lbnQuY3JlYXRlQ2FudmFzRWxlbWVudCA9IGVudi5jcmVhdGVDYW52YXNFbGVtZW50IHx8IChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQ2FudmFzKCk7IH0pO1xyXG4gICAgZW52aXJvbm1lbnQuY3JlYXRlSW1hZ2VFbGVtZW50ID0gZW52LmNyZWF0ZUltYWdlRWxlbWVudCB8fCAoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEltYWdlKCk7IH0pO1xyXG4gICAgZW52aXJvbm1lbnQuSW1hZ2VEYXRhID0gZW52LkltYWdlRGF0YSB8fCBlbnZpcm9ubWVudC5JbWFnZURhdGE7XHJcbiAgICBlbnZpcm9ubWVudC5WaWRlbyA9IGVudi5WaWRlbyB8fCBlbnZpcm9ubWVudC5WaWRlbztcclxuICAgIGVudmlyb25tZW50LmZldGNoID0gZW52LmZldGNoIHx8IGVudmlyb25tZW50LmZldGNoO1xyXG4gICAgZW52aXJvbm1lbnQucmVhZEZpbGUgPSBlbnYucmVhZEZpbGUgfHwgZW52aXJvbm1lbnQucmVhZEZpbGU7XHJcbn1cclxuZXhwb3J0IHZhciBlbnYgPSB7XHJcbiAgICBnZXRFbnY6IGdldEVudixcclxuICAgIHNldEVudjogc2V0RW52LFxyXG4gICAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcclxuICAgIGNyZWF0ZUJyb3dzZXJFbnY6IGNyZWF0ZUJyb3dzZXJFbnYsXHJcbiAgICBjcmVhdGVGaWxlU3lzdGVtOiBjcmVhdGVGaWxlU3lzdGVtLFxyXG4gICAgY3JlYXRlTm9kZWpzRW52OiBjcmVhdGVOb2RlanNFbnYsXHJcbiAgICBtb25rZXlQYXRjaDogbW9ua2V5UGF0Y2gsXHJcbiAgICBpc0Jyb3dzZXI6IGlzQnJvd3NlcixcclxuICAgIGlzTm9kZWpzOiBpc05vZGVqc1xyXG59O1xyXG5pbml0aWFsaXplKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCdcclxuICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgJiYgdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgJiYgdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICYmIHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICYmIHR5cGVvZiBJbWFnZURhdGEgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgJiYgdHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNCcm93c2VyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBpc05vZGVqcygpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0J1xyXG4gICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAvLyBpc3N1ZXMgd2l0aCBnYXRzYnkuanM6IG1vZHVsZS5leHBvcnRzIGlzIHVuZGVmaW5lZFxyXG4gICAgICAgIC8vICYmICEhbW9kdWxlLmV4cG9ydHNcclxuICAgICAgICAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgISFwcm9jZXNzLnZlcnNpb247XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNOb2RlanMuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGV1Y2xpZGVhbkRpc3RhbmNlKGFycjEsIGFycjIpIHtcclxuICAgIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldWNsaWRlYW5EaXN0YW5jZTogYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoJyk7XHJcbiAgICB2YXIgZGVzYzEgPSBBcnJheS5mcm9tKGFycjEpO1xyXG4gICAgdmFyIGRlc2MyID0gQXJyYXkuZnJvbShhcnIyKTtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoZGVzYzFcclxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIHZhbCAtIGRlc2MyW2ldOyB9KVxyXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZGlmZikgeyByZXR1cm4gcmVzICsgTWF0aC5wb3coZGlmZiwgMik7IH0sIDApKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldWNsaWRlYW5EaXN0YW5jZS5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgdG9OZXRJbnB1dCB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IEZhY2VGZWF0dXJlRXh0cmFjdG9yIH0gZnJvbSAnLi4vZmFjZUZlYXR1cmVFeHRyYWN0b3IvRmFjZUZlYXR1cmVFeHRyYWN0b3InO1xyXG5pbXBvcnQgeyBGYWNlUHJvY2Vzc29yIH0gZnJvbSAnLi4vZmFjZVByb2Nlc3Nvci9GYWNlUHJvY2Vzc29yJztcclxuaW1wb3J0IHsgRmFjZUV4cHJlc3Npb25zIH0gZnJvbSAnLi9GYWNlRXhwcmVzc2lvbnMnO1xyXG52YXIgRmFjZUV4cHJlc3Npb25OZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUV4cHJlc3Npb25OZXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlRXhwcmVzc2lvbk5ldChmYWNlRmVhdHVyZUV4dHJhY3Rvcikge1xyXG4gICAgICAgIGlmIChmYWNlRmVhdHVyZUV4dHJhY3RvciA9PT0gdm9pZCAwKSB7IGZhY2VGZWF0dXJlRXh0cmFjdG9yID0gbmV3IEZhY2VGZWF0dXJlRXh0cmFjdG9yKCk7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0ZhY2VFeHByZXNzaW9uTmV0JywgZmFjZUZlYXR1cmVFeHRyYWN0b3IpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBGYWNlRXhwcmVzc2lvbk5ldC5wcm90b3R5cGUuZm9yd2FyZElucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0Zi5zb2Z0bWF4KF90aGlzLnJ1bk5ldChpbnB1dCkpOyB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlRXhwcmVzc2lvbk5ldC5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuZm9yd2FyZElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKV0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUV4cHJlc3Npb25OZXQucHJvdG90eXBlLnByZWRpY3RFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ldElucHV0LCBvdXQsIHByb2JhYmlsaXRlc0J5QmF0Y2gsIHByZWRpY3Rpb25zQnlCYXRjaDtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0SW5wdXQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZm9yd2FyZElucHV0KG5ldElucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHRmLnVuc3RhY2sob3V0KS5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdC5kYXRhKCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2JhYmlsaXRlc0J5QmF0Y2ggPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY3Rpb25zQnlCYXRjaCA9IHByb2JhYmlsaXRlc0J5QmF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb2JhYmlsaXRlcykgeyByZXR1cm4gbmV3IEZhY2VFeHByZXNzaW9ucyhwcm9iYWJpbGl0ZXMpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldElucHV0LmlzQmF0Y2hJbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcHJlZGljdGlvbnNCeUJhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcmVkaWN0aW9uc0J5QmF0Y2hbMF1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlRXhwcmVzc2lvbk5ldC5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ2ZhY2VfZXhwcmVzc2lvbl9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgRmFjZUV4cHJlc3Npb25OZXQucHJvdG90eXBlLmdldENsYXNzaWZpZXJDaGFubmVsc0luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAyNTY7XHJcbiAgICB9O1xyXG4gICAgRmFjZUV4cHJlc3Npb25OZXQucHJvdG90eXBlLmdldENsYXNzaWZpZXJDaGFubmVsc091dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gNztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZUV4cHJlc3Npb25OZXQ7XHJcbn0oRmFjZVByb2Nlc3NvcikpO1xyXG5leHBvcnQgeyBGYWNlRXhwcmVzc2lvbk5ldCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlRXhwcmVzc2lvbk5ldC5qcy5tYXAiLCJleHBvcnQgdmFyIEZBQ0VfRVhQUkVTU0lPTl9MQUJFTFMgPSBbJ25ldXRyYWwnLCAnaGFwcHknLCAnc2FkJywgJ2FuZ3J5JywgJ2ZlYXJmdWwnLCAnZGlzZ3VzdGVkJywgJ3N1cnByaXNlZCddO1xyXG52YXIgRmFjZUV4cHJlc3Npb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmFjZUV4cHJlc3Npb25zKHByb2JhYmlsaXRpZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChwcm9iYWJpbGl0aWVzLmxlbmd0aCAhPT0gNykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWNlRXhwcmVzc2lvbnMuY29uc3RydWN0b3IgLSBleHBlY3RlZCBwcm9iYWJpbGl0aWVzLmxlbmd0aCB0byBiZSA3LCBoYXZlOiBcIiArIHByb2JhYmlsaXRpZXMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRkFDRV9FWFBSRVNTSU9OX0xBQkVMUy5mb3JFYWNoKGZ1bmN0aW9uIChleHByZXNzaW9uLCBpZHgpIHtcclxuICAgICAgICAgICAgX3RoaXNbZXhwcmVzc2lvbl0gPSBwcm9iYWJpbGl0aWVzW2lkeF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBGYWNlRXhwcmVzc2lvbnMucHJvdG90eXBlLmFzU29ydGVkQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gRkFDRV9FWFBSRVNTSU9OX0xBQkVMU1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChleHByZXNzaW9uKSB7IHJldHVybiAoeyBleHByZXNzaW9uOiBleHByZXNzaW9uLCBwcm9iYWJpbGl0eTogX3RoaXNbZXhwcmVzc2lvbl0gfSk7IH0pXHJcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChlMCwgZTEpIHsgcmV0dXJuIGUxLnByb2JhYmlsaXR5IC0gZTAucHJvYmFiaWxpdHk7IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlRXhwcmVzc2lvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEZhY2VFeHByZXNzaW9ucyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlRXhwcmVzc2lvbnMuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9GYWNlRXhwcmVzc2lvbk5ldCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vRmFjZUV4cHJlc3Npb25zJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IHRvTmV0SW5wdXQgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBOZXVyYWxOZXR3b3JrIH0gZnJvbSAnLi4vTmV1cmFsTmV0d29yayc7XHJcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4uL29wcyc7XHJcbmltcG9ydCB7IGRlbnNlQmxvY2s0IH0gZnJvbSAnLi9kZW5zZUJsb2NrJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtcyB9IGZyb20gJy4vZXh0cmFjdFBhcmFtcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCc7XHJcbnZhciBGYWNlRmVhdHVyZUV4dHJhY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlRmVhdHVyZUV4dHJhY3RvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VGZWF0dXJlRXh0cmFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnRmFjZUZlYXR1cmVFeHRyYWN0b3InKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhY2VGZWF0dXJlRXh0cmFjdG9yIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJhdGNoVGVuc29yID0gaW5wdXQudG9CYXRjaFRlbnNvcigxMTIsIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgbWVhblJnYiA9IFsxMjIuNzgyLCAxMTcuMDAxLCAxMDQuMjk4XTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemUoYmF0Y2hUZW5zb3IsIG1lYW5SZ2IpLmRpdih0Zi5zY2FsYXIoMjU1KSk7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBkZW5zZUJsb2NrNChub3JtYWxpemVkLCBwYXJhbXMuZGVuc2UwLCB0cnVlKTtcclxuICAgICAgICAgICAgb3V0ID0gZGVuc2VCbG9jazQob3V0LCBwYXJhbXMuZGVuc2UxKTtcclxuICAgICAgICAgICAgb3V0ID0gZGVuc2VCbG9jazQob3V0LCBwYXJhbXMuZGVuc2UyKTtcclxuICAgICAgICAgICAgb3V0ID0gZGVuc2VCbG9jazQob3V0LCBwYXJhbXMuZGVuc2UzKTtcclxuICAgICAgICAgICAgb3V0ID0gdGYuYXZnUG9vbChvdXQsIFs3LCA3XSwgWzIsIDJdLCAndmFsaWQnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlRmVhdHVyZUV4dHJhY3Rvci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuZm9yd2FyZElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKV0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdmYWNlX2ZlYXR1cmVfZXh0cmFjdG9yX21vZGVsJztcclxuICAgIH07XHJcbiAgICBGYWNlRmVhdHVyZUV4dHJhY3Rvci5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zKHdlaWdodHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlRmVhdHVyZUV4dHJhY3RvcjtcclxufShOZXVyYWxOZXR3b3JrKSk7XHJcbmV4cG9ydCB7IEZhY2VGZWF0dXJlRXh0cmFjdG9yIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VGZWF0dXJlRXh0cmFjdG9yLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9vcHMnO1xyXG5pbXBvcnQgeyBkZW5zZUJsb2NrMyB9IGZyb20gJy4vZGVuc2VCbG9jayc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwVGlueSB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXBUaW55JztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtc1RpbnkgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXNUaW55JztcclxudmFyIFRpbnlGYWNlRmVhdHVyZUV4dHJhY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3InKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yLnByb3RvdHlwZS5mb3J3YXJkSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmF0Y2hUZW5zb3IgPSBpbnB1dC50b0JhdGNoVGVuc29yKDExMiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBtZWFuUmdiID0gWzEyMi43ODIsIDExNy4wMDEsIDEwNC4yOThdO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShiYXRjaFRlbnNvciwgbWVhblJnYikuZGl2KHRmLnNjYWxhcigyNTUpKTtcclxuICAgICAgICAgICAgdmFyIG91dCA9IGRlbnNlQmxvY2szKG5vcm1hbGl6ZWQsIHBhcmFtcy5kZW5zZTAsIHRydWUpO1xyXG4gICAgICAgICAgICBvdXQgPSBkZW5zZUJsb2NrMyhvdXQsIHBhcmFtcy5kZW5zZTEpO1xyXG4gICAgICAgICAgICBvdXQgPSBkZW5zZUJsb2NrMyhvdXQsIHBhcmFtcy5kZW5zZTIpO1xyXG4gICAgICAgICAgICBvdXQgPSB0Zi5hdmdQb29sKG91dCwgWzE0LCAxNF0sIFsyLCAyXSwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5mb3J3YXJkSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh0aGlzLCBbX2Iuc2VudCgpXSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdmYWNlX2ZlYXR1cmVfZXh0cmFjdG9yX3RpbnlfbW9kZWwnO1xyXG4gICAgfTtcclxuICAgIFRpbnlGYWNlRmVhdHVyZUV4dHJhY3Rvci5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwVGlueSh3ZWlnaHRNYXApO1xyXG4gICAgfTtcclxuICAgIFRpbnlGYWNlRmVhdHVyZUV4dHJhY3Rvci5wcm90b3R5cGUuZXh0cmFjdFBhcmFtcyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNUaW55KHdlaWdodHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3I7XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYgfSBmcm9tICcuLi9jb21tb24vZGVwdGh3aXNlU2VwYXJhYmxlQ29udic7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZW5zZUJsb2NrMyh4LCBkZW5zZUJsb2NrUGFyYW1zLCBpc0ZpcnN0TGF5ZXIpIHtcclxuICAgIGlmIChpc0ZpcnN0TGF5ZXIgPT09IHZvaWQgMCkgeyBpc0ZpcnN0TGF5ZXIgPSBmYWxzZTsgfVxyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQxID0gdGYucmVsdShpc0ZpcnN0TGF5ZXJcclxuICAgICAgICAgICAgPyB0Zi5hZGQodGYuY29udjJkKHgsIGRlbnNlQmxvY2tQYXJhbXMuY29udjAuZmlsdGVycywgWzIsIDJdLCAnc2FtZScpLCBkZW5zZUJsb2NrUGFyYW1zLmNvbnYwLmJpYXMpXHJcbiAgICAgICAgICAgIDogZGVwdGh3aXNlU2VwYXJhYmxlQ29udih4LCBkZW5zZUJsb2NrUGFyYW1zLmNvbnYwLCBbMiwgMl0pKTtcclxuICAgICAgICB2YXIgb3V0MiA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYob3V0MSwgZGVuc2VCbG9ja1BhcmFtcy5jb252MSwgWzEsIDFdKTtcclxuICAgICAgICB2YXIgaW4zID0gdGYucmVsdSh0Zi5hZGQob3V0MSwgb3V0MikpO1xyXG4gICAgICAgIHZhciBvdXQzID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihpbjMsIGRlbnNlQmxvY2tQYXJhbXMuY29udjIsIFsxLCAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHRmLnJlbHUodGYuYWRkKG91dDEsIHRmLmFkZChvdXQyLCBvdXQzKSkpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGRlbnNlQmxvY2s0KHgsIGRlbnNlQmxvY2tQYXJhbXMsIGlzRmlyc3RMYXllciwgaXNTY2FsZURvd24pIHtcclxuICAgIGlmIChpc0ZpcnN0TGF5ZXIgPT09IHZvaWQgMCkgeyBpc0ZpcnN0TGF5ZXIgPSBmYWxzZTsgfVxyXG4gICAgaWYgKGlzU2NhbGVEb3duID09PSB2b2lkIDApIHsgaXNTY2FsZURvd24gPSB0cnVlOyB9XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dDEgPSB0Zi5yZWx1KGlzRmlyc3RMYXllclxyXG4gICAgICAgICAgICA/IHRmLmFkZCh0Zi5jb252MmQoeCwgZGVuc2VCbG9ja1BhcmFtcy5jb252MC5maWx0ZXJzLCBpc1NjYWxlRG93biA/IFsyLCAyXSA6IFsxLCAxXSwgJ3NhbWUnKSwgZGVuc2VCbG9ja1BhcmFtcy5jb252MC5iaWFzKVxyXG4gICAgICAgICAgICA6IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYoeCwgZGVuc2VCbG9ja1BhcmFtcy5jb252MCwgaXNTY2FsZURvd24gPyBbMiwgMl0gOiBbMSwgMV0pKTtcclxuICAgICAgICB2YXIgb3V0MiA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYob3V0MSwgZGVuc2VCbG9ja1BhcmFtcy5jb252MSwgWzEsIDFdKTtcclxuICAgICAgICB2YXIgaW4zID0gdGYucmVsdSh0Zi5hZGQob3V0MSwgb3V0MikpO1xyXG4gICAgICAgIHZhciBvdXQzID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihpbjMsIGRlbnNlQmxvY2tQYXJhbXMuY29udjIsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGluNCA9IHRmLnJlbHUodGYuYWRkKG91dDEsIHRmLmFkZChvdXQyLCBvdXQzKSkpO1xyXG4gICAgICAgIHZhciBvdXQ0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihpbjQsIGRlbnNlQmxvY2tQYXJhbXMuY29udjMsIFsxLCAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHRmLnJlbHUodGYuYWRkKG91dDEsIHRmLmFkZChvdXQyLCB0Zi5hZGQob3V0Mywgb3V0NCkpKSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW5zZUJsb2NrLmpzLm1hcCIsImltcG9ydCB7IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGV4dHJhY3RvcnNGYWN0b3J5IH0gZnJvbSAnLi9leHRyYWN0b3JzRmFjdG9yeSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKHdlaWdodHMpIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0V2VpZ2h0c0ZhY3Rvcnkod2VpZ2h0cyksIGV4dHJhY3RXZWlnaHRzID0gX2EuZXh0cmFjdFdlaWdodHMsIGdldFJlbWFpbmluZ1dlaWdodHMgPSBfYS5nZXRSZW1haW5pbmdXZWlnaHRzO1xyXG4gICAgdmFyIGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcyA9IGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKS5leHRyYWN0RGVuc2VCbG9jazRQYXJhbXM7XHJcbiAgICB2YXIgZGVuc2UwID0gZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zKDMsIDMyLCAnZGVuc2UwJywgdHJ1ZSk7XHJcbiAgICB2YXIgZGVuc2UxID0gZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zKDMyLCA2NCwgJ2RlbnNlMScpO1xyXG4gICAgdmFyIGRlbnNlMiA9IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcyg2NCwgMTI4LCAnZGVuc2UyJyk7XHJcbiAgICB2YXIgZGVuc2UzID0gZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zKDEyOCwgMjU2LCAnZGVuc2UzJyk7XHJcbiAgICBpZiAoZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiBcIiArIGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzLFxyXG4gICAgICAgIHBhcmFtczogeyBkZW5zZTA6IGRlbnNlMCwgZGVuc2UxOiBkZW5zZTEsIGRlbnNlMjogZGVuc2UyLCBkZW5zZTM6IGRlbnNlMyB9XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXMuanMubWFwIiwiaW1wb3J0IHsgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBsb2FkUGFyYW1zRmFjdG9yeSB9IGZyb20gJy4vbG9hZFBhcmFtc0ZhY3RvcnknO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcyA9IGxvYWRQYXJhbXNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykuZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zO1xyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICBkZW5zZTA6IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcygnZGVuc2UwJywgdHJ1ZSksXHJcbiAgICAgICAgZGVuc2UxOiBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXMoJ2RlbnNlMScpLFxyXG4gICAgICAgIGRlbnNlMjogZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zKCdkZW5zZTInKSxcclxuICAgICAgICBkZW5zZTM6IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcygnZGVuc2UzJylcclxuICAgIH07XHJcbiAgICBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgcmV0dXJuIHsgcGFyYW1zOiBwYXJhbXMsIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcy5tYXAiLCJpbXBvcnQgeyBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGxvYWRQYXJhbXNGYWN0b3J5IH0gZnJvbSAnLi9sb2FkUGFyYW1zRmFjdG9yeSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcFRpbnkod2VpZ2h0TWFwKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcyA9IGxvYWRQYXJhbXNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykuZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zO1xyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICBkZW5zZTA6IGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcygnZGVuc2UwJywgdHJ1ZSksXHJcbiAgICAgICAgZGVuc2UxOiBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMoJ2RlbnNlMScpLFxyXG4gICAgICAgIGRlbnNlMjogZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zKCdkZW5zZTInKVxyXG4gICAgfTtcclxuICAgIGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzKHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICByZXR1cm4geyBwYXJhbXM6IHBhcmFtcywgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwVGlueS5qcy5tYXAiLCJpbXBvcnQgeyBleHRyYWN0V2VpZ2h0c0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBleHRyYWN0b3JzRmFjdG9yeSB9IGZyb20gJy4vZXh0cmFjdG9yc0ZhY3RvcnknO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc1Rpbnkod2VpZ2h0cykge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSh3ZWlnaHRzKSwgZXh0cmFjdFdlaWdodHMgPSBfYS5leHRyYWN0V2VpZ2h0cywgZ2V0UmVtYWluaW5nV2VpZ2h0cyA9IF9hLmdldFJlbWFpbmluZ1dlaWdodHM7XHJcbiAgICB2YXIgZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zID0gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpLmV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcztcclxuICAgIHZhciBkZW5zZTAgPSBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMoMywgMzIsICdkZW5zZTAnLCB0cnVlKTtcclxuICAgIHZhciBkZW5zZTEgPSBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMoMzIsIDY0LCAnZGVuc2UxJyk7XHJcbiAgICB2YXIgZGVuc2UyID0gZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zKDY0LCAxMjgsICdkZW5zZTInKTtcclxuICAgIGlmIChnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6IFwiICsgZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MsXHJcbiAgICAgICAgcGFyYW1zOiB7IGRlbnNlMDogZGVuc2UwLCBkZW5zZTE6IGRlbnNlMSwgZGVuc2UyOiBkZW5zZTIgfVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zVGlueS5qcy5tYXAiLCJpbXBvcnQgeyBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnksIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeSwgfSBmcm9tICcuLi9jb21tb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0Q29udlBhcmFtcyA9IGV4dHJhY3RDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICB2YXIgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXgsIGlzRmlyc3RMYXllcikge1xyXG4gICAgICAgIGlmIChpc0ZpcnN0TGF5ZXIgPT09IHZvaWQgMCkgeyBpc0ZpcnN0TGF5ZXIgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBjb252MCA9IGlzRmlyc3RMYXllclxyXG4gICAgICAgICAgICA/IGV4dHJhY3RDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCAzLCBtYXBwZWRQcmVmaXggKyBcIi9jb252MFwiKVxyXG4gICAgICAgICAgICA6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXggKyBcIi9jb252MFwiKTtcclxuICAgICAgICB2YXIgY29udjEgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhjaGFubmVsc091dCwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCArIFwiL2NvbnYxXCIpO1xyXG4gICAgICAgIHZhciBjb252MiA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKGNoYW5uZWxzT3V0LCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4ICsgXCIvY29udjJcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjA6IGNvbnYwLCBjb252MTogY29udjEsIGNvbnYyOiBjb252MiB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXgsIGlzRmlyc3RMYXllcikge1xyXG4gICAgICAgIGlmIChpc0ZpcnN0TGF5ZXIgPT09IHZvaWQgMCkgeyBpc0ZpcnN0TGF5ZXIgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBfYSA9IGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4LCBpc0ZpcnN0TGF5ZXIpLCBjb252MCA9IF9hLmNvbnYwLCBjb252MSA9IF9hLmNvbnYxLCBjb252MiA9IF9hLmNvbnYyO1xyXG4gICAgICAgIHZhciBjb252MyA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKGNoYW5uZWxzT3V0LCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4ICsgXCIvY29udjNcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjA6IGNvbnYwLCBjb252MTogY29udjEsIGNvbnYyOiBjb252MiwgY29udjM6IGNvbnYzIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtczogZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtczogZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RvcnNGYWN0b3J5LmpzLm1hcCIsImltcG9ydCB7IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnksIGxvYWRTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGxvYWRDb252UGFyYW1zRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbi9sb2FkQ29udlBhcmFtc0ZhY3RvcnknO1xyXG5leHBvcnQgZnVuY3Rpb24gbG9hZFBhcmFtc0ZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICB2YXIgZXh0cmFjdFdlaWdodEVudHJ5ID0gZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgdmFyIGV4dHJhY3RDb252UGFyYW1zID0gbG9hZENvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRFbnRyeSk7XHJcbiAgICB2YXIgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBsb2FkU2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodEVudHJ5KTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcyhwcmVmaXgsIGlzRmlyc3RMYXllcikge1xyXG4gICAgICAgIGlmIChpc0ZpcnN0TGF5ZXIgPT09IHZvaWQgMCkgeyBpc0ZpcnN0TGF5ZXIgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBjb252MCA9IGlzRmlyc3RMYXllclxyXG4gICAgICAgICAgICA/IGV4dHJhY3RDb252UGFyYW1zKHByZWZpeCArIFwiL2NvbnYwXCIpXHJcbiAgICAgICAgICAgIDogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjBcIik7XHJcbiAgICAgICAgdmFyIGNvbnYxID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjFcIik7XHJcbiAgICAgICAgdmFyIGNvbnYyID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjJcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjA6IGNvbnYwLCBjb252MTogY29udjEsIGNvbnYyOiBjb252MiB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zKHByZWZpeCwgaXNGaXJzdExheWVyKSB7XHJcbiAgICAgICAgaWYgKGlzRmlyc3RMYXllciA9PT0gdm9pZCAwKSB7IGlzRmlyc3RMYXllciA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGNvbnYwID0gaXNGaXJzdExheWVyXHJcbiAgICAgICAgICAgID8gZXh0cmFjdENvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjBcIilcclxuICAgICAgICAgICAgOiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252MFwiKTtcclxuICAgICAgICB2YXIgY29udjEgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252MVwiKTtcclxuICAgICAgICB2YXIgY29udjIgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252MlwiKTtcclxuICAgICAgICB2YXIgY29udjMgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252M1wiKTtcclxuICAgICAgICByZXR1cm4geyBjb252MDogY29udjAsIGNvbnYxOiBjb252MSwgY29udjI6IGNvbnYyLCBjb252MzogY29udjMgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zOiBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zOiBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXNcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFBhcmFtc0ZhY3RvcnkuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEZhY2VGZWF0dXJlRXh0cmFjdG9yIH0gZnJvbSAnLi4vZmFjZUZlYXR1cmVFeHRyYWN0b3IvRmFjZUZlYXR1cmVFeHRyYWN0b3InO1xyXG5pbXBvcnQgeyBGYWNlTGFuZG1hcms2OE5ldEJhc2UgfSBmcm9tICcuL0ZhY2VMYW5kbWFyazY4TmV0QmFzZSc7XHJcbnZhciBGYWNlTGFuZG1hcms2OE5ldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlTGFuZG1hcms2OE5ldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VMYW5kbWFyazY4TmV0KGZhY2VGZWF0dXJlRXh0cmFjdG9yKSB7XHJcbiAgICAgICAgaWYgKGZhY2VGZWF0dXJlRXh0cmFjdG9yID09PSB2b2lkIDApIHsgZmFjZUZlYXR1cmVFeHRyYWN0b3IgPSBuZXcgRmFjZUZlYXR1cmVFeHRyYWN0b3IoKTsgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnRmFjZUxhbmRtYXJrNjhOZXQnLCBmYWNlRmVhdHVyZUV4dHJhY3RvcikgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZhY2VMYW5kbWFyazY4TmV0LnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnZmFjZV9sYW5kbWFya182OF9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrNjhOZXQucHJvdG90eXBlLmdldENsYXNzaWZpZXJDaGFubmVsc0luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAyNTY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VMYW5kbWFyazY4TmV0O1xyXG59KEZhY2VMYW5kbWFyazY4TmV0QmFzZSkpO1xyXG5leHBvcnQgeyBGYWNlTGFuZG1hcms2OE5ldCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlTGFuZG1hcms2OE5ldC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrczY4IH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlTGFuZG1hcmtzNjgnO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgRmFjZVByb2Nlc3NvciB9IGZyb20gJy4uL2ZhY2VQcm9jZXNzb3IvRmFjZVByb2Nlc3Nvcic7XHJcbmltcG9ydCB7IGlzRXZlbiB9IGZyb20gJy4uL3V0aWxzJztcclxudmFyIEZhY2VMYW5kbWFyazY4TmV0QmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlTGFuZG1hcms2OE5ldEJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlTGFuZG1hcms2OE5ldEJhc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmFjZUxhbmRtYXJrNjhOZXRCYXNlLnByb3RvdHlwZS5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0U2l6ZSwgb3JpZ2luYWxEaW1lbnNpb25zKSB7XHJcbiAgICAgICAgdmFyIGlucHV0RGltZW5zaW9ucyA9IG9yaWdpbmFsRGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGlucHV0U2l6ZSAvIE1hdGgubWF4KGhlaWdodCwgd2lkdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoICogc2NhbGUsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIHNjYWxlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGlucHV0RGltZW5zaW9ucy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY3JlYXRlSW50ZXJsZWF2ZWRUZW5zb3IgPSBmdW5jdGlvbiAoZmlsbFgsIGZpbGxZKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGYuc3RhY2soW1xyXG4gICAgICAgICAgICAgICAgICAgIHRmLmZpbGwoWzY4XSwgZmlsbFgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRmLmZpbGwoWzY4XSwgZmlsbFkpXHJcbiAgICAgICAgICAgICAgICBdLCAxKS5hczJEKDEsIDEzNikuYXMxRCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZ2V0UGFkZGluZyA9IGZ1bmN0aW9uIChiYXRjaElkeCwgY29uZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gaW5wdXREaW1lbnNpb25zW2JhdGNoSWR4XSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmQod2lkdGgsIGhlaWdodCkgPyBNYXRoLmFicyh3aWR0aCAtIGhlaWdodCkgLyAyIDogMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGdldFBhZGRpbmdYID0gZnVuY3Rpb24gKGJhdGNoSWR4KSB7IHJldHVybiBnZXRQYWRkaW5nKGJhdGNoSWR4LCBmdW5jdGlvbiAodywgaCkgeyByZXR1cm4gdyA8IGg7IH0pOyB9O1xyXG4gICAgICAgICAgICB2YXIgZ2V0UGFkZGluZ1kgPSBmdW5jdGlvbiAoYmF0Y2hJZHgpIHsgcmV0dXJuIGdldFBhZGRpbmcoYmF0Y2hJZHgsIGZ1bmN0aW9uICh3LCBoKSB7IHJldHVybiBoIDwgdzsgfSk7IH07XHJcbiAgICAgICAgICAgIHZhciBsYW5kbWFya1RlbnNvcnMgPSBvdXRwdXRcclxuICAgICAgICAgICAgICAgIC5tdWwodGYuZmlsbChbYmF0Y2hTaXplLCAxMzZdLCBpbnB1dFNpemUpKVxyXG4gICAgICAgICAgICAgICAgLnN1Yih0Zi5zdGFjayhBcnJheS5mcm9tKEFycmF5KGJhdGNoU2l6ZSksIGZ1bmN0aW9uIChfLCBiYXRjaElkeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludGVybGVhdmVkVGVuc29yKGdldFBhZGRpbmdYKGJhdGNoSWR4KSwgZ2V0UGFkZGluZ1koYmF0Y2hJZHgpKTtcclxuICAgICAgICAgICAgfSkpKVxyXG4gICAgICAgICAgICAgICAgLmRpdih0Zi5zdGFjayhBcnJheS5mcm9tKEFycmF5KGJhdGNoU2l6ZSksIGZ1bmN0aW9uIChfLCBiYXRjaElkeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludGVybGVhdmVkVGVuc29yKGlucHV0RGltZW5zaW9uc1tiYXRjaElkeF0ud2lkdGgsIGlucHV0RGltZW5zaW9uc1tiYXRjaElkeF0uaGVpZ2h0KTtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmRtYXJrVGVuc29ycztcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcms2OE5ldEJhc2UucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgb3V0ID0gX3RoaXMucnVuTmV0KGlucHV0KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvc3RQcm9jZXNzKG91dCwgaW5wdXQuaW5wdXRTaXplLCBpbnB1dC5pbnB1dERpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh7IGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGggfSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcms2OE5ldEJhc2UucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHRoaXMsIFtfYi5zZW50KCldKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFyazY4TmV0QmFzZS5wcm90b3R5cGUuZGV0ZWN0TGFuZG1hcmtzID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbmV0SW5wdXQsIGxhbmRtYXJrVGVuc29ycywgbGFuZG1hcmtzRm9yQmF0Y2g7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldElucHV0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5kbWFya1RlbnNvcnMgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmLnVuc3RhY2soX3RoaXMuZm9yd2FyZElucHV0KG5ldElucHV0KSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChsYW5kbWFya1RlbnNvcnMubWFwKGZ1bmN0aW9uIChsYW5kbWFya1RlbnNvciwgYmF0Y2hJZHgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZG1hcmtzQXJyYXksIF9hLCBfYiwgeENvb3JkcywgeUNvb3JkcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IEFycmF5KS5mcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxhbmRtYXJrVGVuc29yLmRhdGEoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZG1hcmtzQXJyYXkgPSBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhDb29yZHMgPSBsYW5kbWFya3NBcnJheS5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGlzRXZlbihpKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUNvb3JkcyA9IGxhbmRtYXJrc0FycmF5LmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gIWlzRXZlbihpKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBGYWNlTGFuZG1hcmtzNjgoQXJyYXkoNjgpLmZpbGwoMCkubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBuZXcgUG9pbnQoeENvb3Jkc1tpXSwgeUNvb3Jkc1tpXSk7IH0pLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ldElucHV0LmdldElucHV0SGVpZ2h0KGJhdGNoSWR4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXRJbnB1dC5nZXRJbnB1dFdpZHRoKGJhdGNoSWR4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmRtYXJrc0ZvckJhdGNoID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5kbWFya1RlbnNvcnMuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5kaXNwb3NlKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0SW5wdXQuaXNCYXRjaElucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsYW5kbWFya3NGb3JCYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGFuZG1hcmtzRm9yQmF0Y2hbMF1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcms2OE5ldEJhc2UucHJvdG90eXBlLmdldENsYXNzaWZpZXJDaGFubmVsc091dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gMTM2O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlTGFuZG1hcms2OE5ldEJhc2U7XHJcbn0oRmFjZVByb2Nlc3NvcikpO1xyXG5leHBvcnQgeyBGYWNlTGFuZG1hcms2OE5ldEJhc2UgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZUxhbmRtYXJrNjhOZXRCYXNlLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IgfSBmcm9tICcuLi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9UaW55RmFjZUZlYXR1cmVFeHRyYWN0b3InO1xyXG5pbXBvcnQgeyBGYWNlTGFuZG1hcms2OE5ldEJhc2UgfSBmcm9tICcuL0ZhY2VMYW5kbWFyazY4TmV0QmFzZSc7XHJcbnZhciBGYWNlTGFuZG1hcms2OFRpbnlOZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUxhbmRtYXJrNjhUaW55TmV0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmFjZUxhbmRtYXJrNjhUaW55TmV0KGZhY2VGZWF0dXJlRXh0cmFjdG9yKSB7XHJcbiAgICAgICAgaWYgKGZhY2VGZWF0dXJlRXh0cmFjdG9yID09PSB2b2lkIDApIHsgZmFjZUZlYXR1cmVFeHRyYWN0b3IgPSBuZXcgVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yKCk7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0ZhY2VMYW5kbWFyazY4VGlueU5ldCcsIGZhY2VGZWF0dXJlRXh0cmFjdG9yKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmFjZUxhbmRtYXJrNjhUaW55TmV0LnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnZmFjZV9sYW5kbWFya182OF90aW55X21vZGVsJztcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcms2OFRpbnlOZXQucHJvdG90eXBlLmdldENsYXNzaWZpZXJDaGFubmVsc0luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAxMjg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VMYW5kbWFyazY4VGlueU5ldDtcclxufShGYWNlTGFuZG1hcms2OE5ldEJhc2UpKTtcclxuZXhwb3J0IHsgRmFjZUxhbmRtYXJrNjhUaW55TmV0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VMYW5kbWFyazY4VGlueU5ldC5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrNjhOZXQgfSBmcm9tICcuL0ZhY2VMYW5kbWFyazY4TmV0JztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlTGFuZG1hcms2OE5ldCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vRmFjZUxhbmRtYXJrNjhUaW55TmV0JztcclxudmFyIEZhY2VMYW5kbWFya05ldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlTGFuZG1hcmtOZXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlTGFuZG1hcmtOZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEZhY2VMYW5kbWFya05ldDtcclxufShGYWNlTGFuZG1hcms2OE5ldCkpO1xyXG5leHBvcnQgeyBGYWNlTGFuZG1hcmtOZXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGZ1bGx5Q29ubmVjdGVkTGF5ZXIgfSBmcm9tICcuLi9jb21tb24vZnVsbHlDb25uZWN0ZWRMYXllcic7XHJcbmltcG9ydCB7IE5ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwJztcclxuaW1wb3J0IHsgc2VwZXJhdGVXZWlnaHRNYXBzIH0gZnJvbSAnLi91dGlsJztcclxudmFyIEZhY2VQcm9jZXNzb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZVByb2Nlc3NvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VQcm9jZXNzb3IoX25hbWUsIGZhY2VGZWF0dXJlRXh0cmFjdG9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX25hbWUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yID0gZmFjZUZlYXR1cmVFeHRyYWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VQcm9jZXNzb3IucHJvdG90eXBlLCBcImZhY2VGZWF0dXJlRXh0cmFjdG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRmFjZVByb2Nlc3Nvci5wcm90b3R5cGUucnVuTmV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX25hbWUgKyBcIiAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm90dGxlbmVja0ZlYXR1cmVzID0gaW5wdXQgaW5zdGFuY2VvZiBOZXRJbnB1dFxyXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5mb3J3YXJkSW5wdXQoaW5wdXQpXHJcbiAgICAgICAgICAgICAgICA6IGlucHV0O1xyXG4gICAgICAgICAgICByZXR1cm4gZnVsbHlDb25uZWN0ZWRMYXllcihib3R0bGVuZWNrRmVhdHVyZXMuYXMyRChib3R0bGVuZWNrRmVhdHVyZXMuc2hhcGVbMF0sIC0xKSwgcGFyYW1zLmZjKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlUHJvY2Vzc29yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHRocm93T25SZWRpc3Bvc2UpIHtcclxuICAgICAgICBpZiAodGhyb3dPblJlZGlzcG9zZSA9PT0gdm9pZCAwKSB7IHRocm93T25SZWRpc3Bvc2UgPSB0cnVlOyB9XHJcbiAgICAgICAgdGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5kaXNwb3NlKHRocm93T25SZWRpc3Bvc2UpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsIHRocm93T25SZWRpc3Bvc2UpO1xyXG4gICAgfTtcclxuICAgIEZhY2VQcm9jZXNzb3IucHJvdG90eXBlLmxvYWRDbGFzc2lmaWVyUGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLmV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKHdlaWdodHMpLCBwYXJhbXMgPSBfYS5wYXJhbXMsIHBhcmFtTWFwcGluZ3MgPSBfYS5wYXJhbU1hcHBpbmdzO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICB0aGlzLl9wYXJhbU1hcHBpbmdzID0gcGFyYW1NYXBwaW5ncztcclxuICAgIH07XHJcbiAgICBGYWNlUHJvY2Vzc29yLnByb3RvdHlwZS5leHRyYWN0Q2xhc3NpZmllclBhcmFtcyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXMod2VpZ2h0cywgdGhpcy5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbigpLCB0aGlzLmdldENsYXNzaWZpZXJDaGFubmVsc091dCgpKTtcclxuICAgIH07XHJcbiAgICBGYWNlUHJvY2Vzc29yLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICB2YXIgX2EgPSBzZXBlcmF0ZVdlaWdodE1hcHMod2VpZ2h0TWFwKSwgZmVhdHVyZUV4dHJhY3Rvck1hcCA9IF9hLmZlYXR1cmVFeHRyYWN0b3JNYXAsIGNsYXNzaWZpZXJNYXAgPSBfYS5jbGFzc2lmaWVyTWFwO1xyXG4gICAgICAgIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IubG9hZEZyb21XZWlnaHRNYXAoZmVhdHVyZUV4dHJhY3Rvck1hcCk7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKGNsYXNzaWZpZXJNYXApO1xyXG4gICAgfTtcclxuICAgIEZhY2VQcm9jZXNzb3IucHJvdG90eXBlLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHZhciBjSW4gPSB0aGlzLmdldENsYXNzaWZpZXJDaGFubmVsc0luKCk7XHJcbiAgICAgICAgdmFyIGNPdXQgPSB0aGlzLmdldENsYXNzaWZpZXJDaGFubmVsc091dCgpO1xyXG4gICAgICAgIHZhciBjbGFzc2lmaWVyV2VpZ2h0U2l6ZSA9IChjT3V0ICogY0luKSArIGNPdXQ7XHJcbiAgICAgICAgdmFyIGZlYXR1cmVFeHRyYWN0b3JXZWlnaHRzID0gd2VpZ2h0cy5zbGljZSgwLCB3ZWlnaHRzLmxlbmd0aCAtIGNsYXNzaWZpZXJXZWlnaHRTaXplKTtcclxuICAgICAgICB2YXIgY2xhc3NpZmllcldlaWdodHMgPSB3ZWlnaHRzLnNsaWNlKHdlaWdodHMubGVuZ3RoIC0gY2xhc3NpZmllcldlaWdodFNpemUpO1xyXG4gICAgICAgIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZXh0cmFjdFdlaWdodHMoZmVhdHVyZUV4dHJhY3RvcldlaWdodHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKGNsYXNzaWZpZXJXZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZVByb2Nlc3NvcjtcclxufShOZXVyYWxOZXR3b3JrKSk7XHJcbmV4cG9ydCB7IEZhY2VQcm9jZXNzb3IgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZVByb2Nlc3Nvci5qcy5tYXAiLCJpbXBvcnQgeyBleHRyYWN0RkNQYXJhbXNGYWN0b3J5LCBleHRyYWN0V2VpZ2h0c0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzLCBjaGFubmVsc0luLCBjaGFubmVsc091dCkge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSh3ZWlnaHRzKSwgZXh0cmFjdFdlaWdodHMgPSBfYS5leHRyYWN0V2VpZ2h0cywgZ2V0UmVtYWluaW5nV2VpZ2h0cyA9IF9hLmdldFJlbWFpbmluZ1dlaWdodHM7XHJcbiAgICB2YXIgZXh0cmFjdEZDUGFyYW1zID0gZXh0cmFjdEZDUGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICB2YXIgZmMgPSBleHRyYWN0RkNQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsICdmYycpO1xyXG4gICAgaWYgKGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogXCIgKyBnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyxcclxuICAgICAgICBwYXJhbXM6IHsgZmM6IGZjIH1cclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtcy5qcy5tYXAiLCJpbXBvcnQgeyBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycywgZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXApIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgZXh0cmFjdFdlaWdodEVudHJ5ID0gZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZjUGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHZhciB3ZWlnaHRzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL3dlaWdodHNcIiwgMik7XHJcbiAgICAgICAgdmFyIGJpYXMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvYmlhc1wiLCAxKTtcclxuICAgICAgICByZXR1cm4geyB3ZWlnaHRzOiB3ZWlnaHRzLCBiaWFzOiBiaWFzIH07XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgIGZjOiBleHRyYWN0RmNQYXJhbXMoJ2ZjJylcclxuICAgIH07XHJcbiAgICBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgcmV0dXJuIHsgcGFyYW1zOiBwYXJhbXMsIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gc2VwZXJhdGVXZWlnaHRNYXBzKHdlaWdodE1hcCkge1xyXG4gICAgdmFyIGZlYXR1cmVFeHRyYWN0b3JNYXAgPSB7fTtcclxuICAgIHZhciBjbGFzc2lmaWVyTWFwID0ge307XHJcbiAgICBPYmplY3Qua2V5cyh3ZWlnaHRNYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBtYXAgPSBrZXkuc3RhcnRzV2l0aCgnZmMnKSA/IGNsYXNzaWZpZXJNYXAgOiBmZWF0dXJlRXh0cmFjdG9yTWFwO1xyXG4gICAgICAgIG1hcFtrZXldID0gd2VpZ2h0TWFwW2tleV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7IGZlYXR1cmVFeHRyYWN0b3JNYXA6IGZlYXR1cmVFeHRyYWN0b3JNYXAsIGNsYXNzaWZpZXJNYXA6IGNsYXNzaWZpZXJNYXAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9vcHMnO1xyXG5pbXBvcnQgeyBjb252RG93biB9IGZyb20gJy4vY29udkxheWVyJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtcyB9IGZyb20gJy4vZXh0cmFjdFBhcmFtcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCc7XHJcbmltcG9ydCB7IHJlc2lkdWFsLCByZXNpZHVhbERvd24gfSBmcm9tICcuL3Jlc2lkdWFsTGF5ZXInO1xyXG52YXIgRmFjZVJlY29nbml0aW9uTmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZhY2VSZWNvZ25pdGlvbk5ldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VSZWNvZ25pdGlvbk5ldCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0ZhY2VSZWNvZ25pdGlvbk5ldCcpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBGYWNlUmVjb2duaXRpb25OZXQucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhY2VSZWNvZ25pdGlvbk5ldCAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXRjaFRlbnNvciA9IGlucHV0LnRvQmF0Y2hUZW5zb3IoMTUwLCB0cnVlKS50b0Zsb2F0KCk7XHJcbiAgICAgICAgICAgIHZhciBtZWFuUmdiID0gWzEyMi43ODIsIDExNy4wMDEsIDEwNC4yOThdO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShiYXRjaFRlbnNvciwgbWVhblJnYikuZGl2KHRmLnNjYWxhcigyNTYpKTtcclxuICAgICAgICAgICAgdmFyIG91dCA9IGNvbnZEb3duKG5vcm1hbGl6ZWQsIHBhcmFtcy5jb252MzJfZG93bik7XHJcbiAgICAgICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCAzLCAyLCAndmFsaWQnKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWwob3V0LCBwYXJhbXMuY29udjMyXzEpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252MzJfMik7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsKG91dCwgcGFyYW1zLmNvbnYzMl8zKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWxEb3duKG91dCwgcGFyYW1zLmNvbnY2NF9kb3duKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWwob3V0LCBwYXJhbXMuY29udjY0XzEpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252NjRfMik7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsKG91dCwgcGFyYW1zLmNvbnY2NF8zKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWxEb3duKG91dCwgcGFyYW1zLmNvbnYxMjhfZG93bik7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsKG91dCwgcGFyYW1zLmNvbnYxMjhfMSk7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsKG91dCwgcGFyYW1zLmNvbnYxMjhfMik7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsRG93bihvdXQsIHBhcmFtcy5jb252MjU2X2Rvd24pO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252MjU2XzEpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252MjU2XzIpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbERvd24ob3V0LCBwYXJhbXMuY29udjI1Nl9kb3duX291dCk7XHJcbiAgICAgICAgICAgIHZhciBnbG9iYWxBdmcgPSBvdXQubWVhbihbMSwgMl0pO1xyXG4gICAgICAgICAgICB2YXIgZnVsbHlDb25uZWN0ZWQgPSB0Zi5tYXRNdWwoZ2xvYmFsQXZnLCBwYXJhbXMuZmMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVsbHlDb25uZWN0ZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZVJlY29nbml0aW9uTmV0LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5mb3J3YXJkSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh0aGlzLCBbX2Iuc2VudCgpXSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlUmVjb2duaXRpb25OZXQucHJvdG90eXBlLmNvbXB1dGVGYWNlRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ldElucHV0LCBmYWNlRGVzY3JpcHRvclRlbnNvcnMsIGZhY2VEZXNjcmlwdG9yc0ZvckJhdGNoO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRJbnB1dCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZURlc2NyaXB0b3JUZW5zb3JzID0gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0Zi51bnN0YWNrKF90aGlzLmZvcndhcmRJbnB1dChuZXRJbnB1dCkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoZmFjZURlc2NyaXB0b3JUZW5zb3JzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5kYXRhKCk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlRGVzY3JpcHRvcnNGb3JCYXRjaCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZURlc2NyaXB0b3JUZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZGlzcG9zZSgpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldElucHV0LmlzQmF0Y2hJbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmFjZURlc2NyaXB0b3JzRm9yQmF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhY2VEZXNjcmlwdG9yc0ZvckJhdGNoWzBdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZVJlY29nbml0aW9uTmV0LnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnZmFjZV9yZWNvZ25pdGlvbl9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgRmFjZVJlY29nbml0aW9uTmV0LnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKTtcclxuICAgIH07XHJcbiAgICBGYWNlUmVjb2duaXRpb25OZXQucHJvdG90eXBlLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zKHdlaWdodHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlUmVjb2duaXRpb25OZXQ7XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBGYWNlUmVjb2duaXRpb25OZXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZVJlY29nbml0aW9uTmV0LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IHNjYWxlIH0gZnJvbSAnLi9zY2FsZUxheWVyJztcclxuZnVuY3Rpb24gY29udkxheWVyKHgsIHBhcmFtcywgc3RyaWRlcywgd2l0aFJlbHUsIHBhZGRpbmcpIHtcclxuICAgIGlmIChwYWRkaW5nID09PSB2b2lkIDApIHsgcGFkZGluZyA9ICdzYW1lJzsgfVxyXG4gICAgdmFyIF9hID0gcGFyYW1zLmNvbnYsIGZpbHRlcnMgPSBfYS5maWx0ZXJzLCBiaWFzID0gX2EuYmlhcztcclxuICAgIHZhciBvdXQgPSB0Zi5jb252MmQoeCwgZmlsdGVycywgc3RyaWRlcywgcGFkZGluZyk7XHJcbiAgICBvdXQgPSB0Zi5hZGQob3V0LCBiaWFzKTtcclxuICAgIG91dCA9IHNjYWxlKG91dCwgcGFyYW1zLnNjYWxlKTtcclxuICAgIHJldHVybiB3aXRoUmVsdSA/IHRmLnJlbHUob3V0KSA6IG91dDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29udih4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiBjb252TGF5ZXIoeCwgcGFyYW1zLCBbMSwgMV0sIHRydWUpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb252Tm9SZWx1KHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIGNvbnZMYXllcih4LCBwYXJhbXMsIFsxLCAxXSwgZmFsc2UpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb252RG93bih4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiBjb252TGF5ZXIoeCwgcGFyYW1zLCBbMiwgMl0sIHRydWUsICd2YWxpZCcpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZMYXllci5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBleHRyYWN0V2VpZ2h0c0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBpc0Zsb2F0IH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5mdW5jdGlvbiBleHRyYWN0b3JzRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZpbHRlclZhbHVlcyhudW1GaWx0ZXJWYWx1ZXMsIG51bUZpbHRlcnMsIGZpbHRlclNpemUpIHtcclxuICAgICAgICB2YXIgd2VpZ2h0cyA9IGV4dHJhY3RXZWlnaHRzKG51bUZpbHRlclZhbHVlcyk7XHJcbiAgICAgICAgdmFyIGRlcHRoID0gd2VpZ2h0cy5sZW5ndGggLyAobnVtRmlsdGVycyAqIGZpbHRlclNpemUgKiBmaWx0ZXJTaXplKTtcclxuICAgICAgICBpZiAoaXNGbG9hdChkZXB0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVwdGggaGFzIHRvIGJlIGFuIGludGVnZXI6IFwiICsgZGVwdGggKyBcIiwgd2VpZ2h0cy5sZW5ndGg6IFwiICsgd2VpZ2h0cy5sZW5ndGggKyBcIiwgbnVtRmlsdGVyczogXCIgKyBudW1GaWx0ZXJzICsgXCIsIGZpbHRlclNpemU6IFwiICsgZmlsdGVyU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmLnRyYW5zcG9zZSh0Zi50ZW5zb3I0ZCh3ZWlnaHRzLCBbbnVtRmlsdGVycywgZGVwdGgsIGZpbHRlclNpemUsIGZpbHRlclNpemVdKSwgWzIsIDMsIDEsIDBdKTsgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Q29udlBhcmFtcyhudW1GaWx0ZXJWYWx1ZXMsIG51bUZpbHRlcnMsIGZpbHRlclNpemUsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gZXh0cmFjdEZpbHRlclZhbHVlcyhudW1GaWx0ZXJWYWx1ZXMsIG51bUZpbHRlcnMsIGZpbHRlclNpemUpO1xyXG4gICAgICAgIHZhciBiaWFzID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMobnVtRmlsdGVycykpO1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvZmlsdGVyc1wiIH0sIHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9iaWFzXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyczogZmlsdGVycywgYmlhczogYmlhcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFNjYWxlTGF5ZXJQYXJhbXMobnVtV2VpZ2h0cywgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIHdlaWdodHMgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhudW1XZWlnaHRzKSk7XHJcbiAgICAgICAgdmFyIGJpYXNlcyA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKG51bVdlaWdodHMpKTtcclxuICAgICAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL3dlaWdodHNcIiB9LCB7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvYmlhc2VzXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2VpZ2h0czogd2VpZ2h0cyxcclxuICAgICAgICAgICAgYmlhc2VzOiBiaWFzZXNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbnZMYXllclBhcmFtcyhudW1GaWx0ZXJWYWx1ZXMsIG51bUZpbHRlcnMsIGZpbHRlclNpemUsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBjb252ID0gZXh0cmFjdENvbnZQYXJhbXMobnVtRmlsdGVyVmFsdWVzLCBudW1GaWx0ZXJzLCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXggKyBcIi9jb252XCIpO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IGV4dHJhY3RTY2FsZUxheWVyUGFyYW1zKG51bUZpbHRlcnMsIG1hcHBlZFByZWZpeCArIFwiL3NjYWxlXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnY6IGNvbnYsIHNjYWxlOiBzY2FsZSB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMobnVtRmlsdGVyVmFsdWVzLCBudW1GaWx0ZXJzLCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXgsIGlzRG93bikge1xyXG4gICAgICAgIGlmIChpc0Rvd24gPT09IHZvaWQgMCkgeyBpc0Rvd24gPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBjb252MSA9IGV4dHJhY3RDb252TGF5ZXJQYXJhbXMoKGlzRG93biA/IDAuNSA6IDEpICogbnVtRmlsdGVyVmFsdWVzLCBudW1GaWx0ZXJzLCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXggKyBcIi9jb252MVwiKTtcclxuICAgICAgICB2YXIgY29udjIgPSBleHRyYWN0Q29udkxheWVyUGFyYW1zKG51bUZpbHRlclZhbHVlcywgbnVtRmlsdGVycywgZmlsdGVyU2l6ZSwgbWFwcGVkUHJlZml4ICsgXCIvY29udjJcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjE6IGNvbnYxLCBjb252MjogY29udjIgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdENvbnZMYXllclBhcmFtczogZXh0cmFjdENvbnZMYXllclBhcmFtcyxcclxuICAgICAgICBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtczogZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXMod2VpZ2h0cykge1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdFdlaWdodHNGYWN0b3J5KHdlaWdodHMpLCBleHRyYWN0V2VpZ2h0cyA9IF9hLmV4dHJhY3RXZWlnaHRzLCBnZXRSZW1haW5pbmdXZWlnaHRzID0gX2EuZ2V0UmVtYWluaW5nV2VpZ2h0cztcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2IgPSBleHRyYWN0b3JzRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RDb252TGF5ZXJQYXJhbXMgPSBfYi5leHRyYWN0Q29udkxheWVyUGFyYW1zLCBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyA9IF9iLmV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zO1xyXG4gICAgdmFyIGNvbnYzMl9kb3duID0gZXh0cmFjdENvbnZMYXllclBhcmFtcyg0NzA0LCAzMiwgNywgJ2NvbnYzMl9kb3duJyk7XHJcbiAgICB2YXIgY29udjMyXzEgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyg5MjE2LCAzMiwgMywgJ2NvbnYzMl8xJyk7XHJcbiAgICB2YXIgY29udjMyXzIgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyg5MjE2LCAzMiwgMywgJ2NvbnYzMl8yJyk7XHJcbiAgICB2YXIgY29udjMyXzMgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyg5MjE2LCAzMiwgMywgJ2NvbnYzMl8zJyk7XHJcbiAgICB2YXIgY29udjY0X2Rvd24gPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygzNjg2NCwgNjQsIDMsICdjb252NjRfZG93bicsIHRydWUpO1xyXG4gICAgdmFyIGNvbnY2NF8xID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoMzY4NjQsIDY0LCAzLCAnY29udjY0XzEnKTtcclxuICAgIHZhciBjb252NjRfMiA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKDM2ODY0LCA2NCwgMywgJ2NvbnY2NF8yJyk7XHJcbiAgICB2YXIgY29udjY0XzMgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygzNjg2NCwgNjQsIDMsICdjb252NjRfMycpO1xyXG4gICAgdmFyIGNvbnYxMjhfZG93biA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKDE0NzQ1NiwgMTI4LCAzLCAnY29udjEyOF9kb3duJywgdHJ1ZSk7XHJcbiAgICB2YXIgY29udjEyOF8xID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoMTQ3NDU2LCAxMjgsIDMsICdjb252MTI4XzEnKTtcclxuICAgIHZhciBjb252MTI4XzIgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygxNDc0NTYsIDEyOCwgMywgJ2NvbnYxMjhfMicpO1xyXG4gICAgdmFyIGNvbnYyNTZfZG93biA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKDU4OTgyNCwgMjU2LCAzLCAnY29udjI1Nl9kb3duJywgdHJ1ZSk7XHJcbiAgICB2YXIgY29udjI1Nl8xID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoNTg5ODI0LCAyNTYsIDMsICdjb252MjU2XzEnKTtcclxuICAgIHZhciBjb252MjU2XzIgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyg1ODk4MjQsIDI1NiwgMywgJ2NvbnYyNTZfMicpO1xyXG4gICAgdmFyIGNvbnYyNTZfZG93bl9vdXQgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyg1ODk4MjQsIDI1NiwgMywgJ2NvbnYyNTZfZG93bl9vdXQnKTtcclxuICAgIHZhciBmYyA9IHRmLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGYudHJhbnNwb3NlKHRmLnRlbnNvcjJkKGV4dHJhY3RXZWlnaHRzKDI1NiAqIDEyOCksIFsxMjgsIDI1Nl0pLCBbMSwgMF0pOyB9KTtcclxuICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogXCJmY1wiIH0pO1xyXG4gICAgaWYgKGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogXCIgKyBnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgY29udjMyX2Rvd246IGNvbnYzMl9kb3duLFxyXG4gICAgICAgIGNvbnYzMl8xOiBjb252MzJfMSxcclxuICAgICAgICBjb252MzJfMjogY29udjMyXzIsXHJcbiAgICAgICAgY29udjMyXzM6IGNvbnYzMl8zLFxyXG4gICAgICAgIGNvbnY2NF9kb3duOiBjb252NjRfZG93bixcclxuICAgICAgICBjb252NjRfMTogY29udjY0XzEsXHJcbiAgICAgICAgY29udjY0XzI6IGNvbnY2NF8yLFxyXG4gICAgICAgIGNvbnY2NF8zOiBjb252NjRfMyxcclxuICAgICAgICBjb252MTI4X2Rvd246IGNvbnYxMjhfZG93bixcclxuICAgICAgICBjb252MTI4XzE6IGNvbnYxMjhfMSxcclxuICAgICAgICBjb252MTI4XzI6IGNvbnYxMjhfMixcclxuICAgICAgICBjb252MjU2X2Rvd246IGNvbnYyNTZfZG93bixcclxuICAgICAgICBjb252MjU2XzE6IGNvbnYyNTZfMSxcclxuICAgICAgICBjb252MjU2XzI6IGNvbnYyNTZfMixcclxuICAgICAgICBjb252MjU2X2Rvd25fb3V0OiBjb252MjU2X2Rvd25fb3V0LFxyXG4gICAgICAgIGZjOiBmY1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtcy5qcy5tYXAiLCJpbXBvcnQgeyBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycywgZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGlzVGVuc29yMkQgfSBmcm9tICcuLi91dGlscyc7XHJcbmZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgdmFyIGV4dHJhY3RXZWlnaHRFbnRyeSA9IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RTY2FsZUxheWVyUGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHZhciB3ZWlnaHRzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL3NjYWxlL3dlaWdodHNcIiwgMSk7XHJcbiAgICAgICAgdmFyIGJpYXNlcyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9zY2FsZS9iaWFzZXNcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgd2VpZ2h0czogd2VpZ2h0cywgYmlhc2VzOiBiaWFzZXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252TGF5ZXJQYXJhbXMocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvY29udi9maWx0ZXJzXCIsIDQpO1xyXG4gICAgICAgIHZhciBiaWFzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2NvbnYvYmlhc1wiLCAxKTtcclxuICAgICAgICB2YXIgc2NhbGUgPSBleHRyYWN0U2NhbGVMYXllclBhcmFtcyhwcmVmaXgpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnY6IHsgZmlsdGVyczogZmlsdGVycywgYmlhczogYmlhcyB9LCBzY2FsZTogc2NhbGUgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbnYxOiBleHRyYWN0Q29udkxheWVyUGFyYW1zKHByZWZpeCArIFwiL2NvbnYxXCIpLFxyXG4gICAgICAgICAgICBjb252MjogZXh0cmFjdENvbnZMYXllclBhcmFtcyhwcmVmaXggKyBcIi9jb252MlwiKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RDb252TGF5ZXJQYXJhbXM6IGV4dHJhY3RDb252TGF5ZXJQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXM6IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXApIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0b3JzRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpLCBleHRyYWN0Q29udkxheWVyUGFyYW1zID0gX2EuZXh0cmFjdENvbnZMYXllclBhcmFtcywgZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMgPSBfYS5leHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcztcclxuICAgIHZhciBjb252MzJfZG93biA9IGV4dHJhY3RDb252TGF5ZXJQYXJhbXMoJ2NvbnYzMl9kb3duJyk7XHJcbiAgICB2YXIgY29udjMyXzEgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjMyXzEnKTtcclxuICAgIHZhciBjb252MzJfMiA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252MzJfMicpO1xyXG4gICAgdmFyIGNvbnYzMl8zID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnYzMl8zJyk7XHJcbiAgICB2YXIgY29udjY0X2Rvd24gPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjY0X2Rvd24nKTtcclxuICAgIHZhciBjb252NjRfMSA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252NjRfMScpO1xyXG4gICAgdmFyIGNvbnY2NF8yID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnY2NF8yJyk7XHJcbiAgICB2YXIgY29udjY0XzMgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjY0XzMnKTtcclxuICAgIHZhciBjb252MTI4X2Rvd24gPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjEyOF9kb3duJyk7XHJcbiAgICB2YXIgY29udjEyOF8xID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnYxMjhfMScpO1xyXG4gICAgdmFyIGNvbnYxMjhfMiA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252MTI4XzInKTtcclxuICAgIHZhciBjb252MjU2X2Rvd24gPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjI1Nl9kb3duJyk7XHJcbiAgICB2YXIgY29udjI1Nl8xID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnYyNTZfMScpO1xyXG4gICAgdmFyIGNvbnYyNTZfMiA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252MjU2XzInKTtcclxuICAgIHZhciBjb252MjU2X2Rvd25fb3V0ID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnYyNTZfZG93bl9vdXQnKTtcclxuICAgIHZhciBmYyA9IHdlaWdodE1hcFsnZmMnXTtcclxuICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IG9yaWdpbmFsUGF0aDogJ2ZjJywgcGFyYW1QYXRoOiAnZmMnIH0pO1xyXG4gICAgaWYgKCFpc1RlbnNvcjJEKGZjKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHdlaWdodE1hcFtmY10gdG8gYmUgYSBUZW5zb3IyRCwgaW5zdGVhZCBoYXZlIFwiICsgZmMpO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICBjb252MzJfZG93bjogY29udjMyX2Rvd24sXHJcbiAgICAgICAgY29udjMyXzE6IGNvbnYzMl8xLFxyXG4gICAgICAgIGNvbnYzMl8yOiBjb252MzJfMixcclxuICAgICAgICBjb252MzJfMzogY29udjMyXzMsXHJcbiAgICAgICAgY29udjY0X2Rvd246IGNvbnY2NF9kb3duLFxyXG4gICAgICAgIGNvbnY2NF8xOiBjb252NjRfMSxcclxuICAgICAgICBjb252NjRfMjogY29udjY0XzIsXHJcbiAgICAgICAgY29udjY0XzM6IGNvbnY2NF8zLFxyXG4gICAgICAgIGNvbnYxMjhfZG93bjogY29udjEyOF9kb3duLFxyXG4gICAgICAgIGNvbnYxMjhfMTogY29udjEyOF8xLFxyXG4gICAgICAgIGNvbnYxMjhfMjogY29udjEyOF8yLFxyXG4gICAgICAgIGNvbnYyNTZfZG93bjogY29udjI1Nl9kb3duLFxyXG4gICAgICAgIGNvbnYyNTZfMTogY29udjI1Nl8xLFxyXG4gICAgICAgIGNvbnYyNTZfMjogY29udjI1Nl8yLFxyXG4gICAgICAgIGNvbnYyNTZfZG93bl9vdXQ6IGNvbnYyNTZfZG93bl9vdXQsXHJcbiAgICAgICAgZmM6IGZjXHJcbiAgICB9O1xyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMubWFwIiwiaW1wb3J0IHsgRmFjZVJlY29nbml0aW9uTmV0IH0gZnJvbSAnLi9GYWNlUmVjb2duaXRpb25OZXQnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VSZWNvZ25pdGlvbk5ldCc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGYWNlUmVjb2duaXRpb25OZXQod2VpZ2h0cykge1xyXG4gICAgdmFyIG5ldCA9IG5ldyBGYWNlUmVjb2duaXRpb25OZXQoKTtcclxuICAgIG5ldC5leHRyYWN0V2VpZ2h0cyh3ZWlnaHRzKTtcclxuICAgIHJldHVybiBuZXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgX19zcHJlYWRBcnJheXMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgY29udiwgY29udkRvd24sIGNvbnZOb1JlbHUgfSBmcm9tICcuL2NvbnZMYXllcic7XHJcbmV4cG9ydCBmdW5jdGlvbiByZXNpZHVhbCh4LCBwYXJhbXMpIHtcclxuICAgIHZhciBvdXQgPSBjb252KHgsIHBhcmFtcy5jb252MSk7XHJcbiAgICBvdXQgPSBjb252Tm9SZWx1KG91dCwgcGFyYW1zLmNvbnYyKTtcclxuICAgIG91dCA9IHRmLmFkZChvdXQsIHgpO1xyXG4gICAgb3V0ID0gdGYucmVsdShvdXQpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmVzaWR1YWxEb3duKHgsIHBhcmFtcykge1xyXG4gICAgdmFyIG91dCA9IGNvbnZEb3duKHgsIHBhcmFtcy5jb252MSk7XHJcbiAgICBvdXQgPSBjb252Tm9SZWx1KG91dCwgcGFyYW1zLmNvbnYyKTtcclxuICAgIHZhciBwb29sZWQgPSB0Zi5hdmdQb29sKHgsIDIsIDIsICd2YWxpZCcpO1xyXG4gICAgdmFyIHplcm9zID0gdGYuemVyb3MocG9vbGVkLnNoYXBlKTtcclxuICAgIHZhciBpc1BhZCA9IHBvb2xlZC5zaGFwZVszXSAhPT0gb3V0LnNoYXBlWzNdO1xyXG4gICAgdmFyIGlzQWRqdXN0U2hhcGUgPSBwb29sZWQuc2hhcGVbMV0gIT09IG91dC5zaGFwZVsxXSB8fCBwb29sZWQuc2hhcGVbMl0gIT09IG91dC5zaGFwZVsyXTtcclxuICAgIGlmIChpc0FkanVzdFNoYXBlKSB7XHJcbiAgICAgICAgdmFyIHBhZFNoYXBlWCA9IF9fc3ByZWFkQXJyYXlzKG91dC5zaGFwZSk7XHJcbiAgICAgICAgcGFkU2hhcGVYWzFdID0gMTtcclxuICAgICAgICB2YXIgemVyb3NXID0gdGYuemVyb3MocGFkU2hhcGVYKTtcclxuICAgICAgICBvdXQgPSB0Zi5jb25jYXQoW291dCwgemVyb3NXXSwgMSk7XHJcbiAgICAgICAgdmFyIHBhZFNoYXBlWSA9IF9fc3ByZWFkQXJyYXlzKG91dC5zaGFwZSk7XHJcbiAgICAgICAgcGFkU2hhcGVZWzJdID0gMTtcclxuICAgICAgICB2YXIgemVyb3NIID0gdGYuemVyb3MocGFkU2hhcGVZKTtcclxuICAgICAgICBvdXQgPSB0Zi5jb25jYXQoW291dCwgemVyb3NIXSwgMik7XHJcbiAgICB9XHJcbiAgICBwb29sZWQgPSBpc1BhZCA/IHRmLmNvbmNhdChbcG9vbGVkLCB6ZXJvc10sIDMpIDogcG9vbGVkO1xyXG4gICAgb3V0ID0gdGYuYWRkKHBvb2xlZCwgb3V0KTtcclxuICAgIG91dCA9IHRmLnJlbHUob3V0KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaWR1YWxMYXllci5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoeCwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdGYuYWRkKHRmLm11bCh4LCBwYXJhbXMud2VpZ2h0cyksIHBhcmFtcy5iaWFzZXMpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjYWxlTGF5ZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGlzV2l0aEFnZShvYmopIHtcclxuICAgIHJldHVybiB0eXBlb2Ygb2JqWydhZ2UnXSA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFdpdGhBZ2Uoc291cmNlT2JqLCBhZ2UpIHtcclxuICAgIHZhciBleHRlbnNpb24gPSB7IGFnZTogYWdlIH07XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlT2JqLCBleHRlbnNpb24pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhBZ2UuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFdpdGhGYWNlRGVzY3JpcHRvcihzb3VyY2VPYmosIGRlc2NyaXB0b3IpIHtcclxuICAgIHZhciBleHRlbnNpb24gPSB7IGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IgfTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VPYmosIGV4dGVuc2lvbik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2l0aEZhY2VEZXNjcmlwdG9yLmpzLm1hcCIsImltcG9ydCB7IEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzL0ZhY2VEZXRlY3Rpb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXaXRoRmFjZURldGVjdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmpbJ2RldGVjdGlvbiddIGluc3RhbmNlb2YgRmFjZURldGVjdGlvbjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oc291cmNlT2JqLCBkZXRlY3Rpb24pIHtcclxuICAgIHZhciBleHRlbnNpb24gPSB7IGRldGVjdGlvbjogZGV0ZWN0aW9uIH07XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlT2JqLCBleHRlbnNpb24pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhGYWNlRGV0ZWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IEZhY2VFeHByZXNzaW9ucyB9IGZyb20gJy4uL2ZhY2VFeHByZXNzaW9uTmV0L0ZhY2VFeHByZXNzaW9ucyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dpdGhGYWNlRXhwcmVzc2lvbnMob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqWydleHByZXNzaW9ucyddIGluc3RhbmNlb2YgRmFjZUV4cHJlc3Npb25zO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRXaXRoRmFjZUV4cHJlc3Npb25zKHNvdXJjZU9iaiwgZXhwcmVzc2lvbnMpIHtcclxuICAgIHZhciBleHRlbnNpb24gPSB7IGV4cHJlc3Npb25zOiBleHByZXNzaW9ucyB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZU9iaiwgZXh0ZW5zaW9uKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaXRoRmFjZUV4cHJlc3Npb25zLmpzLm1hcCIsImltcG9ydCB7IEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzL0ZhY2VEZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyBGYWNlTGFuZG1hcmtzIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlTGFuZG1hcmtzJztcclxuaW1wb3J0IHsgaXNXaXRoRmFjZURldGVjdGlvbiB9IGZyb20gJy4vV2l0aEZhY2VEZXRlY3Rpb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXaXRoRmFjZUxhbmRtYXJrcyhvYmopIHtcclxuICAgIHJldHVybiBpc1dpdGhGYWNlRGV0ZWN0aW9uKG9iailcclxuICAgICAgICAmJiBvYmpbJ2xhbmRtYXJrcyddIGluc3RhbmNlb2YgRmFjZUxhbmRtYXJrc1xyXG4gICAgICAgICYmIG9ialsndW5zaGlmdGVkTGFuZG1hcmtzJ10gaW5zdGFuY2VvZiBGYWNlTGFuZG1hcmtzXHJcbiAgICAgICAgJiYgb2JqWydhbGlnbmVkUmVjdCddIGluc3RhbmNlb2YgRmFjZURldGVjdGlvbjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kV2l0aEZhY2VMYW5kbWFya3Moc291cmNlT2JqLCB1bnNoaWZ0ZWRMYW5kbWFya3MpIHtcclxuICAgIHZhciBzaGlmdCA9IHNvdXJjZU9iai5kZXRlY3Rpb24uYm94O1xyXG4gICAgdmFyIGxhbmRtYXJrcyA9IHVuc2hpZnRlZExhbmRtYXJrcy5zaGlmdEJ5KHNoaWZ0LngsIHNoaWZ0LnkpO1xyXG4gICAgdmFyIHJlY3QgPSBsYW5kbWFya3MuYWxpZ24oKTtcclxuICAgIHZhciBpbWFnZURpbXMgPSBzb3VyY2VPYmouZGV0ZWN0aW9uLmltYWdlRGltcztcclxuICAgIHZhciBhbGlnbmVkUmVjdCA9IG5ldyBGYWNlRGV0ZWN0aW9uKHNvdXJjZU9iai5kZXRlY3Rpb24uc2NvcmUsIHJlY3QucmVzY2FsZShpbWFnZURpbXMucmV2ZXJzZSgpKSwgaW1hZ2VEaW1zKTtcclxuICAgIHZhciBleHRlbnNpb24gPSB7XHJcbiAgICAgICAgbGFuZG1hcmtzOiBsYW5kbWFya3MsXHJcbiAgICAgICAgdW5zaGlmdGVkTGFuZG1hcmtzOiB1bnNoaWZ0ZWRMYW5kbWFya3MsXHJcbiAgICAgICAgYWxpZ25lZFJlY3Q6IGFsaWduZWRSZWN0XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZU9iaiwgZXh0ZW5zaW9uKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaXRoRmFjZUxhbmRtYXJrcy5qcy5tYXAiLCJpbXBvcnQgeyBHZW5kZXIgfSBmcm9tICcuLi9hZ2VHZW5kZXJOZXQvdHlwZXMnO1xyXG5pbXBvcnQgeyBpc1ZhbGlkUHJvYmFibGl0aXkgfSBmcm9tICcuLi91dGlscyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dpdGhHZW5kZXIob2JqKSB7XHJcbiAgICByZXR1cm4gKG9ialsnZ2VuZGVyJ10gPT09IEdlbmRlci5NQUxFIHx8IG9ialsnZ2VuZGVyJ10gPT09IEdlbmRlci5GRU1BTEUpXHJcbiAgICAgICAgJiYgaXNWYWxpZFByb2JhYmxpdGl5KG9ialsnZ2VuZGVyUHJvYmFiaWxpdHknXSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFdpdGhHZW5kZXIoc291cmNlT2JqLCBnZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5KSB7XHJcbiAgICB2YXIgZXh0ZW5zaW9uID0geyBnZW5kZXI6IGdlbmRlciwgZ2VuZGVyUHJvYmFiaWxpdHk6IGdlbmRlclByb2JhYmlsaXR5IH07XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlT2JqLCBleHRlbnNpb24pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhHZW5kZXIuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9XaXRoRmFjZURlc2NyaXB0b3InO1xyXG5leHBvcnQgKiBmcm9tICcuL1dpdGhGYWNlRGV0ZWN0aW9uJztcclxuZXhwb3J0ICogZnJvbSAnLi9XaXRoRmFjZUV4cHJlc3Npb25zJztcclxuZXhwb3J0ICogZnJvbSAnLi9XaXRoRmFjZUxhbmRtYXJrcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vV2l0aEFnZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vV2l0aEdlbmRlcic7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxudmFyIENvbXBvc2FibGVUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tcG9zYWJsZVRhc2soKSB7XHJcbiAgICB9XHJcbiAgICBDb21wb3NhYmxlVGFzay5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbmZ1bGZpbGxlZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG9uZnVsZmlsbGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJ1bigpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh2b2lkIDAsIFtfYi5zZW50KCldKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENvbXBvc2FibGVUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvc2FibGVUYXNrIC0gcnVuIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcG9zYWJsZVRhc2s7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IENvbXBvc2FibGVUYXNrIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2FibGVUYXNrLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBleHRlbmRXaXRoRmFjZURlc2NyaXB0b3IgfSBmcm9tICcuLi9mYWN0b3JpZXMvV2l0aEZhY2VEZXNjcmlwdG9yJztcclxuaW1wb3J0IHsgQ29tcG9zYWJsZVRhc2sgfSBmcm9tICcuL0NvbXBvc2FibGVUYXNrJztcclxuaW1wb3J0IHsgZXh0cmFjdEFsbEZhY2VzQW5kQ29tcHV0ZVJlc3VsdHMsIGV4dHJhY3RTaW5nbGVGYWNlQW5kQ29tcHV0ZVJlc3VsdCB9IGZyb20gJy4vZXh0cmFjdEZhY2VzQW5kQ29tcHV0ZVJlc3VsdHMnO1xyXG5pbXBvcnQgeyBuZXRzIH0gZnJvbSAnLi9uZXRzJztcclxuaW1wb3J0IHsgUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaywgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaywgfSBmcm9tICcuL1ByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrJztcclxuaW1wb3J0IHsgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaywgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaywgfSBmcm9tICcuL1ByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrJztcclxudmFyIENvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb21wdXRlRmFjZURlc2NyaXB0b3JzVGFza0Jhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb21wdXRlRmFjZURlc2NyaXB0b3JzVGFza0Jhc2UocGFyZW50VGFzaywgaW5wdXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnBhcmVudFRhc2sgPSBwYXJlbnRUYXNrO1xyXG4gICAgICAgIF90aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrQmFzZTtcclxufShDb21wb3NhYmxlVGFzaykpO1xyXG5leHBvcnQgeyBDb21wdXRlRmFjZURlc2NyaXB0b3JzVGFza0Jhc2UgfTtcclxudmFyIENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZXN1bHRzLCBkZXNjcmlwdG9ycztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wYXJlbnRUYXNrXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlc3VsdHMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RBbGxGYWNlc0FuZENvbXB1dGVSZXN1bHRzKHBhcmVudFJlc3VsdHMsIHRoaXMuaW5wdXQsIGZ1bmN0aW9uIChmYWNlcykgeyByZXR1cm4gUHJvbWlzZS5hbGwoZmFjZXMubWFwKGZ1bmN0aW9uIChmYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHMuZmFjZVJlY29nbml0aW9uTmV0LmNvbXB1dGVGYWNlRGVzY3JpcHRvcihmYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTsgfSwgbnVsbCwgZnVuY3Rpb24gKHBhcmVudFJlc3VsdCkgeyByZXR1cm4gcGFyZW50UmVzdWx0LmxhbmRtYXJrcy5hbGlnbihudWxsLCB7IHVzZURsaWJBbGlnbm1lbnQ6IHRydWUgfSk7IH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGVzY3JpcHRvcnMubWFwKGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBpKSB7IHJldHVybiBleHRlbmRXaXRoRmFjZURlc2NyaXB0b3IocGFyZW50UmVzdWx0c1tpXSwgZGVzY3JpcHRvcik7IH0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2sucHJvdG90eXBlLndpdGhGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrLnByb3RvdHlwZS53aXRoQWdlQW5kR2VuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2s7XHJcbn0oQ29tcHV0ZUZhY2VEZXNjcmlwdG9yc1Rhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrIH07XHJcbnZhciBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZXN1bHQsIGRlc2NyaXB0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGFyZW50VGFza107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZXN1bHQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50UmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdFNpbmdsZUZhY2VBbmRDb21wdXRlUmVzdWx0KHBhcmVudFJlc3VsdCwgdGhpcy5pbnB1dCwgZnVuY3Rpb24gKGZhY2UpIHsgcmV0dXJuIG5ldHMuZmFjZVJlY29nbml0aW9uTmV0LmNvbXB1dGVGYWNlRGVzY3JpcHRvcihmYWNlKTsgfSwgbnVsbCwgZnVuY3Rpb24gKHBhcmVudFJlc3VsdCkgeyByZXR1cm4gcGFyZW50UmVzdWx0LmxhbmRtYXJrcy5hbGlnbihudWxsLCB7IHVzZURsaWJBbGlnbm1lbnQ6IHRydWUgfSk7IH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleHRlbmRXaXRoRmFjZURlc2NyaXB0b3IocGFyZW50UmVzdWx0LCBkZXNjcmlwdG9yKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sucHJvdG90eXBlLndpdGhGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrO1xyXG59KENvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrQmFzZSkpO1xyXG5leHBvcnQgeyBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZXh0cmFjdEZhY2VzLCBleHRyYWN0RmFjZVRlbnNvcnMgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBleHRlbmRXaXRoRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4uL2ZhY3Rvcmllcy9XaXRoRmFjZUxhbmRtYXJrcyc7XHJcbmltcG9ydCB7IENvbXBvc2FibGVUYXNrIH0gZnJvbSAnLi9Db21wb3NhYmxlVGFzayc7XHJcbmltcG9ydCB7IENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrLCBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrIH0gZnJvbSAnLi9Db21wdXRlRmFjZURlc2NyaXB0b3JzVGFza3MnO1xyXG5pbXBvcnQgeyBuZXRzIH0gZnJvbSAnLi9uZXRzJztcclxuaW1wb3J0IHsgUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaywgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaywgfSBmcm9tICcuL1ByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrJztcclxuaW1wb3J0IHsgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaywgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaywgfSBmcm9tICcuL1ByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrJztcclxudmFyIERldGVjdEZhY2VMYW5kbWFya3NUYXNrQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZXRlY3RGYWNlTGFuZG1hcmtzVGFza0Jhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZXRlY3RGYWNlTGFuZG1hcmtzVGFza0Jhc2UocGFyZW50VGFzaywgaW5wdXQsIHVzZVRpbnlMYW5kbWFya05ldCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucGFyZW50VGFzayA9IHBhcmVudFRhc2s7XHJcbiAgICAgICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcclxuICAgICAgICBfdGhpcy51c2VUaW55TGFuZG1hcmtOZXQgPSB1c2VUaW55TGFuZG1hcmtOZXQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldGVjdEZhY2VMYW5kbWFya3NUYXNrQmFzZS5wcm90b3R5cGUsIFwibGFuZG1hcmtOZXRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2VUaW55TGFuZG1hcmtOZXRcclxuICAgICAgICAgICAgICAgID8gbmV0cy5mYWNlTGFuZG1hcms2OFRpbnlOZXRcclxuICAgICAgICAgICAgICAgIDogbmV0cy5mYWNlTGFuZG1hcms2OE5ldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEZXRlY3RGYWNlTGFuZG1hcmtzVGFza0Jhc2U7XHJcbn0oQ29tcG9zYWJsZVRhc2spKTtcclxuZXhwb3J0IHsgRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tCYXNlIH07XHJcbnZhciBEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVzdWx0cywgZGV0ZWN0aW9ucywgZmFjZXMsIF9hLCBmYWNlTGFuZG1hcmtzQnlGYWNlO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBhcmVudFRhc2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVzdWx0cyA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0aW9ucyA9IHBhcmVudFJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5kZXRlY3Rpb247IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLmlucHV0IGluc3RhbmNlb2YgdGYuVGVuc29yKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RGYWNlVGVuc29ycyh0aGlzLmlucHV0LCBkZXRlY3Rpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0RmFjZXModGhpcy5pbnB1dCwgZGV0ZWN0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VzID0gX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKGZhY2VzLm1hcChmdW5jdGlvbiAoZmFjZSkgeyByZXR1cm4gX3RoaXMubGFuZG1hcmtOZXQuZGV0ZWN0TGFuZG1hcmtzKGZhY2UpOyB9KSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUxhbmRtYXJrc0J5RmFjZSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXMuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gZiBpbnN0YW5jZW9mIHRmLlRlbnNvciAmJiBmLmRpc3Bvc2UoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwYXJlbnRSZXN1bHRzLm1hcChmdW5jdGlvbiAocGFyZW50UmVzdWx0LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFdpdGhGYWNlTGFuZG1hcmtzKHBhcmVudFJlc3VsdCwgZmFjZUxhbmRtYXJrc0J5RmFjZVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzay5wcm90b3R5cGUud2l0aEFnZUFuZEdlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0QWxsRmFjZUxhbmRtYXJrc1Rhc2sucHJvdG90eXBlLndpdGhGYWNlRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGV0ZWN0QWxsRmFjZUxhbmRtYXJrc1Rhc2s7XHJcbn0oRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrIH07XHJcbnZhciBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERldGVjdFNpbmdsZUZhY2VMYW5kbWFya3NUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIERldGVjdFNpbmdsZUZhY2VMYW5kbWFya3NUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVzdWx0LCBkZXRlY3Rpb24sIGZhY2VzLCBfYSwgbGFuZG1hcmtzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBhcmVudFRhc2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVzdWx0ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGlvbiA9IHBhcmVudFJlc3VsdC5kZXRlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuaW5wdXQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdEZhY2VUZW5zb3JzKHRoaXMuaW5wdXQsIFtkZXRlY3Rpb25dKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0RmFjZXModGhpcy5pbnB1dCwgW2RldGVjdGlvbl0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlcyA9IF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmxhbmRtYXJrTmV0LmRldGVjdExhbmRtYXJrcyhmYWNlc1swXSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZG1hcmtzID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmIGluc3RhbmNlb2YgdGYuVGVuc29yICYmIGYuZGlzcG9zZSgpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV4dGVuZFdpdGhGYWNlTGFuZG1hcmtzKHBhcmVudFJlc3VsdCwgbGFuZG1hcmtzKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERldGVjdFNpbmdsZUZhY2VMYW5kbWFya3NUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzay5wcm90b3R5cGUud2l0aEFnZUFuZEdlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0U2luZ2xlRmFjZUxhbmRtYXJrc1Rhc2sucHJvdG90eXBlLndpdGhGYWNlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERldGVjdFNpbmdsZUZhY2VMYW5kbWFya3NUYXNrO1xyXG59KERldGVjdEZhY2VMYW5kbWFya3NUYXNrQmFzZSkpO1xyXG5leHBvcnQgeyBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzayB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXRlY3RGYWNlTGFuZG1hcmtzVGFza3MuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhGYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgTXRjbm5PcHRpb25zIH0gZnJvbSAnLi4vbXRjbm4vTXRjbm5PcHRpb25zJztcclxuaW1wb3J0IHsgU3NkTW9iaWxlbmV0djFPcHRpb25zIH0gZnJvbSAnLi4vc3NkTW9iaWxlbmV0djEvU3NkTW9iaWxlbmV0djFPcHRpb25zJztcclxuaW1wb3J0IHsgVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMgfSBmcm9tICcuLi90aW55RmFjZURldGVjdG9yL1RpbnlGYWNlRGV0ZWN0b3JPcHRpb25zJztcclxuaW1wb3J0IHsgVGlueVlvbG92Mk9wdGlvbnMgfSBmcm9tICcuLi90aW55WW9sb3YyJztcclxuaW1wb3J0IHsgQ29tcG9zYWJsZVRhc2sgfSBmcm9tICcuL0NvbXBvc2FibGVUYXNrJztcclxuaW1wb3J0IHsgRGV0ZWN0QWxsRmFjZUxhbmRtYXJrc1Rhc2ssIERldGVjdFNpbmdsZUZhY2VMYW5kbWFya3NUYXNrIH0gZnJvbSAnLi9EZXRlY3RGYWNlTGFuZG1hcmtzVGFza3MnO1xyXG5pbXBvcnQgeyBuZXRzIH0gZnJvbSAnLi9uZXRzJztcclxuaW1wb3J0IHsgUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2ssIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrIH0gZnJvbSAnLi9QcmVkaWN0QWdlQW5kR2VuZGVyVGFzayc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrLCBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zVGFzayB9IGZyb20gJy4vUHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2snO1xyXG52YXIgRGV0ZWN0RmFjZXNUYXNrQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZXRlY3RGYWNlc1Rhc2tCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGV0ZWN0RmFjZXNUYXNrQmFzZShpbnB1dCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG5ldyBTc2RNb2JpbGVuZXR2MU9wdGlvbnMoKTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRGV0ZWN0RmFjZXNUYXNrQmFzZTtcclxufShDb21wb3NhYmxlVGFzaykpO1xyXG5leHBvcnQgeyBEZXRlY3RGYWNlc1Rhc2tCYXNlIH07XHJcbnZhciBEZXRlY3RBbGxGYWNlc1Rhc2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGV0ZWN0QWxsRmFjZXNUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGV0ZWN0QWxsRmFjZXNUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIERldGVjdEFsbEZhY2VzVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBpbnB1dCwgb3B0aW9ucywgZmFjZURldGVjdGlvbkZ1bmN0aW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMsIGlucHV0ID0gX2EuaW5wdXQsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvcHRpb25zIGluc3RhbmNlb2YgTXRjbm5PcHRpb25zKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldHMubXRjbm4uZm9yd2FyZChpbnB1dCwgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYi5zZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kZXRlY3Rpb247IH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VEZXRlY3Rpb25GdW5jdGlvbiA9IG9wdGlvbnMgaW5zdGFuY2VvZiBUaW55RmFjZURldGVjdG9yT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG5ldHMudGlueUZhY2VEZXRlY3Rvci5sb2NhdGVGYWNlcyhpbnB1dCwgb3B0aW9ucyk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKG9wdGlvbnMgaW5zdGFuY2VvZiBTc2RNb2JpbGVuZXR2MU9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbmV0cy5zc2RNb2JpbGVuZXR2MS5sb2NhdGVGYWNlcyhpbnB1dCwgb3B0aW9ucyk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChvcHRpb25zIGluc3RhbmNlb2YgVGlueVlvbG92Mk9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG5ldHMudGlueVlvbG92Mi5sb2NhdGVGYWNlcyhpbnB1dCwgb3B0aW9ucyk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmFjZURldGVjdGlvbkZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RldGVjdEZhY2VzIC0gZXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBpbnN0YW5jZSBvZiBUaW55RmFjZURldGVjdG9yT3B0aW9ucyB8IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyB8IE10Y25uT3B0aW9ucyB8IFRpbnlZb2xvdjJPcHRpb25zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhY2VEZXRlY3Rpb25GdW5jdGlvbihpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RBbGxGYWNlc1Rhc2sucHJvdG90eXBlLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXRlY3Rpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJ1bigpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGlvbnMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXMoZGV0ZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGRldGVjdGlvbikgeyByZXR1cm4gZXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oe30sIGRldGVjdGlvbik7IH0pKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pOyB9KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RBbGxGYWNlc1Rhc2sucHJvdG90eXBlLndpdGhGYWNlTGFuZG1hcmtzID0gZnVuY3Rpb24gKHVzZVRpbnlMYW5kbWFya05ldCkge1xyXG4gICAgICAgIGlmICh1c2VUaW55TGFuZG1hcmtOZXQgPT09IHZvaWQgMCkgeyB1c2VUaW55TGFuZG1hcmtOZXQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRGV0ZWN0QWxsRmFjZUxhbmRtYXJrc1Rhc2sodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMoKSwgdGhpcy5pbnB1dCwgdXNlVGlueUxhbmRtYXJrTmV0KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RBbGxGYWNlc1Rhc2sucHJvdG90eXBlLndpdGhGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzayh0aGlzLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9ucygpLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RBbGxGYWNlc1Rhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzayh0aGlzLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9ucygpLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGV0ZWN0QWxsRmFjZXNUYXNrO1xyXG59KERldGVjdEZhY2VzVGFza0Jhc2UpKTtcclxuZXhwb3J0IHsgRGV0ZWN0QWxsRmFjZXNUYXNrIH07XHJcbnZhciBEZXRlY3RTaW5nbGVGYWNlVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZXRlY3RTaW5nbGVGYWNlVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERldGVjdFNpbmdsZUZhY2VUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIERldGVjdFNpbmdsZUZhY2VUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZmFjZURldGVjdGlvbnMsIGZhY2VEZXRlY3Rpb25XaXRoSGlnaGVzdFNjb3JlO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgRGV0ZWN0QWxsRmFjZXNUYXNrKHRoaXMuaW5wdXQsIHRoaXMub3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZURldGVjdGlvbnMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VEZXRlY3Rpb25XaXRoSGlnaGVzdFNjb3JlID0gZmFjZURldGVjdGlvbnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VEZXRlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGZhY2VEZXRlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWNlRGV0ZWN0aW9uLnNjb3JlID4gZmFjZURldGVjdGlvbldpdGhIaWdoZXN0U2NvcmUuc2NvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlRGV0ZWN0aW9uV2l0aEhpZ2hlc3RTY29yZSA9IGZhY2VEZXRlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFjZURldGVjdGlvbldpdGhIaWdoZXN0U2NvcmVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RTaW5nbGVGYWNlVGFzay5wcm90b3R5cGUucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGV0ZWN0aW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJ1bigpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGlvbiA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlcyhkZXRlY3Rpb24gPyBleHRlbmRXaXRoRmFjZURldGVjdGlvbih7fSwgZGV0ZWN0aW9uKSA6IHVuZGVmaW5lZCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0U2luZ2xlRmFjZVRhc2sucHJvdG90eXBlLndpdGhGYWNlTGFuZG1hcmtzID0gZnVuY3Rpb24gKHVzZVRpbnlMYW5kbWFya05ldCkge1xyXG4gICAgICAgIGlmICh1c2VUaW55TGFuZG1hcmtOZXQgPT09IHZvaWQgMCkgeyB1c2VUaW55TGFuZG1hcmtOZXQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRGV0ZWN0U2luZ2xlRmFjZUxhbmRtYXJrc1Rhc2sodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbigpLCB0aGlzLmlucHV0LCB1c2VUaW55TGFuZG1hcmtOZXQpO1xyXG4gICAgfTtcclxuICAgIERldGVjdFNpbmdsZUZhY2VUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2sodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbigpLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RTaW5nbGVGYWNlVGFzay5wcm90b3R5cGUud2l0aEFnZUFuZEdlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oKSwgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERldGVjdFNpbmdsZUZhY2VUYXNrO1xyXG59KERldGVjdEZhY2VzVGFza0Jhc2UpKTtcclxuZXhwb3J0IHsgRGV0ZWN0U2luZ2xlRmFjZVRhc2sgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGV0ZWN0RmFjZXNUYXNrcy5qcy5tYXAiLCJpbXBvcnQgeyBGYWNlTWF0Y2ggfSBmcm9tICcuLi9jbGFzc2VzL0ZhY2VNYXRjaCc7XHJcbmltcG9ydCB7IExhYmVsZWRGYWNlRGVzY3JpcHRvcnMgfSBmcm9tICcuLi9jbGFzc2VzL0xhYmVsZWRGYWNlRGVzY3JpcHRvcnMnO1xyXG5pbXBvcnQgeyBldWNsaWRlYW5EaXN0YW5jZSB9IGZyb20gJy4uL2V1Y2xpZGVhbkRpc3RhbmNlJztcclxudmFyIEZhY2VNYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmFjZU1hdGNoZXIoaW5wdXRzLCBkaXN0YW5jZVRocmVzaG9sZCkge1xyXG4gICAgICAgIGlmIChkaXN0YW5jZVRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IGRpc3RhbmNlVGhyZXNob2xkID0gMC42OyB9XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VUaHJlc2hvbGQgPSBkaXN0YW5jZVRocmVzaG9sZDtcclxuICAgICAgICB2YXIgaW5wdXRBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5wdXRzKSA/IGlucHV0cyA6IFtpbnB1dHNdO1xyXG4gICAgICAgIGlmICghaW5wdXRBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFjZVJlY29nbml6ZXIuY29uc3RydWN0b3IgLSBleHBlY3RlZCBhdGxlYXN0IG9uZSBpbnB1dFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMTtcclxuICAgICAgICB2YXIgY3JlYXRlVW5pcXVlTGFiZWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcInBlcnNvbiBcIiArIGNvdW50Kys7IH07XHJcbiAgICAgICAgdGhpcy5fbGFiZWxlZERlc2NyaXB0b3JzID0gaW5wdXRBcnJheS5tYXAoZnVuY3Rpb24gKGRlc2MpIHtcclxuICAgICAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBMYWJlbGVkRmFjZURlc2NyaXB0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMYWJlbGVkRmFjZURlc2NyaXB0b3JzKGNyZWF0ZVVuaXF1ZUxhYmVsKCksIFtkZXNjXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlc2MuZGVzY3JpcHRvciAmJiBkZXNjLmRlc2NyaXB0b3IgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyhjcmVhdGVVbmlxdWVMYWJlbCgpLCBbZGVzYy5kZXNjcmlwdG9yXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFjZVJlY29nbml6ZXIuY29uc3RydWN0b3IgLSBleHBlY3RlZCBpbnB1dHMgdG8gYmUgb2YgdHlwZSBMYWJlbGVkRmFjZURlc2NyaXB0b3JzIHwgV2l0aEZhY2VEZXNjcmlwdG9yPGFueT4gfCBGbG9hdDMyQXJyYXkgfCBBcnJheTxMYWJlbGVkRmFjZURlc2NyaXB0b3JzIHwgV2l0aEZhY2VEZXNjcmlwdG9yPGFueT4gfCBGbG9hdDMyQXJyYXk+XCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VNYXRjaGVyLnByb3RvdHlwZSwgXCJsYWJlbGVkRGVzY3JpcHRvcnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGFiZWxlZERlc2NyaXB0b3JzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTWF0Y2hlci5wcm90b3R5cGUsIFwiZGlzdGFuY2VUaHJlc2hvbGRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzdGFuY2VUaHJlc2hvbGQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRmFjZU1hdGNoZXIucHJvdG90eXBlLmNvbXB1dGVNZWFuRGlzdGFuY2UgPSBmdW5jdGlvbiAocXVlcnlEZXNjcmlwdG9yLCBkZXNjcmlwdG9ycykge1xyXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yc1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBldWNsaWRlYW5EaXN0YW5jZShkLCBxdWVyeURlc2NyaXB0b3IpOyB9KVxyXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChkMSwgZDIpIHsgcmV0dXJuIGQxICsgZDI7IH0sIDApXHJcbiAgICAgICAgICAgIC8gKGRlc2NyaXB0b3JzLmxlbmd0aCB8fCAxKTtcclxuICAgIH07XHJcbiAgICBGYWNlTWF0Y2hlci5wcm90b3R5cGUubWF0Y2hEZXNjcmlwdG9yID0gZnVuY3Rpb24gKHF1ZXJ5RGVzY3JpcHRvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxlZERlc2NyaXB0b3JzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9ycyA9IF9hLmRlc2NyaXB0b3JzLCBsYWJlbCA9IF9hLmxhYmVsO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhY2VNYXRjaChsYWJlbCwgX3RoaXMuY29tcHV0ZU1lYW5EaXN0YW5jZShxdWVyeURlc2NyaXB0b3IsIGRlc2NyaXB0b3JzKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYmVzdCwgY3VycikgeyByZXR1cm4gYmVzdC5kaXN0YW5jZSA8IGN1cnIuZGlzdGFuY2UgPyBiZXN0IDogY3VycjsgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZU1hdGNoZXIucHJvdG90eXBlLmZpbmRCZXN0TWF0Y2ggPSBmdW5jdGlvbiAocXVlcnlEZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgdmFyIGJlc3RNYXRjaCA9IHRoaXMubWF0Y2hEZXNjcmlwdG9yKHF1ZXJ5RGVzY3JpcHRvcik7XHJcbiAgICAgICAgcmV0dXJuIGJlc3RNYXRjaC5kaXN0YW5jZSA8IHRoaXMuZGlzdGFuY2VUaHJlc2hvbGRcclxuICAgICAgICAgICAgPyBiZXN0TWF0Y2hcclxuICAgICAgICAgICAgOiBuZXcgRmFjZU1hdGNoKCd1bmtub3duJywgYmVzdE1hdGNoLmRpc3RhbmNlKTtcclxuICAgIH07XHJcbiAgICBGYWNlTWF0Y2hlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlVGhyZXNob2xkOiB0aGlzLmRpc3RhbmNlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICBsYWJlbGVkRGVzY3JpcHRvcnM6IHRoaXMubGFiZWxlZERlc2NyaXB0b3JzLm1hcChmdW5jdGlvbiAobGQpIHsgcmV0dXJuIGxkLnRvSlNPTigpOyB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgRmFjZU1hdGNoZXIuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xyXG4gICAgICAgIHZhciBsYWJlbGVkRGVzY3JpcHRvcnMgPSBqc29uLmxhYmVsZWREZXNjcmlwdG9yc1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsZCkgeyByZXR1cm4gTGFiZWxlZEZhY2VEZXNjcmlwdG9ycy5mcm9tSlNPTihsZCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmFjZU1hdGNoZXIobGFiZWxlZERlc2NyaXB0b3JzLCBqc29uLmRpc3RhbmNlVGhyZXNob2xkKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZU1hdGNoZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEZhY2VNYXRjaGVyIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VNYXRjaGVyLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBleHRlbmRXaXRoQWdlIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhBZ2UnO1xyXG5pbXBvcnQgeyBleHRlbmRXaXRoR2VuZGVyIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhHZW5kZXInO1xyXG5pbXBvcnQgeyBDb21wb3NhYmxlVGFzayB9IGZyb20gJy4vQ29tcG9zYWJsZVRhc2snO1xyXG5pbXBvcnQgeyBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzaywgQ29tcHV0ZVNpbmdsZUZhY2VEZXNjcmlwdG9yVGFzayB9IGZyb20gJy4vQ29tcHV0ZUZhY2VEZXNjcmlwdG9yc1Rhc2tzJztcclxuaW1wb3J0IHsgZXh0cmFjdEFsbEZhY2VzQW5kQ29tcHV0ZVJlc3VsdHMsIGV4dHJhY3RTaW5nbGVGYWNlQW5kQ29tcHV0ZVJlc3VsdCB9IGZyb20gJy4vZXh0cmFjdEZhY2VzQW5kQ29tcHV0ZVJlc3VsdHMnO1xyXG5pbXBvcnQgeyBuZXRzIH0gZnJvbSAnLi9uZXRzJztcclxuaW1wb3J0IHsgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2ssIFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2ssIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrLCBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLCB9IGZyb20gJy4vUHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2snO1xyXG52YXIgUHJlZGljdEFnZUFuZEdlbmRlclRhc2tCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrQmFzZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrQmFzZShwYXJlbnRUYXNrLCBpbnB1dCwgZXh0cmFjdGVkRmFjZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnBhcmVudFRhc2sgPSBwYXJlbnRUYXNrO1xyXG4gICAgICAgIF90aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgX3RoaXMuZXh0cmFjdGVkRmFjZXMgPSBleHRyYWN0ZWRGYWNlcztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJlZGljdEFnZUFuZEdlbmRlclRhc2tCYXNlO1xyXG59KENvbXBvc2FibGVUYXNrKSk7XHJcbmV4cG9ydCB7IFByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrQmFzZSB9O1xyXG52YXIgUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFJlc3VsdHMsIGFnZUFuZEdlbmRlckJ5RmFjZTtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wYXJlbnRUYXNrXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlc3VsdHMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RBbGxGYWNlc0FuZENvbXB1dGVSZXN1bHRzKHBhcmVudFJlc3VsdHMsIHRoaXMuaW5wdXQsIGZ1bmN0aW9uIChmYWNlcykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChmYWNlcy5tYXAoZnVuY3Rpb24gKGZhY2UpIHsgcmV0dXJuIG5ldHMuYWdlR2VuZGVyTmV0LnByZWRpY3RBZ2VBbmRHZW5kZXIoZmFjZSk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgdGhpcy5leHRyYWN0ZWRGYWNlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlQW5kR2VuZGVyQnlGYWNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGFyZW50UmVzdWx0cy5tYXAoZnVuY3Rpb24gKHBhcmVudFJlc3VsdCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGFnZUFuZEdlbmRlckJ5RmFjZVtpXSwgYWdlID0gX2EuYWdlLCBnZW5kZXIgPSBfYS5nZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5ID0gX2EuZ2VuZGVyUHJvYmFiaWxpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFdpdGhBZ2UoZXh0ZW5kV2l0aEdlbmRlcihwYXJlbnRSZXN1bHQsIGdlbmRlciwgZ2VuZGVyUHJvYmFiaWxpdHkpLCBhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzay5wcm90b3R5cGUud2l0aEZhY2VFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzaztcclxufShQcmVkaWN0QWdlQW5kR2VuZGVyVGFza0Jhc2UpKTtcclxuZXhwb3J0IHsgUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2sgfTtcclxudmFyIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlclRhc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlclRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZXN1bHQsIF9hLCBhZ2UsIGdlbmRlciwgZ2VuZGVyUHJvYmFiaWxpdHk7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGFyZW50VGFza107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZXN1bHQgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50UmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdFNpbmdsZUZhY2VBbmRDb21wdXRlUmVzdWx0KHBhcmVudFJlc3VsdCwgdGhpcy5pbnB1dCwgZnVuY3Rpb24gKGZhY2UpIHsgcmV0dXJuIG5ldHMuYWdlR2VuZGVyTmV0LnByZWRpY3RBZ2VBbmRHZW5kZXIoZmFjZSk7IH0sIHRoaXMuZXh0cmFjdGVkRmFjZXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpLCBhZ2UgPSBfYS5hZ2UsIGdlbmRlciA9IF9hLmdlbmRlciwgZ2VuZGVyUHJvYmFiaWxpdHkgPSBfYS5nZW5kZXJQcm9iYWJpbGl0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV4dGVuZFdpdGhBZ2UoZXh0ZW5kV2l0aEdlbmRlcihwYXJlbnRSZXN1bHQsIGdlbmRlciwgZ2VuZGVyUHJvYmFiaWxpdHkpLCBhZ2UpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlclRhc2sucHJvdG90eXBlLndpdGhGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zVGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlclRhc2s7XHJcbn0oUHJlZGljdEFnZUFuZEdlbmRlclRhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrIH07XHJcbnZhciBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhGYWNlRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaztcclxufShQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzaykpO1xyXG5leHBvcnQgeyBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrIH07XHJcbnZhciBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhGYWNlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2s7XHJcbn0oUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlclRhc2spKTtcclxuZXhwb3J0IHsgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVkaWN0QWdlQW5kR2VuZGVyVGFzay5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgZXh0ZW5kV2l0aEZhY2VFeHByZXNzaW9ucyB9IGZyb20gJy4uL2ZhY3Rvcmllcy9XaXRoRmFjZUV4cHJlc3Npb25zJztcclxuaW1wb3J0IHsgQ29tcG9zYWJsZVRhc2sgfSBmcm9tICcuL0NvbXBvc2FibGVUYXNrJztcclxuaW1wb3J0IHsgQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2ssIENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sgfSBmcm9tICcuL0NvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RBbGxGYWNlc0FuZENvbXB1dGVSZXN1bHRzLCBleHRyYWN0U2luZ2xlRmFjZUFuZENvbXB1dGVSZXN1bHQgfSBmcm9tICcuL2V4dHJhY3RGYWNlc0FuZENvbXB1dGVSZXN1bHRzJztcclxuaW1wb3J0IHsgbmV0cyB9IGZyb20gJy4vbmV0cyc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJUYXNrLCBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrLCBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyVGFzaywgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaywgfSBmcm9tICcuL1ByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrJztcclxudmFyIFByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFza0Jhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFza0Jhc2UocGFyZW50VGFzaywgaW5wdXQsIGV4dHJhY3RlZEZhY2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wYXJlbnRUYXNrID0gcGFyZW50VGFzaztcclxuICAgICAgICBfdGhpcy5pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgIF90aGlzLmV4dHJhY3RlZEZhY2VzID0gZXh0cmFjdGVkRmFjZXM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrQmFzZTtcclxufShDb21wb3NhYmxlVGFzaykpO1xyXG5leHBvcnQgeyBQcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFza0Jhc2UgfTtcclxudmFyIFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZXN1bHRzLCBmYWNlRXhwcmVzc2lvbnNCeUZhY2U7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGFyZW50VGFza107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZXN1bHRzID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0QWxsRmFjZXNBbmRDb21wdXRlUmVzdWx0cyhwYXJlbnRSZXN1bHRzLCB0aGlzLmlucHV0LCBmdW5jdGlvbiAoZmFjZXMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoZmFjZXMubWFwKGZ1bmN0aW9uIChmYWNlKSB7IHJldHVybiBuZXRzLmZhY2VFeHByZXNzaW9uTmV0LnByZWRpY3RFeHByZXNzaW9ucyhmYWNlKTsgfSkpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9LCB0aGlzLmV4dHJhY3RlZEZhY2VzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlRXhwcmVzc2lvbnNCeUZhY2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwYXJlbnRSZXN1bHRzLm1hcChmdW5jdGlvbiAocGFyZW50UmVzdWx0LCBpKSB7IHJldHVybiBleHRlbmRXaXRoRmFjZUV4cHJlc3Npb25zKHBhcmVudFJlc3VsdCwgZmFjZUV4cHJlc3Npb25zQnlGYWNlW2ldKTsgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzay5wcm90b3R5cGUud2l0aEFnZUFuZEdlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzaztcclxufShQcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFza0Jhc2UpKTtcclxuZXhwb3J0IHsgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2sgfTtcclxudmFyIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZXN1bHQsIGZhY2VFeHByZXNzaW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wYXJlbnRUYXNrXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlc3VsdCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0U2luZ2xlRmFjZUFuZENvbXB1dGVSZXN1bHQocGFyZW50UmVzdWx0LCB0aGlzLmlucHV0LCBmdW5jdGlvbiAoZmFjZSkgeyByZXR1cm4gbmV0cy5mYWNlRXhwcmVzc2lvbk5ldC5wcmVkaWN0RXhwcmVzc2lvbnMoZmFjZSk7IH0sIHRoaXMuZXh0cmFjdGVkRmFjZXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VFeHByZXNzaW9ucyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV4dGVuZFdpdGhGYWNlRXhwcmVzc2lvbnMocGFyZW50UmVzdWx0LCBmYWNlRXhwcmVzc2lvbnMpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyVGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2s7XHJcbn0oUHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrIH07XHJcbnZhciBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhGYWNlRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaztcclxufShQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzaykpO1xyXG5leHBvcnQgeyBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrIH07XHJcbnZhciBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2sucHJvdG90eXBlLndpdGhGYWNlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2s7XHJcbn0oUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2spKTtcclxuZXhwb3J0IHsgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFzay5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IE10Y25uT3B0aW9ucyB9IGZyb20gJy4uL210Y25uL010Y25uT3B0aW9ucyc7XHJcbmltcG9ydCB7IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyB9IGZyb20gJy4uL3NzZE1vYmlsZW5ldHYxJztcclxuaW1wb3J0IHsgVGlueVlvbG92Mk9wdGlvbnMgfSBmcm9tICcuLi90aW55WW9sb3YyJztcclxuaW1wb3J0IHsgZGV0ZWN0QWxsRmFjZXMgfSBmcm9tICcuL2RldGVjdEZhY2VzJztcclxuLy8gZXhwb3J0IGFsbEZhY2VzIEFQSSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5leHBvcnQgZnVuY3Rpb24gYWxsRmFjZXNTc2RNb2JpbGVuZXR2MShpbnB1dCwgbWluQ29uZmlkZW5jZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWxsRmFjZXNTc2RNb2JpbGVuZXR2MSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbiwgdXNlIHRoZSBoaWdoIGxldmVsIGFwaSBpbnN0ZWFkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGV0ZWN0QWxsRmFjZXMoaW5wdXQsIG5ldyBTc2RNb2JpbGVuZXR2MU9wdGlvbnMobWluQ29uZmlkZW5jZSA/IHsgbWluQ29uZmlkZW5jZTogbWluQ29uZmlkZW5jZSB9IDoge30pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhGYWNlTGFuZG1hcmtzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRmFjZURlc2NyaXB0b3JzKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFsbEZhY2VzVGlueVlvbG92MihpbnB1dCwgZm9yd2FyZFBhcmFtcykge1xyXG4gICAgaWYgKGZvcndhcmRQYXJhbXMgPT09IHZvaWQgMCkgeyBmb3J3YXJkUGFyYW1zID0ge307IH1cclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FsbEZhY2VzVGlueVlvbG92MiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbiwgdXNlIHRoZSBoaWdoIGxldmVsIGFwaSBpbnN0ZWFkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGV0ZWN0QWxsRmFjZXMoaW5wdXQsIG5ldyBUaW55WW9sb3YyT3B0aW9ucyhmb3J3YXJkUGFyYW1zKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRmFjZUxhbmRtYXJrcygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEZhY2VEZXNjcmlwdG9ycygpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhbGxGYWNlc010Y25uKGlucHV0LCBmb3J3YXJkUGFyYW1zKSB7XHJcbiAgICBpZiAoZm9yd2FyZFBhcmFtcyA9PT0gdm9pZCAwKSB7IGZvcndhcmRQYXJhbXMgPSB7fTsgfVxyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWxsRmFjZXNNdGNubiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbiwgdXNlIHRoZSBoaWdoIGxldmVsIGFwaSBpbnN0ZWFkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGV0ZWN0QWxsRmFjZXMoaW5wdXQsIG5ldyBNdGNubk9wdGlvbnMoZm9yd2FyZFBhcmFtcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEZhY2VMYW5kbWFya3MoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhGYWNlRGVzY3JpcHRvcnMoKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnQgdmFyIGFsbEZhY2VzID0gYWxsRmFjZXNTc2RNb2JpbGVuZXR2MTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsRmFjZXMuanMubWFwIiwiaW1wb3J0IHsgU3NkTW9iaWxlbmV0djFPcHRpb25zIH0gZnJvbSAnLi4vc3NkTW9iaWxlbmV0djEvU3NkTW9iaWxlbmV0djFPcHRpb25zJztcclxuaW1wb3J0IHsgRGV0ZWN0QWxsRmFjZXNUYXNrLCBEZXRlY3RTaW5nbGVGYWNlVGFzayB9IGZyb20gJy4vRGV0ZWN0RmFjZXNUYXNrcyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RTaW5nbGVGYWNlKGlucHV0LCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBuZXcgU3NkTW9iaWxlbmV0djFPcHRpb25zKCk7IH1cclxuICAgIHJldHVybiBuZXcgRGV0ZWN0U2luZ2xlRmFjZVRhc2soaW5wdXQsIG9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RBbGxGYWNlcyhpbnB1dCwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbmV3IFNzZE1vYmlsZW5ldHYxT3B0aW9ucygpOyB9XHJcbiAgICByZXR1cm4gbmV3IERldGVjdEFsbEZhY2VzVGFzayhpbnB1dCwgb3B0aW9ucyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0RmFjZXMuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBleHRyYWN0RmFjZXMsIGV4dHJhY3RGYWNlVGVuc29ycyB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IGlzV2l0aEZhY2VMYW5kbWFya3MgfSBmcm9tICcuLi9mYWN0b3JpZXMvV2l0aEZhY2VMYW5kbWFya3MnO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEFsbEZhY2VzQW5kQ29tcHV0ZVJlc3VsdHMocGFyZW50UmVzdWx0cywgaW5wdXQsIGNvbXB1dGVSZXN1bHRzLCBleHRyYWN0ZWRGYWNlcywgZ2V0UmVjdEZvckFsaWdubWVudCkge1xyXG4gICAgaWYgKGdldFJlY3RGb3JBbGlnbm1lbnQgPT09IHZvaWQgMCkgeyBnZXRSZWN0Rm9yQWxpZ25tZW50ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGFsaWduZWRSZWN0ID0gX2EuYWxpZ25lZFJlY3Q7XHJcbiAgICAgICAgcmV0dXJuIGFsaWduZWRSZWN0O1xyXG4gICAgfTsgfVxyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmYWNlQm94ZXMsIGZhY2VzLCBfYSwgX2IsIHJlc3VsdHM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUJveGVzID0gcGFyZW50UmVzdWx0cy5tYXAoZnVuY3Rpb24gKHBhcmVudFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNXaXRoRmFjZUxhbmRtYXJrcyhwYXJlbnRSZXN1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdldFJlY3RGb3JBbGlnbm1lbnQocGFyZW50UmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnRSZXN1bHQuZGV0ZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gZXh0cmFjdGVkRmFjZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9hKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIHRmLlRlbnNvcikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RGYWNlVGVuc29ycyhpbnB1dCwgZmFjZUJveGVzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2IgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RGYWNlcyhpbnB1dCwgZmFjZUJveGVzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgX2IgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gKF9iKTtcclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZXMgPSBfYTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb21wdXRlUmVzdWx0cyhmYWNlcyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZXMuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gZiBpbnN0YW5jZW9mIHRmLlRlbnNvciAmJiBmLmRpc3Bvc2UoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdHNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFNpbmdsZUZhY2VBbmRDb21wdXRlUmVzdWx0KHBhcmVudFJlc3VsdCwgaW5wdXQsIGNvbXB1dGVSZXN1bHQsIGV4dHJhY3RlZEZhY2VzLCBnZXRSZWN0Rm9yQWxpZ25tZW50KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleHRyYWN0QWxsRmFjZXNBbmRDb21wdXRlUmVzdWx0cyhbcGFyZW50UmVzdWx0XSwgaW5wdXQsIGZ1bmN0aW9uIChmYWNlcykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNvbXB1dGVSZXN1bHQoZmFjZXNbMF0pXTtcclxuICAgICAgICAgICAgICAgIH0pOyB9KTsgfSwgZXh0cmFjdGVkRmFjZXMsIGdldFJlY3RGb3JBbGlnbm1lbnQpXTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RGYWNlc0FuZENvbXB1dGVSZXN1bHRzLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vYWxsRmFjZXMnO1xyXG5leHBvcnQgKiBmcm9tICcuL0NvbXBvc2FibGVUYXNrJztcclxuZXhwb3J0ICogZnJvbSAnLi9Db21wdXRlRmFjZURlc2NyaXB0b3JzVGFza3MnO1xyXG5leHBvcnQgKiBmcm9tICcuL2RldGVjdEZhY2VzJztcclxuZXhwb3J0ICogZnJvbSAnLi9EZXRlY3RGYWNlc1Rhc2tzJztcclxuZXhwb3J0ICogZnJvbSAnLi9EZXRlY3RGYWNlTGFuZG1hcmtzVGFza3MnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VNYXRjaGVyJztcclxuZXhwb3J0ICogZnJvbSAnLi9uZXRzJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgQWdlR2VuZGVyTmV0IH0gZnJvbSAnLi4vYWdlR2VuZGVyTmV0L0FnZUdlbmRlck5ldCc7XHJcbmltcG9ydCB7IEZhY2VFeHByZXNzaW9uTmV0IH0gZnJvbSAnLi4vZmFjZUV4cHJlc3Npb25OZXQvRmFjZUV4cHJlc3Npb25OZXQnO1xyXG5pbXBvcnQgeyBGYWNlTGFuZG1hcms2OE5ldCB9IGZyb20gJy4uL2ZhY2VMYW5kbWFya05ldC9GYWNlTGFuZG1hcms2OE5ldCc7XHJcbmltcG9ydCB7IEZhY2VMYW5kbWFyazY4VGlueU5ldCB9IGZyb20gJy4uL2ZhY2VMYW5kbWFya05ldC9GYWNlTGFuZG1hcms2OFRpbnlOZXQnO1xyXG5pbXBvcnQgeyBGYWNlUmVjb2duaXRpb25OZXQgfSBmcm9tICcuLi9mYWNlUmVjb2duaXRpb25OZXQvRmFjZVJlY29nbml0aW9uTmV0JztcclxuaW1wb3J0IHsgTXRjbm4gfSBmcm9tICcuLi9tdGNubi9NdGNubic7XHJcbmltcG9ydCB7IFNzZE1vYmlsZW5ldHYxIH0gZnJvbSAnLi4vc3NkTW9iaWxlbmV0djEvU3NkTW9iaWxlbmV0djEnO1xyXG5pbXBvcnQgeyBUaW55RmFjZURldGVjdG9yIH0gZnJvbSAnLi4vdGlueUZhY2VEZXRlY3Rvci9UaW55RmFjZURldGVjdG9yJztcclxuaW1wb3J0IHsgVGlueVlvbG92MiB9IGZyb20gJy4uL3RpbnlZb2xvdjInO1xyXG5leHBvcnQgdmFyIG5ldHMgPSB7XHJcbiAgICBzc2RNb2JpbGVuZXR2MTogbmV3IFNzZE1vYmlsZW5ldHYxKCksXHJcbiAgICB0aW55RmFjZURldGVjdG9yOiBuZXcgVGlueUZhY2VEZXRlY3RvcigpLFxyXG4gICAgdGlueVlvbG92MjogbmV3IFRpbnlZb2xvdjIoKSxcclxuICAgIG10Y25uOiBuZXcgTXRjbm4oKSxcclxuICAgIGZhY2VMYW5kbWFyazY4TmV0OiBuZXcgRmFjZUxhbmRtYXJrNjhOZXQoKSxcclxuICAgIGZhY2VMYW5kbWFyazY4VGlueU5ldDogbmV3IEZhY2VMYW5kbWFyazY4VGlueU5ldCgpLFxyXG4gICAgZmFjZVJlY29nbml0aW9uTmV0OiBuZXcgRmFjZVJlY29nbml0aW9uTmV0KCksXHJcbiAgICBmYWNlRXhwcmVzc2lvbk5ldDogbmV3IEZhY2VFeHByZXNzaW9uTmV0KCksXHJcbiAgICBhZ2VHZW5kZXJOZXQ6IG5ldyBBZ2VHZW5kZXJOZXQoKVxyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZGV0ZWN0IGFsbCBmYWNlcyBpbiBhbiBpbWFnZSB1c2luZyBTU0QgTW9iaWxlbmV0djEgTmV0d29yay5cclxuICpcclxuICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBpbWFnZS5cclxuICogQHBhcmFtIG9wdGlvbnMgKG9wdGlvbmFsLCBkZWZhdWx0OiBzZWUgU3NkTW9iaWxlbmV0djFPcHRpb25zIGNvbnN0cnVjdG9yIGZvciBkZWZhdWx0IHBhcmFtZXRlcnMpLlxyXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggb2YgZWFjaCBmYWNlIHdpdGggc2NvcmUuXHJcbiAqL1xyXG5leHBvcnQgdmFyIHNzZE1vYmlsZW5ldHYxID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV0cy5zc2RNb2JpbGVuZXR2MS5sb2NhdGVGYWNlcyhpbnB1dCwgb3B0aW9ucyk7XHJcbn07XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBkZXRlY3QgYWxsIGZhY2VzIGluIGFuIGltYWdlIHVzaW5nIHRoZSBUaW55IEZhY2UgRGV0ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgaW1hZ2UuXHJcbiAqIEBwYXJhbSBvcHRpb25zIChvcHRpb25hbCwgZGVmYXVsdDogc2VlIFRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zIGNvbnN0cnVjdG9yIGZvciBkZWZhdWx0IHBhcmFtZXRlcnMpLlxyXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggb2YgZWFjaCBmYWNlIHdpdGggc2NvcmUuXHJcbiAqL1xyXG5leHBvcnQgdmFyIHRpbnlGYWNlRGV0ZWN0b3IgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXRzLnRpbnlGYWNlRGV0ZWN0b3IubG9jYXRlRmFjZXMoaW5wdXQsIG9wdGlvbnMpO1xyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZGV0ZWN0IGFsbCBmYWNlcyBpbiBhbiBpbWFnZSB1c2luZyB0aGUgVGlueSBZb2xvdjIgTmV0d29yay5cclxuICpcclxuICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBpbWFnZS5cclxuICogQHBhcmFtIG9wdGlvbnMgKG9wdGlvbmFsLCBkZWZhdWx0OiBzZWUgVGlueVlvbG92Mk9wdGlvbnMgY29uc3RydWN0b3IgZm9yIGRlZmF1bHQgcGFyYW1ldGVycykuXHJcbiAqIEByZXR1cm5zIEJvdW5kaW5nIGJveCBvZiBlYWNoIGZhY2Ugd2l0aCBzY29yZS5cclxuICovXHJcbmV4cG9ydCB2YXIgdGlueVlvbG92MiA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldHMudGlueVlvbG92Mi5sb2NhdGVGYWNlcyhpbnB1dCwgb3B0aW9ucyk7XHJcbn07XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBkZXRlY3QgYWxsIGZhY2VzIGluIGFuIGltYWdlIGFuZCB0aGUgNSBwb2ludCBmYWNlIGxhbmRtYXJrc1xyXG4gKiBvZiBlYWNoIGRldGVjdGVkIGZhY2UgdXNpbmcgdGhlIE1UQ05OIE5ldHdvcmsuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgaW1hZ2UuXHJcbiAqIEBwYXJhbSBvcHRpb25zIChvcHRpb25hbCwgZGVmYXVsdDogc2VlIE10Y25uT3B0aW9ucyBjb25zdHJ1Y3RvciBmb3IgZGVmYXVsdCBwYXJhbWV0ZXJzKS5cclxuICogQHJldHVybnMgQm91bmRpbmcgYm94IG9mIGVhY2ggZmFjZSB3aXRoIHNjb3JlIGFuZCA1IHBvaW50IGZhY2UgbGFuZG1hcmtzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBtdGNubiA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldHMubXRjbm4uZm9yd2FyZChpbnB1dCwgb3B0aW9ucyk7XHJcbn07XHJcbi8qKlxyXG4gKiBEZXRlY3RzIHRoZSA2OCBwb2ludCBmYWNlIGxhbmRtYXJrIHBvc2l0aW9ucyBvZiB0aGUgZmFjZSBzaG93biBpbiBhbiBpbWFnZS5cclxuICpcclxuICogQHBhcmFtIGlucHV0cyBUaGUgZmFjZSBpbWFnZSBleHRyYWN0ZWQgZnJvbSB0aGUgYm91bmRpbmcgYm94IG9mIGEgZmFjZS4gQ2FuXHJcbiAqIGFsc28gYmUgYW4gYXJyYXkgb2YgaW5wdXQgaW1hZ2VzLCB3aGljaCB3aWxsIGJlIGJhdGNoIHByb2Nlc3NlZC5cclxuICogQHJldHVybnMgNjggcG9pbnQgZmFjZSBsYW5kbWFya3Mgb3IgYXJyYXkgdGhlcmVvZiBpbiBjYXNlIG9mIGJhdGNoIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IHZhciBkZXRlY3RGYWNlTGFuZG1hcmtzID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICByZXR1cm4gbmV0cy5mYWNlTGFuZG1hcms2OE5ldC5kZXRlY3RMYW5kbWFya3MoaW5wdXQpO1xyXG59O1xyXG4vKipcclxuICogRGV0ZWN0cyB0aGUgNjggcG9pbnQgZmFjZSBsYW5kbWFyayBwb3NpdGlvbnMgb2YgdGhlIGZhY2Ugc2hvd24gaW4gYW4gaW1hZ2VcclxuICogdXNpbmcgYSB0aW5pZXIgdmVyc2lvbiBvZiB0aGUgNjggcG9pbnQgZmFjZSBsYW5kbWFyayBtb2RlbCwgd2hpY2ggaXMgc2xpZ2h0bHlcclxuICogZmFzdGVyIGF0IGluZmVyZW5jZSwgYnV0IGFsc28gc2xpZ2h0bHkgbGVzcyBhY2N1cmF0ZS5cclxuICpcclxuICogQHBhcmFtIGlucHV0cyBUaGUgZmFjZSBpbWFnZSBleHRyYWN0ZWQgZnJvbSB0aGUgYm91bmRpbmcgYm94IG9mIGEgZmFjZS4gQ2FuXHJcbiAqIGFsc28gYmUgYW4gYXJyYXkgb2YgaW5wdXQgaW1hZ2VzLCB3aGljaCB3aWxsIGJlIGJhdGNoIHByb2Nlc3NlZC5cclxuICogQHJldHVybnMgNjggcG9pbnQgZmFjZSBsYW5kbWFya3Mgb3IgYXJyYXkgdGhlcmVvZiBpbiBjYXNlIG9mIGJhdGNoIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IHZhciBkZXRlY3RGYWNlTGFuZG1hcmtzVGlueSA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIG5ldHMuZmFjZUxhbmRtYXJrNjhUaW55TmV0LmRldGVjdExhbmRtYXJrcyhpbnB1dCk7XHJcbn07XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhIDEyOCBlbnRyeSB2ZWN0b3IgKGZhY2UgZGVzY3JpcHRvciAvIGZhY2UgZW1iZWRkaW5ncykgZnJvbSB0aGUgZmFjZSBzaG93biBpbiBhbiBpbWFnZSxcclxuICogd2hpY2ggdW5pcXVlbHkgcmVwcmVzZW50cyB0aGUgZmVhdHVyZXMgb2YgdGhhdCBwZXJzb25zIGZhY2UuIFRoZSBjb21wdXRlZCBmYWNlIGRlc2NyaXB0b3IgY2FuXHJcbiAqIGJlIHVzZWQgdG8gbWVhc3VyZSB0aGUgc2ltaWxhcml0eSBiZXR3ZWVuIGZhY2VzLCBieSBjb21wdXRpbmcgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSBvZiB0d29cclxuICogZmFjZSBkZXNjcmlwdG9ycy5cclxuICpcclxuICogQHBhcmFtIGlucHV0cyBUaGUgZmFjZSBpbWFnZSBleHRyYWN0ZWQgZnJvbSB0aGUgYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYSBmYWNlLiBDYW5cclxuICogYWxzbyBiZSBhbiBhcnJheSBvZiBpbnB1dCBpbWFnZXMsIHdoaWNoIHdpbGwgYmUgYmF0Y2ggcHJvY2Vzc2VkLlxyXG4gKiBAcmV0dXJucyBGYWNlIGRlc2NyaXB0b3Igd2l0aCAxMjggZW50cmllcyBvciBhcnJheSB0aGVyZW9mIGluIGNhc2Ugb2YgYmF0Y2ggaW5wdXQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIGNvbXB1dGVGYWNlRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIG5ldHMuZmFjZVJlY29nbml0aW9uTmV0LmNvbXB1dGVGYWNlRGVzY3JpcHRvcihpbnB1dCk7XHJcbn07XHJcbi8qKlxyXG4gKiBSZWNvZ25pemVzIHRoZSBmYWNpYWwgZXhwcmVzc2lvbnMgZnJvbSBhIGZhY2UgaW1hZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGZhY2UgaW1hZ2UgZXh0cmFjdGVkIGZyb20gdGhlIGJvdW5kaW5nIGJveCBvZiBhIGZhY2UuIENhblxyXG4gKiBhbHNvIGJlIGFuIGFycmF5IG9mIGlucHV0IGltYWdlcywgd2hpY2ggd2lsbCBiZSBiYXRjaCBwcm9jZXNzZWQuXHJcbiAqIEByZXR1cm5zIEZhY2lhbCBleHByZXNzaW9ucyB3aXRoIGNvcnJlc3BvbmRpbmcgcHJvYmFiaWxpdGllcyBvciBhcnJheSB0aGVyZW9mIGluIGNhc2Ugb2YgYmF0Y2ggaW5wdXQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIHJlY29nbml6ZUZhY2VFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIG5ldHMuZmFjZUV4cHJlc3Npb25OZXQucHJlZGljdEV4cHJlc3Npb25zKGlucHV0KTtcclxufTtcclxuLyoqXHJcbiAqIFByZWRpY3RzIGFnZSBhbmQgZ2VuZGVyIGZyb20gYSBmYWNlIGltYWdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXRzIFRoZSBmYWNlIGltYWdlIGV4dHJhY3RlZCBmcm9tIHRoZSBib3VuZGluZyBib3ggb2YgYSBmYWNlLiBDYW5cclxuICogYWxzbyBiZSBhbiBhcnJheSBvZiBpbnB1dCBpbWFnZXMsIHdoaWNoIHdpbGwgYmUgYmF0Y2ggcHJvY2Vzc2VkLlxyXG4gKiBAcmV0dXJucyBQcmVkaWN0aW9ucyB3aXRoIGFnZSwgZ2VuZGVyIGFuZCBnZW5kZXIgcHJvYmFiaWxpdHkgb3IgYXJyYXkgdGhlcmVvZiBpbiBjYXNlIG9mIGJhdGNoIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IHZhciBwcmVkaWN0QWdlQW5kR2VuZGVyID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICByZXR1cm4gbmV0cy5hZ2VHZW5kZXJOZXQucHJlZGljdEFnZUFuZEdlbmRlcihpbnB1dCk7XHJcbn07XHJcbmV4cG9ydCB2YXIgbG9hZFNzZE1vYmlsZW5ldHYxTW9kZWwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBuZXRzLnNzZE1vYmlsZW5ldHYxLmxvYWQodXJsKTsgfTtcclxuZXhwb3J0IHZhciBsb2FkVGlueUZhY2VEZXRlY3Rvck1vZGVsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbmV0cy50aW55RmFjZURldGVjdG9yLmxvYWQodXJsKTsgfTtcclxuZXhwb3J0IHZhciBsb2FkTXRjbm5Nb2RlbCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG5ldHMubXRjbm4ubG9hZCh1cmwpOyB9O1xyXG5leHBvcnQgdmFyIGxvYWRUaW55WW9sb3YyTW9kZWwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBuZXRzLnRpbnlZb2xvdjIubG9hZCh1cmwpOyB9O1xyXG5leHBvcnQgdmFyIGxvYWRGYWNlTGFuZG1hcmtNb2RlbCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG5ldHMuZmFjZUxhbmRtYXJrNjhOZXQubG9hZCh1cmwpOyB9O1xyXG5leHBvcnQgdmFyIGxvYWRGYWNlTGFuZG1hcmtUaW55TW9kZWwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBuZXRzLmZhY2VMYW5kbWFyazY4VGlueU5ldC5sb2FkKHVybCk7IH07XHJcbmV4cG9ydCB2YXIgbG9hZEZhY2VSZWNvZ25pdGlvbk1vZGVsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbmV0cy5mYWNlUmVjb2duaXRpb25OZXQubG9hZCh1cmwpOyB9O1xyXG5leHBvcnQgdmFyIGxvYWRGYWNlRXhwcmVzc2lvbk1vZGVsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbmV0cy5mYWNlRXhwcmVzc2lvbk5ldC5sb2FkKHVybCk7IH07XHJcbmV4cG9ydCB2YXIgbG9hZEFnZUdlbmRlck1vZGVsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbmV0cy5hZ2VHZW5kZXJOZXQubG9hZCh1cmwpOyB9O1xyXG4vLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbmV4cG9ydCB2YXIgbG9hZEZhY2VEZXRlY3Rpb25Nb2RlbCA9IGxvYWRTc2RNb2JpbGVuZXR2MU1vZGVsO1xyXG5leHBvcnQgdmFyIGxvY2F0ZUZhY2VzID0gc3NkTW9iaWxlbmV0djE7XHJcbmV4cG9ydCB2YXIgZGV0ZWN0TGFuZG1hcmtzID0gZGV0ZWN0RmFjZUxhbmRtYXJrcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0cy5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgKiBhcyBkcmF3IGZyb20gJy4vZHJhdyc7XHJcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xyXG5leHBvcnQgeyBkcmF3LCB1dGlscywgdGYgfTtcclxuZXhwb3J0ICogZnJvbSAnLi9hZ2VHZW5kZXJOZXQvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NsYXNzZXMvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL2RvbS9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZW52L2luZGV4JztcclxuZXhwb3J0ICogZnJvbSAnLi9mYWNlRXhwcmVzc2lvbk5ldC9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZmFjZUxhbmRtYXJrTmV0L2luZGV4JztcclxuZXhwb3J0ICogZnJvbSAnLi9mYWNlUmVjb2duaXRpb25OZXQvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL2ZhY3Rvcmllcy9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2xvYmFsQXBpL2luZGV4JztcclxuZXhwb3J0ICogZnJvbSAnLi9tdGNubi9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vb3BzL2luZGV4JztcclxuZXhwb3J0ICogZnJvbSAnLi9zc2RNb2JpbGVuZXR2MS9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdGlueUZhY2VEZXRlY3Rvci9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdGlueVlvbG92Mi9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZXVjbGlkZWFuRGlzdGFuY2UnO1xyXG5leHBvcnQgKiBmcm9tICcuL05ldXJhbE5ldHdvcmsnO1xyXG5leHBvcnQgKiBmcm9tICcuL3Jlc2l6ZVJlc3VsdHMnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgUG9pbnQsIFJlY3QgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IEZhY2VMYW5kbWFya3M1IH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlTGFuZG1hcmtzNSc7XHJcbmltcG9ydCB7IHRvTmV0SW5wdXQgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBleHRlbmRXaXRoRmFjZURldGVjdGlvbiwgZXh0ZW5kV2l0aEZhY2VMYW5kbWFya3MgfSBmcm9tICcuLi9mYWN0b3JpZXMnO1xyXG5pbXBvcnQgeyBOZXVyYWxOZXR3b3JrIH0gZnJvbSAnLi4vTmV1cmFsTmV0d29yayc7XHJcbmltcG9ydCB7IGJnclRvUmdiVGVuc29yIH0gZnJvbSAnLi9iZ3JUb1JnYlRlbnNvcic7XHJcbmltcG9ydCB7IENFTExfU0laRSB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtcyB9IGZyb20gJy4vZXh0cmFjdFBhcmFtcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCc7XHJcbmltcG9ydCB7IGdldFNpemVzRm9yU2NhbGUgfSBmcm9tICcuL2dldFNpemVzRm9yU2NhbGUnO1xyXG5pbXBvcnQgeyBNdGNubk9wdGlvbnMgfSBmcm9tICcuL010Y25uT3B0aW9ucyc7XHJcbmltcG9ydCB7IHB5cmFtaWREb3duIH0gZnJvbSAnLi9weXJhbWlkRG93bic7XHJcbmltcG9ydCB7IHN0YWdlMSB9IGZyb20gJy4vc3RhZ2UxJztcclxuaW1wb3J0IHsgc3RhZ2UyIH0gZnJvbSAnLi9zdGFnZTInO1xyXG5pbXBvcnQgeyBzdGFnZTMgfSBmcm9tICcuL3N0YWdlMyc7XHJcbnZhciBNdGNubiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNdGNubiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE10Y25uKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnTXRjbm4nKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTXRjbm4ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAod2VpZ2h0c09yVXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ210Y25uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX3N1cGVyLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcywgd2VpZ2h0c09yVXJsKV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE10Y25uLnByb3RvdHlwZS5sb2FkRnJvbURpc2sgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignbXRjbm4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBfc3VwZXIucHJvdG90eXBlLmxvYWRGcm9tRGlzay5jYWxsKHRoaXMsIGZpbGVQYXRoKV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE10Y25uLnByb3RvdHlwZS5mb3J3YXJkSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQsIGZvcndhcmRQYXJhbXMpIHtcclxuICAgICAgICBpZiAoZm9yd2FyZFBhcmFtcyA9PT0gdm9pZCAwKSB7IGZvcndhcmRQYXJhbXMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcywgaW5wdXRDYW52YXMsIHN0YXRzLCB0c1RvdGFsLCBpbWdUZW5zb3IsIG9uUmV0dXJuLCBfYSwgaGVpZ2h0LCB3aWR0aCwgX2IsIG1pbkZhY2VTaXplLCBzY2FsZUZhY3RvciwgbWF4TnVtU2NhbGVzLCBzY29yZVRocmVzaG9sZHMsIHNjYWxlU3RlcHMsIHNjYWxlcywgdHMsIG91dDEsIG91dDIsIG91dDMsIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdGNubiAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Q2FudmFzID0gaW5wdXQuY2FudmFzZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXRDYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXRjbm4gLSBpbnB1dENhbnZhcyBpcyBub3QgZGVmaW5lZCwgbm90ZSB0aGF0IHBhc3NpbmcgdGVuc29ycyBpbnRvIE10Y25uLmZvcndhcmRJbnB1dCBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0c1RvdGFsID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nVGVuc29yID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmdyVG9SZ2JUZW5zb3IodGYuZXhwYW5kRGltcyh0Zi5icm93c2VyLmZyb21QaXhlbHMoaW5wdXRDYW52YXMpKS50b0Zsb2F0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXR1cm4gPSBmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zZSB0ZW5zb3JzIG9uIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnRvdGFsID0gRGF0ZS5ub3coKSAtIHRzVG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBpbWdUZW5zb3Iuc2hhcGUuc2xpY2UoMSksIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IG5ldyBNdGNubk9wdGlvbnMoZm9yd2FyZFBhcmFtcyksIG1pbkZhY2VTaXplID0gX2IubWluRmFjZVNpemUsIHNjYWxlRmFjdG9yID0gX2Iuc2NhbGVGYWN0b3IsIG1heE51bVNjYWxlcyA9IF9iLm1heE51bVNjYWxlcywgc2NvcmVUaHJlc2hvbGRzID0gX2Iuc2NvcmVUaHJlc2hvbGRzLCBzY2FsZVN0ZXBzID0gX2Iuc2NhbGVTdGVwcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVzID0gKHNjYWxlU3RlcHMgfHwgcHlyYW1pZERvd24obWluRmFjZVNpemUsIHNjYWxlRmFjdG9yLCBbaGVpZ2h0LCB3aWR0aF0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplcyA9IGdldFNpemVzRm9yU2NhbGUoc2NhbGUsIFtoZWlnaHQsIHdpZHRoXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oc2l6ZXMud2lkdGgsIHNpemVzLmhlaWdodCkgPiBDRUxMX1NJWkU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgbWF4TnVtU2NhbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuc2NhbGVzID0gc2NhbGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5weXJhbWlkID0gc2NhbGVzLm1hcChmdW5jdGlvbiAoc2NhbGUpIHsgcmV0dXJuIGdldFNpemVzRm9yU2NhbGUoc2NhbGUsIFtoZWlnaHQsIHdpZHRoXSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWdlMShpbWdUZW5zb3IsIHNjYWxlcywgc2NvcmVUaHJlc2hvbGRzWzBdLCBwYXJhbXMucG5ldCwgc3RhdHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDEgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnRvdGFsX3N0YWdlMSA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXQxLmJveGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG9uUmV0dXJuKHsgcmVzdWx0czogW10sIHN0YXRzOiBzdGF0cyB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuc3RhZ2UyX251bUlucHV0Qm94ZXMgPSBvdXQxLmJveGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGlucHV0Q2FudmFzIHRvIGV4dHJhY3QgYW5kIHJlc2l6ZSB0aGUgaW1hZ2UgcGF0Y2hlcywgc2luY2UgaXQgaXMgZmFzdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYW4gZG9pbmcgdGhpcyBvbiB0aGUgZ3B1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhZ2UyKGlucHV0Q2FudmFzLCBvdXQxLmJveGVzLCBzY29yZVRocmVzaG9sZHNbMV0sIHBhcmFtcy5ybmV0LCBzdGF0cyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMudG90YWxfc3RhZ2UyID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW91dDIuYm94ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb25SZXR1cm4oeyByZXN1bHRzOiBbXSwgc3RhdHM6IHN0YXRzIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdGFnZTNfbnVtSW5wdXRCb3hlcyA9IG91dDIuYm94ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWdlMyhpbnB1dENhbnZhcywgb3V0Mi5ib3hlcywgc2NvcmVUaHJlc2hvbGRzWzJdLCBwYXJhbXMub25ldCwgc3RhdHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDMgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnRvdGFsX3N0YWdlMyA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IG91dDMuYm94ZXMubWFwKGZ1bmN0aW9uIChib3gsIGlkeCkgeyByZXR1cm4gZXh0ZW5kV2l0aEZhY2VMYW5kbWFya3MoZXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oe30sIG5ldyBGYWNlRGV0ZWN0aW9uKG91dDMuc2NvcmVzW2lkeF0sIG5ldyBSZWN0KGJveC5sZWZ0IC8gd2lkdGgsIGJveC50b3AgLyBoZWlnaHQsIGJveC53aWR0aCAvIHdpZHRoLCBib3guaGVpZ2h0IC8gaGVpZ2h0KSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBuZXcgRmFjZUxhbmRtYXJrczUob3V0My5wb2ludHNbaWR4XS5tYXAoZnVuY3Rpb24gKHB0KSB7IHJldHVybiBwdC5zdWIobmV3IFBvaW50KGJveC5sZWZ0LCBib3gudG9wKSkuZGl2KG5ldyBQb2ludChib3gud2lkdGgsIGJveC5oZWlnaHQpKTsgfSksIHsgd2lkdGg6IGJveC53aWR0aCwgaGVpZ2h0OiBib3guaGVpZ2h0IH0pKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBvblJldHVybih7IHJlc3VsdHM6IHJlc3VsdHMsIHN0YXRzOiBzdGF0cyB9KV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE10Y25uLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0LCBmb3J3YXJkUGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKGZvcndhcmRQYXJhbXMgPT09IHZvaWQgMCkgeyBmb3J3YXJkUGFyYW1zID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRQYXJhbXNdKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9iLnNlbnQoKSkucmVzdWx0c107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE10Y25uLnByb3RvdHlwZS5mb3J3YXJkV2l0aFN0YXRzID0gZnVuY3Rpb24gKGlucHV0LCBmb3J3YXJkUGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKGZvcndhcmRQYXJhbXMgPT09IHZvaWQgMCkgeyBmb3J3YXJkUGFyYW1zID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHRoaXMsIFtfYi5zZW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkUGFyYW1zXSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdGNubi5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ210Y25uX21vZGVsJztcclxuICAgIH07XHJcbiAgICBNdGNubi5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCk7XHJcbiAgICB9O1xyXG4gICAgTXRjbm4ucHJvdG90eXBlLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zKHdlaWdodHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNdGNubjtcclxufShOZXVyYWxOZXR3b3JrKSk7XHJcbmV4cG9ydCB7IE10Y25uIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU10Y25uLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBCb3ggfSBmcm9tICcuLi9jbGFzc2VzJztcclxudmFyIE10Y25uQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE10Y25uQm94LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTXRjbm5Cb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20gfSwgdHJ1ZSkgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBNdGNubkJveDtcclxufShCb3gpKTtcclxuZXhwb3J0IHsgTXRjbm5Cb3ggfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXRjbm5Cb3guanMubWFwIiwidmFyIE10Y25uT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE10Y25uT3B0aW9ucyhfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5GYWNlU2l6ZSA9IF9iLm1pbkZhY2VTaXplLCBzY2FsZUZhY3RvciA9IF9iLnNjYWxlRmFjdG9yLCBtYXhOdW1TY2FsZXMgPSBfYi5tYXhOdW1TY2FsZXMsIHNjb3JlVGhyZXNob2xkcyA9IF9iLnNjb3JlVGhyZXNob2xkcywgc2NhbGVTdGVwcyA9IF9iLnNjYWxlU3RlcHM7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdNdGNubk9wdGlvbnMnO1xyXG4gICAgICAgIHRoaXMuX21pbkZhY2VTaXplID0gbWluRmFjZVNpemUgfHwgMjA7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvciB8fCAwLjcwOTtcclxuICAgICAgICB0aGlzLl9tYXhOdW1TY2FsZXMgPSBtYXhOdW1TY2FsZXMgfHwgMTA7XHJcbiAgICAgICAgdGhpcy5fc2NvcmVUaHJlc2hvbGRzID0gc2NvcmVUaHJlc2hvbGRzIHx8IFswLjYsIDAuNywgMC43XTtcclxuICAgICAgICB0aGlzLl9zY2FsZVN0ZXBzID0gc2NhbGVTdGVwcztcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21pbkZhY2VTaXplICE9PSAnbnVtYmVyJyB8fCB0aGlzLl9taW5GYWNlU2l6ZSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX25hbWUgKyBcIiAtIGV4cGVjdGVkIG1pbkZhY2VTaXplIHRvIGJlIGEgbnVtYmVyID4gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zY2FsZUZhY3RvciAhPT0gJ251bWJlcicgfHwgdGhpcy5fc2NhbGVGYWN0b3IgPD0gMCB8fCB0aGlzLl9zY2FsZUZhY3RvciA+PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBzY2FsZUZhY3RvciB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fbWF4TnVtU2NhbGVzICE9PSAnbnVtYmVyJyB8fCB0aGlzLl9tYXhOdW1TY2FsZXMgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBtYXhOdW1TY2FsZXMgdG8gYmUgYSBudW1iZXIgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5fc2NvcmVUaHJlc2hvbGRzKVxyXG4gICAgICAgICAgICB8fCB0aGlzLl9zY29yZVRocmVzaG9sZHMubGVuZ3RoICE9PSAzXHJcbiAgICAgICAgICAgIHx8IHRoaXMuX3Njb3JlVGhyZXNob2xkcy5zb21lKGZ1bmN0aW9uICh0aCkgeyByZXR1cm4gdHlwZW9mIHRoICE9PSAnbnVtYmVyJzsgfSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX25hbWUgKyBcIiAtIGV4cGVjdGVkIHNjb3JlVGhyZXNob2xkcyB0byBiZSBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGxlbmd0aCAzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc2NhbGVTdGVwc1xyXG4gICAgICAgICAgICAmJiAoIUFycmF5LmlzQXJyYXkodGhpcy5fc2NhbGVTdGVwcykgfHwgdGhpcy5fc2NhbGVTdGVwcy5zb21lKGZ1bmN0aW9uICh0aCkgeyByZXR1cm4gdHlwZW9mIHRoICE9PSAnbnVtYmVyJzsgfSkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBzY2FsZVN0ZXBzIHRvIGJlIGFuIGFycmF5IG9mIG51bWJlcnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE10Y25uT3B0aW9ucy5wcm90b3R5cGUsIFwibWluRmFjZVNpemVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWluRmFjZVNpemU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE10Y25uT3B0aW9ucy5wcm90b3R5cGUsIFwic2NhbGVGYWN0b3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2NhbGVGYWN0b3I7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE10Y25uT3B0aW9ucy5wcm90b3R5cGUsIFwibWF4TnVtU2NhbGVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21heE51bVNjYWxlczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTXRjbm5PcHRpb25zLnByb3RvdHlwZSwgXCJzY29yZVRocmVzaG9sZHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2NvcmVUaHJlc2hvbGRzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNdGNubk9wdGlvbnMucHJvdG90eXBlLCBcInNjYWxlU3RlcHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2NhbGVTdGVwczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gTXRjbm5PcHRpb25zO1xyXG59KCkpO1xyXG5leHBvcnQgeyBNdGNubk9wdGlvbnMgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXRjbm5PcHRpb25zLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGNvbnZMYXllciB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGZ1bGx5Q29ubmVjdGVkTGF5ZXIgfSBmcm9tICcuLi9jb21tb24vZnVsbHlDb25uZWN0ZWRMYXllcic7XHJcbmltcG9ydCB7IHByZWx1IH0gZnJvbSAnLi9wcmVsdSc7XHJcbmltcG9ydCB7IHNoYXJlZExheWVyIH0gZnJvbSAnLi9zaGFyZWRMYXllcnMnO1xyXG5leHBvcnQgZnVuY3Rpb24gT05ldCh4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gc2hhcmVkTGF5ZXIoeCwgcGFyYW1zKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gY29udkxheWVyKG91dCwgcGFyYW1zLmNvbnY0LCAndmFsaWQnKTtcclxuICAgICAgICBvdXQgPSBwcmVsdShvdXQsIHBhcmFtcy5wcmVsdTRfYWxwaGEpO1xyXG4gICAgICAgIHZhciB2ZWN0b3JpemVkID0gdGYucmVzaGFwZShvdXQsIFtvdXQuc2hhcGVbMF0sIHBhcmFtcy5mYzEud2VpZ2h0cy5zaGFwZVswXV0pO1xyXG4gICAgICAgIHZhciBmYzEgPSBmdWxseUNvbm5lY3RlZExheWVyKHZlY3Rvcml6ZWQsIHBhcmFtcy5mYzEpO1xyXG4gICAgICAgIHZhciBwcmVsdTUgPSBwcmVsdShmYzEsIHBhcmFtcy5wcmVsdTVfYWxwaGEpO1xyXG4gICAgICAgIHZhciBmYzJfMSA9IGZ1bGx5Q29ubmVjdGVkTGF5ZXIocHJlbHU1LCBwYXJhbXMuZmMyXzEpO1xyXG4gICAgICAgIHZhciBtYXggPSB0Zi5leHBhbmREaW1zKHRmLm1heChmYzJfMSwgMSksIDEpO1xyXG4gICAgICAgIHZhciBwcm9iID0gdGYuc29mdG1heCh0Zi5zdWIoZmMyXzEsIG1heCksIDEpO1xyXG4gICAgICAgIHZhciByZWdpb25zID0gZnVsbHlDb25uZWN0ZWRMYXllcihwcmVsdTUsIHBhcmFtcy5mYzJfMik7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGZ1bGx5Q29ubmVjdGVkTGF5ZXIocHJlbHU1LCBwYXJhbXMuZmMyXzMpO1xyXG4gICAgICAgIHZhciBzY29yZXMgPSB0Zi51bnN0YWNrKHByb2IsIDEpWzFdO1xyXG4gICAgICAgIHJldHVybiB7IHNjb3Jlczogc2NvcmVzLCByZWdpb25zOiByZWdpb25zLCBwb2ludHM6IHBvaW50cyB9O1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T05ldC5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBjb252TGF5ZXIgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBzaGFyZWRMYXllciB9IGZyb20gJy4vc2hhcmVkTGF5ZXJzJztcclxuZXhwb3J0IGZ1bmN0aW9uIFBOZXQoeCwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IHNoYXJlZExheWVyKHgsIHBhcmFtcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGNvbnYgPSBjb252TGF5ZXIob3V0LCBwYXJhbXMuY29udjRfMSwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgdmFyIG1heCA9IHRmLmV4cGFuZERpbXModGYubWF4KGNvbnYsIDMpLCAzKTtcclxuICAgICAgICB2YXIgcHJvYiA9IHRmLnNvZnRtYXgodGYuc3ViKGNvbnYsIG1heCksIDMpO1xyXG4gICAgICAgIHZhciByZWdpb25zID0gY29udkxheWVyKG91dCwgcGFyYW1zLmNvbnY0XzIsICd2YWxpZCcpO1xyXG4gICAgICAgIHJldHVybiB7IHByb2I6IHByb2IsIHJlZ2lvbnM6IHJlZ2lvbnMgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBOZXQuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZnVsbHlDb25uZWN0ZWRMYXllciB9IGZyb20gJy4uL2NvbW1vbi9mdWxseUNvbm5lY3RlZExheWVyJztcclxuaW1wb3J0IHsgcHJlbHUgfSBmcm9tICcuL3ByZWx1JztcclxuaW1wb3J0IHsgc2hhcmVkTGF5ZXIgfSBmcm9tICcuL3NoYXJlZExheWVycyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBSTmV0KHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb252T3V0ID0gc2hhcmVkTGF5ZXIoeCwgcGFyYW1zKTtcclxuICAgICAgICB2YXIgdmVjdG9yaXplZCA9IHRmLnJlc2hhcGUoY29udk91dCwgW2NvbnZPdXQuc2hhcGVbMF0sIHBhcmFtcy5mYzEud2VpZ2h0cy5zaGFwZVswXV0pO1xyXG4gICAgICAgIHZhciBmYzEgPSBmdWxseUNvbm5lY3RlZExheWVyKHZlY3Rvcml6ZWQsIHBhcmFtcy5mYzEpO1xyXG4gICAgICAgIHZhciBwcmVsdTQgPSBwcmVsdShmYzEsIHBhcmFtcy5wcmVsdTRfYWxwaGEpO1xyXG4gICAgICAgIHZhciBmYzJfMSA9IGZ1bGx5Q29ubmVjdGVkTGF5ZXIocHJlbHU0LCBwYXJhbXMuZmMyXzEpO1xyXG4gICAgICAgIHZhciBtYXggPSB0Zi5leHBhbmREaW1zKHRmLm1heChmYzJfMSwgMSksIDEpO1xyXG4gICAgICAgIHZhciBwcm9iID0gdGYuc29mdG1heCh0Zi5zdWIoZmMyXzEsIG1heCksIDEpO1xyXG4gICAgICAgIHZhciByZWdpb25zID0gZnVsbHlDb25uZWN0ZWRMYXllcihwcmVsdTQsIHBhcmFtcy5mYzJfMik7XHJcbiAgICAgICAgdmFyIHNjb3JlcyA9IHRmLnVuc3RhY2socHJvYiwgMSlbMV07XHJcbiAgICAgICAgcmV0dXJuIHsgc2NvcmVzOiBzY29yZXMsIHJlZ2lvbnM6IHJlZ2lvbnMgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJOZXQuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGJnclRvUmdiVGVuc29yKHRlbnNvcikge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGYuc3RhY2sodGYudW5zdGFjayh0ZW5zb3IsIDMpLnJldmVyc2UoKSwgMyk7IH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJnclRvUmdiVGVuc29yLmpzLm1hcCIsImV4cG9ydCB2YXIgQ0VMTF9TVFJJREUgPSAyO1xyXG5leHBvcnQgdmFyIENFTExfU0laRSA9IDEyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBjcmVhdGVDYW52YXMsIGNyZWF0ZUNhbnZhc0Zyb21NZWRpYSwgZ2V0Q29udGV4dDJkT3JUaHJvdyB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4vbm9ybWFsaXplJztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJbWFnZVBhdGNoZXMoaW1nLCBib3hlcywgX2EpIHtcclxuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGltZ0N0eCwgYml0bWFwcywgaW1hZ2VQYXRjaGVzRGF0YXM7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpbWdDdHggPSBnZXRDb250ZXh0MmRPclRocm93KGltZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoYm94ZXMubWFwKGZ1bmN0aW9uIChib3gpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgeSwgZXksIHgsIGV4LCBmcm9tWCwgZnJvbVksIGltZ0RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBib3gucGFkQXRCb3JkZXJzKGltZy5oZWlnaHQsIGltZy53aWR0aCksIHkgPSBfYS55LCBleSA9IF9hLmV5LCB4ID0gX2EueCwgZXggPSBfYS5leDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tWCA9IHggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21ZID0geSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nRGF0YSA9IGltZ0N0eC5nZXRJbWFnZURhdGEoZnJvbVgsIGZyb21ZLCAoZXggLSBmcm9tWCksIChleSAtIGZyb21ZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGVudi5pc05vZGVqcygpID8gY3JlYXRlQ2FudmFzRnJvbU1lZGlhKGltZ0RhdGEpIDogY3JlYXRlSW1hZ2VCaXRtYXAoaW1nRGF0YSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGJpdG1hcHMgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VQYXRjaGVzRGF0YXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBiaXRtYXBzLmZvckVhY2goZnVuY3Rpb24gKGJtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2ggPSBjcmVhdGVDYW52YXMoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2hDdHggPSBnZXRDb250ZXh0MmRPclRocm93KHBhdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hDdHguZHJhd0ltYWdlKGJtcCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcGF0Y2hDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSR0JBIC0+IEJHUlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJEYXRhLnB1c2goZGF0YVtpICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckRhdGEucHVzaChkYXRhW2kgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyRGF0YS5wdXNoKGRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlUGF0Y2hlc0RhdGFzLnB1c2goY3VyckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbWFnZVBhdGNoZXNEYXRhcy5tYXAoZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlUGF0Y2hUZW5zb3IgPSB0Zi50cmFuc3Bvc2UodGYudGVuc29yNGQoZGF0YSwgWzEsIHdpZHRoLCBoZWlnaHQsIDNdKSwgWzAsIDIsIDEsIDNdKS50b0Zsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShpbWFnZVBhdGNoVGVuc29yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdEltYWdlUGF0Y2hlcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnksIGV4dHJhY3RGQ1BhcmFtc0ZhY3RvcnksIGV4dHJhY3RXZWlnaHRzRmFjdG9yeSwgfSBmcm9tICcuLi9jb21tb24nO1xyXG5mdW5jdGlvbiBleHRyYWN0b3JzRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgdmFyIGV4dHJhY3RDb252UGFyYW1zID0gZXh0cmFjdENvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHZhciBleHRyYWN0RkNQYXJhbXMgPSBleHRyYWN0RkNQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RQUmVsdVBhcmFtcyhzaXplLCBwYXJhbVBhdGgpIHtcclxuICAgICAgICB2YXIgYWxwaGEgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhzaXplKSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBwYXJhbVBhdGggfSk7XHJcbiAgICAgICAgcmV0dXJuIGFscGhhO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFNoYXJlZFBhcmFtcyhudW1GaWx0ZXJzLCBtYXBwZWRQcmVmaXgsIGlzUm5ldCkge1xyXG4gICAgICAgIGlmIChpc1JuZXQgPT09IHZvaWQgMCkgeyBpc1JuZXQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBjb252MSA9IGV4dHJhY3RDb252UGFyYW1zKG51bUZpbHRlcnNbMF0sIG51bUZpbHRlcnNbMV0sIDMsIG1hcHBlZFByZWZpeCArIFwiL2NvbnYxXCIpO1xyXG4gICAgICAgIHZhciBwcmVsdTFfYWxwaGEgPSBleHRyYWN0UFJlbHVQYXJhbXMobnVtRmlsdGVyc1sxXSwgbWFwcGVkUHJlZml4ICsgXCIvcHJlbHUxX2FscGhhXCIpO1xyXG4gICAgICAgIHZhciBjb252MiA9IGV4dHJhY3RDb252UGFyYW1zKG51bUZpbHRlcnNbMV0sIG51bUZpbHRlcnNbMl0sIDMsIG1hcHBlZFByZWZpeCArIFwiL2NvbnYyXCIpO1xyXG4gICAgICAgIHZhciBwcmVsdTJfYWxwaGEgPSBleHRyYWN0UFJlbHVQYXJhbXMobnVtRmlsdGVyc1syXSwgbWFwcGVkUHJlZml4ICsgXCIvcHJlbHUyX2FscGhhXCIpO1xyXG4gICAgICAgIHZhciBjb252MyA9IGV4dHJhY3RDb252UGFyYW1zKG51bUZpbHRlcnNbMl0sIG51bUZpbHRlcnNbM10sIGlzUm5ldCA/IDIgOiAzLCBtYXBwZWRQcmVmaXggKyBcIi9jb252M1wiKTtcclxuICAgICAgICB2YXIgcHJlbHUzX2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKG51bUZpbHRlcnNbM10sIG1hcHBlZFByZWZpeCArIFwiL3ByZWx1M19hbHBoYVwiKTtcclxuICAgICAgICByZXR1cm4geyBjb252MTogY29udjEsIHByZWx1MV9hbHBoYTogcHJlbHUxX2FscGhhLCBjb252MjogY29udjIsIHByZWx1Ml9hbHBoYTogcHJlbHUyX2FscGhhLCBjb252MzogY29udjMsIHByZWx1M19hbHBoYTogcHJlbHUzX2FscGhhIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UE5ldFBhcmFtcygpIHtcclxuICAgICAgICB2YXIgc2hhcmVkUGFyYW1zID0gZXh0cmFjdFNoYXJlZFBhcmFtcyhbMywgMTAsIDE2LCAzMl0sICdwbmV0Jyk7XHJcbiAgICAgICAgdmFyIGNvbnY0XzEgPSBleHRyYWN0Q29udlBhcmFtcygzMiwgMiwgMSwgJ3BuZXQvY29udjRfMScpO1xyXG4gICAgICAgIHZhciBjb252NF8yID0gZXh0cmFjdENvbnZQYXJhbXMoMzIsIDQsIDEsICdwbmV0L2NvbnY0XzInKTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHNoYXJlZFBhcmFtcyksIHsgY29udjRfMTogY29udjRfMSwgY29udjRfMjogY29udjRfMiB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RSTmV0UGFyYW1zKCkge1xyXG4gICAgICAgIHZhciBzaGFyZWRQYXJhbXMgPSBleHRyYWN0U2hhcmVkUGFyYW1zKFszLCAyOCwgNDgsIDY0XSwgJ3JuZXQnLCB0cnVlKTtcclxuICAgICAgICB2YXIgZmMxID0gZXh0cmFjdEZDUGFyYW1zKDU3NiwgMTI4LCAncm5ldC9mYzEnKTtcclxuICAgICAgICB2YXIgcHJlbHU0X2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKDEyOCwgJ3JuZXQvcHJlbHU0X2FscGhhJyk7XHJcbiAgICAgICAgdmFyIGZjMl8xID0gZXh0cmFjdEZDUGFyYW1zKDEyOCwgMiwgJ3JuZXQvZmMyXzEnKTtcclxuICAgICAgICB2YXIgZmMyXzIgPSBleHRyYWN0RkNQYXJhbXMoMTI4LCA0LCAncm5ldC9mYzJfMicpO1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2hhcmVkUGFyYW1zKSwgeyBmYzE6IGZjMSwgcHJlbHU0X2FscGhhOiBwcmVsdTRfYWxwaGEsIGZjMl8xOiBmYzJfMSwgZmMyXzI6IGZjMl8yIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdE9OZXRQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIHNoYXJlZFBhcmFtcyA9IGV4dHJhY3RTaGFyZWRQYXJhbXMoWzMsIDMyLCA2NCwgNjRdLCAnb25ldCcpO1xyXG4gICAgICAgIHZhciBjb252NCA9IGV4dHJhY3RDb252UGFyYW1zKDY0LCAxMjgsIDIsICdvbmV0L2NvbnY0Jyk7XHJcbiAgICAgICAgdmFyIHByZWx1NF9hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcygxMjgsICdvbmV0L3ByZWx1NF9hbHBoYScpO1xyXG4gICAgICAgIHZhciBmYzEgPSBleHRyYWN0RkNQYXJhbXMoMTE1MiwgMjU2LCAnb25ldC9mYzEnKTtcclxuICAgICAgICB2YXIgcHJlbHU1X2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKDI1NiwgJ29uZXQvcHJlbHU1X2FscGhhJyk7XHJcbiAgICAgICAgdmFyIGZjMl8xID0gZXh0cmFjdEZDUGFyYW1zKDI1NiwgMiwgJ29uZXQvZmMyXzEnKTtcclxuICAgICAgICB2YXIgZmMyXzIgPSBleHRyYWN0RkNQYXJhbXMoMjU2LCA0LCAnb25ldC9mYzJfMicpO1xyXG4gICAgICAgIHZhciBmYzJfMyA9IGV4dHJhY3RGQ1BhcmFtcygyNTYsIDEwLCAnb25ldC9mYzJfMycpO1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2hhcmVkUGFyYW1zKSwgeyBjb252NDogY29udjQsIHByZWx1NF9hbHBoYTogcHJlbHU0X2FscGhhLCBmYzE6IGZjMSwgcHJlbHU1X2FscGhhOiBwcmVsdTVfYWxwaGEsIGZjMl8xOiBmYzJfMSwgZmMyXzI6IGZjMl8yLCBmYzJfMzogZmMyXzMgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RQTmV0UGFyYW1zOiBleHRyYWN0UE5ldFBhcmFtcyxcclxuICAgICAgICBleHRyYWN0Uk5ldFBhcmFtczogZXh0cmFjdFJOZXRQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdE9OZXRQYXJhbXM6IGV4dHJhY3RPTmV0UGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKHdlaWdodHMpIHtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSh3ZWlnaHRzKSwgZXh0cmFjdFdlaWdodHMgPSBfYS5leHRyYWN0V2VpZ2h0cywgZ2V0UmVtYWluaW5nV2VpZ2h0cyA9IF9hLmdldFJlbWFpbmluZ1dlaWdodHM7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9iID0gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpLCBleHRyYWN0UE5ldFBhcmFtcyA9IF9iLmV4dHJhY3RQTmV0UGFyYW1zLCBleHRyYWN0Uk5ldFBhcmFtcyA9IF9iLmV4dHJhY3RSTmV0UGFyYW1zLCBleHRyYWN0T05ldFBhcmFtcyA9IF9iLmV4dHJhY3RPTmV0UGFyYW1zO1xyXG4gICAgdmFyIHBuZXQgPSBleHRyYWN0UE5ldFBhcmFtcygpO1xyXG4gICAgdmFyIHJuZXQgPSBleHRyYWN0Uk5ldFBhcmFtcygpO1xyXG4gICAgdmFyIG9uZXQgPSBleHRyYWN0T05ldFBhcmFtcygpO1xyXG4gICAgaWYgKGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogXCIgKyBnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHBhcmFtczogeyBwbmV0OiBwbmV0LCBybmV0OiBybmV0LCBvbmV0OiBvbmV0IH0sIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zLmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzLCBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uJztcclxuZnVuY3Rpb24gZXh0cmFjdG9yc0ZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICB2YXIgZXh0cmFjdFdlaWdodEVudHJ5ID0gZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbnZQYXJhbXMocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvd2VpZ2h0c1wiLCA0LCBwcmVmaXggKyBcIi9maWx0ZXJzXCIpO1xyXG4gICAgICAgIHZhciBiaWFzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2JpYXNcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyczogZmlsdGVycywgYmlhczogYmlhcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZDUGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHZhciB3ZWlnaHRzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL3dlaWdodHNcIiwgMik7XHJcbiAgICAgICAgdmFyIGJpYXMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvYmlhc1wiLCAxKTtcclxuICAgICAgICByZXR1cm4geyB3ZWlnaHRzOiB3ZWlnaHRzLCBiaWFzOiBiaWFzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UFJlbHVQYXJhbXMocGFyYW1QYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RXZWlnaHRFbnRyeShwYXJhbVBhdGgsIDEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFNoYXJlZFBhcmFtcyhwcmVmaXgpIHtcclxuICAgICAgICB2YXIgY29udjEgPSBleHRyYWN0Q29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252MVwiKTtcclxuICAgICAgICB2YXIgcHJlbHUxX2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKHByZWZpeCArIFwiL3ByZWx1MV9hbHBoYVwiKTtcclxuICAgICAgICB2YXIgY29udjIgPSBleHRyYWN0Q29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252MlwiKTtcclxuICAgICAgICB2YXIgcHJlbHUyX2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKHByZWZpeCArIFwiL3ByZWx1Ml9hbHBoYVwiKTtcclxuICAgICAgICB2YXIgY29udjMgPSBleHRyYWN0Q29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252M1wiKTtcclxuICAgICAgICB2YXIgcHJlbHUzX2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKHByZWZpeCArIFwiL3ByZWx1M19hbHBoYVwiKTtcclxuICAgICAgICByZXR1cm4geyBjb252MTogY29udjEsIHByZWx1MV9hbHBoYTogcHJlbHUxX2FscGhhLCBjb252MjogY29udjIsIHByZWx1Ml9hbHBoYTogcHJlbHUyX2FscGhhLCBjb252MzogY29udjMsIHByZWx1M19hbHBoYTogcHJlbHUzX2FscGhhIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UE5ldFBhcmFtcygpIHtcclxuICAgICAgICB2YXIgc2hhcmVkUGFyYW1zID0gZXh0cmFjdFNoYXJlZFBhcmFtcygncG5ldCcpO1xyXG4gICAgICAgIHZhciBjb252NF8xID0gZXh0cmFjdENvbnZQYXJhbXMoJ3BuZXQvY29udjRfMScpO1xyXG4gICAgICAgIHZhciBjb252NF8yID0gZXh0cmFjdENvbnZQYXJhbXMoJ3BuZXQvY29udjRfMicpO1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2hhcmVkUGFyYW1zKSwgeyBjb252NF8xOiBjb252NF8xLCBjb252NF8yOiBjb252NF8yIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFJOZXRQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIHNoYXJlZFBhcmFtcyA9IGV4dHJhY3RTaGFyZWRQYXJhbXMoJ3JuZXQnKTtcclxuICAgICAgICB2YXIgZmMxID0gZXh0cmFjdEZDUGFyYW1zKCdybmV0L2ZjMScpO1xyXG4gICAgICAgIHZhciBwcmVsdTRfYWxwaGEgPSBleHRyYWN0UFJlbHVQYXJhbXMoJ3JuZXQvcHJlbHU0X2FscGhhJyk7XHJcbiAgICAgICAgdmFyIGZjMl8xID0gZXh0cmFjdEZDUGFyYW1zKCdybmV0L2ZjMl8xJyk7XHJcbiAgICAgICAgdmFyIGZjMl8yID0gZXh0cmFjdEZDUGFyYW1zKCdybmV0L2ZjMl8yJyk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzaGFyZWRQYXJhbXMpLCB7IGZjMTogZmMxLCBwcmVsdTRfYWxwaGE6IHByZWx1NF9hbHBoYSwgZmMyXzE6IGZjMl8xLCBmYzJfMjogZmMyXzIgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0T05ldFBhcmFtcygpIHtcclxuICAgICAgICB2YXIgc2hhcmVkUGFyYW1zID0gZXh0cmFjdFNoYXJlZFBhcmFtcygnb25ldCcpO1xyXG4gICAgICAgIHZhciBjb252NCA9IGV4dHJhY3RDb252UGFyYW1zKCdvbmV0L2NvbnY0Jyk7XHJcbiAgICAgICAgdmFyIHByZWx1NF9hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcygnb25ldC9wcmVsdTRfYWxwaGEnKTtcclxuICAgICAgICB2YXIgZmMxID0gZXh0cmFjdEZDUGFyYW1zKCdvbmV0L2ZjMScpO1xyXG4gICAgICAgIHZhciBwcmVsdTVfYWxwaGEgPSBleHRyYWN0UFJlbHVQYXJhbXMoJ29uZXQvcHJlbHU1X2FscGhhJyk7XHJcbiAgICAgICAgdmFyIGZjMl8xID0gZXh0cmFjdEZDUGFyYW1zKCdvbmV0L2ZjMl8xJyk7XHJcbiAgICAgICAgdmFyIGZjMl8yID0gZXh0cmFjdEZDUGFyYW1zKCdvbmV0L2ZjMl8yJyk7XHJcbiAgICAgICAgdmFyIGZjMl8zID0gZXh0cmFjdEZDUGFyYW1zKCdvbmV0L2ZjMl8zJyk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzaGFyZWRQYXJhbXMpLCB7IGNvbnY0OiBjb252NCwgcHJlbHU0X2FscGhhOiBwcmVsdTRfYWxwaGEsIGZjMTogZmMxLCBwcmVsdTVfYWxwaGE6IHByZWx1NV9hbHBoYSwgZmMyXzE6IGZjMl8xLCBmYzJfMjogZmMyXzIsIGZjMl8zOiBmYzJfMyB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdFBOZXRQYXJhbXM6IGV4dHJhY3RQTmV0UGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RSTmV0UGFyYW1zOiBleHRyYWN0Uk5ldFBhcmFtcyxcclxuICAgICAgICBleHRyYWN0T05ldFBhcmFtczogZXh0cmFjdE9OZXRQYXJhbXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCkge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RvcnNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RQTmV0UGFyYW1zID0gX2EuZXh0cmFjdFBOZXRQYXJhbXMsIGV4dHJhY3RSTmV0UGFyYW1zID0gX2EuZXh0cmFjdFJOZXRQYXJhbXMsIGV4dHJhY3RPTmV0UGFyYW1zID0gX2EuZXh0cmFjdE9OZXRQYXJhbXM7XHJcbiAgICB2YXIgcG5ldCA9IGV4dHJhY3RQTmV0UGFyYW1zKCk7XHJcbiAgICB2YXIgcm5ldCA9IGV4dHJhY3RSTmV0UGFyYW1zKCk7XHJcbiAgICB2YXIgb25ldCA9IGV4dHJhY3RPTmV0UGFyYW1zKCk7XHJcbiAgICBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgcmV0dXJuIHsgcGFyYW1zOiB7IHBuZXQ6IHBuZXQsIHJuZXQ6IHJuZXQsIG9uZXQ6IG9uZXQgfSwgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBnZXRTaXplc0ZvclNjYWxlKHNjYWxlLCBfYSkge1xyXG4gICAgdmFyIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWlnaHQ6IE1hdGguZmxvb3IoaGVpZ2h0ICogc2NhbGUpLFxyXG4gICAgICAgIHdpZHRoOiBNYXRoLmZsb29yKHdpZHRoICogc2NhbGUpXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFNpemVzRm9yU2NhbGUuanMubWFwIiwiaW1wb3J0IHsgTXRjbm4gfSBmcm9tICcuL010Y25uJztcclxuZXhwb3J0ICogZnJvbSAnLi9NdGNubic7XHJcbmV4cG9ydCAqIGZyb20gJy4vTXRjbm5PcHRpb25zJztcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU10Y25uKHdlaWdodHMpIHtcclxuICAgIHZhciBuZXQgPSBuZXcgTXRjbm4oKTtcclxuICAgIG5ldC5leHRyYWN0V2VpZ2h0cyh3ZWlnaHRzKTtcclxuICAgIHJldHVybiBuZXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh4KSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0Zi5tdWwodGYuc3ViKHgsIHRmLnNjYWxhcigxMjcuNSkpLCB0Zi5zY2FsYXIoMC4wMDc4MTI1KSk7IH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gcHJlbHUoeCwgYWxwaGEpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGYuYWRkKHRmLnJlbHUoeCksIHRmLm11bChhbHBoYSwgdGYubmVnKHRmLnJlbHUodGYubmVnKHgpKSkpKTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWx1LmpzLm1hcCIsImltcG9ydCB7IENFTExfU0laRSB9IGZyb20gJy4vY29uZmlnJztcclxuZXhwb3J0IGZ1bmN0aW9uIHB5cmFtaWREb3duKG1pbkZhY2VTaXplLCBzY2FsZUZhY3RvciwgZGltcykge1xyXG4gICAgdmFyIGhlaWdodCA9IGRpbXNbMF0sIHdpZHRoID0gZGltc1sxXTtcclxuICAgIHZhciBtID0gQ0VMTF9TSVpFIC8gbWluRmFjZVNpemU7XHJcbiAgICB2YXIgc2NhbGVzID0gW107XHJcbiAgICB2YXIgbWluTGF5ZXIgPSBNYXRoLm1pbihoZWlnaHQsIHdpZHRoKSAqIG07XHJcbiAgICB2YXIgZXhwID0gMDtcclxuICAgIHdoaWxlIChtaW5MYXllciA+PSAxMikge1xyXG4gICAgICAgIHNjYWxlcy5wdXNoKG0gKiBNYXRoLnBvdyhzY2FsZUZhY3RvciwgZXhwKSk7XHJcbiAgICAgICAgbWluTGF5ZXIgPSBtaW5MYXllciAqIHNjYWxlRmFjdG9yO1xyXG4gICAgICAgIGV4cCArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNjYWxlcztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1weXJhbWlkRG93bi5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBjb252TGF5ZXIgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBwcmVsdSB9IGZyb20gJy4vcHJlbHUnO1xyXG5leHBvcnQgZnVuY3Rpb24gc2hhcmVkTGF5ZXIoeCwgcGFyYW1zLCBpc1BuZXQpIHtcclxuICAgIGlmIChpc1BuZXQgPT09IHZvaWQgMCkgeyBpc1BuZXQgPSBmYWxzZTsgfVxyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQgPSBjb252TGF5ZXIoeCwgcGFyYW1zLmNvbnYxLCAndmFsaWQnKTtcclxuICAgICAgICBvdXQgPSBwcmVsdShvdXQsIHBhcmFtcy5wcmVsdTFfYWxwaGEpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBpc1BuZXQgPyBbMiwgMl0gOiBbMywgM10sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBjb252TGF5ZXIob3V0LCBwYXJhbXMuY29udjIsICd2YWxpZCcpO1xyXG4gICAgICAgIG91dCA9IHByZWx1KG91dCwgcGFyYW1zLnByZWx1Ml9hbHBoYSk7XHJcbiAgICAgICAgb3V0ID0gaXNQbmV0ID8gb3V0IDogdGYubWF4UG9vbChvdXQsIFszLCAzXSwgWzIsIDJdLCAndmFsaWQnKTtcclxuICAgICAgICBvdXQgPSBjb252TGF5ZXIob3V0LCBwYXJhbXMuY29udjMsICd2YWxpZCcpO1xyXG4gICAgICAgIG91dCA9IHByZWx1KG91dCwgcGFyYW1zLnByZWx1M19hbHBoYSk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlZExheWVycy5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBCb3VuZGluZ0JveCwgUG9pbnQgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgbm9uTWF4U3VwcHJlc3Npb24gfSBmcm9tICcuLi9vcHMnO1xyXG5pbXBvcnQgeyBDRUxMX1NJWkUsIENFTExfU1RSSURFIH0gZnJvbSAnLi9jb25maWcnO1xyXG5pbXBvcnQgeyBnZXRTaXplc0ZvclNjYWxlIH0gZnJvbSAnLi9nZXRTaXplc0ZvclNjYWxlJztcclxuaW1wb3J0IHsgTXRjbm5Cb3ggfSBmcm9tICcuL010Y25uQm94JztcclxuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi9ub3JtYWxpemUnO1xyXG5pbXBvcnQgeyBQTmV0IH0gZnJvbSAnLi9QTmV0JztcclxuZnVuY3Rpb24gcmVzY2FsZUFuZE5vcm1hbGl6ZSh4LCBzY2FsZSkge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IGdldFNpemVzRm9yU2NhbGUoc2NhbGUsIHguc2hhcGUuc2xpY2UoMSkpLCBoZWlnaHQgPSBfYS5oZWlnaHQsIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdmFyIHJlc2l6ZWQgPSB0Zi5pbWFnZS5yZXNpemVCaWxpbmVhcih4LCBbaGVpZ2h0LCB3aWR0aF0pO1xyXG4gICAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplKHJlc2l6ZWQpO1xyXG4gICAgICAgIHJldHVybiB0Zi50cmFuc3Bvc2Uobm9ybWFsaXplZCwgWzAsIDIsIDEsIDNdKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RCb3VuZGluZ0JveGVzKHNjb3Jlc1RlbnNvciwgcmVnaW9uc1RlbnNvciwgc2NhbGUsIHNjb3JlVGhyZXNob2xkKSB7XHJcbiAgICAvLyBUT0RPOiBmaXggdGhpcyEsIG1heWJlIGJldHRlciB0byB1c2UgdGYuZ2F0aGVyIGhlcmVcclxuICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICB2YXIgc2NvcmVzRGF0YSA9IHNjb3Jlc1RlbnNvci5hcnJheVN5bmMoKTtcclxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2NvcmVzVGVuc29yLnNoYXBlWzBdOyB5KyspIHtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHNjb3Jlc1RlbnNvci5zaGFwZVsxXTsgeCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChzY29yZXNEYXRhW3ldW3hdID49IHNjb3JlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2gobmV3IFBvaW50KHgsIHkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBib3VuZGluZ0JveGVzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgIHZhciBjZWxsID0gbmV3IEJvdW5kaW5nQm94KE1hdGgucm91bmQoKGlkeC55ICogQ0VMTF9TVFJJREUgKyAxKSAvIHNjYWxlKSwgTWF0aC5yb3VuZCgoaWR4LnggKiBDRUxMX1NUUklERSArIDEpIC8gc2NhbGUpLCBNYXRoLnJvdW5kKChpZHgueSAqIENFTExfU1RSSURFICsgQ0VMTF9TSVpFKSAvIHNjYWxlKSwgTWF0aC5yb3VuZCgoaWR4LnggKiBDRUxMX1NUUklERSArIENFTExfU0laRSkgLyBzY2FsZSkpO1xyXG4gICAgICAgIHZhciBzY29yZSA9IHNjb3Jlc0RhdGFbaWR4LnldW2lkeC54XTtcclxuICAgICAgICB2YXIgcmVnaW9uc0RhdGEgPSByZWdpb25zVGVuc29yLmFycmF5U3luYygpO1xyXG4gICAgICAgIHZhciByZWdpb24gPSBuZXcgTXRjbm5Cb3gocmVnaW9uc0RhdGFbaWR4LnldW2lkeC54XVswXSwgcmVnaW9uc0RhdGFbaWR4LnldW2lkeC54XVsxXSwgcmVnaW9uc0RhdGFbaWR4LnldW2lkeC54XVsyXSwgcmVnaW9uc0RhdGFbaWR4LnldW2lkeC54XVszXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2VsbDogY2VsbCxcclxuICAgICAgICAgICAgc2NvcmU6IHNjb3JlLFxyXG4gICAgICAgICAgICByZWdpb246IHJlZ2lvblxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBib3VuZGluZ0JveGVzO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFnZTEoaW1nVGVuc29yLCBzY2FsZXMsIHNjb3JlVGhyZXNob2xkLCBwYXJhbXMsIHN0YXRzKSB7XHJcbiAgICBzdGF0cy5zdGFnZTEgPSBbXTtcclxuICAgIHZhciBwbmV0T3V0cHV0cyA9IHNjYWxlcy5tYXAoZnVuY3Rpb24gKHNjYWxlKSB7IHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RhdHNGb3JTY2FsZSA9IHsgc2NhbGU6IHNjYWxlIH07XHJcbiAgICAgICAgdmFyIHJlc2l6ZWQgPSByZXNjYWxlQW5kTm9ybWFsaXplKGltZ1RlbnNvciwgc2NhbGUpO1xyXG4gICAgICAgIHZhciB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdmFyIF9hID0gUE5ldChyZXNpemVkLCBwYXJhbXMpLCBwcm9iID0gX2EucHJvYiwgcmVnaW9ucyA9IF9hLnJlZ2lvbnM7XHJcbiAgICAgICAgc3RhdHNGb3JTY2FsZS5wbmV0ID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgIHZhciBzY29yZXNUZW5zb3IgPSB0Zi51bnN0YWNrKHRmLnVuc3RhY2socHJvYiwgMylbMV0pWzBdO1xyXG4gICAgICAgIHZhciByZWdpb25zVGVuc29yID0gdGYudW5zdGFjayhyZWdpb25zKVswXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY29yZXNUZW5zb3I6IHNjb3Jlc1RlbnNvcixcclxuICAgICAgICAgICAgcmVnaW9uc1RlbnNvcjogcmVnaW9uc1RlbnNvcixcclxuICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgICAgICAgICBzdGF0c0ZvclNjYWxlOiBzdGF0c0ZvclNjYWxlXHJcbiAgICAgICAgfTtcclxuICAgIH0pOyB9KTtcclxuICAgIHZhciBib3hlc0ZvclNjYWxlID0gcG5ldE91dHB1dHMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBzY29yZXNUZW5zb3IgPSBfYS5zY29yZXNUZW5zb3IsIHJlZ2lvbnNUZW5zb3IgPSBfYS5yZWdpb25zVGVuc29yLCBzY2FsZSA9IF9hLnNjYWxlLCBzdGF0c0ZvclNjYWxlID0gX2Euc3RhdHNGb3JTY2FsZTtcclxuICAgICAgICB2YXIgYm91bmRpbmdCb3hlcyA9IGV4dHJhY3RCb3VuZGluZ0JveGVzKHNjb3Jlc1RlbnNvciwgcmVnaW9uc1RlbnNvciwgc2NhbGUsIHNjb3JlVGhyZXNob2xkKTtcclxuICAgICAgICBzY29yZXNUZW5zb3IuZGlzcG9zZSgpO1xyXG4gICAgICAgIHJlZ2lvbnNUZW5zb3IuZGlzcG9zZSgpO1xyXG4gICAgICAgIGlmICghYm91bmRpbmdCb3hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc3RhdHMuc3RhZ2UxLnB1c2goc3RhdHNGb3JTY2FsZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IG5vbk1heFN1cHByZXNzaW9uKGJvdW5kaW5nQm94ZXMubWFwKGZ1bmN0aW9uIChiYm94KSB7IHJldHVybiBiYm94LmNlbGw7IH0pLCBib3VuZGluZ0JveGVzLm1hcChmdW5jdGlvbiAoYmJveCkgeyByZXR1cm4gYmJveC5zY29yZTsgfSksIDAuNSk7XHJcbiAgICAgICAgc3RhdHNGb3JTY2FsZS5ubXMgPSBEYXRlLm5vdygpIC0gdHM7XHJcbiAgICAgICAgc3RhdHNGb3JTY2FsZS5udW1Cb3hlcyA9IGluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHN0YXRzLnN0YWdlMS5wdXNoKHN0YXRzRm9yU2NhbGUpO1xyXG4gICAgICAgIHJldHVybiBpbmRpY2VzLm1hcChmdW5jdGlvbiAoYm94SWR4KSB7IHJldHVybiBib3VuZGluZ0JveGVzW2JveElkeF07IH0pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgYWxsQm94ZXMgPSBib3hlc0ZvclNjYWxlLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBib3hlcykgeyByZXR1cm4gYWxsLmNvbmNhdChib3hlcyk7IH0sIFtdKTtcclxuICAgIHZhciBmaW5hbEJveGVzID0gW107XHJcbiAgICB2YXIgZmluYWxTY29yZXMgPSBbXTtcclxuICAgIGlmIChhbGxCb3hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIHRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IG5vbk1heFN1cHByZXNzaW9uKGFsbEJveGVzLm1hcChmdW5jdGlvbiAoYmJveCkgeyByZXR1cm4gYmJveC5jZWxsOyB9KSwgYWxsQm94ZXMubWFwKGZ1bmN0aW9uIChiYm94KSB7IHJldHVybiBiYm94LnNjb3JlOyB9KSwgMC43KTtcclxuICAgICAgICBzdGF0cy5zdGFnZTFfbm1zID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgIGZpbmFsU2NvcmVzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gYWxsQm94ZXNbaWR4XS5zY29yZTsgfSk7XHJcbiAgICAgICAgZmluYWxCb3hlcyA9IGluZGljZXNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBhbGxCb3hlc1tpZHhdOyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgY2VsbCA9IF9hLmNlbGwsIHJlZ2lvbiA9IF9hLnJlZ2lvbjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjZWxsLmxlZnQgKyAocmVnaW9uLmxlZnQgKiBjZWxsLndpZHRoKSwgY2VsbC50b3AgKyAocmVnaW9uLnRvcCAqIGNlbGwuaGVpZ2h0KSwgY2VsbC5yaWdodCArIChyZWdpb24ucmlnaHQgKiBjZWxsLndpZHRoKSwgY2VsbC5ib3R0b20gKyAocmVnaW9uLmJvdHRvbSAqIGNlbGwuaGVpZ2h0KSkudG9TcXVhcmUoKS5yb3VuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBib3hlczogZmluYWxCb3hlcyxcclxuICAgICAgICBzY29yZXM6IGZpbmFsU2NvcmVzXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YWdlMS5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IG5vbk1heFN1cHByZXNzaW9uIH0gZnJvbSAnLi4vb3BzJztcclxuaW1wb3J0IHsgZXh0cmFjdEltYWdlUGF0Y2hlcyB9IGZyb20gJy4vZXh0cmFjdEltYWdlUGF0Y2hlcyc7XHJcbmltcG9ydCB7IE10Y25uQm94IH0gZnJvbSAnLi9NdGNubkJveCc7XHJcbmltcG9ydCB7IFJOZXQgfSBmcm9tICcuL1JOZXQnO1xyXG5leHBvcnQgZnVuY3Rpb24gc3RhZ2UyKGltZywgaW5wdXRCb3hlcywgc2NvcmVUaHJlc2hvbGQsIHBhcmFtcywgc3RhdHMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHMsIHJuZXRJbnB1dHMsIHJuZXRPdXRzLCBzY29yZXNUZW5zb3IsIHNjb3JlcywgX2EsIF9iLCBpbmRpY2VzLCBmaWx0ZXJlZEJveGVzLCBmaWx0ZXJlZFNjb3JlcywgZmluYWxCb3hlcywgZmluYWxTY29yZXMsIGluZGljZXNObXMsIHJlZ2lvbnNfMTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdEltYWdlUGF0Y2hlcyhpbWcsIGlucHV0Qm94ZXMsIHsgd2lkdGg6IDI0LCBoZWlnaHQ6IDI0IH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBybmV0SW5wdXRzID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN0YWdlMl9leHRyYWN0SW1hZ2VQYXRjaGVzID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICBybmV0T3V0cyA9IHJuZXRJbnB1dHMubWFwKGZ1bmN0aW9uIChybmV0SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFJOZXQocm5ldElucHV0LCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBybmV0SW5wdXQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN0YWdlMl9ybmV0ID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3Jlc1RlbnNvciA9IHJuZXRPdXRzLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0Zi5jb25jYXQocm5ldE91dHMubWFwKGZ1bmN0aW9uIChvdXQpIHsgcmV0dXJuIG91dC5zY29yZXM7IH0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJuZXRPdXRzWzBdLnNjb3JlcztcclxuICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IEFycmF5KS5mcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNjb3Jlc1RlbnNvci5kYXRhKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlcyA9IF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVzVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzID0gc2NvcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNjb3JlLCBpZHgpIHsgcmV0dXJuICh7IHNjb3JlOiBzY29yZSwgaWR4OiBpZHggfSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc2NvcmUgPiBzY29yZVRocmVzaG9sZDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IF9hLmlkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEJveGVzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gaW5wdXRCb3hlc1tpZHhdOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFNjb3JlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIHNjb3Jlc1tpZHhdOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbEJveGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTY29yZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRCb3hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc05tcyA9IG5vbk1heFN1cHByZXNzaW9uKGZpbHRlcmVkQm94ZXMsIGZpbHRlcmVkU2NvcmVzLCAwLjcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdGFnZTJfbm1zID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb25zXzEgPSBpbmRpY2VzTm1zLm1hcChmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uc0RhdGEgPSBybmV0T3V0c1tpbmRpY2VzW2lkeF1dLnJlZ2lvbnMuYXJyYXlTeW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE10Y25uQm94KHJlZ2lvbnNEYXRhWzBdWzBdLCByZWdpb25zRGF0YVswXVsxXSwgcmVnaW9uc0RhdGFbMF1bMl0sIHJlZ2lvbnNEYXRhWzBdWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsU2NvcmVzID0gaW5kaWNlc05tcy5tYXAoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gZmlsdGVyZWRTY29yZXNbaWR4XTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQm94ZXMgPSBpbmRpY2VzTm1zLm1hcChmdW5jdGlvbiAoaWR4LCBpKSB7IHJldHVybiBmaWx0ZXJlZEJveGVzW2lkeF0uY2FsaWJyYXRlKHJlZ2lvbnNfMVtpXSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBybmV0T3V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucmVnaW9ucy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuc2NvcmVzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94ZXM6IGZpbmFsQm94ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZXM6IGZpbmFsU2NvcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFnZTIuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5pbXBvcnQgeyBub25NYXhTdXBwcmVzc2lvbiB9IGZyb20gJy4uL29wcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RJbWFnZVBhdGNoZXMgfSBmcm9tICcuL2V4dHJhY3RJbWFnZVBhdGNoZXMnO1xyXG5pbXBvcnQgeyBNdGNubkJveCB9IGZyb20gJy4vTXRjbm5Cb3gnO1xyXG5pbXBvcnQgeyBPTmV0IH0gZnJvbSAnLi9PTmV0JztcclxuZXhwb3J0IGZ1bmN0aW9uIHN0YWdlMyhpbWcsIGlucHV0Qm94ZXMsIHNjb3JlVGhyZXNob2xkLCBwYXJhbXMsIHN0YXRzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRzLCBvbmV0SW5wdXRzLCBvbmV0T3V0cywgc2NvcmVzVGVuc29yLCBzY29yZXMsIF9hLCBfYiwgaW5kaWNlcywgZmlsdGVyZWRSZWdpb25zLCBmaWx0ZXJlZEJveGVzLCBmaWx0ZXJlZFNjb3JlcywgZmluYWxCb3hlcywgZmluYWxTY29yZXMsIHBvaW50cywgaW5kaWNlc05tcztcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdEltYWdlUGF0Y2hlcyhpbWcsIGlucHV0Qm94ZXMsIHsgd2lkdGg6IDQ4LCBoZWlnaHQ6IDQ4IH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBvbmV0SW5wdXRzID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN0YWdlM19leHRyYWN0SW1hZ2VQYXRjaGVzID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICBvbmV0T3V0cyA9IG9uZXRJbnB1dHMubWFwKGZ1bmN0aW9uIChvbmV0SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IE9OZXQob25ldElucHV0LCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmV0SW5wdXQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN0YWdlM19vbmV0ID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3Jlc1RlbnNvciA9IG9uZXRPdXRzLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0Zi5jb25jYXQob25ldE91dHMubWFwKGZ1bmN0aW9uIChvdXQpIHsgcmV0dXJuIG91dC5zY29yZXM7IH0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9uZXRPdXRzWzBdLnNjb3JlcztcclxuICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IEFycmF5KS5mcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNjb3Jlc1RlbnNvci5kYXRhKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlcyA9IF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVzVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzID0gc2NvcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNjb3JlLCBpZHgpIHsgcmV0dXJuICh7IHNjb3JlOiBzY29yZSwgaWR4OiBpZHggfSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc2NvcmUgPiBzY29yZVRocmVzaG9sZDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IF9hLmlkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFJlZ2lvbnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb25zRGF0YSA9IG9uZXRPdXRzW2lkeF0ucmVnaW9ucy5hcnJheVN5bmMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNdGNubkJveChyZWdpb25zRGF0YVswXVswXSwgcmVnaW9uc0RhdGFbMF1bMV0sIHJlZ2lvbnNEYXRhWzBdWzJdLCByZWdpb25zRGF0YVswXVszXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCb3hlcyA9IGluZGljZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWR4LCBpKSB7IHJldHVybiBpbnB1dEJveGVzW2lkeF0uY2FsaWJyYXRlKGZpbHRlcmVkUmVnaW9uc1tpXSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkU2NvcmVzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gc2NvcmVzW2lkeF07IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQm94ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbFNjb3JlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZEJveGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzTm1zID0gbm9uTWF4U3VwcHJlc3Npb24oZmlsdGVyZWRCb3hlcywgZmlsdGVyZWRTY29yZXMsIDAuNywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdGFnZTNfbm1zID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEJveGVzID0gaW5kaWNlc05tcy5tYXAoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gZmlsdGVyZWRCb3hlc1tpZHhdOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxTY29yZXMgPSBpbmRpY2VzTm1zLm1hcChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBmaWx0ZXJlZFNjb3Jlc1tpZHhdOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gaW5kaWNlc05tcy5tYXAoZnVuY3Rpb24gKGlkeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5KDUpLmZpbGwoMCkubWFwKGZ1bmN0aW9uIChfLCBwdElkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHNEYXRhID0gb25ldE91dHNbaWR4XS5wb2ludHMuYXJyYXlTeW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgoKHBvaW50c0RhdGFbMF1bcHRJZHhdICogKGZpbmFsQm94ZXNbaV0ud2lkdGggKyAxKSkgKyBmaW5hbEJveGVzW2ldLmxlZnQpLCAoKHBvaW50c0RhdGFbMF1bcHRJZHggKyA1XSAqIChmaW5hbEJveGVzW2ldLmhlaWdodCArIDEpKSArIGZpbmFsQm94ZXNbaV0udG9wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uZXRPdXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5yZWdpb25zLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5zY29yZXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LnBvaW50cy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzOiBmaW5hbEJveGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzOiBmaW5hbFNjb3JlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFnZTMuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9pb3UnO1xyXG5leHBvcnQgKiBmcm9tICcuL21pbkJib3gnO1xyXG5leHBvcnQgKiBmcm9tICcuL25vbk1heFN1cHByZXNzaW9uJztcclxuZXhwb3J0ICogZnJvbSAnLi9ub3JtYWxpemUnO1xyXG5leHBvcnQgKiBmcm9tICcuL3BhZFRvU3F1YXJlJztcclxuZXhwb3J0ICogZnJvbSAnLi9zaHVmZmxlQXJyYXknO1xyXG5leHBvcnQgZnVuY3Rpb24gc2lnbW9pZCh4KSB7XHJcbiAgICByZXR1cm4gMSAvICgxICsgTWF0aC5leHAoLXgpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZVNpZ21vaWQoeCkge1xyXG4gICAgcmV0dXJuIE1hdGgubG9nKHggLyAoMSAtIHgpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gaW91KGJveDEsIGJveDIsIGlzSU9VKSB7XHJcbiAgICBpZiAoaXNJT1UgPT09IHZvaWQgMCkgeyBpc0lPVSA9IHRydWU7IH1cclxuICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oYm94MS5yaWdodCwgYm94Mi5yaWdodCkgLSBNYXRoLm1heChib3gxLmxlZnQsIGJveDIubGVmdCkpO1xyXG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oYm94MS5ib3R0b20sIGJveDIuYm90dG9tKSAtIE1hdGgubWF4KGJveDEudG9wLCBib3gyLnRvcCkpO1xyXG4gICAgdmFyIGludGVyU2VjdGlvbiA9IHdpZHRoICogaGVpZ2h0O1xyXG4gICAgcmV0dXJuIGlzSU9VXHJcbiAgICAgICAgPyBpbnRlclNlY3Rpb24gLyAoYm94MS5hcmVhICsgYm94Mi5hcmVhIC0gaW50ZXJTZWN0aW9uKVxyXG4gICAgICAgIDogaW50ZXJTZWN0aW9uIC8gTWF0aC5taW4oYm94MS5hcmVhLCBib3gyLmFyZWEpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlvdS5qcy5tYXAiLCJpbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5leHBvcnQgZnVuY3Rpb24gbWluQmJveChwdHMpIHtcclxuICAgIHZhciB4cyA9IHB0cy5tYXAoZnVuY3Rpb24gKHB0KSB7IHJldHVybiBwdC54OyB9KTtcclxuICAgIHZhciB5cyA9IHB0cy5tYXAoZnVuY3Rpb24gKHB0KSB7IHJldHVybiBwdC55OyB9KTtcclxuICAgIHZhciBtaW5YID0geHMucmVkdWNlKGZ1bmN0aW9uIChtaW4sIHgpIHsgcmV0dXJuIHggPCBtaW4gPyB4IDogbWluOyB9LCBJbmZpbml0eSk7XHJcbiAgICB2YXIgbWluWSA9IHlzLnJlZHVjZShmdW5jdGlvbiAobWluLCB5KSB7IHJldHVybiB5IDwgbWluID8geSA6IG1pbjsgfSwgSW5maW5pdHkpO1xyXG4gICAgdmFyIG1heFggPSB4cy5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgeCkgeyByZXR1cm4gbWF4IDwgeCA/IHggOiBtYXg7IH0sIDApO1xyXG4gICAgdmFyIG1heFkgPSB5cy5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgeSkgeyByZXR1cm4gbWF4IDwgeSA/IHkgOiBtYXg7IH0sIDApO1xyXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1taW5CYm94LmpzLm1hcCIsImltcG9ydCB7IGlvdSB9IGZyb20gJy4vaW91JztcclxuZXhwb3J0IGZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uKGJveGVzLCBzY29yZXMsIGlvdVRocmVzaG9sZCwgaXNJT1UpIHtcclxuICAgIGlmIChpc0lPVSA9PT0gdm9pZCAwKSB7IGlzSU9VID0gdHJ1ZTsgfVxyXG4gICAgdmFyIGluZGljZXNTb3J0ZWRCeVNjb3JlID0gc2NvcmVzXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc2NvcmUsIGJveEluZGV4KSB7IHJldHVybiAoeyBzY29yZTogc2NvcmUsIGJveEluZGV4OiBib3hJbmRleCB9KTsgfSlcclxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7IHJldHVybiBjMS5zY29yZSAtIGMyLnNjb3JlOyB9KVxyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuYm94SW5kZXg7IH0pO1xyXG4gICAgdmFyIHBpY2sgPSBbXTtcclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyID0gaW5kaWNlc1NvcnRlZEJ5U2NvcmUucG9wKCk7XHJcbiAgICAgICAgcGljay5wdXNoKGN1cnIpO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gaW5kaWNlc1NvcnRlZEJ5U2NvcmU7XHJcbiAgICAgICAgdmFyIG91dHB1dHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGluZGljZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBjdXJyQm94ID0gYm94ZXNbY3Vycl07XHJcbiAgICAgICAgICAgIHZhciBpZHhCb3ggPSBib3hlc1tpZHhdO1xyXG4gICAgICAgICAgICBvdXRwdXRzLnB1c2goaW91KGN1cnJCb3gsIGlkeEJveCwgaXNJT1UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5kaWNlc1NvcnRlZEJ5U2NvcmUgPSBpbmRpY2VzU29ydGVkQnlTY29yZS5maWx0ZXIoZnVuY3Rpb24gKF8sIGopIHsgcmV0dXJuIG91dHB1dHNbal0gPD0gaW91VGhyZXNob2xkOyB9KTtcclxuICAgIH07XHJcbiAgICB3aGlsZSAoaW5kaWNlc1NvcnRlZEJ5U2NvcmUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIF9sb29wXzEoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwaWNrO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbk1heFN1cHByZXNzaW9uLmpzLm1hcCIsImltcG9ydCB7IF9fc3ByZWFkQXJyYXlzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoeCwgbWVhblJnYikge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByID0gbWVhblJnYlswXSwgZyA9IG1lYW5SZ2JbMV0sIGIgPSBtZWFuUmdiWzJdO1xyXG4gICAgICAgIHZhciBhdmdfciA9IHRmLmZpbGwoX19zcHJlYWRBcnJheXMoeC5zaGFwZS5zbGljZSgwLCAzKSwgWzFdKSwgcik7XHJcbiAgICAgICAgdmFyIGF2Z19nID0gdGYuZmlsbChfX3NwcmVhZEFycmF5cyh4LnNoYXBlLnNsaWNlKDAsIDMpLCBbMV0pLCBnKTtcclxuICAgICAgICB2YXIgYXZnX2IgPSB0Zi5maWxsKF9fc3ByZWFkQXJyYXlzKHguc2hhcGUuc2xpY2UoMCwgMyksIFsxXSksIGIpO1xyXG4gICAgICAgIHZhciBhdmdfcmdiID0gdGYuY29uY2F0KFthdmdfciwgYXZnX2csIGF2Z19iXSwgMyk7XHJcbiAgICAgICAgcmV0dXJuIHRmLnN1Yih4LCBhdmdfcmdiKTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG4vKipcclxuICogUGFkcyB0aGUgc21hbGxlciBkaW1lbnNpb24gb2YgYW4gaW1hZ2UgdGVuc29yIHdpdGggemVyb3MsIHN1Y2ggdGhhdCB3aWR0aCA9PT0gaGVpZ2h0LlxyXG4gKlxyXG4gKiBAcGFyYW0gaW1nVGVuc29yIFRoZSBpbWFnZSB0ZW5zb3IuXHJcbiAqIEBwYXJhbSBpc0NlbnRlckltYWdlIChvcHRpb25hbCwgZGVmYXVsdDogZmFsc2UpIElmIHRydWUsIGFkZCBhbiBlcXVhbCBhbW91bnQgb2YgcGFkZGluZyBvblxyXG4gKiBib3RoIHNpZGVzIG9mIHRoZSBtaW5vciBkaW1lbnNpb24gb29mIHRoZSBpbWFnZS5cclxuICogQHJldHVybnMgVGhlIHBhZGRlZCB0ZW5zb3Igd2l0aCB3aWR0aCA9PT0gaGVpZ2h0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhZFRvU3F1YXJlKGltZ1RlbnNvciwgaXNDZW50ZXJJbWFnZSkge1xyXG4gICAgaWYgKGlzQ2VudGVySW1hZ2UgPT09IHZvaWQgMCkgeyBpc0NlbnRlckltYWdlID0gZmFsc2U7IH1cclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSBpbWdUZW5zb3Iuc2hhcGUuc2xpY2UoMSksIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWdUZW5zb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaW1EaWZmID0gTWF0aC5hYnMoaGVpZ2h0IC0gd2lkdGgpO1xyXG4gICAgICAgIHZhciBwYWRkaW5nQW1vdW50ID0gTWF0aC5yb3VuZChkaW1EaWZmICogKGlzQ2VudGVySW1hZ2UgPyAwLjUgOiAxKSk7XHJcbiAgICAgICAgdmFyIHBhZGRpbmdBeGlzID0gaGVpZ2h0ID4gd2lkdGggPyAyIDogMTtcclxuICAgICAgICB2YXIgY3JlYXRlUGFkZGluZ1RlbnNvciA9IGZ1bmN0aW9uIChwYWRkaW5nQW1vdW50KSB7XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nVGVuc29yU2hhcGUgPSBpbWdUZW5zb3Iuc2hhcGUuc2xpY2UoKTtcclxuICAgICAgICAgICAgcGFkZGluZ1RlbnNvclNoYXBlW3BhZGRpbmdBeGlzXSA9IHBhZGRpbmdBbW91bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0Zi5maWxsKHBhZGRpbmdUZW5zb3JTaGFwZSwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcGFkZGluZ1RlbnNvckFwcGVuZCA9IGNyZWF0ZVBhZGRpbmdUZW5zb3IocGFkZGluZ0Ftb3VudCk7XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZ1BhZGRpbmdBbW91bnQgPSBkaW1EaWZmIC0gcGFkZGluZ1RlbnNvckFwcGVuZC5zaGFwZVtwYWRkaW5nQXhpc107XHJcbiAgICAgICAgdmFyIHBhZGRpbmdUZW5zb3JQcmVwZW5kID0gaXNDZW50ZXJJbWFnZSAmJiByZW1haW5pbmdQYWRkaW5nQW1vdW50XHJcbiAgICAgICAgICAgID8gY3JlYXRlUGFkZGluZ1RlbnNvcihyZW1haW5pbmdQYWRkaW5nQW1vdW50KVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgdmFyIHRlbnNvcnNUb1N0YWNrID0gW1xyXG4gICAgICAgICAgICBwYWRkaW5nVGVuc29yUHJlcGVuZCxcclxuICAgICAgICAgICAgaW1nVGVuc29yLFxyXG4gICAgICAgICAgICBwYWRkaW5nVGVuc29yQXBwZW5kXHJcbiAgICAgICAgXVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiAhIXQ7IH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudG9GbG9hdCgpOyB9KTtcclxuICAgICAgICByZXR1cm4gdGYuY29uY2F0KHRlbnNvcnNUb1N0YWNrLCBwYWRkaW5nQXhpcyk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWRUb1NxdWFyZS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gc2h1ZmZsZUFycmF5KGlucHV0QXJyYXkpIHtcclxuICAgIHZhciBhcnJheSA9IGlucHV0QXJyYXkuc2xpY2UoKTtcclxuICAgIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcclxuICAgICAgICB2YXIgeCA9IGFycmF5W2ldO1xyXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XHJcbiAgICAgICAgYXJyYXlbal0gPSB4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNodWZmbGVBcnJheS5qcy5tYXAiLCJpbXBvcnQgeyBEaW1lbnNpb25zIH0gZnJvbSAnLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4vY2xhc3Nlcy9GYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4vY2xhc3Nlcy9GYWNlTGFuZG1hcmtzJztcclxuaW1wb3J0IHsgZXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24sIGlzV2l0aEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuL2ZhY3Rvcmllcy9XaXRoRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IGV4dGVuZFdpdGhGYWNlTGFuZG1hcmtzLCBpc1dpdGhGYWNlTGFuZG1hcmtzIH0gZnJvbSAnLi9mYWN0b3JpZXMvV2l0aEZhY2VMYW5kbWFya3MnO1xyXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplUmVzdWx0cyhyZXN1bHRzLCBkaW1lbnNpb25zKSB7XHJcbiAgICB2YXIgX2EgPSBuZXcgRGltZW5zaW9ucyhkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzaXplUmVzdWx0cyAtIGludmFsaWQgZGltZW5zaW9uczogXCIgKyBKU09OLnN0cmluZ2lmeSh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gcmVzaXplUmVzdWx0cyhvYmosIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNXaXRoRmFjZUxhbmRtYXJrcyhyZXN1bHRzKSkge1xyXG4gICAgICAgIHZhciByZXNpemVkRGV0ZWN0aW9uID0gcmVzdWx0cy5kZXRlY3Rpb24uZm9yU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB2YXIgcmVzaXplZExhbmRtYXJrcyA9IHJlc3VsdHMudW5zaGlmdGVkTGFuZG1hcmtzLmZvclNpemUocmVzaXplZERldGVjdGlvbi5ib3gud2lkdGgsIHJlc2l6ZWREZXRlY3Rpb24uYm94LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFdpdGhGYWNlTGFuZG1hcmtzKGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uKHJlc3VsdHMsIHJlc2l6ZWREZXRlY3Rpb24pLCByZXNpemVkTGFuZG1hcmtzKTtcclxuICAgIH1cclxuICAgIGlmIChpc1dpdGhGYWNlRGV0ZWN0aW9uKHJlc3VsdHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uKHJlc3VsdHMsIHJlc3VsdHMuZGV0ZWN0aW9uLmZvclNpemUod2lkdGgsIGhlaWdodCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdHMgaW5zdGFuY2VvZiBGYWNlTGFuZG1hcmtzIHx8IHJlc3VsdHMgaW5zdGFuY2VvZiBGYWNlRGV0ZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMuZm9yU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2l6ZVJlc3VsdHMuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IHRvTmV0SW5wdXQgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBOZXVyYWxOZXR3b3JrIH0gZnJvbSAnLi4vTmV1cmFsTmV0d29yayc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXMgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAnO1xyXG5pbXBvcnQgeyBtb2JpbGVOZXRWMSB9IGZyb20gJy4vbW9iaWxlTmV0VjEnO1xyXG5pbXBvcnQgeyBub25NYXhTdXBwcmVzc2lvbiB9IGZyb20gJy4vbm9uTWF4U3VwcHJlc3Npb24nO1xyXG5pbXBvcnQgeyBvdXRwdXRMYXllciB9IGZyb20gJy4vb3V0cHV0TGF5ZXInO1xyXG5pbXBvcnQgeyBwcmVkaWN0aW9uTGF5ZXIgfSBmcm9tICcuL3ByZWRpY3Rpb25MYXllcic7XHJcbmltcG9ydCB7IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyB9IGZyb20gJy4vU3NkTW9iaWxlbmV0djFPcHRpb25zJztcclxudmFyIFNzZE1vYmlsZW5ldHYxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNzZE1vYmlsZW5ldHYxLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3NkTW9iaWxlbmV0djEoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdTc2RNb2JpbGVuZXR2MScpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBTc2RNb2JpbGVuZXR2MS5wcm90b3R5cGUuZm9yd2FyZElucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3NkTW9iaWxlbmV0djEgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmF0Y2hUZW5zb3IgPSBpbnB1dC50b0JhdGNoVGVuc29yKDUxMiwgZmFsc2UpLnRvRmxvYXQoKTtcclxuICAgICAgICAgICAgdmFyIHggPSB0Zi5zdWIodGYubXVsKGJhdGNoVGVuc29yLCB0Zi5zY2FsYXIoMC4wMDc4NDMxMzc3MTg3MzcxMjUpKSwgdGYuc2NhbGFyKDEpKTtcclxuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gbW9iaWxlTmV0VjEoeCwgcGFyYW1zLm1vYmlsZW5ldHYxKTtcclxuICAgICAgICAgICAgdmFyIF9hID0gcHJlZGljdGlvbkxheWVyKGZlYXR1cmVzLm91dCwgZmVhdHVyZXMuY29udjExLCBwYXJhbXMucHJlZGljdGlvbl9sYXllciksIGJveFByZWRpY3Rpb25zID0gX2EuYm94UHJlZGljdGlvbnMsIGNsYXNzUHJlZGljdGlvbnMgPSBfYS5jbGFzc1ByZWRpY3Rpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGF5ZXIoYm94UHJlZGljdGlvbnMsIGNsYXNzUHJlZGljdGlvbnMsIHBhcmFtcy5vdXRwdXRfbGF5ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFNzZE1vYmlsZW5ldHYxLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5mb3J3YXJkSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh0aGlzLCBbX2Iuc2VudCgpXSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTc2RNb2JpbGVuZXR2MS5wcm90b3R5cGUubG9jYXRlRmFjZXMgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBtYXhSZXN1bHRzLCBtaW5Db25maWRlbmNlLCBuZXRJbnB1dCwgX2IsIF9ib3hlcywgX3Njb3JlcywgYm94ZXMsIHNjb3JlcywgaSwgc2NvcmVzRGF0YSwgX2MsIF9kLCBpb3VUaHJlc2hvbGQsIGluZGljZXMsIHJlc2hhcGVkRGltcywgaW5wdXRTaXplLCBwYWRYLCBwYWRZLCBib3hlc0RhdGEsIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gbmV3IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyhvcHRpb25zKSwgbWF4UmVzdWx0cyA9IF9hLm1heFJlc3VsdHMsIG1pbkNvbmZpZGVuY2UgPSBfYS5taW5Db25maWRlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRJbnB1dCA9IF9lLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSB0aGlzLmZvcndhcmRJbnB1dChuZXRJbnB1dCksIF9ib3hlcyA9IF9iLmJveGVzLCBfc2NvcmVzID0gX2Iuc2NvcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlcyA9IF9ib3hlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzID0gX3Njb3Jlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IF9ib3hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JveGVzW2ldLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY29yZXNbaV0uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gKF9jID0gQXJyYXkpLmZyb207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNjb3Jlcy5kYXRhKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzRGF0YSA9IF9kLmFwcGx5KF9jLCBbX2Uuc2VudCgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlvdVRocmVzaG9sZCA9IDAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyA9IG5vbk1heFN1cHByZXNzaW9uKGJveGVzLCBzY29yZXNEYXRhLCBtYXhSZXN1bHRzLCBpb3VUaHJlc2hvbGQsIG1pbkNvbmZpZGVuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNoYXBlZERpbXMgPSBuZXRJbnB1dC5nZXRSZXNoYXBlZElucHV0RGltZW5zaW9ucygwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRTaXplID0gbmV0SW5wdXQuaW5wdXRTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRYID0gaW5wdXRTaXplIC8gcmVzaGFwZWREaW1zLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRZID0gaW5wdXRTaXplIC8gcmVzaGFwZWREaW1zLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94ZXNEYXRhID0gYm94ZXMuYXJyYXlTeW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBib3hlc0RhdGFbaWR4XVswXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oMS4wLCBib3hlc0RhdGFbaWR4XVsyXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0ubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCAqIHBhZFk7IH0pLCB0b3AgPSBfYVswXSwgYm90dG9tID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgYm94ZXNEYXRhW2lkeF1bMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDEuMCwgYm94ZXNEYXRhW2lkeF1bM10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgKiBwYWRYOyB9KSwgbGVmdCA9IF9iWzBdLCByaWdodCA9IF9iWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWNlRGV0ZWN0aW9uKHNjb3Jlc0RhdGFbaWR4XSwgbmV3IFJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ldElucHV0LmdldElucHV0SGVpZ2h0KDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXRJbnB1dC5nZXRJbnB1dFdpZHRoKDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdHNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTc2RNb2JpbGVuZXR2MS5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ3NzZF9tb2JpbGVuZXR2MV9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgU3NkTW9iaWxlbmV0djEucHJvdG90eXBlLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwID0gZnVuY3Rpb24gKHdlaWdodE1hcCkge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXApO1xyXG4gICAgfTtcclxuICAgIFNzZE1vYmlsZW5ldHYxLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3NkTW9iaWxlbmV0djE7XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBTc2RNb2JpbGVuZXR2MSB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Tc2RNb2JpbGVuZXR2MS5qcy5tYXAiLCJ2YXIgU3NkTW9iaWxlbmV0djFPcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3NkTW9iaWxlbmV0djFPcHRpb25zKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbkNvbmZpZGVuY2UgPSBfYi5taW5Db25maWRlbmNlLCBtYXhSZXN1bHRzID0gX2IubWF4UmVzdWx0cztcclxuICAgICAgICB0aGlzLl9uYW1lID0gJ1NzZE1vYmlsZW5ldHYxT3B0aW9ucyc7XHJcbiAgICAgICAgdGhpcy5fbWluQ29uZmlkZW5jZSA9IG1pbkNvbmZpZGVuY2UgfHwgMC41O1xyXG4gICAgICAgIHRoaXMuX21heFJlc3VsdHMgPSBtYXhSZXN1bHRzIHx8IDEwMDtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21pbkNvbmZpZGVuY2UgIT09ICdudW1iZXInIHx8IHRoaXMuX21pbkNvbmZpZGVuY2UgPD0gMCB8fCB0aGlzLl9taW5Db25maWRlbmNlID49IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX25hbWUgKyBcIiAtIGV4cGVjdGVkIG1pbkNvbmZpZGVuY2UgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21heFJlc3VsdHMgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBtYXhSZXN1bHRzIHRvIGJlIGEgbnVtYmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTc2RNb2JpbGVuZXR2MU9wdGlvbnMucHJvdG90eXBlLCBcIm1pbkNvbmZpZGVuY2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWluQ29uZmlkZW5jZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3NkTW9iaWxlbmV0djFPcHRpb25zLnByb3RvdHlwZSwgXCJtYXhSZXN1bHRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21heFJlc3VsdHM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFNzZE1vYmlsZW5ldHYxT3B0aW9ucztcclxufSgpKTtcclxuZXhwb3J0IHsgU3NkTW9iaWxlbmV0djFPcHRpb25zIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNzZE1vYmlsZW5ldHYxT3B0aW9ucy5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBjb252TGF5ZXIgfSBmcm9tICcuLi9jb21tb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gYm94UHJlZGljdGlvbkxheWVyKHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYXRjaFNpemUgPSB4LnNoYXBlWzBdO1xyXG4gICAgICAgIHZhciBib3hQcmVkaWN0aW9uRW5jb2RpbmcgPSB0Zi5yZXNoYXBlKGNvbnZMYXllcih4LCBwYXJhbXMuYm94X2VuY29kaW5nX3ByZWRpY3RvciksIFtiYXRjaFNpemUsIC0xLCAxLCA0XSk7XHJcbiAgICAgICAgdmFyIGNsYXNzUHJlZGljdGlvbiA9IHRmLnJlc2hhcGUoY29udkxheWVyKHgsIHBhcmFtcy5jbGFzc19wcmVkaWN0b3IpLCBbYmF0Y2hTaXplLCAtMSwgM10pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb25FbmNvZGluZzogYm94UHJlZGljdGlvbkVuY29kaW5nLFxyXG4gICAgICAgICAgICBjbGFzc1ByZWRpY3Rpb246IGNsYXNzUHJlZGljdGlvblxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib3hQcmVkaWN0aW9uTGF5ZXIuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZXh0cmFjdFdlaWdodHNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uJztcclxuZnVuY3Rpb24gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3REZXB0aHdpc2VDb252UGFyYW1zKG51bUNoYW5uZWxzLCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IHRmLnRlbnNvcjRkKGV4dHJhY3RXZWlnaHRzKDMgKiAzICogbnVtQ2hhbm5lbHMpLCBbMywgMywgbnVtQ2hhbm5lbHMsIDFdKTtcclxuICAgICAgICB2YXIgYmF0Y2hfbm9ybV9zY2FsZSA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKG51bUNoYW5uZWxzKSk7XHJcbiAgICAgICAgdmFyIGJhdGNoX25vcm1fb2Zmc2V0ID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMobnVtQ2hhbm5lbHMpKTtcclxuICAgICAgICB2YXIgYmF0Y2hfbm9ybV9tZWFuID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMobnVtQ2hhbm5lbHMpKTtcclxuICAgICAgICB2YXIgYmF0Y2hfbm9ybV92YXJpYW5jZSA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKG51bUNoYW5uZWxzKSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9maWx0ZXJzXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2JhdGNoX25vcm1fc2NhbGVcIiB9LCB7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvYmF0Y2hfbm9ybV9vZmZzZXRcIiB9LCB7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvYmF0Y2hfbm9ybV9tZWFuXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2JhdGNoX25vcm1fdmFyaWFuY2VcIiB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxyXG4gICAgICAgICAgICBiYXRjaF9ub3JtX3NjYWxlOiBiYXRjaF9ub3JtX3NjYWxlLFxyXG4gICAgICAgICAgICBiYXRjaF9ub3JtX29mZnNldDogYmF0Y2hfbm9ybV9vZmZzZXQsXHJcbiAgICAgICAgICAgIGJhdGNoX25vcm1fbWVhbjogYmF0Y2hfbm9ybV9tZWFuLFxyXG4gICAgICAgICAgICBiYXRjaF9ub3JtX3ZhcmlhbmNlOiBiYXRjaF9ub3JtX3ZhcmlhbmNlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXgsIGlzUG9pbnR3aXNlQ29udikge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGYudGVuc29yNGQoZXh0cmFjdFdlaWdodHMoY2hhbm5lbHNJbiAqIGNoYW5uZWxzT3V0ICogZmlsdGVyU2l6ZSAqIGZpbHRlclNpemUpLCBbZmlsdGVyU2l6ZSwgZmlsdGVyU2l6ZSwgY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXRdKTtcclxuICAgICAgICB2YXIgYmlhcyA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKGNoYW5uZWxzT3V0KSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9maWx0ZXJzXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL1wiICsgKGlzUG9pbnR3aXNlQ29udiA/ICdiYXRjaF9ub3JtX29mZnNldCcgOiAnYmlhcycpIH0pO1xyXG4gICAgICAgIHJldHVybiB7IGZpbHRlcnM6IGZpbHRlcnMsIGJpYXM6IGJpYXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgX2EgPSBleHRyYWN0Q29udlBhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgZmlsdGVyU2l6ZSwgbWFwcGVkUHJlZml4LCB0cnVlKSwgZmlsdGVycyA9IF9hLmZpbHRlcnMsIGJpYXMgPSBfYS5iaWFzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXHJcbiAgICAgICAgICAgIGJhdGNoX25vcm1fb2Zmc2V0OiBiaWFzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252UGFpclBhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGRlcHRod2lzZV9jb252ID0gZXh0cmFjdERlcHRod2lzZUNvbnZQYXJhbXMoY2hhbm5lbHNJbiwgbWFwcGVkUHJlZml4ICsgXCIvZGVwdGh3aXNlX2NvbnZcIik7XHJcbiAgICAgICAgdmFyIHBvaW50d2lzZV9jb252ID0gZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIDEsIG1hcHBlZFByZWZpeCArIFwiL3BvaW50d2lzZV9jb252XCIpO1xyXG4gICAgICAgIHJldHVybiB7IGRlcHRod2lzZV9jb252OiBkZXB0aHdpc2VfY29udiwgcG9pbnR3aXNlX2NvbnY6IHBvaW50d2lzZV9jb252IH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIGNvbnZfMCA9IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKDMsIDMyLCAzLCAnbW9iaWxlbmV0djEvY29udl8wJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMSA9IGV4dHJhY3RDb252UGFpclBhcmFtcygzMiwgNjQsICdtb2JpbGVuZXR2MS9jb252XzEnKTtcclxuICAgICAgICB2YXIgY29udl8yID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDY0LCAxMjgsICdtb2JpbGVuZXR2MS9jb252XzInKTtcclxuICAgICAgICB2YXIgY29udl8zID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDEyOCwgMTI4LCAnbW9iaWxlbmV0djEvY29udl8zJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfNCA9IGV4dHJhY3RDb252UGFpclBhcmFtcygxMjgsIDI1NiwgJ21vYmlsZW5ldHYxL2NvbnZfNCcpO1xyXG4gICAgICAgIHZhciBjb252XzUgPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoMjU2LCAyNTYsICdtb2JpbGVuZXR2MS9jb252XzUnKTtcclxuICAgICAgICB2YXIgY29udl82ID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDI1NiwgNTEyLCAnbW9iaWxlbmV0djEvY29udl82Jyk7XHJcbiAgICAgICAgdmFyIGNvbnZfNyA9IGV4dHJhY3RDb252UGFpclBhcmFtcyg1MTIsIDUxMiwgJ21vYmlsZW5ldHYxL2NvbnZfNycpO1xyXG4gICAgICAgIHZhciBjb252XzggPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoNTEyLCA1MTIsICdtb2JpbGVuZXR2MS9jb252XzgnKTtcclxuICAgICAgICB2YXIgY29udl85ID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDUxMiwgNTEyLCAnbW9iaWxlbmV0djEvY29udl85Jyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMTAgPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoNTEyLCA1MTIsICdtb2JpbGVuZXR2MS9jb252XzEwJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMTEgPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoNTEyLCA1MTIsICdtb2JpbGVuZXR2MS9jb252XzExJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMTIgPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoNTEyLCAxMDI0LCAnbW9iaWxlbmV0djEvY29udl8xMicpO1xyXG4gICAgICAgIHZhciBjb252XzEzID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDEwMjQsIDEwMjQsICdtb2JpbGVuZXR2MS9jb252XzEzJyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udl8wOiBjb252XzAsXHJcbiAgICAgICAgICAgIGNvbnZfMTogY29udl8xLFxyXG4gICAgICAgICAgICBjb252XzI6IGNvbnZfMixcclxuICAgICAgICAgICAgY29udl8zOiBjb252XzMsXHJcbiAgICAgICAgICAgIGNvbnZfNDogY29udl80LFxyXG4gICAgICAgICAgICBjb252XzU6IGNvbnZfNSxcclxuICAgICAgICAgICAgY29udl82OiBjb252XzYsXHJcbiAgICAgICAgICAgIGNvbnZfNzogY29udl83LFxyXG4gICAgICAgICAgICBjb252Xzg6IGNvbnZfOCxcclxuICAgICAgICAgICAgY29udl85OiBjb252XzksXHJcbiAgICAgICAgICAgIGNvbnZfMTA6IGNvbnZfMTAsXHJcbiAgICAgICAgICAgIGNvbnZfMTE6IGNvbnZfMTEsXHJcbiAgICAgICAgICAgIGNvbnZfMTI6IGNvbnZfMTIsXHJcbiAgICAgICAgICAgIGNvbnZfMTM6IGNvbnZfMTNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtcygpIHtcclxuICAgICAgICB2YXIgY29udl8wID0gZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoMTAyNCwgMjU2LCAxLCAncHJlZGljdGlvbl9sYXllci9jb252XzAnKTtcclxuICAgICAgICB2YXIgY29udl8xID0gZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoMjU2LCA1MTIsIDMsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfMScpO1xyXG4gICAgICAgIHZhciBjb252XzIgPSBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcyg1MTIsIDEyOCwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl8yJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMyA9IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKDEyOCwgMjU2LCAzLCAncHJlZGljdGlvbl9sYXllci9jb252XzMnKTtcclxuICAgICAgICB2YXIgY29udl80ID0gZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoMjU2LCAxMjgsIDEsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfNCcpO1xyXG4gICAgICAgIHZhciBjb252XzUgPSBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygxMjgsIDI1NiwgMywgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl81Jyk7XHJcbiAgICAgICAgdmFyIGNvbnZfNiA9IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKDI1NiwgNjQsIDEsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfNicpO1xyXG4gICAgICAgIHZhciBjb252XzcgPSBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcyg2NCwgMTI4LCAzLCAncHJlZGljdGlvbl9sYXllci9jb252XzcnKTtcclxuICAgICAgICB2YXIgYm94X2VuY29kaW5nXzBfcHJlZGljdG9yID0gZXh0cmFjdENvbnZQYXJhbXMoNTEyLCAxMiwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8wL2JveF9lbmNvZGluZ19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgY2xhc3NfcHJlZGljdG9yXzAgPSBleHRyYWN0Q29udlBhcmFtcyg1MTIsIDksIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMC9jbGFzc19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgYm94X2VuY29kaW5nXzFfcHJlZGljdG9yID0gZXh0cmFjdENvbnZQYXJhbXMoMTAyNCwgMjQsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMS9ib3hfZW5jb2RpbmdfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGNsYXNzX3ByZWRpY3Rvcl8xID0gZXh0cmFjdENvbnZQYXJhbXMoMTAyNCwgMTgsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMS9jbGFzc19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgYm94X2VuY29kaW5nXzJfcHJlZGljdG9yID0gZXh0cmFjdENvbnZQYXJhbXMoNTEyLCAyNCwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8yL2JveF9lbmNvZGluZ19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgY2xhc3NfcHJlZGljdG9yXzIgPSBleHRyYWN0Q29udlBhcmFtcyg1MTIsIDE4LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzIvY2xhc3NfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGJveF9lbmNvZGluZ18zX3ByZWRpY3RvciA9IGV4dHJhY3RDb252UGFyYW1zKDI1NiwgMjQsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMy9ib3hfZW5jb2RpbmdfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGNsYXNzX3ByZWRpY3Rvcl8zID0gZXh0cmFjdENvbnZQYXJhbXMoMjU2LCAxOCwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8zL2NsYXNzX3ByZWRpY3RvcicpO1xyXG4gICAgICAgIHZhciBib3hfZW5jb2RpbmdfNF9wcmVkaWN0b3IgPSBleHRyYWN0Q29udlBhcmFtcygyNTYsIDI0LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzQvYm94X2VuY29kaW5nX3ByZWRpY3RvcicpO1xyXG4gICAgICAgIHZhciBjbGFzc19wcmVkaWN0b3JfNCA9IGV4dHJhY3RDb252UGFyYW1zKDI1NiwgMTgsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfNC9jbGFzc19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgYm94X2VuY29kaW5nXzVfcHJlZGljdG9yID0gZXh0cmFjdENvbnZQYXJhbXMoMTI4LCAyNCwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl81L2JveF9lbmNvZGluZ19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgY2xhc3NfcHJlZGljdG9yXzUgPSBleHRyYWN0Q29udlBhcmFtcygxMjgsIDE4LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzUvY2xhc3NfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGJveF9wcmVkaWN0b3JfMCA9IHtcclxuICAgICAgICAgICAgYm94X2VuY29kaW5nX3ByZWRpY3RvcjogYm94X2VuY29kaW5nXzBfcHJlZGljdG9yLFxyXG4gICAgICAgICAgICBjbGFzc19wcmVkaWN0b3I6IGNsYXNzX3ByZWRpY3Rvcl8wXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYm94X3ByZWRpY3Rvcl8xID0ge1xyXG4gICAgICAgICAgICBib3hfZW5jb2RpbmdfcHJlZGljdG9yOiBib3hfZW5jb2RpbmdfMV9wcmVkaWN0b3IsXHJcbiAgICAgICAgICAgIGNsYXNzX3ByZWRpY3RvcjogY2xhc3NfcHJlZGljdG9yXzFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBib3hfcHJlZGljdG9yXzIgPSB7XHJcbiAgICAgICAgICAgIGJveF9lbmNvZGluZ19wcmVkaWN0b3I6IGJveF9lbmNvZGluZ18yX3ByZWRpY3RvcixcclxuICAgICAgICAgICAgY2xhc3NfcHJlZGljdG9yOiBjbGFzc19wcmVkaWN0b3JfMlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGJveF9wcmVkaWN0b3JfMyA9IHtcclxuICAgICAgICAgICAgYm94X2VuY29kaW5nX3ByZWRpY3RvcjogYm94X2VuY29kaW5nXzNfcHJlZGljdG9yLFxyXG4gICAgICAgICAgICBjbGFzc19wcmVkaWN0b3I6IGNsYXNzX3ByZWRpY3Rvcl8zXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYm94X3ByZWRpY3Rvcl80ID0ge1xyXG4gICAgICAgICAgICBib3hfZW5jb2RpbmdfcHJlZGljdG9yOiBib3hfZW5jb2RpbmdfNF9wcmVkaWN0b3IsXHJcbiAgICAgICAgICAgIGNsYXNzX3ByZWRpY3RvcjogY2xhc3NfcHJlZGljdG9yXzRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBib3hfcHJlZGljdG9yXzUgPSB7XHJcbiAgICAgICAgICAgIGJveF9lbmNvZGluZ19wcmVkaWN0b3I6IGJveF9lbmNvZGluZ181X3ByZWRpY3RvcixcclxuICAgICAgICAgICAgY2xhc3NfcHJlZGljdG9yOiBjbGFzc19wcmVkaWN0b3JfNVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udl8wOiBjb252XzAsXHJcbiAgICAgICAgICAgIGNvbnZfMTogY29udl8xLFxyXG4gICAgICAgICAgICBjb252XzI6IGNvbnZfMixcclxuICAgICAgICAgICAgY29udl8zOiBjb252XzMsXHJcbiAgICAgICAgICAgIGNvbnZfNDogY29udl80LFxyXG4gICAgICAgICAgICBjb252XzU6IGNvbnZfNSxcclxuICAgICAgICAgICAgY29udl82OiBjb252XzYsXHJcbiAgICAgICAgICAgIGNvbnZfNzogY29udl83LFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzA6IGJveF9wcmVkaWN0b3JfMCxcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl8xOiBib3hfcHJlZGljdG9yXzEsXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfMjogYm94X3ByZWRpY3Rvcl8yLFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzM6IGJveF9wcmVkaWN0b3JfMyxcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl80OiBib3hfcHJlZGljdG9yXzQsXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfNTogYm94X3ByZWRpY3Rvcl81XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zOiBleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtczogZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdFdlaWdodHNGYWN0b3J5KHdlaWdodHMpLCBleHRyYWN0V2VpZ2h0cyA9IF9hLmV4dHJhY3RXZWlnaHRzLCBnZXRSZW1haW5pbmdXZWlnaHRzID0gX2EuZ2V0UmVtYWluaW5nV2VpZ2h0cztcclxuICAgIHZhciBfYiA9IGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSwgZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zID0gX2IuZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zLCBleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zID0gX2IuZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtcztcclxuICAgIHZhciBtb2JpbGVuZXR2MSA9IGV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtcygpO1xyXG4gICAgdmFyIHByZWRpY3Rpb25fbGF5ZXIgPSBleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zKCk7XHJcbiAgICB2YXIgZXh0cmFfZGltID0gdGYudGVuc29yM2QoZXh0cmFjdFdlaWdodHMoNTExOCAqIDQpLCBbMSwgNTExOCwgNF0pO1xyXG4gICAgdmFyIG91dHB1dF9sYXllciA9IHtcclxuICAgICAgICBleHRyYV9kaW06IGV4dHJhX2RpbVxyXG4gICAgfTtcclxuICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogJ291dHB1dF9sYXllci9leHRyYV9kaW0nIH0pO1xyXG4gICAgaWYgKGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogXCIgKyBnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICAgIG1vYmlsZW5ldHYxOiBtb2JpbGVuZXR2MSxcclxuICAgICAgICAgICAgcHJlZGljdGlvbl9sYXllcjogcHJlZGljdGlvbl9sYXllcixcclxuICAgICAgICAgICAgb3V0cHV0X2xheWVyOiBvdXRwdXRfbGF5ZXJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3NcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtcy5qcy5tYXAiLCJpbXBvcnQgeyBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycywgZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGlzVGVuc29yM0QgfSBmcm9tICcuLi91dGlscyc7XHJcbmZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgdmFyIGV4dHJhY3RXZWlnaHRFbnRyeSA9IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKHByZWZpeCwgaWR4LCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9Db252MmRfXCIgKyBpZHggKyBcIl9wb2ludHdpc2Uvd2VpZ2h0c1wiLCA0LCBtYXBwZWRQcmVmaXggKyBcIi9maWx0ZXJzXCIpO1xyXG4gICAgICAgIHZhciBiYXRjaF9ub3JtX29mZnNldCA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9Db252MmRfXCIgKyBpZHggKyBcIl9wb2ludHdpc2UvY29udm9sdXRpb25fYm5fb2Zmc2V0XCIsIDEsIG1hcHBlZFByZWZpeCArIFwiL2JhdGNoX25vcm1fb2Zmc2V0XCIpO1xyXG4gICAgICAgIHJldHVybiB7IGZpbHRlcnM6IGZpbHRlcnMsIGJhdGNoX25vcm1fb2Zmc2V0OiBiYXRjaF9ub3JtX29mZnNldCB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbnZQYWlyUGFyYW1zKGlkeCkge1xyXG4gICAgICAgIHZhciBtYXBwZWRQcmVmaXggPSBcIm1vYmlsZW5ldHYxL2NvbnZfXCIgKyBpZHg7XHJcbiAgICAgICAgdmFyIHByZWZpeERlcHRod2lzZUNvbnYgPSBcIk1vYmlsZW5ldFYxL0NvbnYyZF9cIiArIGlkeCArIFwiX2RlcHRod2lzZVwiO1xyXG4gICAgICAgIHZhciBtYXBwZWRQcmVmaXhEZXB0aHdpc2VDb252ID0gbWFwcGVkUHJlZml4ICsgXCIvZGVwdGh3aXNlX2NvbnZcIjtcclxuICAgICAgICB2YXIgbWFwcGVkUHJlZml4UG9pbnR3aXNlQ29udiA9IG1hcHBlZFByZWZpeCArIFwiL3BvaW50d2lzZV9jb252XCI7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4RGVwdGh3aXNlQ29udiArIFwiL2RlcHRod2lzZV93ZWlnaHRzXCIsIDQsIG1hcHBlZFByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9maWx0ZXJzXCIpO1xyXG4gICAgICAgIHZhciBiYXRjaF9ub3JtX3NjYWxlID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9CYXRjaE5vcm0vZ2FtbWFcIiwgMSwgbWFwcGVkUHJlZml4RGVwdGh3aXNlQ29udiArIFwiL2JhdGNoX25vcm1fc2NhbGVcIik7XHJcbiAgICAgICAgdmFyIGJhdGNoX25vcm1fb2Zmc2V0ID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9CYXRjaE5vcm0vYmV0YVwiLCAxLCBtYXBwZWRQcmVmaXhEZXB0aHdpc2VDb252ICsgXCIvYmF0Y2hfbm9ybV9vZmZzZXRcIik7XHJcbiAgICAgICAgdmFyIGJhdGNoX25vcm1fbWVhbiA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXhEZXB0aHdpc2VDb252ICsgXCIvQmF0Y2hOb3JtL21vdmluZ19tZWFuXCIsIDEsIG1hcHBlZFByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9iYXRjaF9ub3JtX21lYW5cIik7XHJcbiAgICAgICAgdmFyIGJhdGNoX25vcm1fdmFyaWFuY2UgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4RGVwdGh3aXNlQ29udiArIFwiL0JhdGNoTm9ybS9tb3ZpbmdfdmFyaWFuY2VcIiwgMSwgbWFwcGVkUHJlZml4RGVwdGh3aXNlQ29udiArIFwiL2JhdGNoX25vcm1fdmFyaWFuY2VcIik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGVwdGh3aXNlX2NvbnY6IHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXHJcbiAgICAgICAgICAgICAgICBiYXRjaF9ub3JtX3NjYWxlOiBiYXRjaF9ub3JtX3NjYWxlLFxyXG4gICAgICAgICAgICAgICAgYmF0Y2hfbm9ybV9vZmZzZXQ6IGJhdGNoX25vcm1fb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgYmF0Y2hfbm9ybV9tZWFuOiBiYXRjaF9ub3JtX21lYW4sXHJcbiAgICAgICAgICAgICAgICBiYXRjaF9ub3JtX3ZhcmlhbmNlOiBiYXRjaF9ub3JtX3ZhcmlhbmNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBvaW50d2lzZV9jb252OiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygnTW9iaWxlbmV0VjEnLCBpZHgsIG1hcHBlZFByZWZpeFBvaW50d2lzZUNvbnYpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb252XzA6IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKCdNb2JpbGVuZXRWMScsIDAsICdtb2JpbGVuZXR2MS9jb252XzAnKSxcclxuICAgICAgICAgICAgY29udl8xOiBleHRyYWN0Q29udlBhaXJQYXJhbXMoMSksXHJcbiAgICAgICAgICAgIGNvbnZfMjogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDIpLFxyXG4gICAgICAgICAgICBjb252XzM6IGV4dHJhY3RDb252UGFpclBhcmFtcygzKSxcclxuICAgICAgICAgICAgY29udl80OiBleHRyYWN0Q29udlBhaXJQYXJhbXMoNCksXHJcbiAgICAgICAgICAgIGNvbnZfNTogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDUpLFxyXG4gICAgICAgICAgICBjb252XzY6IGV4dHJhY3RDb252UGFpclBhcmFtcyg2KSxcclxuICAgICAgICAgICAgY29udl83OiBleHRyYWN0Q29udlBhaXJQYXJhbXMoNyksXHJcbiAgICAgICAgICAgIGNvbnZfODogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDgpLFxyXG4gICAgICAgICAgICBjb252Xzk6IGV4dHJhY3RDb252UGFpclBhcmFtcyg5KSxcclxuICAgICAgICAgICAgY29udl8xMDogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDEwKSxcclxuICAgICAgICAgICAgY29udl8xMTogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDExKSxcclxuICAgICAgICAgICAgY29udl8xMjogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDEyKSxcclxuICAgICAgICAgICAgY29udl8xMzogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDEzKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Q29udlBhcmFtcyhwcmVmaXgsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL3dlaWdodHNcIiwgNCwgbWFwcGVkUHJlZml4ICsgXCIvZmlsdGVyc1wiKTtcclxuICAgICAgICB2YXIgYmlhcyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9iaWFzZXNcIiwgMSwgbWFwcGVkUHJlZml4ICsgXCIvYmlhc1wiKTtcclxuICAgICAgICByZXR1cm4geyBmaWx0ZXJzOiBmaWx0ZXJzLCBiaWFzOiBiaWFzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Qm94UHJlZGljdG9yUGFyYW1zKGlkeCkge1xyXG4gICAgICAgIHZhciBib3hfZW5jb2RpbmdfcHJlZGljdG9yID0gZXh0cmFjdENvbnZQYXJhbXMoXCJQcmVkaWN0aW9uL0JveFByZWRpY3Rvcl9cIiArIGlkeCArIFwiL0JveEVuY29kaW5nUHJlZGljdG9yXCIsIFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yX1wiICsgaWR4ICsgXCIvYm94X2VuY29kaW5nX3ByZWRpY3RvclwiKTtcclxuICAgICAgICB2YXIgY2xhc3NfcHJlZGljdG9yID0gZXh0cmFjdENvbnZQYXJhbXMoXCJQcmVkaWN0aW9uL0JveFByZWRpY3Rvcl9cIiArIGlkeCArIFwiL0NsYXNzUHJlZGljdG9yXCIsIFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yX1wiICsgaWR4ICsgXCIvY2xhc3NfcHJlZGljdG9yXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGJveF9lbmNvZGluZ19wcmVkaWN0b3I6IGJveF9lbmNvZGluZ19wcmVkaWN0b3IsIGNsYXNzX3ByZWRpY3RvcjogY2xhc3NfcHJlZGljdG9yIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbnZfMDogZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoJ1ByZWRpY3Rpb24nLCAwLCAncHJlZGljdGlvbl9sYXllci9jb252XzAnKSxcclxuICAgICAgICAgICAgY29udl8xOiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygnUHJlZGljdGlvbicsIDEsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfMScpLFxyXG4gICAgICAgICAgICBjb252XzI6IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKCdQcmVkaWN0aW9uJywgMiwgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl8yJyksXHJcbiAgICAgICAgICAgIGNvbnZfMzogZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoJ1ByZWRpY3Rpb24nLCAzLCAncHJlZGljdGlvbl9sYXllci9jb252XzMnKSxcclxuICAgICAgICAgICAgY29udl80OiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygnUHJlZGljdGlvbicsIDQsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfNCcpLFxyXG4gICAgICAgICAgICBjb252XzU6IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKCdQcmVkaWN0aW9uJywgNSwgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl81JyksXHJcbiAgICAgICAgICAgIGNvbnZfNjogZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoJ1ByZWRpY3Rpb24nLCA2LCAncHJlZGljdGlvbl9sYXllci9jb252XzYnKSxcclxuICAgICAgICAgICAgY29udl83OiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygnUHJlZGljdGlvbicsIDcsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfNycpLFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzA6IGV4dHJhY3RCb3hQcmVkaWN0b3JQYXJhbXMoMCksXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfMTogZXh0cmFjdEJveFByZWRpY3RvclBhcmFtcygxKSxcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl8yOiBleHRyYWN0Qm94UHJlZGljdG9yUGFyYW1zKDIpLFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzM6IGV4dHJhY3RCb3hQcmVkaWN0b3JQYXJhbXMoMyksXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfNDogZXh0cmFjdEJveFByZWRpY3RvclBhcmFtcyg0KSxcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl81OiBleHRyYWN0Qm94UHJlZGljdG9yUGFyYW1zKDUpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zOiBleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtczogZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdG9yc0ZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSwgZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zID0gX2EuZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zLCBleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zID0gX2EuZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtcztcclxuICAgIHZhciBleHRyYV9kaW0gPSB3ZWlnaHRNYXBbJ091dHB1dC9leHRyYV9kaW0nXTtcclxuICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IG9yaWdpbmFsUGF0aDogJ091dHB1dC9leHRyYV9kaW0nLCBwYXJhbVBhdGg6ICdvdXRwdXRfbGF5ZXIvZXh0cmFfZGltJyB9KTtcclxuICAgIGlmICghaXNUZW5zb3IzRChleHRyYV9kaW0pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgd2VpZ2h0TWFwWydPdXRwdXQvZXh0cmFfZGltJ10gdG8gYmUgYSBUZW5zb3IzRCwgaW5zdGVhZCBoYXZlIFwiICsgZXh0cmFfZGltKTtcclxuICAgIH1cclxuICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgbW9iaWxlbmV0djE6IGV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtcygpLFxyXG4gICAgICAgIHByZWRpY3Rpb25fbGF5ZXI6IGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXMoKSxcclxuICAgICAgICBvdXRwdXRfbGF5ZXI6IHtcclxuICAgICAgICAgICAgZXh0cmFfZGltOiBleHRyYV9kaW1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IFNzZE1vYmlsZW5ldHYxIH0gZnJvbSAnLi9Tc2RNb2JpbGVuZXR2MSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vU3NkTW9iaWxlbmV0djEnO1xyXG5leHBvcnQgKiBmcm9tICcuL1NzZE1vYmlsZW5ldHYxT3B0aW9ucyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTc2RNb2JpbGVuZXR2MSh3ZWlnaHRzKSB7XHJcbiAgICB2YXIgbmV0ID0gbmV3IFNzZE1vYmlsZW5ldHYxKCk7XHJcbiAgICBuZXQuZXh0cmFjdFdlaWdodHMod2VpZ2h0cyk7XHJcbiAgICByZXR1cm4gbmV0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGYWNlRGV0ZWN0aW9uTmV0KHdlaWdodHMpIHtcclxuICAgIHJldHVybiBjcmVhdGVTc2RNb2JpbGVuZXR2MSh3ZWlnaHRzKTtcclxufVxyXG4vLyBhbGlhcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbHlcclxudmFyIEZhY2VEZXRlY3Rpb25OZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZURldGVjdGlvbk5ldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VEZXRlY3Rpb25OZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEZhY2VEZXRlY3Rpb25OZXQ7XHJcbn0oU3NkTW9iaWxlbmV0djEpKTtcclxuZXhwb3J0IHsgRmFjZURldGVjdGlvbk5ldCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBwb2ludHdpc2VDb252TGF5ZXIgfSBmcm9tICcuL3BvaW50d2lzZUNvbnZMYXllcic7XHJcbnZhciBlcHNpbG9uID0gMC4wMDEwMDAwMDAwNDc0OTc0NTEzO1xyXG5mdW5jdGlvbiBkZXB0aHdpc2VDb252TGF5ZXIoeCwgcGFyYW1zLCBzdHJpZGVzKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IHRmLmRlcHRod2lzZUNvbnYyZCh4LCBwYXJhbXMuZmlsdGVycywgc3RyaWRlcywgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSB0Zi5iYXRjaE5vcm0ob3V0LCBwYXJhbXMuYmF0Y2hfbm9ybV9tZWFuLCBwYXJhbXMuYmF0Y2hfbm9ybV92YXJpYW5jZSwgcGFyYW1zLmJhdGNoX25vcm1fb2Zmc2V0LCBwYXJhbXMuYmF0Y2hfbm9ybV9zY2FsZSwgZXBzaWxvbik7XHJcbiAgICAgICAgcmV0dXJuIHRmLmNsaXBCeVZhbHVlKG91dCwgMCwgNik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRTdHJpZGVzRm9yTGF5ZXJJZHgobGF5ZXJJZHgpIHtcclxuICAgIHJldHVybiBbMiwgNCwgNiwgMTJdLnNvbWUoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gaWR4ID09PSBsYXllcklkeDsgfSkgPyBbMiwgMl0gOiBbMSwgMV07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG1vYmlsZU5ldFYxKHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb252MTEgPSBudWxsO1xyXG4gICAgICAgIHZhciBvdXQgPSBwb2ludHdpc2VDb252TGF5ZXIoeCwgcGFyYW1zLmNvbnZfMCwgWzIsIDJdKTtcclxuICAgICAgICB2YXIgY29udlBhaXJQYXJhbXMgPSBbXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzEsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzIsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzMsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzQsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzUsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzYsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzcsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzgsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzksXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzEwLFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl8xMSxcclxuICAgICAgICAgICAgcGFyYW1zLmNvbnZfMTIsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzEzXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb252UGFpclBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaSkge1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXJJZHggPSBpICsgMTtcclxuICAgICAgICAgICAgdmFyIGRlcHRod2lzZUNvbnZTdHJpZGVzID0gZ2V0U3RyaWRlc0ZvckxheWVySWR4KGxheWVySWR4KTtcclxuICAgICAgICAgICAgb3V0ID0gZGVwdGh3aXNlQ29udkxheWVyKG91dCwgcGFyYW0uZGVwdGh3aXNlX2NvbnYsIGRlcHRod2lzZUNvbnZTdHJpZGVzKTtcclxuICAgICAgICAgICAgb3V0ID0gcG9pbnR3aXNlQ29udkxheWVyKG91dCwgcGFyYW0ucG9pbnR3aXNlX2NvbnYsIFsxLCAxXSk7XHJcbiAgICAgICAgICAgIGlmIChsYXllcklkeCA9PT0gMTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnYxMSA9IG91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjb252MTEgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2JpbGVOZXRWMSAtIG91dHB1dCBvZiBjb252IGxheWVyIDExIGlzIG51bGwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3V0OiBvdXQsXHJcbiAgICAgICAgICAgIGNvbnYxMTogY29udjExXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vYmlsZU5ldFYxLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBub25NYXhTdXBwcmVzc2lvbihib3hlcywgc2NvcmVzLCBtYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKSB7XHJcbiAgICB2YXIgbnVtQm94ZXMgPSBib3hlcy5zaGFwZVswXTtcclxuICAgIHZhciBvdXRwdXRTaXplID0gTWF0aC5taW4obWF4T3V0cHV0U2l6ZSwgbnVtQm94ZXMpO1xyXG4gICAgdmFyIGNhbmRpZGF0ZXMgPSBzY29yZXNcclxuICAgICAgICAubWFwKGZ1bmN0aW9uIChzY29yZSwgYm94SW5kZXgpIHsgcmV0dXJuICh7IHNjb3JlOiBzY29yZSwgYm94SW5kZXg6IGJveEluZGV4IH0pOyB9KVxyXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc2NvcmUgPiBzY29yZVRocmVzaG9sZDsgfSlcclxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7IHJldHVybiBjMi5zY29yZSAtIGMxLnNjb3JlOyB9KTtcclxuICAgIHZhciBzdXBwcmVzc0Z1bmMgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA8PSBpb3VUaHJlc2hvbGQgPyAxIDogMDsgfTtcclxuICAgIHZhciBzZWxlY3RlZCA9IFtdO1xyXG4gICAgY2FuZGlkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkLmxlbmd0aCA+PSBvdXRwdXRTaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsU2NvcmUgPSBjLnNjb3JlO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBzZWxlY3RlZC5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xyXG4gICAgICAgICAgICB2YXIgaW91ID0gSU9VKGJveGVzLCBjLmJveEluZGV4LCBzZWxlY3RlZFtqXSk7XHJcbiAgICAgICAgICAgIGlmIChpb3UgPT09IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYy5zY29yZSAqPSBzdXBwcmVzc0Z1bmMoaW91KTtcclxuICAgICAgICAgICAgaWYgKGMuc2NvcmUgPD0gc2NvcmVUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnaW5hbFNjb3JlID09PSBjLnNjb3JlKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkLnB1c2goYy5ib3hJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbn1cclxuZnVuY3Rpb24gSU9VKGJveGVzLCBpLCBqKSB7XHJcbiAgICB2YXIgYm94ZXNEYXRhID0gYm94ZXMuYXJyYXlTeW5jKCk7XHJcbiAgICB2YXIgeW1pbkkgPSBNYXRoLm1pbihib3hlc0RhdGFbaV1bMF0sIGJveGVzRGF0YVtpXVsyXSk7XHJcbiAgICB2YXIgeG1pbkkgPSBNYXRoLm1pbihib3hlc0RhdGFbaV1bMV0sIGJveGVzRGF0YVtpXVszXSk7XHJcbiAgICB2YXIgeW1heEkgPSBNYXRoLm1heChib3hlc0RhdGFbaV1bMF0sIGJveGVzRGF0YVtpXVsyXSk7XHJcbiAgICB2YXIgeG1heEkgPSBNYXRoLm1heChib3hlc0RhdGFbaV1bMV0sIGJveGVzRGF0YVtpXVszXSk7XHJcbiAgICB2YXIgeW1pbkogPSBNYXRoLm1pbihib3hlc0RhdGFbal1bMF0sIGJveGVzRGF0YVtqXVsyXSk7XHJcbiAgICB2YXIgeG1pbkogPSBNYXRoLm1pbihib3hlc0RhdGFbal1bMV0sIGJveGVzRGF0YVtqXVszXSk7XHJcbiAgICB2YXIgeW1heEogPSBNYXRoLm1heChib3hlc0RhdGFbal1bMF0sIGJveGVzRGF0YVtqXVsyXSk7XHJcbiAgICB2YXIgeG1heEogPSBNYXRoLm1heChib3hlc0RhdGFbal1bMV0sIGJveGVzRGF0YVtqXVszXSk7XHJcbiAgICB2YXIgYXJlYUkgPSAoeW1heEkgLSB5bWluSSkgKiAoeG1heEkgLSB4bWluSSk7XHJcbiAgICB2YXIgYXJlYUogPSAoeW1heEogLSB5bWluSikgKiAoeG1heEogLSB4bWluSik7XHJcbiAgICBpZiAoYXJlYUkgPD0gMCB8fCBhcmVhSiA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDAuMDtcclxuICAgIH1cclxuICAgIHZhciBpbnRlcnNlY3Rpb25ZbWluID0gTWF0aC5tYXgoeW1pbkksIHltaW5KKTtcclxuICAgIHZhciBpbnRlcnNlY3Rpb25YbWluID0gTWF0aC5tYXgoeG1pbkksIHhtaW5KKTtcclxuICAgIHZhciBpbnRlcnNlY3Rpb25ZbWF4ID0gTWF0aC5taW4oeW1heEksIHltYXhKKTtcclxuICAgIHZhciBpbnRlcnNlY3Rpb25YbWF4ID0gTWF0aC5taW4oeG1heEksIHhtYXhKKTtcclxuICAgIHZhciBpbnRlcnNlY3Rpb25BcmVhID0gTWF0aC5tYXgoaW50ZXJzZWN0aW9uWW1heCAtIGludGVyc2VjdGlvblltaW4sIDAuMCkgKlxyXG4gICAgICAgIE1hdGgubWF4KGludGVyc2VjdGlvblhtYXggLSBpbnRlcnNlY3Rpb25YbWluLCAwLjApO1xyXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbkFyZWEgLyAoYXJlYUkgKyBhcmVhSiAtIGludGVyc2VjdGlvbkFyZWEpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbk1heFN1cHByZXNzaW9uLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmZ1bmN0aW9uIGdldENlbnRlckNvb3JkaW5hdGVzQW5kU2l6ZXNMYXllcih4KSB7XHJcbiAgICB2YXIgdmVjID0gdGYudW5zdGFjayh0Zi50cmFuc3Bvc2UoeCwgWzEsIDBdKSk7XHJcbiAgICB2YXIgc2l6ZXMgPSBbXHJcbiAgICAgICAgdGYuc3ViKHZlY1syXSwgdmVjWzBdKSxcclxuICAgICAgICB0Zi5zdWIodmVjWzNdLCB2ZWNbMV0pXHJcbiAgICBdO1xyXG4gICAgdmFyIGNlbnRlcnMgPSBbXHJcbiAgICAgICAgdGYuYWRkKHZlY1swXSwgdGYuZGl2KHNpemVzWzBdLCB0Zi5zY2FsYXIoMikpKSxcclxuICAgICAgICB0Zi5hZGQodmVjWzFdLCB0Zi5kaXYoc2l6ZXNbMV0sIHRmLnNjYWxhcigyKSkpXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzaXplczogc2l6ZXMsXHJcbiAgICAgICAgY2VudGVyczogY2VudGVyc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGVCb3hlc0xheWVyKHgwLCB4MSkge1xyXG4gICAgdmFyIF9hID0gZ2V0Q2VudGVyQ29vcmRpbmF0ZXNBbmRTaXplc0xheWVyKHgwKSwgc2l6ZXMgPSBfYS5zaXplcywgY2VudGVycyA9IF9hLmNlbnRlcnM7XHJcbiAgICB2YXIgdmVjID0gdGYudW5zdGFjayh0Zi50cmFuc3Bvc2UoeDEsIFsxLCAwXSkpO1xyXG4gICAgdmFyIGRpdjBfb3V0ID0gdGYuZGl2KHRmLm11bCh0Zi5leHAodGYuZGl2KHZlY1syXSwgdGYuc2NhbGFyKDUpKSksIHNpemVzWzBdKSwgdGYuc2NhbGFyKDIpKTtcclxuICAgIHZhciBhZGQwX291dCA9IHRmLmFkZCh0Zi5tdWwodGYuZGl2KHZlY1swXSwgdGYuc2NhbGFyKDEwKSksIHNpemVzWzBdKSwgY2VudGVyc1swXSk7XHJcbiAgICB2YXIgZGl2MV9vdXQgPSB0Zi5kaXYodGYubXVsKHRmLmV4cCh0Zi5kaXYodmVjWzNdLCB0Zi5zY2FsYXIoNSkpKSwgc2l6ZXNbMV0pLCB0Zi5zY2FsYXIoMikpO1xyXG4gICAgdmFyIGFkZDFfb3V0ID0gdGYuYWRkKHRmLm11bCh0Zi5kaXYodmVjWzFdLCB0Zi5zY2FsYXIoMTApKSwgc2l6ZXNbMV0pLCBjZW50ZXJzWzFdKTtcclxuICAgIHJldHVybiB0Zi50cmFuc3Bvc2UodGYuc3RhY2soW1xyXG4gICAgICAgIHRmLnN1YihhZGQwX291dCwgZGl2MF9vdXQpLFxyXG4gICAgICAgIHRmLnN1YihhZGQxX291dCwgZGl2MV9vdXQpLFxyXG4gICAgICAgIHRmLmFkZChhZGQwX291dCwgZGl2MF9vdXQpLFxyXG4gICAgICAgIHRmLmFkZChhZGQxX291dCwgZGl2MV9vdXQpXHJcbiAgICBdKSwgWzEsIDBdKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gb3V0cHV0TGF5ZXIoYm94UHJlZGljdGlvbnMsIGNsYXNzUHJlZGljdGlvbnMsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBib3hQcmVkaWN0aW9ucy5zaGFwZVswXTtcclxuICAgICAgICB2YXIgYm94ZXMgPSBkZWNvZGVCb3hlc0xheWVyKHRmLnJlc2hhcGUodGYudGlsZShwYXJhbXMuZXh0cmFfZGltLCBbYmF0Y2hTaXplLCAxLCAxXSksIFstMSwgNF0pLCB0Zi5yZXNoYXBlKGJveFByZWRpY3Rpb25zLCBbLTEsIDRdKSk7XHJcbiAgICAgICAgYm94ZXMgPSB0Zi5yZXNoYXBlKGJveGVzLCBbYmF0Y2hTaXplLCAoYm94ZXMuc2hhcGVbMF0gLyBiYXRjaFNpemUpLCA0XSk7XHJcbiAgICAgICAgdmFyIHNjb3Jlc0FuZENsYXNzZXMgPSB0Zi5zaWdtb2lkKHRmLnNsaWNlKGNsYXNzUHJlZGljdGlvbnMsIFswLCAwLCAxXSwgWy0xLCAtMSwgLTFdKSk7XHJcbiAgICAgICAgdmFyIHNjb3JlcyA9IHRmLnNsaWNlKHNjb3Jlc0FuZENsYXNzZXMsIFswLCAwLCAwXSwgWy0xLCAtMSwgMV0pO1xyXG4gICAgICAgIHNjb3JlcyA9IHRmLnJlc2hhcGUoc2NvcmVzLCBbYmF0Y2hTaXplLCBzY29yZXMuc2hhcGVbMV1dKTtcclxuICAgICAgICB2YXIgYm94ZXNCeUJhdGNoID0gdGYudW5zdGFjayhib3hlcyk7XHJcbiAgICAgICAgdmFyIHNjb3Jlc0J5QmF0Y2ggPSB0Zi51bnN0YWNrKHNjb3Jlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm94ZXM6IGJveGVzQnlCYXRjaCxcclxuICAgICAgICAgICAgc2NvcmVzOiBzY29yZXNCeUJhdGNoXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW91dHB1dExheWVyLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludHdpc2VDb252TGF5ZXIoeCwgcGFyYW1zLCBzdHJpZGVzKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IHRmLmNvbnYyZCh4LCBwYXJhbXMuZmlsdGVycywgc3RyaWRlcywgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSB0Zi5hZGQob3V0LCBwYXJhbXMuYmF0Y2hfbm9ybV9vZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiB0Zi5jbGlwQnlWYWx1ZShvdXQsIDAsIDYpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9pbnR3aXNlQ29udkxheWVyLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGJveFByZWRpY3Rpb25MYXllciB9IGZyb20gJy4vYm94UHJlZGljdGlvbkxheWVyJztcclxuaW1wb3J0IHsgcG9pbnR3aXNlQ29udkxheWVyIH0gZnJvbSAnLi9wb2ludHdpc2VDb252TGF5ZXInO1xyXG5leHBvcnQgZnVuY3Rpb24gcHJlZGljdGlvbkxheWVyKHgsIGNvbnYxMSwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvbnYwID0gcG9pbnR3aXNlQ29udkxheWVyKHgsIHBhcmFtcy5jb252XzAsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGNvbnYxID0gcG9pbnR3aXNlQ29udkxheWVyKGNvbnYwLCBwYXJhbXMuY29udl8xLCBbMiwgMl0pO1xyXG4gICAgICAgIHZhciBjb252MiA9IHBvaW50d2lzZUNvbnZMYXllcihjb252MSwgcGFyYW1zLmNvbnZfMiwgWzEsIDFdKTtcclxuICAgICAgICB2YXIgY29udjMgPSBwb2ludHdpc2VDb252TGF5ZXIoY29udjIsIHBhcmFtcy5jb252XzMsIFsyLCAyXSk7XHJcbiAgICAgICAgdmFyIGNvbnY0ID0gcG9pbnR3aXNlQ29udkxheWVyKGNvbnYzLCBwYXJhbXMuY29udl80LCBbMSwgMV0pO1xyXG4gICAgICAgIHZhciBjb252NSA9IHBvaW50d2lzZUNvbnZMYXllcihjb252NCwgcGFyYW1zLmNvbnZfNSwgWzIsIDJdKTtcclxuICAgICAgICB2YXIgY29udjYgPSBwb2ludHdpc2VDb252TGF5ZXIoY29udjUsIHBhcmFtcy5jb252XzYsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGNvbnY3ID0gcG9pbnR3aXNlQ29udkxheWVyKGNvbnY2LCBwYXJhbXMuY29udl83LCBbMiwgMl0pO1xyXG4gICAgICAgIHZhciBib3hQcmVkaWN0aW9uMCA9IGJveFByZWRpY3Rpb25MYXllcihjb252MTEsIHBhcmFtcy5ib3hfcHJlZGljdG9yXzApO1xyXG4gICAgICAgIHZhciBib3hQcmVkaWN0aW9uMSA9IGJveFByZWRpY3Rpb25MYXllcih4LCBwYXJhbXMuYm94X3ByZWRpY3Rvcl8xKTtcclxuICAgICAgICB2YXIgYm94UHJlZGljdGlvbjIgPSBib3hQcmVkaWN0aW9uTGF5ZXIoY29udjEsIHBhcmFtcy5ib3hfcHJlZGljdG9yXzIpO1xyXG4gICAgICAgIHZhciBib3hQcmVkaWN0aW9uMyA9IGJveFByZWRpY3Rpb25MYXllcihjb252MywgcGFyYW1zLmJveF9wcmVkaWN0b3JfMyk7XHJcbiAgICAgICAgdmFyIGJveFByZWRpY3Rpb240ID0gYm94UHJlZGljdGlvbkxheWVyKGNvbnY1LCBwYXJhbXMuYm94X3ByZWRpY3Rvcl80KTtcclxuICAgICAgICB2YXIgYm94UHJlZGljdGlvbjUgPSBib3hQcmVkaWN0aW9uTGF5ZXIoY29udjcsIHBhcmFtcy5ib3hfcHJlZGljdG9yXzUpO1xyXG4gICAgICAgIHZhciBib3hQcmVkaWN0aW9ucyA9IHRmLmNvbmNhdChbXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb24wLmJveFByZWRpY3Rpb25FbmNvZGluZyxcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjEuYm94UHJlZGljdGlvbkVuY29kaW5nLFxyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uMi5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb24zLmJveFByZWRpY3Rpb25FbmNvZGluZyxcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjQuYm94UHJlZGljdGlvbkVuY29kaW5nLFxyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uNS5ib3hQcmVkaWN0aW9uRW5jb2RpbmdcclxuICAgICAgICBdLCAxKTtcclxuICAgICAgICB2YXIgY2xhc3NQcmVkaWN0aW9ucyA9IHRmLmNvbmNhdChbXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb24wLmNsYXNzUHJlZGljdGlvbixcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjEuY2xhc3NQcmVkaWN0aW9uLFxyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uMi5jbGFzc1ByZWRpY3Rpb24sXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb24zLmNsYXNzUHJlZGljdGlvbixcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjQuY2xhc3NQcmVkaWN0aW9uLFxyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uNS5jbGFzc1ByZWRpY3Rpb25cclxuICAgICAgICBdLCAxKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uczogYm94UHJlZGljdGlvbnMsXHJcbiAgICAgICAgICAgIGNsYXNzUHJlZGljdGlvbnM6IGNsYXNzUHJlZGljdGlvbnNcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZGljdGlvbkxheWVyLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmltcG9ydCB7IFRpbnlZb2xvdjJCYXNlIH0gZnJvbSAnLi4vdGlueVlvbG92Mi9UaW55WW9sb3YyQmFzZSc7XHJcbmltcG9ydCB7IEJPWF9BTkNIT1JTLCBJT1VfVEhSRVNIT0xELCBNRUFOX1JHQiB9IGZyb20gJy4vY29uc3QnO1xyXG52YXIgVGlueUZhY2VEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW55RmFjZURldGVjdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGlueUZhY2VEZXRlY3RvcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIHdpdGhTZXBhcmFibGVDb252czogdHJ1ZSxcclxuICAgICAgICAgICAgaW91VGhyZXNob2xkOiBJT1VfVEhSRVNIT0xELFxyXG4gICAgICAgICAgICBjbGFzc2VzOiBbJ2ZhY2UnXSxcclxuICAgICAgICAgICAgYW5jaG9yczogQk9YX0FOQ0hPUlMsXHJcbiAgICAgICAgICAgIG1lYW5SZ2I6IE1FQU5fUkdCLFxyXG4gICAgICAgICAgICBpc0ZpcnN0TGF5ZXJDb252MmQ6IHRydWUsXHJcbiAgICAgICAgICAgIGZpbHRlclNpemVzOiBbMywgMTYsIDMyLCA2NCwgMTI4LCAyNTYsIDUxMl1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW55RmFjZURldGVjdG9yLnByb3RvdHlwZSwgXCJhbmNob3JzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmFuY2hvcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBUaW55RmFjZURldGVjdG9yLnByb3RvdHlwZS5sb2NhdGVGYWNlcyA9IGZ1bmN0aW9uIChpbnB1dCwgZm9yd2FyZFBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdERldGVjdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGV0ZWN0KGlucHV0LCBmb3J3YXJkUGFyYW1zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3REZXRlY3Rpb25zID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb2JqZWN0RGV0ZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGRldCkgeyByZXR1cm4gbmV3IEZhY2VEZXRlY3Rpb24oZGV0LnNjb3JlLCBkZXQucmVsYXRpdmVCb3gsIHsgd2lkdGg6IGRldC5pbWFnZVdpZHRoLCBoZWlnaHQ6IGRldC5pbWFnZUhlaWdodCB9KTsgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUaW55RmFjZURldGVjdG9yLnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAndGlueV9mYWNlX2RldGVjdG9yX21vZGVsJztcclxuICAgIH07XHJcbiAgICBUaW55RmFjZURldGVjdG9yLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5jYWxsKHRoaXMsIHdlaWdodE1hcCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbnlGYWNlRGV0ZWN0b3I7XHJcbn0oVGlueVlvbG92MkJhc2UpKTtcclxuZXhwb3J0IHsgVGlueUZhY2VEZXRlY3RvciB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW55RmFjZURldGVjdG9yLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBUaW55WW9sb3YyT3B0aW9ucyB9IGZyb20gJy4uL3RpbnlZb2xvdjInO1xyXG52YXIgVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW55RmFjZURldGVjdG9yT3B0aW9ucygpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fbmFtZSA9ICdUaW55RmFjZURldGVjdG9yT3B0aW9ucyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zO1xyXG59KFRpbnlZb2xvdjJPcHRpb25zKSk7XHJcbmV4cG9ydCB7IFRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zLmpzLm1hcCIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmV4cG9ydCB2YXIgSU9VX1RIUkVTSE9MRCA9IDAuNDtcclxuZXhwb3J0IHZhciBCT1hfQU5DSE9SUyA9IFtcclxuICAgIG5ldyBQb2ludCgxLjYwMzIzMSwgMi4wOTQ0NjgpLFxyXG4gICAgbmV3IFBvaW50KDYuMDQxMTQzLCA3LjA4MDEyNiksXHJcbiAgICBuZXcgUG9pbnQoMi44ODI0NTksIDMuNTE4MDYxKSxcclxuICAgIG5ldyBQb2ludCg0LjI2NjkwNiwgNS4xNzg4NTcpLFxyXG4gICAgbmV3IFBvaW50KDkuMDQxNzY1LCAxMC42NjMwOClcclxuXTtcclxuZXhwb3J0IHZhciBNRUFOX1JHQiA9IFsxMTcuMDAxLCAxMTQuNjk3LCA5Ny40MDRdO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiLCJpbXBvcnQgeyBUaW55RmFjZURldGVjdG9yIH0gZnJvbSAnLi9UaW55RmFjZURldGVjdG9yJztcclxuZXhwb3J0ICogZnJvbSAnLi9UaW55RmFjZURldGVjdG9yJztcclxuZXhwb3J0ICogZnJvbSAnLi9UaW55RmFjZURldGVjdG9yT3B0aW9ucyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUaW55RmFjZURldGVjdG9yKHdlaWdodHMpIHtcclxuICAgIHZhciBuZXQgPSBuZXcgVGlueUZhY2VEZXRlY3RvcigpO1xyXG4gICAgbmV0LmV4dHJhY3RXZWlnaHRzKHdlaWdodHMpO1xyXG4gICAgcmV0dXJuIG5ldDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5pbXBvcnQgeyBCT1hfQU5DSE9SUywgQk9YX0FOQ0hPUlNfU0VQQVJBQkxFLCBERUZBVUxUX01PREVMX05BTUUsIERFRkFVTFRfTU9ERUxfTkFNRV9TRVBBUkFCTEVfQ09OViwgSU9VX1RIUkVTSE9MRCwgTUVBTl9SR0JfU0VQQVJBQkxFLCB9IGZyb20gJy4vY29uc3QnO1xyXG5pbXBvcnQgeyBUaW55WW9sb3YyQmFzZSB9IGZyb20gJy4vVGlueVlvbG92MkJhc2UnO1xyXG52YXIgVGlueVlvbG92MiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW55WW9sb3YyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGlueVlvbG92Mih3aXRoU2VwYXJhYmxlQ29udnMpIHtcclxuICAgICAgICBpZiAod2l0aFNlcGFyYWJsZUNvbnZzID09PSB2b2lkIDApIHsgd2l0aFNlcGFyYWJsZUNvbnZzID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHtcclxuICAgICAgICAgICAgd2l0aFNlcGFyYWJsZUNvbnZzOiB3aXRoU2VwYXJhYmxlQ29udnMsXHJcbiAgICAgICAgICAgIGlvdVRocmVzaG9sZDogSU9VX1RIUkVTSE9MRCxcclxuICAgICAgICAgICAgY2xhc3NlczogWydmYWNlJ11cclxuICAgICAgICB9LCB3aXRoU2VwYXJhYmxlQ29udnNcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JzOiBCT1hfQU5DSE9SU19TRVBBUkFCTEUsXHJcbiAgICAgICAgICAgICAgICBtZWFuUmdiOiBNRUFOX1JHQl9TRVBBUkFCTEVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgIGFuY2hvcnM6IEJPWF9BTkNIT1JTLFxyXG4gICAgICAgICAgICAgICAgd2l0aENsYXNzU2NvcmVzOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW55WW9sb3YyLnByb3RvdHlwZSwgXCJ3aXRoU2VwYXJhYmxlQ29udnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcud2l0aFNlcGFyYWJsZUNvbnZzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbnlZb2xvdjIucHJvdG90eXBlLCBcImFuY2hvcnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuYW5jaG9ycztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRpbnlZb2xvdjIucHJvdG90eXBlLmxvY2F0ZUZhY2VzID0gZnVuY3Rpb24gKGlucHV0LCBmb3J3YXJkUGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0RGV0ZWN0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZXRlY3QoaW5wdXQsIGZvcndhcmRQYXJhbXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdERldGVjdGlvbnMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBvYmplY3REZXRlY3Rpb25zLm1hcChmdW5jdGlvbiAoZGV0KSB7IHJldHVybiBuZXcgRmFjZURldGVjdGlvbihkZXQuc2NvcmUsIGRldC5yZWxhdGl2ZUJveCwgeyB3aWR0aDogZGV0LmltYWdlV2lkdGgsIGhlaWdodDogZGV0LmltYWdlSGVpZ2h0IH0pOyB9KV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjIucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFNlcGFyYWJsZUNvbnZzID8gREVGQVVMVF9NT0RFTF9OQU1FX1NFUEFSQUJMRV9DT05WIDogREVGQVVMVF9NT0RFTF9OQU1FO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjIucHJvdG90eXBlLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwID0gZnVuY3Rpb24gKHdlaWdodE1hcCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmNhbGwodGhpcywgd2VpZ2h0TWFwKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGlueVlvbG92MjtcclxufShUaW55WW9sb3YyQmFzZSkpO1xyXG5leHBvcnQgeyBUaW55WW9sb3YyIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbnlZb2xvdjIuanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gJy4uL2NsYXNzZXMvQm91bmRpbmdCb3gnO1xyXG5pbXBvcnQgeyBPYmplY3REZXRlY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzL09iamVjdERldGVjdGlvbic7XHJcbmltcG9ydCB7IGNvbnZMYXllciB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IHRvTmV0SW5wdXQgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBOZXVyYWxOZXR3b3JrIH0gZnJvbSAnLi4vTmV1cmFsTmV0d29yayc7XHJcbmltcG9ydCB7IHNpZ21vaWQgfSBmcm9tICcuLi9vcHMnO1xyXG5pbXBvcnQgeyBub25NYXhTdXBwcmVzc2lvbiB9IGZyb20gJy4uL29wcy9ub25NYXhTdXBwcmVzc2lvbic7XHJcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4uL29wcy9ub3JtYWxpemUnO1xyXG5pbXBvcnQgeyB2YWxpZGF0ZUNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgY29udldpdGhCYXRjaE5vcm0gfSBmcm9tICcuL2NvbnZXaXRoQmF0Y2hOb3JtJztcclxuaW1wb3J0IHsgZGVwdGh3aXNlU2VwYXJhYmxlQ29udiB9IGZyb20gJy4vZGVwdGh3aXNlU2VwYXJhYmxlQ29udic7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXMgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAnO1xyXG5pbXBvcnQgeyBsZWFreSB9IGZyb20gJy4vbGVha3knO1xyXG5pbXBvcnQgeyBUaW55WW9sb3YyT3B0aW9ucyB9IGZyb20gJy4vVGlueVlvbG92Mk9wdGlvbnMnO1xyXG52YXIgVGlueVlvbG92MkJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGlueVlvbG92MkJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW55WW9sb3YyQmFzZShjb25maWcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnVGlueVlvbG92MicpIHx8IHRoaXM7XHJcbiAgICAgICAgdmFsaWRhdGVDb25maWcoY29uZmlnKTtcclxuICAgICAgICBfdGhpcy5fY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW55WW9sb3YyQmFzZS5wcm90b3R5cGUsIFwiY29uZmlnXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW55WW9sb3YyQmFzZS5wcm90b3R5cGUsIFwid2l0aENsYXNzU2NvcmVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLndpdGhDbGFzc1Njb3JlcyB8fCB0aGlzLmNvbmZpZy5jbGFzc2VzLmxlbmd0aCA+IDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlueVlvbG92MkJhc2UucHJvdG90eXBlLCBcImJveEVuY29kaW5nU2l6ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA1ICsgKHRoaXMud2l0aENsYXNzU2NvcmVzID8gdGhpcy5jb25maWcuY2xhc3Nlcy5sZW5ndGggOiAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5ydW5UaW55WW9sb3YyID0gZnVuY3Rpb24gKHgsIHBhcmFtcykge1xyXG4gICAgICAgIHZhciBvdXQgPSBjb252V2l0aEJhdGNoTm9ybSh4LCBwYXJhbXMuY29udjApO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBjb252V2l0aEJhdGNoTm9ybShvdXQsIHBhcmFtcy5jb252MSk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGNvbnZXaXRoQmF0Y2hOb3JtKG91dCwgcGFyYW1zLmNvbnYyKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gY29udldpdGhCYXRjaE5vcm0ob3V0LCBwYXJhbXMuY29udjMpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBjb252V2l0aEJhdGNoTm9ybShvdXQsIHBhcmFtcy5jb252NCk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGNvbnZXaXRoQmF0Y2hOb3JtKG91dCwgcGFyYW1zLmNvbnY1KTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMSwgMV0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gY29udldpdGhCYXRjaE5vcm0ob3V0LCBwYXJhbXMuY29udjYpO1xyXG4gICAgICAgIG91dCA9IGNvbnZXaXRoQmF0Y2hOb3JtKG91dCwgcGFyYW1zLmNvbnY3KTtcclxuICAgICAgICByZXR1cm4gY29udkxheWVyKG91dCwgcGFyYW1zLmNvbnY4LCAndmFsaWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgVGlueVlvbG92MkJhc2UucHJvdG90eXBlLnJ1bk1vYmlsZW5ldCA9IGZ1bmN0aW9uICh4LCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy5jb25maWcuaXNGaXJzdExheWVyQ29udjJkXHJcbiAgICAgICAgICAgID8gbGVha3koY29udkxheWVyKHgsIHBhcmFtcy5jb252MCwgJ3ZhbGlkJywgZmFsc2UpKVxyXG4gICAgICAgICAgICA6IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYoeCwgcGFyYW1zLmNvbnYwKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihvdXQsIHBhcmFtcy5jb252MSk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYob3V0LCBwYXJhbXMuY29udjIpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dCwgcGFyYW1zLmNvbnYzKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihvdXQsIHBhcmFtcy5jb252NCk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYob3V0LCBwYXJhbXMuY29udjUpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsxLCAxXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBwYXJhbXMuY29udjYgPyBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dCwgcGFyYW1zLmNvbnY2KSA6IG91dDtcclxuICAgICAgICBvdXQgPSBwYXJhbXMuY29udjcgPyBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dCwgcGFyYW1zLmNvbnY3KSA6IG91dDtcclxuICAgICAgICByZXR1cm4gY29udkxheWVyKG91dCwgcGFyYW1zLmNvbnY4LCAndmFsaWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgVGlueVlvbG92MkJhc2UucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCwgaW5wdXRTaXplKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW55WW9sb3YyIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJhdGNoVGVuc29yID0gaW5wdXQudG9CYXRjaFRlbnNvcihpbnB1dFNpemUsIGZhbHNlKS50b0Zsb2F0KCk7XHJcbiAgICAgICAgICAgIGJhdGNoVGVuc29yID0gX3RoaXMuY29uZmlnLm1lYW5SZ2JcclxuICAgICAgICAgICAgICAgID8gbm9ybWFsaXplKGJhdGNoVGVuc29yLCBfdGhpcy5jb25maWcubWVhblJnYilcclxuICAgICAgICAgICAgICAgIDogYmF0Y2hUZW5zb3I7XHJcbiAgICAgICAgICAgIGJhdGNoVGVuc29yID0gYmF0Y2hUZW5zb3IuZGl2KHRmLnNjYWxhcigyNTYpKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbmZpZy53aXRoU2VwYXJhYmxlQ29udnNcclxuICAgICAgICAgICAgICAgID8gX3RoaXMucnVuTW9iaWxlbmV0KGJhdGNoVGVuc29yLCBwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICA6IF90aGlzLnJ1blRpbnlZb2xvdjIoYmF0Y2hUZW5zb3IsIHBhcmFtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGlueVlvbG92MkJhc2UucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoaW5wdXQsIGlucHV0U2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuZm9yd2FyZElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5hcHBseSh0aGlzLCBbX2Iuc2VudCgpLCBpbnB1dFNpemVdKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Iuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGlueVlvbG92MkJhc2UucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uIChpbnB1dCwgZm9yd2FyZFBhcmFtcykge1xyXG4gICAgICAgIGlmIChmb3J3YXJkUGFyYW1zID09PSB2b2lkIDApIHsgZm9yd2FyZFBhcmFtcyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIGlucHV0U2l6ZSwgc2NvcmVUaHJlc2hvbGQsIG5ldElucHV0LCBvdXQsIG91dDAsIGlucHV0RGltZW5zaW9ucywgcmVzdWx0cywgYm94ZXMsIHNjb3JlcywgY2xhc3NTY29yZXMsIGNsYXNzTmFtZXMsIGluZGljZXMsIGRldGVjdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gbmV3IFRpbnlZb2xvdjJPcHRpb25zKGZvcndhcmRQYXJhbXMpLCBpbnB1dFNpemUgPSBfYS5pbnB1dFNpemUsIHNjb3JlVGhyZXNob2xkID0gX2Euc2NvcmVUaHJlc2hvbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldElucHV0ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZvcndhcmRJbnB1dChuZXRJbnB1dCwgaW5wdXRTaXplKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDAgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmLnVuc3RhY2sob3V0KVswXS5leHBhbmREaW1zKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dERpbWVuc2lvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV0SW5wdXQuZ2V0SW5wdXRXaWR0aCgwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV0SW5wdXQuZ2V0SW5wdXRIZWlnaHQoMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5leHRyYWN0Qm94ZXMob3V0MCwgbmV0SW5wdXQuZ2V0UmVzaGFwZWRJbnB1dERpbWVuc2lvbnMoMCksIHNjb3JlVGhyZXNob2xkKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94ZXMgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuYm94OyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLnNjb3JlOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NTY29yZXMgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuY2xhc3NTY29yZTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfdGhpcy5jb25maWcuY2xhc3Nlc1tyZXMubGFiZWxdOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyA9IG5vbk1heFN1cHByZXNzaW9uKGJveGVzLm1hcChmdW5jdGlvbiAoYm94KSB7IHJldHVybiBib3gucmVzY2FsZShpbnB1dFNpemUpOyB9KSwgc2NvcmVzLCB0aGlzLmNvbmZpZy5pb3VUaHJlc2hvbGQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb25zID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3REZXRlY3Rpb24oc2NvcmVzW2lkeF0sIGNsYXNzU2NvcmVzW2lkeF0sIGNsYXNzTmFtZXNbaWR4XSwgYm94ZXNbaWR4XSwgaW5wdXREaW1lbnNpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkZXRlY3Rpb25zXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGlueVlvbG92MkJhc2UucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwLCB0aGlzLmNvbmZpZyk7XHJcbiAgICB9O1xyXG4gICAgVGlueVlvbG92MkJhc2UucHJvdG90eXBlLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHZhciBmaWx0ZXJTaXplcyA9IHRoaXMuY29uZmlnLmZpbHRlclNpemVzIHx8IFRpbnlZb2xvdjJCYXNlLkRFRkFVTFRfRklMVEVSX1NJWkVTO1xyXG4gICAgICAgIHZhciBudW1GaWx0ZXJzID0gZmlsdGVyU2l6ZXMgPyBmaWx0ZXJTaXplcy5sZW5ndGggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKG51bUZpbHRlcnMgIT09IDcgJiYgbnVtRmlsdGVycyAhPT0gOCAmJiBudW1GaWx0ZXJzICE9PSA5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbnlZb2xvdjIgLSBleHBlY3RlZCA3IHwgOCB8IDkgY29udm9sdXRpb25hbCBmaWx0ZXJzLCBidXQgZm91bmQgXCIgKyBudW1GaWx0ZXJzICsgXCIgZmlsdGVyU2l6ZXMgaW4gY29uZmlnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzLCB0aGlzLmNvbmZpZywgdGhpcy5ib3hFbmNvZGluZ1NpemUsIGZpbHRlclNpemVzKTtcclxuICAgIH07XHJcbiAgICBUaW55WW9sb3YyQmFzZS5wcm90b3R5cGUuZXh0cmFjdEJveGVzID0gZnVuY3Rpb24gKG91dHB1dFRlbnNvciwgaW5wdXRCbG9iRGltZW5zaW9ucywgc2NvcmVUaHJlc2hvbGQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCwgaGVpZ2h0LCBpbnB1dFNpemUsIGNvcnJlY3Rpb25GYWN0b3JYLCBjb3JyZWN0aW9uRmFjdG9yWSwgbnVtQ2VsbHMsIG51bUJveGVzLCBfYSwgYm94ZXNUZW5zb3IsIHNjb3Jlc1RlbnNvciwgY2xhc3NTY29yZXNUZW5zb3IsIHJlc3VsdHMsIHNjb3Jlc0RhdGEsIGJveGVzRGF0YSwgcm93LCBjb2wsIGFuY2hvciwgc2NvcmUsIGN0WCwgY3RZLCB3aWR0aF8xLCBoZWlnaHRfMSwgeCwgeSwgcG9zLCBfYiwgY2xhc3NTY29yZSwgbGFiZWwsIF9jO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGlucHV0QmxvYkRpbWVuc2lvbnMud2lkdGgsIGhlaWdodCA9IGlucHV0QmxvYkRpbWVuc2lvbnMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGlvbkZhY3RvclggPSBpbnB1dFNpemUgLyB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGlvbkZhY3RvclkgPSBpbnB1dFNpemUgLyBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bUNlbGxzID0gb3V0cHV0VGVuc29yLnNoYXBlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Cb3hlcyA9IHRoaXMuY29uZmlnLmFuY2hvcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2hhcGVkID0gb3V0cHV0VGVuc29yLnJlc2hhcGUoW251bUNlbGxzLCBudW1DZWxscywgbnVtQm94ZXMsIF90aGlzLmJveEVuY29kaW5nU2l6ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveGVzID0gcmVzaGFwZWQuc2xpY2UoWzAsIDAsIDAsIDBdLCBbbnVtQ2VsbHMsIG51bUNlbGxzLCBudW1Cb3hlcywgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3JlcyA9IHJlc2hhcGVkLnNsaWNlKFswLCAwLCAwLCA0XSwgW251bUNlbGxzLCBudW1DZWxscywgbnVtQm94ZXMsIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc1Njb3JlcyA9IF90aGlzLndpdGhDbGFzc1Njb3Jlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGYuc29mdG1heChyZXNoYXBlZC5zbGljZShbMCwgMCwgMCwgNV0sIFtudW1DZWxscywgbnVtQ2VsbHMsIG51bUJveGVzLCBfdGhpcy5jb25maWcuY2xhc3Nlcy5sZW5ndGhdKSwgMylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRmLnNjYWxhcigwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbYm94ZXMsIHNjb3JlcywgY2xhc3NTY29yZXNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgYm94ZXNUZW5zb3IgPSBfYVswXSwgc2NvcmVzVGVuc29yID0gX2FbMV0sIGNsYXNzU2NvcmVzVGVuc29yID0gX2FbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2NvcmVzVGVuc29yLmFycmF5KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzRGF0YSA9IF9kLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYm94ZXNUZW5zb3IuYXJyYXkoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlc0RhdGEgPSBfZC5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJvdyA8IG51bUNlbGxzKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2wgPCBudW1DZWxscykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYW5jaG9yIDwgbnVtQm94ZXMpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlID0gc2lnbW9pZChzY29yZXNEYXRhW3Jvd11bY29sXVthbmNob3JdWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoIXNjb3JlVGhyZXNob2xkIHx8IHNjb3JlID4gc2NvcmVUaHJlc2hvbGQpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RYID0gKChjb2wgKyBzaWdtb2lkKGJveGVzRGF0YVtyb3ddW2NvbF1bYW5jaG9yXVswXSkpIC8gbnVtQ2VsbHMpICogY29ycmVjdGlvbkZhY3Rvclg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0WSA9ICgocm93ICsgc2lnbW9pZChib3hlc0RhdGFbcm93XVtjb2xdW2FuY2hvcl1bMV0pKSAvIG51bUNlbGxzKSAqIGNvcnJlY3Rpb25GYWN0b3JZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aF8xID0gKChNYXRoLmV4cChib3hlc0RhdGFbcm93XVtjb2xdW2FuY2hvcl1bMl0pICogdGhpcy5jb25maWcuYW5jaG9yc1thbmNob3JdLngpIC8gbnVtQ2VsbHMpICogY29ycmVjdGlvbkZhY3Rvclg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodF8xID0gKChNYXRoLmV4cChib3hlc0RhdGFbcm93XVtjb2xdW2FuY2hvcl1bM10pICogdGhpcy5jb25maWcuYW5jaG9yc1thbmNob3JdLnkpIC8gbnVtQ2VsbHMpICogY29ycmVjdGlvbkZhY3Rvclk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAoY3RYIC0gKHdpZHRoXzEgLyAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAoY3RZIC0gKGhlaWdodF8xIC8gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSB7IHJvdzogcm93LCBjb2w6IGNvbCwgYW5jaG9yOiBhbmNob3IgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLndpdGhDbGFzc1Njb3JlcykgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZXh0cmFjdFByZWRpY3RlZENsYXNzKGNsYXNzU2NvcmVzVGVuc29yLCBwb3MpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gX2Quc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0geyBjbGFzc1Njb3JlOiAxLCBsYWJlbDogMCB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IF9jLCBjbGFzc1Njb3JlID0gX2IuY2xhc3NTY29yZSwgbGFiZWwgPSBfYi5sYWJlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKF9fYXNzaWduKHsgYm94OiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoXzEsIHkgKyBoZWlnaHRfMSksIHNjb3JlOiBzY29yZSwgY2xhc3NTY29yZTogc2NvcmUgKiBjbGFzc1Njb3JlLCBsYWJlbDogbGFiZWwgfSwgcG9zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gOTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NTY29yZXNUZW5zb3IuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0c107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5leHRyYWN0UHJlZGljdGVkQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3Nlc1RlbnNvciwgcG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcm93LCBjb2wsIGFuY2hvciwgY2xhc3Nlc0RhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHBvcy5yb3csIGNvbCA9IHBvcy5jb2wsIGFuY2hvciA9IHBvcy5hbmNob3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNsYXNzZXNUZW5zb3IuYXJyYXkoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzRGF0YSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEFycmF5KHRoaXMuY29uZmlnLmNsYXNzZXMubGVuZ3RoKS5maWxsKDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gY2xhc3Nlc0RhdGFbcm93XVtjb2xdW2FuY2hvcl1baV07IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY2xhc3NTY29yZSwgbGFiZWwpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NTY29yZTogY2xhc3NTY29yZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgY3VycikgeyByZXR1cm4gbWF4LmNsYXNzU2NvcmUgPiBjdXJyLmNsYXNzU2NvcmUgPyBtYXggOiBjdXJyOyB9KV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLkRFRkFVTFRfRklMVEVSX1NJWkVTID0gW1xyXG4gICAgICAgIDMsIDE2LCAzMiwgNjQsIDEyOCwgMjU2LCA1MTIsIDEwMjQsIDEwMjRcclxuICAgIF07XHJcbiAgICByZXR1cm4gVGlueVlvbG92MkJhc2U7XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBUaW55WW9sb3YyQmFzZSB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW55WW9sb3YyQmFzZS5qcy5tYXAiLCJleHBvcnQgdmFyIFRpbnlZb2xvdjJTaXplVHlwZTtcclxuKGZ1bmN0aW9uIChUaW55WW9sb3YyU2l6ZVR5cGUpIHtcclxuICAgIFRpbnlZb2xvdjJTaXplVHlwZVtUaW55WW9sb3YyU2l6ZVR5cGVbXCJYU1wiXSA9IDIyNF0gPSBcIlhTXCI7XHJcbiAgICBUaW55WW9sb3YyU2l6ZVR5cGVbVGlueVlvbG92MlNpemVUeXBlW1wiU01cIl0gPSAzMjBdID0gXCJTTVwiO1xyXG4gICAgVGlueVlvbG92MlNpemVUeXBlW1RpbnlZb2xvdjJTaXplVHlwZVtcIk1EXCJdID0gNDE2XSA9IFwiTURcIjtcclxuICAgIFRpbnlZb2xvdjJTaXplVHlwZVtUaW55WW9sb3YyU2l6ZVR5cGVbXCJMR1wiXSA9IDYwOF0gPSBcIkxHXCI7XHJcbn0pKFRpbnlZb2xvdjJTaXplVHlwZSB8fCAoVGlueVlvbG92MlNpemVUeXBlID0ge30pKTtcclxudmFyIFRpbnlZb2xvdjJPcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGlueVlvbG92Mk9wdGlvbnMoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgaW5wdXRTaXplID0gX2IuaW5wdXRTaXplLCBzY29yZVRocmVzaG9sZCA9IF9iLnNjb3JlVGhyZXNob2xkO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSAnVGlueVlvbG92Mk9wdGlvbnMnO1xyXG4gICAgICAgIHRoaXMuX2lucHV0U2l6ZSA9IGlucHV0U2l6ZSB8fCA0MTY7XHJcbiAgICAgICAgdGhpcy5fc2NvcmVUaHJlc2hvbGQgPSBzY29yZVRocmVzaG9sZCB8fCAwLjU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnB1dFNpemUgIT09ICdudW1iZXInIHx8IHRoaXMuX2lucHV0U2l6ZSAlIDMyICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBpbnB1dFNpemUgdG8gYmUgYSBudW1iZXIgZGl2aXNpYmxlIGJ5IDMyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3Njb3JlVGhyZXNob2xkICE9PSAnbnVtYmVyJyB8fCB0aGlzLl9zY29yZVRocmVzaG9sZCA8PSAwIHx8IHRoaXMuX3Njb3JlVGhyZXNob2xkID49IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX25hbWUgKyBcIiAtIGV4cGVjdGVkIHNjb3JlVGhyZXNob2xkIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlueVlvbG92Mk9wdGlvbnMucHJvdG90eXBlLCBcImlucHV0U2l6ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbnB1dFNpemU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbnlZb2xvdjJPcHRpb25zLnByb3RvdHlwZSwgXCJzY29yZVRocmVzaG9sZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zY29yZVRocmVzaG9sZDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gVGlueVlvbG92Mk9wdGlvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFRpbnlZb2xvdjJPcHRpb25zIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbnlZb2xvdjJPcHRpb25zLmpzLm1hcCIsInZhciBpc051bWJlciA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInOyB9O1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb25maWcoY29uZmlnKSB7XHJcbiAgICBpZiAoIWNvbmZpZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29uZmlnOiBcIiArIGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbmZpZy53aXRoU2VwYXJhYmxlQ29udnMgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy53aXRoU2VwYXJhYmxlQ29udnMgaGFzIHRvIGJlIGEgYm9vbGVhbiwgaGF2ZTogXCIgKyBjb25maWcud2l0aFNlcGFyYWJsZUNvbnZzKTtcclxuICAgIH1cclxuICAgIGlmICghaXNOdW1iZXIoY29uZmlnLmlvdVRocmVzaG9sZCkgfHwgY29uZmlnLmlvdVRocmVzaG9sZCA8IDAgfHwgY29uZmlnLmlvdVRocmVzaG9sZCA+IDEuMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy5pb3VUaHJlc2hvbGQgaGFzIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gWzAsIDFdLCBoYXZlOiBcIiArIGNvbmZpZy5pb3VUaHJlc2hvbGQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5jbGFzc2VzKVxyXG4gICAgICAgIHx8ICFjb25maWcuY2xhc3Nlcy5sZW5ndGhcclxuICAgICAgICB8fCAhY29uZmlnLmNsYXNzZXMuZXZlcnkoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJzsgfSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25maWcuY2xhc3NlcyBoYXMgdG8gYmUgYW4gYXJyYXkgY2xhc3MgbmFtZXM6IHN0cmluZ1tdLCBoYXZlOiBcIiArIEpTT04uc3RyaW5naWZ5KGNvbmZpZy5jbGFzc2VzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLmFuY2hvcnMpXHJcbiAgICAgICAgfHwgIWNvbmZpZy5hbmNob3JzLmxlbmd0aFxyXG4gICAgICAgIHx8ICFjb25maWcuYW5jaG9ycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgfHwge307IH0pLmV2ZXJ5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBpc051bWJlcihhLngpICYmIGlzTnVtYmVyKGEueSk7IH0pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uZmlnLmFuY2hvcnMgaGFzIHRvIGJlIGFuIGFycmF5IG9mIHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSwgaGF2ZTogXCIgKyBKU09OLnN0cmluZ2lmeShjb25maWcuYW5jaG9ycykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5tZWFuUmdiICYmICghQXJyYXkuaXNBcnJheShjb25maWcubWVhblJnYilcclxuICAgICAgICB8fCBjb25maWcubWVhblJnYi5sZW5ndGggIT09IDNcclxuICAgICAgICB8fCAhY29uZmlnLm1lYW5SZ2IuZXZlcnkoaXNOdW1iZXIpKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy5tZWFuUmdiIGhhcyB0byBiZSBhbiBhcnJheSBvZiBzaGFwZSBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGhhdmU6IFwiICsgSlNPTi5zdHJpbmdpZnkoY29uZmlnLm1lYW5SZ2IpKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuZXhwb3J0IHZhciBJT1VfVEhSRVNIT0xEID0gMC40O1xyXG5leHBvcnQgdmFyIEJPWF9BTkNIT1JTID0gW1xyXG4gICAgbmV3IFBvaW50KDAuNzM4NzY4LCAwLjg3NDk0NiksXHJcbiAgICBuZXcgUG9pbnQoMi40MjIwNCwgMi42NTcwNCksXHJcbiAgICBuZXcgUG9pbnQoNC4zMDk3MSwgNy4wNDQ5MyksXHJcbiAgICBuZXcgUG9pbnQoMTAuMjQ2LCA0LjU5NDI4KSxcclxuICAgIG5ldyBQb2ludCgxMi42ODY4LCAxMS44NzQxKVxyXG5dO1xyXG5leHBvcnQgdmFyIEJPWF9BTkNIT1JTX1NFUEFSQUJMRSA9IFtcclxuICAgIG5ldyBQb2ludCgxLjYwMzIzMSwgMi4wOTQ0NjgpLFxyXG4gICAgbmV3IFBvaW50KDYuMDQxMTQzLCA3LjA4MDEyNiksXHJcbiAgICBuZXcgUG9pbnQoMi44ODI0NTksIDMuNTE4MDYxKSxcclxuICAgIG5ldyBQb2ludCg0LjI2NjkwNiwgNS4xNzg4NTcpLFxyXG4gICAgbmV3IFBvaW50KDkuMDQxNzY1LCAxMC42NjMwOClcclxuXTtcclxuZXhwb3J0IHZhciBNRUFOX1JHQl9TRVBBUkFCTEUgPSBbMTE3LjAwMSwgMTE0LjY5NywgOTcuNDA0XTtcclxuZXhwb3J0IHZhciBERUZBVUxUX01PREVMX05BTUUgPSAndGlueV95b2xvdjJfbW9kZWwnO1xyXG5leHBvcnQgdmFyIERFRkFVTFRfTU9ERUxfTkFNRV9TRVBBUkFCTEVfQ09OViA9ICd0aW55X3lvbG92Ml9zZXBhcmFibGVfY29udl9tb2RlbCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGxlYWt5IH0gZnJvbSAnLi9sZWFreSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjb252V2l0aEJhdGNoTm9ybSh4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGYucGFkKHgsIFtbMCwgMF0sIFsxLCAxXSwgWzEsIDFdLCBbMCwgMF1dKTtcclxuICAgICAgICBvdXQgPSB0Zi5jb252MmQob3V0LCBwYXJhbXMuY29udi5maWx0ZXJzLCBbMSwgMV0sICd2YWxpZCcpO1xyXG4gICAgICAgIG91dCA9IHRmLnN1YihvdXQsIHBhcmFtcy5ibi5zdWIpO1xyXG4gICAgICAgIG91dCA9IHRmLm11bChvdXQsIHBhcmFtcy5ibi50cnVlZGl2KTtcclxuICAgICAgICBvdXQgPSB0Zi5hZGQob3V0LCBwYXJhbXMuY29udi5iaWFzKTtcclxuICAgICAgICByZXR1cm4gbGVha3kob3V0KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZXaXRoQmF0Y2hOb3JtLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGxlYWt5IH0gZnJvbSAnLi9sZWFreSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZXB0aHdpc2VTZXBhcmFibGVDb252KHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQgPSB0Zi5wYWQoeCwgW1swLCAwXSwgWzEsIDFdLCBbMSwgMV0sIFswLCAwXV0pO1xyXG4gICAgICAgIG91dCA9IHRmLnNlcGFyYWJsZUNvbnYyZChvdXQsIHBhcmFtcy5kZXB0aHdpc2VfZmlsdGVyLCBwYXJhbXMucG9pbnR3aXNlX2ZpbHRlciwgWzEsIDFdLCAndmFsaWQnKTtcclxuICAgICAgICBvdXQgPSB0Zi5hZGQob3V0LCBwYXJhbXMuYmlhcyk7XHJcbiAgICAgICAgcmV0dXJuIGxlYWt5KG91dCk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXB0aHdpc2VTZXBhcmFibGVDb252LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGV4dHJhY3RDb252UGFyYW1zRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbi9leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnknO1xyXG5pbXBvcnQgeyBleHRyYWN0V2VpZ2h0c0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24vZXh0cmFjdFdlaWdodHNGYWN0b3J5JztcclxuZnVuY3Rpb24gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0Q29udlBhcmFtcyA9IGV4dHJhY3RDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0QmF0Y2hOb3JtUGFyYW1zKHNpemUsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBzdWIgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhzaXplKSk7XHJcbiAgICAgICAgdmFyIHRydWVkaXYgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhzaXplKSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9zdWJcIiB9LCB7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvdHJ1ZWRpdlwiIH0pO1xyXG4gICAgICAgIHJldHVybiB7IHN1Yjogc3ViLCB0cnVlZGl2OiB0cnVlZGl2IH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBjb252ID0gZXh0cmFjdENvbnZQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIDMsIG1hcHBlZFByZWZpeCArIFwiL2NvbnZcIik7XHJcbiAgICAgICAgdmFyIGJuID0gZXh0cmFjdEJhdGNoTm9ybVBhcmFtcyhjaGFubmVsc091dCwgbWFwcGVkUHJlZml4ICsgXCIvYm5cIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjogY29udiwgYm46IGJuIH07XHJcbiAgICB9XHJcbiAgICB2YXIgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0Q29udlBhcmFtczogZXh0cmFjdENvbnZQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zOiBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKHdlaWdodHMsIGNvbmZpZywgYm94RW5jb2RpbmdTaXplLCBmaWx0ZXJTaXplcykge1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdFdlaWdodHNGYWN0b3J5KHdlaWdodHMpLCBleHRyYWN0V2VpZ2h0cyA9IF9hLmV4dHJhY3RXZWlnaHRzLCBnZXRSZW1haW5pbmdXZWlnaHRzID0gX2EuZ2V0UmVtYWluaW5nV2VpZ2h0cztcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2IgPSBleHRyYWN0b3JzRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RDb252UGFyYW1zID0gX2IuZXh0cmFjdENvbnZQYXJhbXMsIGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcyA9IF9iLmV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcywgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBfYi5leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcztcclxuICAgIHZhciBwYXJhbXM7XHJcbiAgICBpZiAoY29uZmlnLndpdGhTZXBhcmFibGVDb252cykge1xyXG4gICAgICAgIHZhciBzMCA9IGZpbHRlclNpemVzWzBdLCBzMSA9IGZpbHRlclNpemVzWzFdLCBzMiA9IGZpbHRlclNpemVzWzJdLCBzMyA9IGZpbHRlclNpemVzWzNdLCBzNCA9IGZpbHRlclNpemVzWzRdLCBzNSA9IGZpbHRlclNpemVzWzVdLCBzNiA9IGZpbHRlclNpemVzWzZdLCBzNyA9IGZpbHRlclNpemVzWzddLCBzOCA9IGZpbHRlclNpemVzWzhdO1xyXG4gICAgICAgIHZhciBjb252MCA9IGNvbmZpZy5pc0ZpcnN0TGF5ZXJDb252MmRcclxuICAgICAgICAgICAgPyBleHRyYWN0Q29udlBhcmFtcyhzMCwgczEsIDMsICdjb252MCcpXHJcbiAgICAgICAgICAgIDogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoczAsIHMxLCAnY29udjAnKTtcclxuICAgICAgICB2YXIgY29udjEgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhzMSwgczIsICdjb252MScpO1xyXG4gICAgICAgIHZhciBjb252MiA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHMyLCBzMywgJ2NvbnYyJyk7XHJcbiAgICAgICAgdmFyIGNvbnYzID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoczMsIHM0LCAnY29udjMnKTtcclxuICAgICAgICB2YXIgY29udjQgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhzNCwgczUsICdjb252NCcpO1xyXG4gICAgICAgIHZhciBjb252NSA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHM1LCBzNiwgJ2NvbnY1Jyk7XHJcbiAgICAgICAgdmFyIGNvbnY2ID0gczcgPyBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhzNiwgczcsICdjb252NicpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBjb252NyA9IHM4ID8gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoczcsIHM4LCAnY29udjcnKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgY29udjggPSBleHRyYWN0Q29udlBhcmFtcyhzOCB8fCBzNyB8fCBzNiwgNSAqIGJveEVuY29kaW5nU2l6ZSwgMSwgJ2NvbnY4Jyk7XHJcbiAgICAgICAgcGFyYW1zID0geyBjb252MDogY29udjAsIGNvbnYxOiBjb252MSwgY29udjI6IGNvbnYyLCBjb252MzogY29udjMsIGNvbnY0OiBjb252NCwgY29udjU6IGNvbnY1LCBjb252NjogY29udjYsIGNvbnY3OiBjb252NywgY29udjg6IGNvbnY4IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgczAgPSBmaWx0ZXJTaXplc1swXSwgczEgPSBmaWx0ZXJTaXplc1sxXSwgczIgPSBmaWx0ZXJTaXplc1syXSwgczMgPSBmaWx0ZXJTaXplc1szXSwgczQgPSBmaWx0ZXJTaXplc1s0XSwgczUgPSBmaWx0ZXJTaXplc1s1XSwgczYgPSBmaWx0ZXJTaXplc1s2XSwgczcgPSBmaWx0ZXJTaXplc1s3XSwgczggPSBmaWx0ZXJTaXplc1s4XTtcclxuICAgICAgICB2YXIgY29udjAgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczAsIHMxLCAnY29udjAnKTtcclxuICAgICAgICB2YXIgY29udjEgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczEsIHMyLCAnY29udjEnKTtcclxuICAgICAgICB2YXIgY29udjIgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczIsIHMzLCAnY29udjInKTtcclxuICAgICAgICB2YXIgY29udjMgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczMsIHM0LCAnY29udjMnKTtcclxuICAgICAgICB2YXIgY29udjQgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczQsIHM1LCAnY29udjQnKTtcclxuICAgICAgICB2YXIgY29udjUgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczUsIHM2LCAnY29udjUnKTtcclxuICAgICAgICB2YXIgY29udjYgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczYsIHM3LCAnY29udjYnKTtcclxuICAgICAgICB2YXIgY29udjcgPSBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMoczcsIHM4LCAnY29udjcnKTtcclxuICAgICAgICB2YXIgY29udjggPSBleHRyYWN0Q29udlBhcmFtcyhzOCwgNSAqIGJveEVuY29kaW5nU2l6ZSwgMSwgJ2NvbnY4Jyk7XHJcbiAgICAgICAgcGFyYW1zID0geyBjb252MDogY29udjAsIGNvbnYxOiBjb252MSwgY29udjI6IGNvbnYyLCBjb252MzogY29udjMsIGNvbnY0OiBjb252NCwgY29udjU6IGNvbnY1LCBjb252NjogY29udjYsIGNvbnY3OiBjb252NywgY29udjg6IGNvbnY4IH07XHJcbiAgICB9XHJcbiAgICBpZiAoZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiBcIiArIGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgcGFyYW1zOiBwYXJhbXMsIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zLmpzLm1hcCIsImltcG9ydCB7IGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzIH0gZnJvbSAnLi4vY29tbW9uL2Rpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzJztcclxuaW1wb3J0IHsgbG9hZFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uL2V4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeSc7XHJcbmltcG9ydCB7IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24vZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSc7XHJcbmZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgdmFyIGV4dHJhY3RXZWlnaHRFbnRyeSA9IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RCYXRjaE5vcm1QYXJhbXMocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIHN1YiA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9zdWJcIiwgMSk7XHJcbiAgICAgICAgdmFyIHRydWVkaXYgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvdHJ1ZWRpdlwiLCAxKTtcclxuICAgICAgICByZXR1cm4geyBzdWI6IHN1YiwgdHJ1ZWRpdjogdHJ1ZWRpdiB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbnZQYXJhbXMocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvZmlsdGVyc1wiLCA0KTtcclxuICAgICAgICB2YXIgYmlhcyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9iaWFzXCIsIDEpO1xyXG4gICAgICAgIHJldHVybiB7IGZpbHRlcnM6IGZpbHRlcnMsIGJpYXM6IGJpYXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcyhwcmVmaXgpIHtcclxuICAgICAgICB2YXIgY29udiA9IGV4dHJhY3RDb252UGFyYW1zKHByZWZpeCArIFwiL2NvbnZcIik7XHJcbiAgICAgICAgdmFyIGJuID0gZXh0cmFjdEJhdGNoTm9ybVBhcmFtcyhwcmVmaXggKyBcIi9iblwiKTtcclxuICAgICAgICByZXR1cm4geyBjb252OiBjb252LCBibjogYm4gfTtcclxuICAgIH1cclxuICAgIHZhciBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyA9IGxvYWRTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0RW50cnkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0Q29udlBhcmFtczogZXh0cmFjdENvbnZQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zOiBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXAsIGNvbmZpZykge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RvcnNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RDb252UGFyYW1zID0gX2EuZXh0cmFjdENvbnZQYXJhbXMsIGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcyA9IF9hLmV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcywgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBfYS5leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcztcclxuICAgIHZhciBwYXJhbXM7XHJcbiAgICBpZiAoY29uZmlnLndpdGhTZXBhcmFibGVDb252cykge1xyXG4gICAgICAgIHZhciBudW1GaWx0ZXJzID0gKGNvbmZpZy5maWx0ZXJTaXplcyAmJiBjb25maWcuZmlsdGVyU2l6ZXMubGVuZ3RoIHx8IDkpO1xyXG4gICAgICAgIHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgY29udjA6IGNvbmZpZy5pc0ZpcnN0TGF5ZXJDb252MmQgPyBleHRyYWN0Q29udlBhcmFtcygnY29udjAnKSA6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKCdjb252MCcpLFxyXG4gICAgICAgICAgICBjb252MTogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoJ2NvbnYxJyksXHJcbiAgICAgICAgICAgIGNvbnYyOiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcygnY29udjInKSxcclxuICAgICAgICAgICAgY29udjM6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKCdjb252MycpLFxyXG4gICAgICAgICAgICBjb252NDogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoJ2NvbnY0JyksXHJcbiAgICAgICAgICAgIGNvbnY1OiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcygnY29udjUnKSxcclxuICAgICAgICAgICAgY29udjY6IG51bUZpbHRlcnMgPiA3ID8gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoJ2NvbnY2JykgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvbnY3OiBudW1GaWx0ZXJzID4gOCA/IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKCdjb252NycpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb252ODogZXh0cmFjdENvbnZQYXJhbXMoJ2NvbnY4JylcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBjb252MDogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252MCcpLFxyXG4gICAgICAgICAgICBjb252MTogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252MScpLFxyXG4gICAgICAgICAgICBjb252MjogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252MicpLFxyXG4gICAgICAgICAgICBjb252MzogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252MycpLFxyXG4gICAgICAgICAgICBjb252NDogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252NCcpLFxyXG4gICAgICAgICAgICBjb252NTogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252NScpLFxyXG4gICAgICAgICAgICBjb252NjogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252NicpLFxyXG4gICAgICAgICAgICBjb252NzogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKCdjb252NycpLFxyXG4gICAgICAgICAgICBjb252ODogZXh0cmFjdENvbnZQYXJhbXMoJ2NvbnY4JylcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMubWFwIiwiaW1wb3J0IHsgVGlueVlvbG92MiB9IGZyb20gJy4vVGlueVlvbG92Mic7XHJcbmV4cG9ydCAqIGZyb20gJy4vVGlueVlvbG92Mk9wdGlvbnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvbmZpZyc7XHJcbmV4cG9ydCB7IFRpbnlZb2xvdjIgfTtcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRpbnlZb2xvdjIod2VpZ2h0cywgd2l0aFNlcGFyYWJsZUNvbnZzKSB7XHJcbiAgICBpZiAod2l0aFNlcGFyYWJsZUNvbnZzID09PSB2b2lkIDApIHsgd2l0aFNlcGFyYWJsZUNvbnZzID0gdHJ1ZTsgfVxyXG4gICAgdmFyIG5ldCA9IG5ldyBUaW55WW9sb3YyKHdpdGhTZXBhcmFibGVDb252cyk7XHJcbiAgICBuZXQuZXh0cmFjdFdlaWdodHMod2VpZ2h0cyk7XHJcbiAgICByZXR1cm4gbmV0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBsZWFreSh4KSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1pbiA9IHRmLm11bCh4LCB0Zi5zY2FsYXIoMC4xMDAwMDAwMDE0OTAxMTYxMikpO1xyXG4gICAgICAgIHJldHVybiB0Zi5hZGQodGYucmVsdSh0Zi5zdWIoeCwgbWluKSksIG1pbik7XHJcbiAgICAgICAgLy9yZXR1cm4gdGYubWF4aW11bSh4LCBtaW4pXHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFreS5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5pbXBvcnQgeyBEaW1lbnNpb25zIH0gZnJvbSAnLi4vY2xhc3Nlcy9EaW1lbnNpb25zJztcclxuZXhwb3J0IGZ1bmN0aW9uIGlzVGVuc29yKHRlbnNvciwgZGltKSB7XHJcbiAgICByZXR1cm4gdGVuc29yIGluc3RhbmNlb2YgdGYuVGVuc29yICYmIHRlbnNvci5zaGFwZS5sZW5ndGggPT09IGRpbTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNUZW5zb3IxRCh0ZW5zb3IpIHtcclxuICAgIHJldHVybiBpc1RlbnNvcih0ZW5zb3IsIDEpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1RlbnNvcjJEKHRlbnNvcikge1xyXG4gICAgcmV0dXJuIGlzVGVuc29yKHRlbnNvciwgMik7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVGVuc29yM0QodGVuc29yKSB7XHJcbiAgICByZXR1cm4gaXNUZW5zb3IodGVuc29yLCAzKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNUZW5zb3I0RCh0ZW5zb3IpIHtcclxuICAgIHJldHVybiBpc1RlbnNvcih0ZW5zb3IsIDQpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Zsb2F0KG51bSkge1xyXG4gICAgcmV0dXJuIG51bSAlIDEgIT09IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXZlbihudW0pIHtcclxuICAgIHJldHVybiBudW0gJSAyID09PSAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByb3VuZChudW0sIHByZWMpIHtcclxuICAgIGlmIChwcmVjID09PSB2b2lkIDApIHsgcHJlYyA9IDI7IH1cclxuICAgIHZhciBmID0gTWF0aC5wb3coMTAsIHByZWMpO1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IobnVtICogZikgLyBmO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc0RpbWVuc2lvbnMob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIG9iai53aWR0aCAmJiBvYmouaGVpZ2h0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmVzaGFwZWREaW1lbnNpb25zKF9hLCBpbnB1dFNpemUpIHtcclxuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICB2YXIgc2NhbGUgPSBpbnB1dFNpemUgLyBNYXRoLm1heChoZWlnaHQsIHdpZHRoKTtcclxuICAgIHJldHVybiBuZXcgRGltZW5zaW9ucyhNYXRoLnJvdW5kKHdpZHRoICogc2NhbGUpLCBNYXRoLnJvdW5kKGhlaWdodCAqIHNjYWxlKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENlbnRlclBvaW50KHB0cykge1xyXG4gICAgcmV0dXJuIHB0cy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgcHQpIHsgcmV0dXJuIHN1bS5hZGQocHQpOyB9LCBuZXcgUG9pbnQoMCwgMCkpXHJcbiAgICAgICAgLmRpdihuZXcgUG9pbnQocHRzLmxlbmd0aCwgcHRzLmxlbmd0aCkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByYW5nZShudW0sIHN0YXJ0LCBzdGVwKSB7XHJcbiAgICByZXR1cm4gQXJyYXkobnVtKS5maWxsKDApLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gc3RhcnQgKyAoaSAqIHN0ZXApOyB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE51bWJlcihudW0pIHtcclxuICAgIHJldHVybiAhIW51bSAmJiBudW0gIT09IEluZmluaXR5ICYmIG51bSAhPT0gLUluZmluaXR5ICYmICFpc05hTihudW0pIHx8IG51bSA9PT0gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFByb2JhYmxpdGl5KG51bSkge1xyXG4gICAgcmV0dXJuIGlzVmFsaWROdW1iZXIobnVtKSAmJiAwIDw9IG51bSAmJiBudW0gPD0gMS4wO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBkZXB0aHdpc2VTZXBhcmFibGVDb252IH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgdG9OZXRJbnB1dCB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IE5ldXJhbE5ldHdvcmsgfSBmcm9tICcuLi9OZXVyYWxOZXR3b3JrJztcclxuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vb3BzJztcclxuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXMgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAnO1xyXG5mdW5jdGlvbiBjb252KHgsIHBhcmFtcywgc3RyaWRlKSB7XHJcbiAgICByZXR1cm4gdGYuYWRkKHRmLmNvbnYyZCh4LCBwYXJhbXMuZmlsdGVycywgc3RyaWRlLCAnc2FtZScpLCBwYXJhbXMuYmlhcyk7XHJcbn1cclxuZnVuY3Rpb24gcmVkdWN0aW9uQmxvY2soeCwgcGFyYW1zLCBpc0FjdGl2YXRlSW5wdXQpIHtcclxuICAgIGlmIChpc0FjdGl2YXRlSW5wdXQgPT09IHZvaWQgMCkgeyBpc0FjdGl2YXRlSW5wdXQgPSB0cnVlOyB9XHJcbiAgICB2YXIgb3V0ID0gaXNBY3RpdmF0ZUlucHV0ID8gdGYucmVsdSh4KSA6IHg7XHJcbiAgICBvdXQgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dCwgcGFyYW1zLnNlcGFyYWJsZV9jb252MCwgWzEsIDFdKTtcclxuICAgIG91dCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYodGYucmVsdShvdXQpLCBwYXJhbXMuc2VwYXJhYmxlX2NvbnYxLCBbMSwgMV0pO1xyXG4gICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFszLCAzXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgb3V0ID0gdGYuYWRkKG91dCwgY29udih4LCBwYXJhbXMuZXhwYW5zaW9uX2NvbnYsIFsyLCAyXSkpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufVxyXG5mdW5jdGlvbiBtYWluQmxvY2soeCwgcGFyYW1zKSB7XHJcbiAgICB2YXIgb3V0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udih0Zi5yZWx1KHgpLCBwYXJhbXMuc2VwYXJhYmxlX2NvbnYwLCBbMSwgMV0pO1xyXG4gICAgb3V0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udih0Zi5yZWx1KG91dCksIHBhcmFtcy5zZXBhcmFibGVfY29udjEsIFsxLCAxXSk7XHJcbiAgICBvdXQgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KHRmLnJlbHUob3V0KSwgcGFyYW1zLnNlcGFyYWJsZV9jb252MiwgWzEsIDFdKTtcclxuICAgIG91dCA9IHRmLmFkZChvdXQsIHgpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufVxyXG52YXIgVGlueVhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbnlYY2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbnlYY2VwdGlvbihudW1NYWluQmxvY2tzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ1RpbnlYY2VwdGlvbicpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX251bU1haW5CbG9ja3MgPSBudW1NYWluQmxvY2tzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFRpbnlYY2VwdGlvbi5wcm90b3R5cGUuZm9yd2FyZElucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW55WGNlcHRpb24gLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmF0Y2hUZW5zb3IgPSBpbnB1dC50b0JhdGNoVGVuc29yKDExMiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBtZWFuUmdiID0gWzEyMi43ODIsIDExNy4wMDEsIDEwNC4yOThdO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShiYXRjaFRlbnNvciwgbWVhblJnYikuZGl2KHRmLnNjYWxhcigyNTYpKTtcclxuICAgICAgICAgICAgdmFyIG91dCA9IHRmLnJlbHUoY29udihub3JtYWxpemVkLCBwYXJhbXMuZW50cnlfZmxvdy5jb252X2luLCBbMiwgMl0pKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVkdWN0aW9uQmxvY2sob3V0LCBwYXJhbXMuZW50cnlfZmxvdy5yZWR1Y3Rpb25fYmxvY2tfMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBvdXQgPSByZWR1Y3Rpb25CbG9jayhvdXQsIHBhcmFtcy5lbnRyeV9mbG93LnJlZHVjdGlvbl9ibG9ja18xKTtcclxuICAgICAgICAgICAgcmFuZ2UoX3RoaXMuX251bU1haW5CbG9ja3MsIDAsIDEpLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgb3V0ID0gbWFpbkJsb2NrKG91dCwgcGFyYW1zLm1pZGRsZV9mbG93W1wibWFpbl9ibG9ja19cIiArIGlkeF0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgb3V0ID0gcmVkdWN0aW9uQmxvY2sob3V0LCBwYXJhbXMuZXhpdF9mbG93LnJlZHVjdGlvbl9ibG9jayk7XHJcbiAgICAgICAgICAgIG91dCA9IHRmLnJlbHUoZGVwdGh3aXNlU2VwYXJhYmxlQ29udihvdXQsIHBhcmFtcy5leGl0X2Zsb3cuc2VwYXJhYmxlX2NvbnYsIFsxLCAxXSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlYY2VwdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuZm9yd2FyZElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKV0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGlueVhjZXB0aW9uLnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAndGlueV94Y2VwdGlvbl9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgVGlueVhjZXB0aW9uLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwLCB0aGlzLl9udW1NYWluQmxvY2tzKTtcclxuICAgIH07XHJcbiAgICBUaW55WGNlcHRpb24ucHJvdG90eXBlLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zKHdlaWdodHMsIHRoaXMuX251bU1haW5CbG9ja3MpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW55WGNlcHRpb247XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBUaW55WGNlcHRpb24gfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlueVhjZXB0aW9uLmpzLm1hcCIsImltcG9ydCB7IGV4dHJhY3RDb252UGFyYW1zRmFjdG9yeSwgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5LCBleHRyYWN0V2VpZ2h0c0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyByYW5nZSB9IGZyb20gJy4uL3V0aWxzJztcclxuZnVuY3Rpb24gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0Q29udlBhcmFtcyA9IGV4dHJhY3RDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICB2YXIgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgc2VwYXJhYmxlX2NvbnYwID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCArIFwiL3NlcGFyYWJsZV9jb252MFwiKTtcclxuICAgICAgICB2YXIgc2VwYXJhYmxlX2NvbnYxID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoY2hhbm5lbHNPdXQsIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjFcIik7XHJcbiAgICAgICAgdmFyIGV4cGFuc2lvbl9jb252ID0gZXh0cmFjdENvbnZQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIDEsIG1hcHBlZFByZWZpeCArIFwiL2V4cGFuc2lvbl9jb252XCIpO1xyXG4gICAgICAgIHJldHVybiB7IHNlcGFyYWJsZV9jb252MDogc2VwYXJhYmxlX2NvbnYwLCBzZXBhcmFibGVfY29udjE6IHNlcGFyYWJsZV9jb252MSwgZXhwYW5zaW9uX2NvbnY6IGV4cGFuc2lvbl9jb252IH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0TWFpbkJsb2NrUGFyYW1zKGNoYW5uZWxzLCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgc2VwYXJhYmxlX2NvbnYwID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoY2hhbm5lbHMsIGNoYW5uZWxzLCBtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjBcIik7XHJcbiAgICAgICAgdmFyIHNlcGFyYWJsZV9jb252MSA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKGNoYW5uZWxzLCBjaGFubmVscywgbWFwcGVkUHJlZml4ICsgXCIvc2VwYXJhYmxlX2NvbnYxXCIpO1xyXG4gICAgICAgIHZhciBzZXBhcmFibGVfY29udjIgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhjaGFubmVscywgY2hhbm5lbHMsIG1hcHBlZFByZWZpeCArIFwiL3NlcGFyYWJsZV9jb252MlwiKTtcclxuICAgICAgICByZXR1cm4geyBzZXBhcmFibGVfY29udjA6IHNlcGFyYWJsZV9jb252MCwgc2VwYXJhYmxlX2NvbnYxOiBzZXBhcmFibGVfY29udjEsIHNlcGFyYWJsZV9jb252Mjogc2VwYXJhYmxlX2NvbnYyIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RDb252UGFyYW1zOiBleHRyYWN0Q29udlBhcmFtcyxcclxuICAgICAgICBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zOiBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdE1haW5CbG9ja1BhcmFtczogZXh0cmFjdE1haW5CbG9ja1BhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzLCBudW1NYWluQmxvY2tzKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdFdlaWdodHNGYWN0b3J5KHdlaWdodHMpLCBleHRyYWN0V2VpZ2h0cyA9IF9hLmV4dHJhY3RXZWlnaHRzLCBnZXRSZW1haW5pbmdXZWlnaHRzID0gX2EuZ2V0UmVtYWluaW5nV2VpZ2h0cztcclxuICAgIHZhciBfYiA9IGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSwgZXh0cmFjdENvbnZQYXJhbXMgPSBfYi5leHRyYWN0Q29udlBhcmFtcywgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBfYi5leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcywgZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zID0gX2IuZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zLCBleHRyYWN0TWFpbkJsb2NrUGFyYW1zID0gX2IuZXh0cmFjdE1haW5CbG9ja1BhcmFtcztcclxuICAgIHZhciBlbnRyeV9mbG93X2NvbnZfaW4gPSBleHRyYWN0Q29udlBhcmFtcygzLCAzMiwgMywgJ2VudHJ5X2Zsb3cvY29udl9pbicpO1xyXG4gICAgdmFyIGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzAgPSBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMoMzIsIDY0LCAnZW50cnlfZmxvdy9yZWR1Y3Rpb25fYmxvY2tfMCcpO1xyXG4gICAgdmFyIGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzEgPSBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMoNjQsIDEyOCwgJ2VudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzEnKTtcclxuICAgIHZhciBlbnRyeV9mbG93ID0ge1xyXG4gICAgICAgIGNvbnZfaW46IGVudHJ5X2Zsb3dfY29udl9pbixcclxuICAgICAgICByZWR1Y3Rpb25fYmxvY2tfMDogZW50cnlfZmxvd19yZWR1Y3Rpb25fYmxvY2tfMCxcclxuICAgICAgICByZWR1Y3Rpb25fYmxvY2tfMTogZW50cnlfZmxvd19yZWR1Y3Rpb25fYmxvY2tfMVxyXG4gICAgfTtcclxuICAgIHZhciBtaWRkbGVfZmxvdyA9IHt9O1xyXG4gICAgcmFuZ2UobnVtTWFpbkJsb2NrcywgMCwgMSkuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgbWlkZGxlX2Zsb3dbXCJtYWluX2Jsb2NrX1wiICsgaWR4XSA9IGV4dHJhY3RNYWluQmxvY2tQYXJhbXMoMTI4LCBcIm1pZGRsZV9mbG93L21haW5fYmxvY2tfXCIgKyBpZHgpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgZXhpdF9mbG93X3JlZHVjdGlvbl9ibG9jayA9IGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcygxMjgsIDI1NiwgJ2V4aXRfZmxvdy9yZWR1Y3Rpb25fYmxvY2snKTtcclxuICAgIHZhciBleGl0X2Zsb3dfc2VwYXJhYmxlX2NvbnYgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcygyNTYsIDUxMiwgJ2V4aXRfZmxvdy9zZXBhcmFibGVfY29udicpO1xyXG4gICAgdmFyIGV4aXRfZmxvdyA9IHtcclxuICAgICAgICByZWR1Y3Rpb25fYmxvY2s6IGV4aXRfZmxvd19yZWR1Y3Rpb25fYmxvY2ssXHJcbiAgICAgICAgc2VwYXJhYmxlX2NvbnY6IGV4aXRfZmxvd19zZXBhcmFibGVfY29udlxyXG4gICAgfTtcclxuICAgIGlmIChnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6IFwiICsgZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MsXHJcbiAgICAgICAgcGFyYW1zOiB7IGVudHJ5X2Zsb3c6IGVudHJ5X2Zsb3csIG1pZGRsZV9mbG93OiBtaWRkbGVfZmxvdywgZXhpdF9mbG93OiBleGl0X2Zsb3cgfVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zLmpzLm1hcCIsImltcG9ydCB7IGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzLCBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5LCBsb2FkU2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnksIH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgbG9hZENvbnZQYXJhbXNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uL2xvYWRDb252UGFyYW1zRmFjdG9yeSc7XHJcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5mdW5jdGlvbiBsb2FkUGFyYW1zRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0V2VpZ2h0RW50cnkgPSBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICB2YXIgZXh0cmFjdENvbnZQYXJhbXMgPSBsb2FkQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodEVudHJ5KTtcclxuICAgIHZhciBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyA9IGxvYWRTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0RW50cnkpO1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zKG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBzZXBhcmFibGVfY29udjAgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjBcIik7XHJcbiAgICAgICAgdmFyIHNlcGFyYWJsZV9jb252MSA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKG1hcHBlZFByZWZpeCArIFwiL3NlcGFyYWJsZV9jb252MVwiKTtcclxuICAgICAgICB2YXIgZXhwYW5zaW9uX2NvbnYgPSBleHRyYWN0Q29udlBhcmFtcyhtYXBwZWRQcmVmaXggKyBcIi9leHBhbnNpb25fY29udlwiKTtcclxuICAgICAgICByZXR1cm4geyBzZXBhcmFibGVfY29udjA6IHNlcGFyYWJsZV9jb252MCwgc2VwYXJhYmxlX2NvbnYxOiBzZXBhcmFibGVfY29udjEsIGV4cGFuc2lvbl9jb252OiBleHBhbnNpb25fY29udiB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdE1haW5CbG9ja1BhcmFtcyhtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgc2VwYXJhYmxlX2NvbnYwID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMobWFwcGVkUHJlZml4ICsgXCIvc2VwYXJhYmxlX2NvbnYwXCIpO1xyXG4gICAgICAgIHZhciBzZXBhcmFibGVfY29udjEgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjFcIik7XHJcbiAgICAgICAgdmFyIHNlcGFyYWJsZV9jb252MiA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKG1hcHBlZFByZWZpeCArIFwiL3NlcGFyYWJsZV9jb252MlwiKTtcclxuICAgICAgICByZXR1cm4geyBzZXBhcmFibGVfY29udjA6IHNlcGFyYWJsZV9jb252MCwgc2VwYXJhYmxlX2NvbnYxOiBzZXBhcmFibGVfY29udjEsIHNlcGFyYWJsZV9jb252Mjogc2VwYXJhYmxlX2NvbnYyIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RDb252UGFyYW1zOiBleHRyYWN0Q29udlBhcmFtcyxcclxuICAgICAgICBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zOiBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdE1haW5CbG9ja1BhcmFtczogZXh0cmFjdE1haW5CbG9ja1BhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwLCBudW1NYWluQmxvY2tzKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9hID0gbG9hZFBhcmFtc0ZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSwgZXh0cmFjdENvbnZQYXJhbXMgPSBfYS5leHRyYWN0Q29udlBhcmFtcywgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBfYS5leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcywgZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zID0gX2EuZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zLCBleHRyYWN0TWFpbkJsb2NrUGFyYW1zID0gX2EuZXh0cmFjdE1haW5CbG9ja1BhcmFtcztcclxuICAgIHZhciBlbnRyeV9mbG93X2NvbnZfaW4gPSBleHRyYWN0Q29udlBhcmFtcygnZW50cnlfZmxvdy9jb252X2luJyk7XHJcbiAgICB2YXIgZW50cnlfZmxvd19yZWR1Y3Rpb25fYmxvY2tfMCA9IGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcygnZW50cnlfZmxvdy9yZWR1Y3Rpb25fYmxvY2tfMCcpO1xyXG4gICAgdmFyIGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzEgPSBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMoJ2VudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzEnKTtcclxuICAgIHZhciBlbnRyeV9mbG93ID0ge1xyXG4gICAgICAgIGNvbnZfaW46IGVudHJ5X2Zsb3dfY29udl9pbixcclxuICAgICAgICByZWR1Y3Rpb25fYmxvY2tfMDogZW50cnlfZmxvd19yZWR1Y3Rpb25fYmxvY2tfMCxcclxuICAgICAgICByZWR1Y3Rpb25fYmxvY2tfMTogZW50cnlfZmxvd19yZWR1Y3Rpb25fYmxvY2tfMVxyXG4gICAgfTtcclxuICAgIHZhciBtaWRkbGVfZmxvdyA9IHt9O1xyXG4gICAgcmFuZ2UobnVtTWFpbkJsb2NrcywgMCwgMSkuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgbWlkZGxlX2Zsb3dbXCJtYWluX2Jsb2NrX1wiICsgaWR4XSA9IGV4dHJhY3RNYWluQmxvY2tQYXJhbXMoXCJtaWRkbGVfZmxvdy9tYWluX2Jsb2NrX1wiICsgaWR4KTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGV4aXRfZmxvd19yZWR1Y3Rpb25fYmxvY2sgPSBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMoJ2V4aXRfZmxvdy9yZWR1Y3Rpb25fYmxvY2snKTtcclxuICAgIHZhciBleGl0X2Zsb3dfc2VwYXJhYmxlX2NvbnYgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcygnZXhpdF9mbG93L3NlcGFyYWJsZV9jb252Jyk7XHJcbiAgICB2YXIgZXhpdF9mbG93ID0ge1xyXG4gICAgICAgIHJlZHVjdGlvbl9ibG9jazogZXhpdF9mbG93X3JlZHVjdGlvbl9ibG9jayxcclxuICAgICAgICBzZXBhcmFibGVfY29udjogZXhpdF9mbG93X3NlcGFyYWJsZV9jb252XHJcbiAgICB9O1xyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogeyBlbnRyeV9mbG93OiBlbnRyeV9mbG93LCBtaWRkbGVfZmxvdzogbWlkZGxlX2Zsb3csIGV4aXRfZmxvdzogZXhpdF9mbG93IH0sIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcy5tYXAiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tCcmlnaHQoaWQpIHtcclxuICAgIGlmICghaWQpIHJldHVybjtcclxuICAgIGNvbnN0IGRhcmtfdGhyZXNob2xkID0gMC40O1xyXG4gICAgY29uc3QgbGlnaHRfdGhyZXNob2xkID0gMC40XHJcbiAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcclxuICAgIGNvbnNvbGUubG9nKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xyXG4gICAgY29uc3QgaW1nRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodCkuZGF0YTtcclxuXHJcbiAgICBsZXQgY2hhbnMgPSBbW11dLFxyXG4gICAgICAgIG1heENvdW50ID0gMCwgdmFsID0gMDtcclxuICAgIGxldCBzdGVwID0gMTtcclxuICAgIHN0ZXAgKj0gNDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGltZ0RhdGEubGVuZ3RoOyBpIDwgbjsgaSArPSBzdGVwKSB7XHJcbiAgICAgICAgdmFsID0gcmdiMmhzdihpbWdEYXRhW2ldLCBpbWdEYXRhW2kgKyAxXSwgaW1nRGF0YVtpICsgMl0pO1xyXG5cclxuICAgICAgICB2YWwgPSBbdmFsWzJdXTtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMCwgbSA9IHZhbC5sZW5ndGg7IHkgPCBtOyB5KyspIHtcclxuICAgICAgICAgICAgaWYgKHZhbFt5XSBpbiBjaGFuc1t5XSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbnNbeV1bdmFsW3ldXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hhbnNbeV1bdmFsW3ldXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5zW3ldW3ZhbFt5XV0gPiBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgbWF4Q291bnQgPSBjaGFuc1t5XVt2YWxbeV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXhDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB2YWxzID0gY2hhbnNbMF07XHJcbiAgICBsZXQgeCwgeSA9IDA7XHJcbiAgICBsZXQgbGlnaHQgPSAwLCBkYXJrID0gMCwgYXZyID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDI1NTsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCEoaSBpbiB2YWxzKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeSA9IE1hdGgucm91bmQoKHZhbHNbaV0gLyBtYXhDb3VudCkgKiA0ODApO1xyXG4gICAgICAgIHggPSBNYXRoLnJvdW5kKChpIC8gMjU1KSAqIDY0MCk7XHJcbiAgICAgICAgaWYgKGkgPCAzMCkgZGFyayArPSB5O1xyXG4gICAgICAgIGlmIChpID4gMjEwKSBsaWdodCArPSB5O1xyXG4gICAgICAgIGF2ciArPSB5O1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJ2Rhcms9ICcsIGRhcmssICcgJywgZGFyayAvIGF2cik7XHJcbiAgICBjb25zb2xlLmxvZygnbGlnaHQ9ICcsIGxpZ2h0LCAnICcsIGxpZ2h0IC8gYXZyKTtcclxuICAgIGNvbnNvbGUubG9nKCdzdW09ICcsIGF2cik7XHJcbiAgICBpZiAoZGFyayAvIGF2ciA+IGRhcmtfdGhyZXNob2xkKSB7XHJcbiAgICAgICAgcmV0dXJuIDFcclxuICAgIH1cclxuICAgIGlmIChsaWdodCAvIGF2ciA+IGxpZ2h0X3RocmVzaG9sZCkge1xyXG4gICAgICAgIHJldHVybiAyXHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIGlzIGdyYXlcclxuICAgIGZ1bmN0aW9uIHJnYjJoc3YocmVkLCBncmVlbiwgYmx1ZSkge1xyXG4gICAgICAgIHJlZCAvPSAyNTU7XHJcbiAgICAgICAgZ3JlZW4gLz0gMjU1O1xyXG4gICAgICAgIGJsdWUgLz0gMjU1O1xyXG5cclxuICAgICAgICBsZXQgaHVlLCBzYXQsXHJcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpLFxyXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKSxcclxuICAgICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXHJcbiAgICAgICAgICAgIHZhbHVlID0gbWF4O1xyXG5cclxuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcclxuICAgICAgICAgICAgaHVlID0gc2F0ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzYXQgPSBkZWx0YSAvIG1heDtcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IHJlZCkge1xyXG4gICAgICAgICAgICAgICAgaHVlID0gKGdyZWVuIC0gYmx1ZSkgLyBkZWx0YTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXggPT09IGdyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBodWUgPSAoYmx1ZSAtIHJlZCkgLyBkZWx0YSArIDI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF4ID09PSBibHVlKSB7XHJcbiAgICAgICAgICAgICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gZGVsdGEgKyA0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBodWUgLz0gNjtcclxuICAgICAgICAgICAgaWYgKGh1ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGh1ZSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW01hdGgucm91bmQoaHVlICogMjU1KSwgTWF0aC5yb3VuZChzYXQgKiAyNTUpLCBNYXRoLnJvdW5kKHZhbHVlICogMjU1KV07XHJcbiAgICB9XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcbmltcG9ydCB7Y2hlY2tCcmlnaHR9IGZyb20gXCIuL2hpc3RvZ3JhbVwiO1xyXG5pbXBvcnQgKiBhcyBmYWNlYXBpIGZyb20gXCJmYWNlLWFwaS5qc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2hlY2tQaG90byhpZCkge1xyXG4gICAgaWYgKCFpZCkgcmV0dXJuO1xyXG5cclxuICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZmFjZWFwaS5uZXRzLnRpbnlGYWNlRGV0ZWN0b3IubG9hZEZyb21VcmkoJy4vbW9kZWxzJyk7XHJcbiAgICAgICAgY29uc3QgZGV0ZWN0aW9uID0gYXdhaXQgZmFjZWFwaS5kZXRlY3RBbGxGYWNlcyhpZCwgbmV3IGZhY2VhcGkuVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMoKSk7XHJcbiAgICAgICAgY29uc3QgYnJpZ2h0UmVzdWx0ID0gY2hlY2tCcmlnaHQoaWQpO1xyXG4gICAgICAgIGxldCBlcnJvcnM9W107XHJcbiAgICAgICAgaWYgKGJyaWdodFJlc3VsdD09PTEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLQotC10LzQvdC+0LUg0LjQt9C+0LHRgNCw0LbQtdC90LjQtVwiKTtcclxuICAgICAgICAgICAgZXJyb3JzLnB1c2goLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnJpZ2h0UmVzdWx0PT09Mil7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcItCh0LLQtdGC0LvQvtC1INC40LfQvtCx0YDQsNC20LXQvdC40LVcIik7XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKC0yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZXRlY3Rpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLQm9C40YbQviDQvdC1INC+0LHQvdCw0YDRg9C20LXQvdC+XCIpO1xyXG4gICAgICAgICAgICBlcnJvcnMucHVzaCgtMyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChkZXRlY3Rpb24ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcItCe0LHQvdCw0YDRg9C20LXQvdC+INC90LXRgdC60L7Qu9GM0LrQviDQu9C40YZcIik7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCgtNCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCLQktGB0LUg0J7QmlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3JzO1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG59IiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==